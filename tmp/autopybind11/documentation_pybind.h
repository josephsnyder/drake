#pragma once

// GENERATED FILE DO NOT EDIT
// This file contains docstrings for the Python bindings that were
// automatically extracted by mkdoc.py.

#if defined(__GNUG__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-variable"
#endif

// #include "drake/common/autodiff.h"
// #include "drake/common/autodiff_overloads.h"
// #include "drake/common/autodiffxd.h"
// #include "drake/common/autodiffxd_make_coherent.h"
// #include "drake/common/cond.h"
// #include "drake/common/constants.h"
// #include "drake/common/copyable_unique_ptr.h"
// #include "drake/common/default_scalars.h"
// #include "drake/common/double_overloads.h"
// #include "drake/common/drake_assert.h"
// #include "drake/common/drake_assertion_error.h"
// #include "drake/common/drake_bool.h"
// #include "drake/common/drake_copyable.h"
// #include "drake/common/drake_deprecated.h"
// #include "drake/common/drake_marker.h"
// #include "drake/common/drake_path.h"
// #include "drake/common/drake_throw.h"
// #include "drake/common/dummy_value.h"
// #include "drake/common/eigen_autodiff_types.h"
// #include "drake/common/eigen_stl_types.h"
// #include "drake/common/eigen_types.h"
// #include "drake/common/extract_double.h"
// #include "drake/common/find_loaded_library.h"
// #include "drake/common/find_resource.h"
// #include "drake/common/find_runfiles.h"
// #include "drake/common/hash.h"
// #include "drake/common/identifier.h"
// #include "drake/common/is_approx_equal_abstol.h"
// #include "drake/common/is_cloneable.h"
// #include "drake/common/is_less_than_comparable.h"
// #include "drake/common/name_value.h"
// #include "drake/common/never_destroyed.h"
// #include "drake/common/nice_type_name.h"
// #include "drake/common/pointer_cast.h"
// #include "drake/common/polynomial.h"
// #include "drake/common/proto/call_python.h"
// #include "drake/common/proto/rpc_pipe_temp_directory.h"
// #include "drake/common/random.h"
// #include "drake/common/reset_after_move.h"
// #include "drake/common/reset_on_copy.h"
// #include "drake/common/schema/rotation.h"
// #include "drake/common/schema/stochastic.h"
// #include "drake/common/schema/transform.h"
// #include "drake/common/scope_exit.h"
// #include "drake/common/scoped_singleton.h"
// #include "drake/common/sorted_pair.h"
// #include "drake/common/sorted_vectors_have_intersection.h"
// #include "drake/common/symbolic.h"
// #include "drake/common/symbolic_chebyshev_basis_element.h"
// #include "drake/common/symbolic_chebyshev_polynomial.h"
// #include "drake/common/symbolic_codegen.h"
// #include "drake/common/symbolic_decompose.h"
// #include "drake/common/symbolic_environment.h"
// #include "drake/common/symbolic_expression.h"
// #include "drake/common/symbolic_expression_cell.h"
// #include "drake/common/symbolic_expression_visitor.h"
// #include "drake/common/symbolic_formula.h"
// #include "drake/common/symbolic_formula_cell.h"
// #include "drake/common/symbolic_formula_visitor.h"
// #include "drake/common/symbolic_generic_polynomial.h"
// #include "drake/common/symbolic_ldlt.h"
// #include "drake/common/symbolic_monomial.h"
// #include "drake/common/symbolic_monomial_basis_element.h"
// #include "drake/common/symbolic_monomial_util.h"
// #include "drake/common/symbolic_polynomial.h"
// #include "drake/common/symbolic_polynomial_basis.h"
// #include "drake/common/symbolic_polynomial_basis_element.h"
// #include "drake/common/symbolic_rational_function.h"
// #include "drake/common/symbolic_simplification.h"
// #include "drake/common/symbolic_variable.h"
// #include "drake/common/symbolic_variables.h"
// #include "drake/common/temp_directory.h"
// #include "drake/common/text_logging.h"
// #include "drake/common/trajectories/bspline_trajectory.h"
// #include "drake/common/trajectories/discrete_time_trajectory.h"
// #include "drake/common/trajectories/exponential_plus_piecewise_polynomial.h"
// #include "drake/common/trajectories/piecewise_polynomial.h"
// #include "drake/common/trajectories/piecewise_pose.h"
// #include "drake/common/trajectories/piecewise_quaternion.h"
// #include "drake/common/trajectories/piecewise_trajectory.h"
// #include "drake/common/trajectories/trajectory.h"
// #include "drake/common/trig_poly.h"
// #include "drake/common/type_safe_index.h"
// #include "drake/common/unused.h"
// #include "drake/common/value.h"
// #include "drake/common/yaml/yaml_read_archive.h"
// #include "drake/common/yaml/yaml_write_archive.h"
// #include "drake/examples/acrobot/acrobot_geometry.h"
// #include "drake/examples/acrobot/acrobot_plant.h"
// #include "drake/examples/acrobot/gen/acrobot_input.h"
// #include "drake/examples/acrobot/gen/acrobot_params.h"
// #include "drake/examples/acrobot/gen/acrobot_state.h"
// #include "drake/examples/acrobot/gen/spong_controller_params.h"
// #include "drake/examples/acrobot/spong_controller.h"
// #include "drake/examples/compass_gait/compass_gait.h"
// #include "drake/examples/compass_gait/compass_gait.h"
// #include "drake/examples/compass_gait/compass_gait_geometry.h"
// #include "drake/examples/compass_gait/gen/compass_gait_continuous_state.h"
// #include "drake/examples/compass_gait/gen/compass_gait_continuous_state.h"
// #include "drake/examples/compass_gait/gen/compass_gait_params.h"
// #include "drake/examples/compass_gait/gen/compass_gait_params.h"
// #include "drake/examples/manipulation_station/manipulation_station.h"
// #include "drake/examples/manipulation_station/manipulation_station.h"
// #include "drake/examples/manipulation_station/manipulation_station_hardware_interface.h"
// #include "drake/examples/manipulation_station/manipulation_station_hardware_interface.h"
// #include "drake/examples/pendulum/gen/pendulum_input.h"
// #include "drake/examples/pendulum/gen/pendulum_input.h"
// #include "drake/examples/pendulum/gen/pendulum_params.h"
// #include "drake/examples/pendulum/gen/pendulum_params.h"
// #include "drake/examples/pendulum/gen/pendulum_state.h"
// #include "drake/examples/pendulum/gen/pendulum_state.h"
// #include "drake/examples/pendulum/pendulum_geometry.h"
// #include "drake/examples/pendulum/pendulum_plant.h"
// #include "drake/examples/pendulum/pendulum_plant.h"
// #include "drake/examples/quadrotor/quadrotor_geometry.h"
// #include "drake/examples/quadrotor/quadrotor_plant.h"
// #include "drake/examples/quadrotor/quadrotor_plant.h"
// #include "drake/examples/rimless_wheel/gen/rimless_wheel_continuous_state.h"
// #include "drake/examples/rimless_wheel/gen/rimless_wheel_continuous_state.h"
// #include "drake/examples/rimless_wheel/gen/rimless_wheel_params.h"
// #include "drake/examples/rimless_wheel/gen/rimless_wheel_params.h"
// #include "drake/examples/rimless_wheel/rimless_wheel.h"
// #include "drake/examples/rimless_wheel/rimless_wheel.h"
// #include "drake/examples/rimless_wheel/rimless_wheel_geometry.h"
// #include "drake/examples/van_der_pol/van_der_pol.h"
// #include "drake/examples/van_der_pol/van_der_pol.h"
// #include "drake/geometry/drake_visualizer.h"
// #include "drake/geometry/frame_kinematics_vector.h"
// #include "drake/geometry/geometry_frame.h"
// #include "drake/geometry/geometry_ids.h"
// #include "drake/geometry/geometry_index.h"
// #include "drake/geometry/geometry_instance.h"
// #include "drake/geometry/geometry_properties.h"
// #include "drake/geometry/geometry_roles.h"
// #include "drake/geometry/geometry_set.h"
// #include "drake/geometry/geometry_state.h"
// #include "drake/geometry/geometry_version.h"
// #include "drake/geometry/geometry_visualization.h"
// #include "drake/geometry/internal_frame.h"
// #include "drake/geometry/internal_geometry.h"
// #include "drake/geometry/proximity/bvh.h"
// #include "drake/geometry/proximity/collision_filter_legacy.h"
// #include "drake/geometry/proximity/contact_surface_utility.h"
// #include "drake/geometry/proximity/hydroelastic_internal.h"
// #include "drake/geometry/proximity/make_box_field.h"
// #include "drake/geometry/proximity/make_box_mesh.h"
// #include "drake/geometry/proximity/make_capsule_mesh.h"
// #include "drake/geometry/proximity/make_cylinder_field.h"
// #include "drake/geometry/proximity/make_cylinder_mesh.h"
// #include "drake/geometry/proximity/make_ellipsoid_field.h"
// #include "drake/geometry/proximity/make_ellipsoid_mesh.h"
// #include "drake/geometry/proximity/make_sphere_field.h"
// #include "drake/geometry/proximity/make_sphere_mesh.h"
// #include "drake/geometry/proximity/mesh_field.h"
// #include "drake/geometry/proximity/mesh_field_linear.h"
// #include "drake/geometry/proximity/mesh_half_space_intersection.h"
// #include "drake/geometry/proximity/mesh_intersection.h"
// #include "drake/geometry/proximity/mesh_plane_intersection.h"
// #include "drake/geometry/proximity/mesh_to_vtk.h"
// #include "drake/geometry/proximity/meshing_utilities.h"
// #include "drake/geometry/proximity/obb.h"
// #include "drake/geometry/proximity/obj_to_surface_mesh.h"
// #include "drake/geometry/proximity/plane.h"
// #include "drake/geometry/proximity/posed_half_space.h"
// #include "drake/geometry/proximity/sorted_triplet.h"
// #include "drake/geometry/proximity/surface_mesh.h"
// #include "drake/geometry/proximity/tessellation_strategy.h"
// #include "drake/geometry/proximity/volume_mesh.h"
// #include "drake/geometry/proximity/volume_mesh_field.h"
// #include "drake/geometry/proximity/volume_to_surface_mesh.h"
// #include "drake/geometry/proximity_engine.h"
// #include "drake/geometry/proximity_properties.h"
// #include "drake/geometry/query_object.h"
// #include "drake/geometry/query_results/contact_surface.h"
// #include "drake/geometry/query_results/penetration_as_point_pair.h"
// #include "drake/geometry/query_results/signed_distance_pair.h"
// #include "drake/geometry/query_results/signed_distance_to_point.h"
// #include "drake/geometry/query_results/signed_distance_to_point_with_gradient.h"
// #include "drake/geometry/render/camera_properties.h"
// #include "drake/geometry/render/gl_renderer/render_engine_gl_factory.h"
// #include "drake/geometry/render/gl_renderer/render_engine_gl_params.h"
// #include "drake/geometry/render/render_camera.h"
// #include "drake/geometry/render/render_engine.h"
// #include "drake/geometry/render/render_engine_vtk_factory.h"
// #include "drake/geometry/render/render_label.h"
// #include "drake/geometry/render/render_label_class.h"
// #include "drake/geometry/render/shaders/depth_shaders.h"
// #include "drake/geometry/rgba.h"
// #include "drake/geometry/scene_graph.h"
// #include "drake/geometry/scene_graph_inspector.h"
// #include "drake/geometry/shape_specification.h"
// #include "drake/geometry/shape_to_string.h"
// #include "drake/geometry/utilities.h"
// #include "drake/lcm/drake_lcm.h"
// #include "drake/lcm/drake_lcm_interface.h"
// #include "drake/lcm/drake_lcm_log.h"
// #include "drake/lcm/drake_mock_lcm.h"
// #include "drake/lcm/lcm_messages.h"
// #include "drake/manipulation/kinova_jaco/jaco_command_receiver.h"
// #include "drake/manipulation/kinova_jaco/jaco_command_sender.h"
// #include "drake/manipulation/kinova_jaco/jaco_constants.h"
// #include "drake/manipulation/kinova_jaco/jaco_status_receiver.h"
// #include "drake/manipulation/kinova_jaco/jaco_status_sender.h"
// #include "drake/manipulation/kuka_iiwa/iiwa_command_receiver.h"
// #include "drake/manipulation/kuka_iiwa/iiwa_command_sender.h"
// #include "drake/manipulation/kuka_iiwa/iiwa_constants.h"
// #include "drake/manipulation/kuka_iiwa/iiwa_status_receiver.h"
// #include "drake/manipulation/kuka_iiwa/iiwa_status_sender.h"
// #include "drake/manipulation/perception/optitrack_pose_extractor.h"
// #include "drake/manipulation/perception/pose_smoother.h"
// #include "drake/manipulation/planner/constraint_relaxing_ik.h"
// #include "drake/manipulation/planner/differential_inverse_kinematics.h"
// #include "drake/manipulation/planner/differential_inverse_kinematics_integrator.h"
// #include "drake/manipulation/planner/robot_plan_interpolator.h"
// #include "drake/manipulation/schunk_wsg/gen/schunk_wsg_trajectory_generator_state_vector.h"
// #include "drake/manipulation/schunk_wsg/schunk_wsg_constants.h"
// #include "drake/manipulation/schunk_wsg/schunk_wsg_controller.h"
// #include "drake/manipulation/schunk_wsg/schunk_wsg_lcm.h"
// #include "drake/manipulation/schunk_wsg/schunk_wsg_plain_controller.h"
// #include "drake/manipulation/schunk_wsg/schunk_wsg_position_controller.h"
// #include "drake/manipulation/schunk_wsg/schunk_wsg_trajectory_generator.h"
// #include "drake/manipulation/util/move_ik_demo_base.h"
// #include "drake/manipulation/util/moving_average_filter.h"
// #include "drake/manipulation/util/robot_plan_utils.h"
// #include "drake/manipulation/util/trajectory_utils.h"
// #include "drake/math/autodiff.h"
// #include "drake/math/autodiff_gradient.h"
// #include "drake/math/barycentric.h"
// #include "drake/math/bspline_basis.h"
// #include "drake/math/compute_numerical_gradient.h"
// #include "drake/math/continuous_algebraic_riccati_equation.h"
// #include "drake/math/continuous_lyapunov_equation.h"
// #include "drake/math/convert_time_derivative.h"
// #include "drake/math/cross_product.h"
// #include "drake/math/discrete_algebraic_riccati_equation.h"
// #include "drake/math/discrete_lyapunov_equation.h"
// #include "drake/math/eigen_sparse_triplet.h"
// #include "drake/math/evenly_distributed_pts_on_sphere.h"
// #include "drake/math/gradient.h"
// #include "drake/math/gradient_util.h"
// #include "drake/math/gray_code.h"
// #include "drake/math/hopf_coordinate.h"
// #include "drake/math/jacobian.h"
// #include "drake/math/knot_vector_type.h"
// #include "drake/math/matrix_util.h"
// #include "drake/math/normalize_vector.h"
// #include "drake/math/orthonormal_basis.h"
// #include "drake/math/quadratic_form.h"
// #include "drake/math/quaternion.h"
// #include "drake/math/random_rotation.h"
// #include "drake/math/rigid_transform.h"
// #include "drake/math/roll_pitch_yaw.h"
// #include "drake/math/rotation_conversion_gradient.h"
// #include "drake/math/rotation_matrix.h"
// #include "drake/math/saturate.h"
// #include "drake/math/wrap_to.h"
// #include "drake/multibody/benchmarks/acrobot/acrobot.h"
// #include "drake/multibody/benchmarks/acrobot/make_acrobot_plant.h"
// #include "drake/multibody/benchmarks/free_body/free_body.h"
// #include "drake/multibody/benchmarks/inclined_plane/inclined_plane_plant.h"
// #include "drake/multibody/benchmarks/kuka_iiwa_robot/make_kuka_iiwa_model.h"
// #include "drake/multibody/benchmarks/mass_damper_spring/mass_damper_spring_analytical_solution.h"
// #include "drake/multibody/benchmarks/pendulum/make_pendulum_plant.h"
// #include "drake/multibody/constraint/constraint_problem_data.h"
// #include "drake/multibody/constraint/constraint_solver.h"
// #include "drake/multibody/contact_solvers/contact_solver.h"
// #include "drake/multibody/contact_solvers/contact_solver_results.h"
// #include "drake/multibody/contact_solvers/contact_solver_utils.h"
// #include "drake/multibody/contact_solvers/linear_operator.h"
// #include "drake/multibody/contact_solvers/point_contact_data.h"
// #include "drake/multibody/contact_solvers/sparse_linear_operator.h"
// #include "drake/multibody/contact_solvers/system_dynamics_data.h"
// #include "drake/multibody/hydroelastics/hydroelastic_engine.h"
// #include "drake/multibody/hydroelastics/hydroelastic_field.h"
// #include "drake/multibody/hydroelastics/hydroelastic_field_sphere.h"
// #include "drake/multibody/hydroelastics/level_set_field.h"
// #include "drake/multibody/inverse_kinematics/angle_between_vectors_constraint.h"
// #include "drake/multibody/inverse_kinematics/distance_constraint.h"
// #include "drake/multibody/inverse_kinematics/distance_constraint_utilities.h"
// #include "drake/multibody/inverse_kinematics/gaze_target_constraint.h"
// #include "drake/multibody/inverse_kinematics/global_inverse_kinematics.h"
// #include "drake/multibody/inverse_kinematics/inverse_kinematics.h"
// #include "drake/multibody/inverse_kinematics/kinematic_constraint_utilities.h"
// #include "drake/multibody/inverse_kinematics/minimum_distance_constraint.h"
// #include "drake/multibody/inverse_kinematics/orientation_constraint.h"
// #include "drake/multibody/inverse_kinematics/point_to_point_distance_constraint.h"
// #include "drake/multibody/inverse_kinematics/position_constraint.h"
// #include "drake/multibody/inverse_kinematics/unit_quaternion_constraint.h"
// #include "drake/multibody/math/spatial_acceleration.h"
// #include "drake/multibody/math/spatial_algebra.h"
// #include "drake/multibody/math/spatial_force.h"
// #include "drake/multibody/math/spatial_momentum.h"
// #include "drake/multibody/math/spatial_vector.h"
// #include "drake/multibody/math/spatial_velocity.h"
// #include "drake/multibody/optimization/contact_wrench.h"
// #include "drake/multibody/optimization/contact_wrench_evaluator.h"
// #include "drake/multibody/optimization/manipulator_equation_constraint.h"
// #include "drake/multibody/optimization/sliding_friction_complementarity_constraint.h"
// #include "drake/multibody/optimization/static_equilibrium_constraint.h"
// #include "drake/multibody/optimization/static_equilibrium_problem.h"
// #include "drake/multibody/optimization/static_friction_cone_complementarity_constraint.h"
// #include "drake/multibody/optimization/static_friction_cone_constraint.h"
// #include "drake/multibody/parsing/detail_common.h"
// #include "drake/multibody/parsing/detail_path_utils.h"
// #include "drake/multibody/parsing/detail_sdf_parser.h"
// #include "drake/multibody/parsing/detail_tinyxml.h"
// #include "drake/multibody/parsing/detail_urdf_geometry.h"
// #include "drake/multibody/parsing/detail_urdf_parser.h"
// #include "drake/multibody/parsing/model_directives.h"
// #include "drake/multibody/parsing/package_map.h"
// #include "drake/multibody/parsing/parser.h"
// #include "drake/multibody/parsing/process_model_directives.h"
// #include "drake/multibody/parsing/scoped_names.h"
// #include "drake/multibody/plant/calc_distance_and_time_derivative.h"
// #include "drake/multibody/plant/contact_jacobians.h"
// #include "drake/multibody/plant/contact_results.h"
// #include "drake/multibody/plant/contact_results_to_lcm.h"
// #include "drake/multibody/plant/coulomb_friction.h"
// #include "drake/multibody/plant/discrete_contact_pair.h"
// #include "drake/multibody/plant/externally_applied_spatial_force.h"
// #include "drake/multibody/plant/hydroelastic_contact_info.h"
// #include "drake/multibody/plant/hydroelastic_quadrature_point_data.h"
// #include "drake/multibody/plant/hydroelastic_traction_calculator.h"
// #include "drake/multibody/plant/multibody_plant.h"
// #include "drake/multibody/plant/point_pair_contact_info.h"
// #include "drake/multibody/plant/propeller.h"
// #include "drake/multibody/plant/tamsi_solver.h"
// #include "drake/multibody/topology/multibody_graph.h"
// #include "drake/multibody/tree/acceleration_kinematics_cache.h"
// #include "drake/multibody/tree/articulated_body_force_cache.h"
// #include "drake/multibody/tree/articulated_body_inertia.h"
// #include "drake/multibody/tree/articulated_body_inertia_cache.h"
// #include "drake/multibody/tree/ball_rpy_joint.h"
// #include "drake/multibody/tree/body.h"
// #include "drake/multibody/tree/body_node.h"
// #include "drake/multibody/tree/body_node_impl.h"
// #include "drake/multibody/tree/body_node_welded.h"
// #include "drake/multibody/tree/door_hinge.h"
// #include "drake/multibody/tree/fixed_offset_frame.h"
// #include "drake/multibody/tree/force_element.h"
// #include "drake/multibody/tree/frame.h"
// #include "drake/multibody/tree/frame_base.h"
// #include "drake/multibody/tree/joint.h"
// #include "drake/multibody/tree/joint_actuator.h"
// #include "drake/multibody/tree/linear_bushing_roll_pitch_yaw.h"
// #include "drake/multibody/tree/linear_spring_damper.h"
// #include "drake/multibody/tree/mobilizer.h"
// #include "drake/multibody/tree/mobilizer_impl.h"
// #include "drake/multibody/tree/model_instance.h"
// #include "drake/multibody/tree/multibody_element.h"
// #include "drake/multibody/tree/multibody_forces.h"
// #include "drake/multibody/tree/multibody_tree-inl.h"
// #include "drake/multibody/tree/multibody_tree.h"
// #include "drake/multibody/tree/multibody_tree_indexes.h"
// #include "drake/multibody/tree/multibody_tree_system.h"
// #include "drake/multibody/tree/multibody_tree_topology.h"
// #include "drake/multibody/tree/parameter_conversion.h"
// #include "drake/multibody/tree/planar_joint.h"
// #include "drake/multibody/tree/planar_mobilizer.h"
// #include "drake/multibody/tree/position_kinematics_cache.h"
// #include "drake/multibody/tree/prismatic_joint.h"
// #include "drake/multibody/tree/prismatic_mobilizer.h"
// #include "drake/multibody/tree/quaternion_floating_mobilizer.h"
// #include "drake/multibody/tree/revolute_joint.h"
// #include "drake/multibody/tree/revolute_mobilizer.h"
// #include "drake/multibody/tree/revolute_spring.h"
// #include "drake/multibody/tree/rigid_body.h"
// #include "drake/multibody/tree/rotational_inertia.h"
// #include "drake/multibody/tree/space_xyz_mobilizer.h"
// #include "drake/multibody/tree/spatial_inertia.h"
// #include "drake/multibody/tree/uniform_gravity_field_element.h"
// #include "drake/multibody/tree/unit_inertia.h"
// #include "drake/multibody/tree/universal_joint.h"
// #include "drake/multibody/tree/universal_mobilizer.h"
// #include "drake/multibody/tree/velocity_kinematics_cache.h"
// #include "drake/multibody/tree/weld_joint.h"
// #include "drake/multibody/tree/weld_mobilizer.h"
// #include "drake/multibody/triangle_quadrature/gaussian_triangle_quadrature_rule.h"
// #include "drake/multibody/triangle_quadrature/triangle_quadrature.h"
// #include "drake/multibody/triangle_quadrature/triangle_quadrature_rule.h"
// #include "drake/perception/depth_image_to_point_cloud.h"
// #include "drake/perception/point_cloud.h"
// #include "drake/perception/point_cloud_flags.h"
// #include "drake/solvers/aggregate_costs_constraints.h"
// #include "drake/solvers/bilinear_product_util.h"
// #include "drake/solvers/binding.h"
// #include "drake/solvers/branch_and_bound.h"
// #include "drake/solvers/choose_best_solver.h"
// #include "drake/solvers/common_solver_option.h"
// #include "drake/solvers/constraint.h"
// #include "drake/solvers/cost.h"
// #include "drake/solvers/create_constraint.h"
// #include "drake/solvers/create_cost.h"
// #include "drake/solvers/csdp_solver.h"
// #include "drake/solvers/decision_variable.h"
// #include "drake/solvers/dreal_solver.h"
// #include "drake/solvers/equality_constrained_qp_solver.h"
// #include "drake/solvers/evaluator_base.h"
// #include "drake/solvers/fbstab/components/dense_data.h"
// #include "drake/solvers/fbstab/components/dense_feasibility.h"
// #include "drake/solvers/fbstab/components/dense_linear_solver.h"
// #include "drake/solvers/fbstab/components/dense_residual.h"
// #include "drake/solvers/fbstab/components/dense_variable.h"
// #include "drake/solvers/fbstab/components/mpc_data.h"
// #include "drake/solvers/fbstab/components/mpc_feasibility.h"
// #include "drake/solvers/fbstab/components/mpc_residual.h"
// #include "drake/solvers/fbstab/components/mpc_variable.h"
// #include "drake/solvers/fbstab/components/riccati_linear_solver.h"
// #include "drake/solvers/fbstab/fbstab_algorithm.h"
// #include "drake/solvers/fbstab/fbstab_dense.h"
// #include "drake/solvers/fbstab/fbstab_mpc.h"
// #include "drake/solvers/function.h"
// #include "drake/solvers/gurobi_solver.h"
// #include "drake/solvers/indeterminate.h"
// #include "drake/solvers/integer_inequality_solver.h"
// #include "drake/solvers/integer_optimization_util.h"
// #include "drake/solvers/ipopt_solver.h"
// #include "drake/solvers/linear_system_solver.h"
// #include "drake/solvers/mathematical_program.h"
// #include "drake/solvers/mathematical_program_result.h"
// #include "drake/solvers/minimum_value_constraint.h"
// #include "drake/solvers/mixed_integer_optimization_util.h"
// #include "drake/solvers/mixed_integer_rotation_constraint.h"
// #include "drake/solvers/mixed_integer_rotation_constraint_internal.h"
// #include "drake/solvers/moby_lcp_solver.h"
// #include "drake/solvers/mosek_solver.h"
// #include "drake/solvers/nlopt_solver.h"
// #include "drake/solvers/non_convex_optimization_util.h"
// #include "drake/solvers/osqp_solver.h"
// #include "drake/solvers/program_attribute.h"
// #include "drake/solvers/rotation_constraint.h"
// #include "drake/solvers/scs_solver.h"
// #include "drake/solvers/sdpa_free_format.h"
// #include "drake/solvers/snopt_solver.h"
// #include "drake/solvers/solution_result.h"
// #include "drake/solvers/solve.h"
// #include "drake/solvers/solver_base.h"
// #include "drake/solvers/solver_id.h"
// #include "drake/solvers/solver_interface.h"
// #include "drake/solvers/solver_options.h"
// #include "drake/solvers/solver_type.h"
// #include "drake/solvers/solver_type_converter.h"
// #include "drake/solvers/sos_basis_generator.h"
// #include "drake/solvers/symbolic_extraction.h"
// #include "drake/solvers/system_identification.h"
// #include "drake/solvers/unrevised_lemke_solver.h"
// #include "drake/systems/analysis/antiderivative_function.h"
// #include "drake/systems/analysis/bogacki_shampine3_integrator.h"
// #include "drake/systems/analysis/dense_output.h"
// #include "drake/systems/analysis/explicit_euler_integrator.h"
// #include "drake/systems/analysis/hermitian_dense_output.h"
// #include "drake/systems/analysis/implicit_euler_integrator.h"
// #include "drake/systems/analysis/implicit_integrator.h"
// #include "drake/systems/analysis/initial_value_problem.h"
// #include "drake/systems/analysis/integrator_base.h"
// #include "drake/systems/analysis/lyapunov.h"
// #include "drake/systems/analysis/monte_carlo.h"
// #include "drake/systems/analysis/radau_integrator.h"
// #include "drake/systems/analysis/region_of_attraction.h"
// #include "drake/systems/analysis/runge_kutta2_integrator.h"
// #include "drake/systems/analysis/runge_kutta3_integrator.h"
// #include "drake/systems/analysis/runge_kutta5_integrator.h"
// #include "drake/systems/analysis/scalar_dense_output.h"
// #include "drake/systems/analysis/scalar_initial_value_problem.h"
// #include "drake/systems/analysis/scalar_view_dense_output.h"
// #include "drake/systems/analysis/semi_explicit_euler_integrator.h"
// #include "drake/systems/analysis/simulator.h"
// #include "drake/systems/analysis/simulator_config.h"
// #include "drake/systems/analysis/simulator_config_functions.h"
// #include "drake/systems/analysis/simulator_print_stats.h"
// #include "drake/systems/analysis/simulator_status.h"
// #include "drake/systems/analysis/stepwise_dense_output.h"
// #include "drake/systems/analysis/velocity_implicit_euler_integrator.h"
// #include "drake/systems/controllers/dynamic_programming.h"
// #include "drake/systems/controllers/finite_horizon_linear_quadratic_regulator.h"
// #include "drake/systems/controllers/inverse_dynamics.h"
// #include "drake/systems/controllers/inverse_dynamics_controller.h"
// #include "drake/systems/controllers/linear_model_predictive_controller.h"
// #include "drake/systems/controllers/linear_quadratic_regulator.h"
// #include "drake/systems/controllers/pid_controlled_system.h"
// #include "drake/systems/controllers/pid_controller.h"
// #include "drake/systems/controllers/setpoint.h"
// #include "drake/systems/controllers/state_feedback_controller_interface.h"
// #include "drake/systems/controllers/zmp_planner.h"
// #include "drake/systems/estimators/kalman_filter.h"
// #include "drake/systems/estimators/luenberger_observer.h"
// #include "drake/systems/framework/abstract_values.h"
// #include "drake/systems/framework/basic_vector.h"
// #include "drake/systems/framework/cache.h"
// #include "drake/systems/framework/cache_entry.h"
// #include "drake/systems/framework/context.h"
// #include "drake/systems/framework/context_base.h"
// #include "drake/systems/framework/continuous_state.h"
// #include "drake/systems/framework/dependency_tracker.h"
// #include "drake/systems/framework/diagram.h"
// #include "drake/systems/framework/diagram_builder.h"
// #include "drake/systems/framework/diagram_context.h"
// #include "drake/systems/framework/diagram_continuous_state.h"
// #include "drake/systems/framework/diagram_discrete_values.h"
// #include "drake/systems/framework/diagram_output_port.h"
// #include "drake/systems/framework/diagram_state.h"
// #include "drake/systems/framework/discrete_values.h"
// #include "drake/systems/framework/event.h"
// #include "drake/systems/framework/event_collection.h"
// #include "drake/systems/framework/event_status.h"
// #include "drake/systems/framework/fixed_input_port_value.h"
// #include "drake/systems/framework/framework_common.h"
// #include "drake/systems/framework/input_port.h"
// #include "drake/systems/framework/input_port_base.h"
// #include "drake/systems/framework/leaf_context.h"
// #include "drake/systems/framework/leaf_output_port.h"
// #include "drake/systems/framework/leaf_system.h"
// #include "drake/systems/framework/model_values.h"
// #include "drake/systems/framework/output_port.h"
// #include "drake/systems/framework/output_port_base.h"
// #include "drake/systems/framework/parameters.h"
// #include "drake/systems/framework/port_base.h"
// #include "drake/systems/framework/scalar_conversion_traits.h"
// #include "drake/systems/framework/single_output_vector_source.h"
// #include "drake/systems/framework/state.h"
// #include "drake/systems/framework/subvector.h"
// #include "drake/systems/framework/supervector.h"
// #include "drake/systems/framework/system.h"
// #include "drake/systems/framework/system_base.h"
// #include "drake/systems/framework/system_constraint.h"
// #include "drake/systems/framework/system_html.h"
// #include "drake/systems/framework/system_output.h"
// #include "drake/systems/framework/system_scalar_converter.h"
// #include "drake/systems/framework/system_symbolic_inspector.h"
// #include "drake/systems/framework/system_type_tag.h"
// #include "drake/systems/framework/system_visitor.h"
// #include "drake/systems/framework/value_checker.h"
// #include "drake/systems/framework/value_to_abstract_value.h"
// #include "drake/systems/framework/vector_base.h"
// #include "drake/systems/framework/vector_system.h"
// #include "drake/systems/framework/witness_function.h"
// #include "drake/systems/lcm/connect_lcm_scope.h"
// #include "drake/systems/lcm/lcm_interface_system.h"
// #include "drake/systems/lcm/lcm_log_playback_system.h"
// #include "drake/systems/lcm/lcm_publisher_system.h"
// #include "drake/systems/lcm/lcm_scope_system.h"
// #include "drake/systems/lcm/lcm_subscriber_system.h"
// #include "drake/systems/lcm/serializer.h"
// #include "drake/systems/optimization/system_constraint_adapter.h"
// #include "drake/systems/optimization/system_constraint_wrapper.h"
// #include "drake/systems/primitives/adder.h"
// #include "drake/systems/primitives/affine_system.h"
// #include "drake/systems/primitives/barycentric_system.h"
// #include "drake/systems/primitives/constant_value_source.h"
// #include "drake/systems/primitives/constant_vector_source.h"
// #include "drake/systems/primitives/demultiplexer.h"
// #include "drake/systems/primitives/discrete_derivative.h"
// #include "drake/systems/primitives/discrete_time_delay.h"
// #include "drake/systems/primitives/first_order_low_pass_filter.h"
// #include "drake/systems/primitives/gain.h"
// #include "drake/systems/primitives/integrator.h"
// #include "drake/systems/primitives/linear_system.h"
// #include "drake/systems/primitives/matrix_gain.h"
// #include "drake/systems/primitives/multiplexer.h"
// #include "drake/systems/primitives/pass_through.h"
// #include "drake/systems/primitives/port_switch.h"
// #include "drake/systems/primitives/random_source.h"
// #include "drake/systems/primitives/saturation.h"
// #include "drake/systems/primitives/signal_log.h"
// #include "drake/systems/primitives/signal_logger.h"
// #include "drake/systems/primitives/sine.h"
// #include "drake/systems/primitives/symbolic_vector_system.h"
// #include "drake/systems/primitives/trajectory_affine_system.h"
// #include "drake/systems/primitives/trajectory_linear_system.h"
// #include "drake/systems/primitives/trajectory_source.h"
// #include "drake/systems/primitives/wrap_to_system.h"
// #include "drake/systems/primitives/zero_order_hold.h"
// #include "drake/systems/rendering/frame_velocity.h"
// #include "drake/systems/rendering/multibody_position_to_geometry_pose.h"
// #include "drake/systems/rendering/pose_aggregator.h"
// #include "drake/systems/rendering/pose_bundle.h"
// #include "drake/systems/rendering/pose_bundle_to_draw_message.h"
// #include "drake/systems/rendering/pose_vector.h"
// #include "drake/systems/rendering/render_pose_to_geometry_pose.h"
// #include "drake/systems/sensors/accelerometer.h"
// #include "drake/systems/sensors/beam_model.h"
// #include "drake/systems/sensors/camera_info.h"
// #include "drake/systems/sensors/color_palette.h"
// #include "drake/systems/sensors/gen/beam_model_params.h"
// #include "drake/systems/sensors/gyroscope.h"
// #include "drake/systems/sensors/image.h"
// #include "drake/systems/sensors/image_to_lcm_image_array_t.h"
// #include "drake/systems/sensors/image_writer.h"
// #include "drake/systems/sensors/lcm_image_array_to_images.h"
// #include "drake/systems/sensors/lcm_image_traits.h"
// #include "drake/systems/sensors/optitrack_sender.h"
// #include "drake/systems/sensors/pixel_types.h"
// #include "drake/systems/sensors/rgbd_sensor.h"
// #include "drake/systems/sensors/rotary_encoders.h"
// #include "drake/systems/trajectory_optimization/direct_collocation.h"
// #include "drake/systems/trajectory_optimization/direct_transcription.h"
// #include "drake/systems/trajectory_optimization/integration_constraint.h"
// #include "drake/systems/trajectory_optimization/multiple_shooting.h"
// #include "drake/systems/trajectory_optimization/sequential_expression_manager.h"

// Symbol: pydrake_doc
constexpr struct /* pydrake_doc */ {
  // Symbol: drake
  struct /* drake */ {
    // Symbol: drake::AbstractValue
    struct /* AbstractValue */ {
      // Source: drake/common/value.h:67
      const char* doc =
R"""(A fully type-erased container class. An AbstractValue stores an object
of some type T (where T is declared during at construction time) that
at runtime can be passed between functions without mentioning T. Only
when the stored T must be accessed does the user need to mention T
again.

(Advanced.) Note that AbstractValue's getters and setters method
declare that "If T does not match, a RuntimeError will be thrown with
a helpful error message". The code that implements this check uses
hashing, so in the extraordinarily unlikely case of a 64-bit hash
collision, the error may go undetected in Release builds. (Debug
builds have extra checks that will trigger.)

(Advanced.) Only Value should inherit directly from AbstractValue.
User-defined classes with additional features may inherit from Value.)""";
      // Symbol: drake::AbstractValue::AbstractValue
      struct /* ctor */ {
        // Source: drake/common/value.h:69
        const char* doc = R"""()""";
      } ctor;
      // Symbol: drake::AbstractValue::Clone
      struct /* Clone */ {
        // Source: drake/common/value.h:109
        const char* doc = R"""(Returns a copy of this AbstractValue.)""";
      } Clone;
      // Symbol: drake::AbstractValue::GetNiceTypeName
      struct /* GetNiceTypeName */ {
        // Source: drake/common/value.h:128
        const char* doc =
R"""(Returns a human-readable name for the underlying type T. This may be
slow but is useful for error messages. If T is polymorphic, this
returns the typeid of the most-derived type of the contained object.)""";
      } GetNiceTypeName;
      // Symbol: drake::AbstractValue::Make
      struct /* Make */ {
        // Source: drake/common/value.h:75
        const char* doc =
R"""(Returns an AbstractValue containing the given ``value``.)""";
      } Make;
      // Symbol: drake::AbstractValue::SetFrom
      struct /* SetFrom */ {
        // Source: drake/common/value.h:114
        const char* doc =
R"""(Copies the value in ``other`` to this value. If other is not
compatible with this object, a RuntimeError will be thrown with a
helpful error message.)""";
      } SetFrom;
      // Symbol: drake::AbstractValue::Wrap
      struct /* Wrap */ {
        // Source: drake/common/value.h:135
        const char* doc = R"""()""";
        // Symbol: drake::AbstractValue::Wrap::value
        struct /* value */ {
          // Source: drake/common/value.h:135
          const char* doc = R"""()""";
        } value;
      } Wrap;
      // Symbol: drake::AbstractValue::get_mutable_value
      struct /* get_mutable_value */ {
        // Source: drake/common/value.h:91
        const char* doc =
R"""(Returns the value wrapped in this AbstractValue as mutable reference.
The reference remains valid only until this object is set or
destroyed.

Template parameter ``T``:
    The originally declared type of this AbstractValue, e.g., from
    AbstractValue::Make<T>() or Value<T>::Value(). If T does not
    match, a RuntimeError will be thrown with a helpful error message.)""";
      } get_mutable_value;
      // Symbol: drake::AbstractValue::get_value
      struct /* get_value */ {
        // Source: drake/common/value.h:83
        const char* doc =
R"""(Returns the value wrapped in this AbstractValue as a const reference.
The reference remains valid only until this object is set or
destroyed.

Template parameter ``T``:
    The originally declared type of this AbstractValue, e.g., from
    AbstractValue::Make<T>() or Value<T>::Value(). If T does not
    match, a RuntimeError will be thrown with a helpful error message.)""";
      } get_value;
      // Symbol: drake::AbstractValue::maybe_get_value
      struct /* maybe_get_value */ {
        // Source: drake/common/value.h:106
        const char* doc =
R"""(Returns the value wrapped in this AbstractValue, if T matches the
originally declared type of this AbstractValue.

Template parameter ``T``:
    The originally declared type of this AbstractValue, e.g., from
    AbstractValue::Make<T>() or Value<T>::Value(). If T does not
    match, returns nullptr.)""";
      } maybe_get_value;
      // Symbol: drake::AbstractValue::set_value
      struct /* set_value */ {
        // Source: drake/common/value.h:98
        const char* doc =
R"""(Sets the value wrapped in this AbstractValue.

Template parameter ``T``:
    The originally declared type of this AbstractValue, e.g., from
    AbstractValue::Make<T>() or Value<T>::Value(). If T does not
    match, a RuntimeError will be thrown with a helpful error message.)""";
      } set_value;
      // Symbol: drake::AbstractValue::static_type_info
      struct /* static_type_info */ {
        // Source: drake/common/value.h:123
        const char* doc =
R"""(Returns typeid(T) for this Value<T> object. If T is polymorphic, this
does NOT reflect the typeid of the most-derived type of the contained
object; the result is always the base type T.)""";
      } static_type_info;
      // Symbol: drake::AbstractValue::type_info
      struct /* type_info */ {
        // Source: drake/common/value.h:118
        const char* doc =
R"""(Returns typeid of the contained object of type T. If T is polymorphic,
this returns the typeid of the most-derived type of the contained
object.)""";
      } type_info;
    } AbstractValue;
    // Symbol: drake::AutoDiffVecXd
    struct /* AutoDiffVecXd */ {
      // Source: drake/common/eigen_autodiff_types.h:36
      const char* doc =
R"""(A dynamic-sized vector of autodiff variables, each with a
dynamic-sized vector of partials.)""";
    } AutoDiffVecXd;
    // Symbol: drake::AutoDiffXd
    struct /* AutoDiffXd */ {
      // Source: drake/common/eigen_autodiff_types.h:22
      const char* doc =
R"""(An autodiff variable with a dynamic number of partials.)""";
    } AutoDiffXd;
    // Symbol: drake::DefaultHash
    struct /* DefaultHash */ {
      // Source: drake/common/hash.h:245
      const char* doc =
R"""(The default hashing functor, akin to std::hash.)""";
    } DefaultHash;
    // Symbol: drake::DefaultHasher
    struct /* DefaultHasher */ {
      // Source: drake/common/hash.h:242
      const char* doc =
R"""(The default HashAlgorithm concept implementation across Drake. This is
guaranteed to have a result_type of size_t to be compatible with
std::hash.)""";
    } DefaultHasher;
    // Symbol: drake::DelegatingHasher
    struct /* DelegatingHasher */ {
      // Source: drake/common/hash.h:251
      const char* doc =
R"""(An adapter that forwards the HashAlgorithm::operator(data, length)
function concept into a runtime-provided std::function of the same
signature. This is useful for passing a concrete HashAlgorithm
implementation through into non-templated code, such as with an Impl
or Cell pattern.)""";
      // Symbol: drake::DelegatingHasher::DelegatingHasher
      struct /* ctor */ {
        // Source: drake/common/hash.h:256
        const char* doc =
R"""(Create a delegating hasher that calls the given ``func``.)""";
      } ctor;
      // Symbol: drake::DelegatingHasher::Func
      struct /* Func */ {
        // Source: drake/common/hash.h:253
        const char* doc =
R"""(A std::function whose signature matches HashAlgorithm::operator().)""";
      } Func;
      // Symbol: drake::DelegatingHasher::operator()
      struct /* operator_call */ {
        // Source: drake/common/hash.h:262
        const char* doc =
R"""(Append [data, data + length) bytes into the wrapped algorithm.)""";
      } operator_call;
    } DelegatingHasher;
    // Symbol: drake::EigenPtr
    struct /* EigenPtr */ {
      // Source: drake/common/eigen_types.h:329
      const char* doc =
R"""(This wrapper class provides a way to write non-template functions
taking raw pointers to Eigen objects as parameters while limiting the
number of copies, similar to ``Eigen::Ref``. Internally, it keeps an
instance of ``Eigen::Ref<T>`` and provides access to it via
``operator*`` and ``operator->``. As with ordinary pointers, these
operators do not perform nullptr checks in Release builds. User-facing
APIs should check for nullptr explicitly.

The primary motivation of this class is to follow <a
href="https://google.github.io/styleguide/cppguide.html#Reference_Arguments">GSG's
"output arguments should be pointers" convention</a> while taking
advantage of using ``Eigen::Ref``. It can also be used to pass
optional Eigen objects since EigenPtr, unlike ``Eigen::Ref``, can be
null.

Some examples:


::

    // This function is taking an Eigen::Ref of a matrix and modifies it in
    // the body. This violates GSG's pointer convention for output parameters.
    void foo(Eigen::Ref<Eigen::MatrixXd> M) {
       M(0, 0) = 0;
    }
    // At Call-site, we have:
    foo(M);
    foo(M.block(0, 0, 2, 2));
    
    // We can rewrite the above function into the following using EigenPtr.
    void foo(EigenPtr<Eigen::MatrixXd> M) {
       DRAKE_THROW_UNLESS(M != nullptr);  // If you want a Release-build check.
       (*M)(0, 0) = 0;
    }
    // Note that, call sites should be changed to:
    foo(&M);
    
    // We need tmp to avoid taking the address of a temporary object such as the
    // return value of .block().
    auto tmp = M.block(0, 0, 2, 2);
    foo(&tmp);

Notice that methods taking an EigenPtr can mutate the entries of a
matrix as in method ``foo()`` in the example code above, but cannot
change its size. This is because ``operator*`` and ``operator->``
return an ``Eigen::Ref<T>`` object and only plain matrices/arrays can
be resized and not expressions. This **is** the desired behavior,
since resizing the block of a matrix or even a more general expression
should not be allowed. If you do want to be able to resize a mutable
matrix argument, then you must pass it as a ``Matrix<T>*``, like so:


::

    void bar(Eigen::MatrixXd* M) {
      DRAKE_THROW_UNLESS(M != nullptr);
      // In this case this method only works with 4x3 matrices.
      if (M->rows() != 4 && M->cols() != 3) {
        M->resize(4, 3);
      }
      (*M)(0, 0) = 0;
    }

Note:
    This class provides a way to avoid the ``const_cast`` hack
    introduced in <a
    href="https://eigen.tuxfamily.org/dox/TopicFunctionTakingEigenTypes.html#TopicPlainFunctionsFailing">Eigen's
    documentation</a>.)""";
      // Symbol: drake::EigenPtr::EigenPtr<PlainObjectType>
      struct /* ctor */ {
        // Source: drake/common/eigen_types.h:333
        const char* doc_0args = R"""()""";
        // Source: drake/common/eigen_types.h:337
        const char* doc_1args_stdnullptrt = R"""(Overload for ``nullptr``.)""";
        // Source: drake/common/eigen_types.h:340
        const char* doc_copy =
R"""(Copy constructor results in a *reference* to the given matrix type.)""";
        // Source: drake/common/eigen_types.h:346
        const char* doc_1args_PlainObjectTypeIn =
R"""(Constructs with a reference to another matrix type. May be
``nullptr``.)""";
        // Source: drake/common/eigen_types.h:355
        const char* doc_1args_constEigenPtr = R"""(Constructs from another EigenPtr.)""";
      } ctor;
      // Symbol: drake::EigenPtr::RefType
      struct /* RefType */ {
        // Source: drake/common/eigen_types.h:331
        const char* doc = R"""()""";
      } RefType;
      // Symbol: drake::EigenPtr::operator bool
      struct /* operator_bool */ {
        // Source: drake/common/eigen_types.h:379
        const char* doc =
R"""(Returns whether or not this contains a valid reference.)""";
      } operator_bool;
      // Symbol: drake::EigenPtr::operator!=
      struct /* operator_ne */ {
        // Source: drake/common/eigen_types.h:383
        const char* doc = R"""()""";
      } operator_ne;
      // Symbol: drake::EigenPtr::operator*
      struct /* operator_mul */ {
        // Source: drake/common/eigen_types.h:373
        const char* doc =
R"""(Precondition:
    The pointer is not null (enforced in Debug builds only).)""";
      } operator_mul;
    } EigenPtr;
    // Symbol: drake::EigenSizeMinPreferDynamic
    struct /* EigenSizeMinPreferDynamic */ {
      // Source: drake/common/eigen_types.h:177
      const char* doc =
R"""(EigenSizeMinPreferDynamic<a, b>::value gives the min between
compile-time sizes ``a`` and ``b``. 0 has absolute priority, followed
by 1, followed by Dynamic, followed by other finite values.

Note that this is a type-trait version of
EIGEN_SIZE_MIN_PREFER_DYNAMIC macro in "Eigen/Core/util/Macros.h".)""";
    } EigenSizeMinPreferDynamic;
    // Symbol: drake::EigenSizeMinPreferFixed
    struct /* EigenSizeMinPreferFixed */ {
      // Source: drake/common/eigen_types.h:193
      const char* doc =
R"""(EigenSizeMinPreferFixed is a variant of EigenSizeMinPreferDynamic. The
difference is that finite values now have priority over Dynamic, so
that EigenSizeMinPreferFixed<3, Dynamic>::value gives 3.

Note that this is a type-trait version of EIGEN_SIZE_MIN_PREFER_FIXED
macro in "Eigen/Core/util/Macros.h".)""";
    } EigenSizeMinPreferFixed;
    // Symbol: drake::ExtractDoubleOrThrow
    struct /* ExtractDoubleOrThrow */ {
      // Source: drake/common/autodiff_overloads.h:159
      const char* doc_1args_constEigenAutoDiffScalar =
R"""(Returns the autodiff scalar's value() as a double. Never throws.
Overloads ExtractDoubleOrThrow from common/extract_double.h.)""";
      // Source: drake/common/extract_double.h:24
      const char* doc_1args_constT =
R"""(Converts a ScalarType value to a double, failing at runtime (not
compile time) if the type cannot be converted to a double.

This function is useful for writing ScalarType-generic code that (1)
can reasonably discard any supplemental scalar data, e.g., the
derivatives of an AutoDiffScalar, and (2) is reasonable to fail at
runtime if the extraction fails.

The default implementation throws an exception. ScalarTypes that can
hold a numeric value must overload this method to provide an
appropriate extraction. An overload for ``double`` is already
provided.

See autodiff_overloads.h to use this with Eigen's AutoDiffScalar. See
symbolic_expression.h to use this with symbolic::Expression.)""";
      // Source: drake/common/extract_double.h:30
      const char* doc_1args_scalar =
R"""(Returns ``scalar`` as a double. Never throws.)""";
      // Source: drake/common/symbolic_expression.h:1482
      const char* doc_1args_e =
R"""(Returns the symbolic expression's value() as a double.

Raises:
    RuntimeError if it is not possible to evaluate the symbolic
    expression with an empty environment.)""";
    } ExtractDoubleOrThrow;
    // Symbol: drake::FindResource
    struct /* FindResource */ {
      // Source: drake/common/find_resource.h:95
      const char* doc =
R"""(Attempts to locate a Drake resource named by the given
``resource_path``. The ``resource_path`` refers to the relative path
within the Drake source repository, prepended with ``drake/``. For
example, to find the source file ``examples/pendulum/Pendulum.urdf``,
the ``resource_path`` would be
``drake/examples/pendulum/Pendulum.urdf``. Paths that do not start
with ``drake/`` will return an error result. The ``resource_path``
must refer to a file (not a directory).

The search scans for the resource in the following resource roots and
in the following order:

1. In the DRAKE_RESOURCE_ROOT environment variable.
2. In the Bazel runfiles for a bazel-bin/pkg/program.
3. In the Drake CMake install directory.

The first resource root from the list that exists is used to find any
and all Drake resources. If the resource root does not contain the
resource, the result is an error even (if a resource root lower on the
list happens to have the resource). If all three roots are
unavailable, then returns an error result.)""";
    } FindResource;
    // Symbol: drake::FindResourceOrThrow
    struct /* FindResourceOrThrow */ {
      // Source: drake/common/find_resource.h:99
      const char* doc =
R"""(Convenient wrapper for querying FindResource(resource_path) followed
by FindResourceResult::get_absolute_path_or_throw().)""";
    } FindResourceOrThrow;
    // Symbol: drake::FindResourceResult
    struct /* FindResourceResult */ {
      // Source: drake/common/find_resource.h:21
      const char* doc =
R"""(Models the outcome of drake::FindResource. After a call to
FindResource, typical calling code would use
get_absolute_path_or_throw(). Alternatively, get_absolute_path() will
return an ``optional<string>``, which can be manually checked to
contain a value before using the path. If the resource was not found,
get_error_message() will contain an error message.

For a given FindResourceResult instance, exactly one of
get_absolute_path() or get_error_message() will contain a value.
(Similarly, exactly one of them will not contain a value.))""";
      // Symbol: drake::FindResourceResult::FindResourceResult
      struct /* ctor */ {
        // Source: drake/common/find_resource.h:23
        const char* doc = R"""()""";
      } ctor;
      // Symbol: drake::FindResourceResult::get_absolute_path
      struct /* get_absolute_path */ {
        // Source: drake/common/find_resource.h:26
        const char* doc =
R"""(Returns the absolute path to the resource, iff the resource was found.)""";
      } get_absolute_path;
      // Symbol: drake::FindResourceResult::get_absolute_path_or_throw
      struct /* get_absolute_path_or_throw */ {
        // Source: drake/common/find_resource.h:30
        const char* doc =
R"""(Either returns the get_absolute_path() iff the resource was found, or
else throws RuntimeError.)""";
      } get_absolute_path_or_throw;
      // Symbol: drake::FindResourceResult::get_error_message
      struct /* get_error_message */ {
        // Source: drake/common/find_resource.h:34
        const char* doc =
R"""(Returns the error message, iff the resource was not found. The string
will never be empty; only the optional can be empty.)""";
      } get_error_message;
      // Symbol: drake::FindResourceResult::get_resource_path
      struct /* get_resource_path */ {
        // Source: drake/common/find_resource.h:38
        const char* doc =
R"""(Returns the resource_path asked of FindResource. (This may be empty
only in the make_empty() case.))""";
      } get_resource_path;
      // Symbol: drake::FindResourceResult::make_empty
      struct /* make_empty */ {
        // Source: drake/common/find_resource.h:54
        const char* doc =
R"""(Returns an empty error result (no requested resource).)""";
      } make_empty;
      // Symbol: drake::FindResourceResult::make_error
      struct /* make_error */ {
        // Source: drake/common/find_resource.h:50
        const char* doc =
R"""(Returns an error result (the requested resource was NOT found).

Precondition:
    neither string parameter is empty

Parameter ``resource_path``:
    the value passed to FindResource)""";
      } make_error;
      // Symbol: drake::FindResourceResult::make_success
      struct /* make_success */ {
        // Source: drake/common/find_resource.h:44
        const char* doc =
R"""(Returns a success result (the requested resource was found).

Precondition:
    neither string parameter is empty

Parameter ``resource_path``:
    the value passed to FindResource

Parameter ``base_path``:
    an absolute base path that precedes resource_path)""";
      } make_success;
    } FindResourceResult;
    // Symbol: drake::FindRunfile
    struct /* FindRunfile */ {
      // Source: drake/common/find_runfiles.h:41
      const char* doc =
R"""((Advanced.) Returns the absolute path to the given resource_path from
Bazel runfiles, or else an error message when not found. When
HasRunfiles() is false, returns an error. The ``resource_path`` looks
like ``workspace/pkg/subpkg/file.ext``, e.g., "drake/common/foo.txt".)""";
    } FindRunfile;
    // Symbol: drake::GetScopedSingleton
    struct /* GetScopedSingleton */ {
      // Source: drake/common/scoped_singleton.h:26
      const char* doc =
R"""(Provides thread-safe, global-safe access to a shared resource. When
all references are gone, the resource will be freed due to using a
weak_ptr.

Template parameter ``T``:
    Class of the resource. Must be default-constructible.

Template parameter ``Unique``:
    Optional class, meant to make a unique specialization, such that
    you can have multiple singletons of T if necessary.

Note:
    An example application is obtaining license for multiple disjoint
    solver objects, where acquiring a license requires network
    communication, and the solver is under an interface where you
    cannot explicitly pass the license resource to the solver without
    violating encapsulation.)""";
    } GetScopedSingleton;
    // Symbol: drake::HasRunfiles
    struct /* HasRunfiles */ {
      // Source: drake/common/find_runfiles.h:26
      const char* doc =
R"""((Advanced.) Returns true iff this process has Bazel runfiles
available. For both C++ and Python programs, and no matter what
workspace a program resides in (``@drake`` or otherwise), this will be
true when running ``bazel-bin/pkg/program`` or ``bazel test
//pkg:program`` or ``bazel run //pkg:program``.)""";
    } HasRunfiles;
    // Symbol: drake::Identifier
    struct /* Identifier */ {
      // Source: drake/common/identifier.h:138
      const char* doc =
R"""(A simple identifier class.

Note:
    This is *purposely* a separate class from TypeSafeIndex. For more
    explanatation, see TypeSafeIndexVsIndentifier "this section".

This class serves as an upgrade to the standard practice of passing
``int`s around as unique identifiers (or, as in this case,
`int64_t`s). In the common practice, a method that takes identifiers
to different types of objects would have an interface like:


::

    void foo(int64_t bar_id, int64_t thing_id);

It is possible for a programmer to accidentally switch the two ids in
an invocation. This mistake would still be *syntactically* correct; it
will successfully compile but lead to inscrutable run-time errors.
This identifier class provides the same speed and efficiency of
passing `int64_t`s, but enforces unique types and limits the valid
operations, providing compile-time checking. The function would now
look like:


::

    void foo(BarId bar_id, ThingId thing_id)

and the compiler will catch instances where the order is reversed.

The identifier is a *stripped down* 64-bit int. Each uniquely declared
identifier type has the following properties:

- The identifier's default constructor produces *invalid* identifiers.
- Valid identifiers must be constructed via the copy constructor or through
Identifier::get_new_id().
- The identifier is immutable.
- The identifier can only be tested for equality/inequality with other
identifiers of the *same* type.
- Identifiers of different types are *not* interconvertible.
- The identifier can be queried for its underlying `int64_t`` value.
- The identifier can be written to an output stream; its underlying ``int64_t``
value gets written.
- Identifiers are not guaranteed to possess *meaningful* ordering. I.e.,
identifiers for two objects created sequentially may not have sequential
identifier values.
- Identifiers can only be generated from the static method get_new_id().

While there *is* the concept of an invalid identifier, this only
exists to facilitate use with STL containers that require default
constructors. Using an invalid identifier is generally considered to
be an error. In Debug build, attempts to compare, get the value of, or
write an invalid identifier to a stream will throw an exception.

Functions that query for identifiers should not return invalid
identifiers. We prefer the practice of returning
std::optional<Identifier> instead.

It is the designed intent of this class, that ids derived from this
class can be passed and returned by value. (Drake's typical calling
convention requires passing input arguments by const reference, or by
value when moved from. That convention does not apply to this class.)

The following alias will create a unique identifier type for class
``Foo``:


::

    using FooId = Identifier<class FooTag>;

**Examples of valid and invalid operations**

The Identifier guarantees that id instances of different types can't
be compared or combined. Efforts to do so will cause a compile-time
failure. For example:


::

    using AId = Identifier<class ATag>;
    using BId = Identifier<class BTag>;
    AId a1;                              // Compiler error; there is no
    //   default constructor.
    AId a2 = AId::get_new_id();          // Ok.
    AId a3(a2);                          // Ok.
    AId a4 = AId::get_new_id();          // Ok.
    BId b = BId::get_new_id();           // Ok.
    if ( a2 == 1 ) { ... }               // Compiler error.
    if ( a2 == a4 ) { ... }              // Ok, evaluates to false.
    if ( a2 == a3 ) { ... }              // Ok, evaluates to true.
    if ( a2 == b ) { ... }               // Compiler error.
    a4 = a2;                             // Ok.
    a3 = 7;                              // Compiler error.

**TypeSafeIndex vs Identifier**

In principle, the *identifier* is related to the TypeSafeIndex. In
some sense, both are "type-safe" ``int`s. They differ in their
semantics. We can consider `ints``, indices, and identifiers as a list
of ``int`` types with *decreasing* functionality.

- The int, obviously, has the full range of C++ ints.
- The TypeSafeIndex can be implicitly cast *to* an int, but there are a
limited number of operations *on* the index that produce other instances
of the index (e.g., increment, in-place addition, etc.) They can be
compared with ``int`` and other indices of the same type. This behavior
arises from the intention of having them serve as an *index* in an
ordered set (e.g., ``std::vector``).
- The Identifier is the most restricted. They exist solely to serve as a
unique identifier. They are immutable when created. Very few operations
exist on them (comparison for *equality* with other identifiers of the same
type, hashing, writing to output stream). These *cannot* be used as
indices.

Ultimately, indices *can* serve as identifiers (within the scope of
the object they index into). Although, their mutability could make
this a dangerous practice for a public API. Identifiers are more
general in that they don't reflect an object's position in memory
(hence the inability to transform to or compare with an ``int``). This
decouples details of implementation from the idea of the object.
Combined with its immutability, it would serve well as a element of a
public API.

See also:
    TypeSafeIndex

Template parameter ``Tag``:
    The name of the tag that uniquely segregates one instantiation
    from another.)""";
      // Symbol: drake::Identifier::Identifier<Tag>
      struct /* ctor */ {
        // Source: drake/common/identifier.h:144
        const char* doc =
R"""(Default constructor; the result is an *invalid* identifier. This only
exists to satisfy demands of working with various container classes.)""";
      } ctor;
      // Symbol: drake::Identifier::get_new_id
      struct /* get_new_id */ {
        // Source: drake/common/identifier.h:185
        const char* doc =
R"""(Generates a new identifier for this id type. This new identifier will
be different from all previous identifiers created. This method does
*not* make any guarantees about the values of ids from successive
invocations. This method is guaranteed to be thread safe.)""";
      } get_new_id;
      // Symbol: drake::Identifier::get_value
      struct /* get_value */ {
        // Source: drake/common/identifier.h:149
        const char* doc =
R"""(Extracts the underlying representation from the identifier. This is
considered invalid for invalid ids and is strictly enforced in Debug
builds.)""";
      } get_value;
      // Symbol: drake::Identifier::is_valid
      struct /* is_valid */ {
        // Source: drake/common/identifier.h:157
        const char* doc = R"""(Reports if the id is valid.)""";
      } is_valid;
      // Symbol: drake::Identifier::operator!=
      struct /* operator_ne */ {
        // Source: drake/common/identifier.h:169
        const char* doc =
R"""(Compares one identifier with another of the same type for inequality.
This is considered invalid for invalid ids and is strictly enforced in
Debug builds.)""";
      } operator_ne;
      // Symbol: drake::Identifier::operator<
      struct /* operator_lt */ {
        // Source: drake/common/identifier.h:176
        const char* doc =
R"""(Compare two identifiers in order to define a total ordering among
identifiers. This makes identifiers compatible with data structures
which require total ordering (e.g., std::set).)""";
      } operator_lt;
    } Identifier;
    // Symbol: drake::IsApproxEqualAbsTolWithPermutedColumns
    struct /* IsApproxEqualAbsTolWithPermutedColumns */ {
      // Source: drake/common/is_approx_equal_abstol.h:38
      const char* doc =
R"""(Returns true if and only if a simple greedy search reveals a
permutation of the columns of m2 to make the matrix equal to m1 to
within a certain absolute elementwise ``tolerance``. E.g., there
exists a P such that


::

    forall i,j,  |m1 - m2*P|_{i,j} <= tolerance
       where P is a permutation matrix:
          P(i,j)={0,1}, sum_i P(i,j)=1, sum_j P(i,j)=1.

Note: Returns false for matrices of different sizes. Note: The current
implementation is O(n^2) in the number of columns. Note: In marginal
cases (with similar but not identical columns) this algorithm can fail
to find a permutation P even if it exists because it accepts the first
column match (m1(i),m2(j)) and removes m2(j) from the pool. It is
possible that other columns of m2 would also match m1(i) but that
m2(j) is the only match possible for a later column of m1.)""";
    } IsApproxEqualAbsTolWithPermutedColumns;
    // Symbol: drake::LoadedLibraryPath
    struct /* LoadedLibraryPath */ {
      // Source: drake/common/find_loaded_library.h:11
      const char* doc =
R"""(This function returns the absolute path of the library with the name
``library_name`` if that library was loaded in the current running
process. Otherwise it returns an empty optional.)""";
    } LoadedLibraryPath;
    // Symbol: drake::MakeNameValue
    struct /* MakeNameValue */ {
      // Source: drake/common/name_value.h:93
      const char* doc =
R"""((Advanced.) Creates a NameValue. The conventional method for calling
this function is the DRAKE_NVP sugar macro below.

Both pointers are aliased for the lifetime of the return value.)""";
    } MakeNameValue;
    // Symbol: drake::MakeSortedPair
    struct /* MakeSortedPair */ {
      // Source: drake/common/sorted_pair.h:147
      const char* doc =
R"""(A convenience wrapper for creating a sorted pair from two objects.

Parameter ``x``:
    The first_ object.

Parameter ``y``:
    The second_ object.

Returns:
    A newly-constructed SortedPair object.)""";
    } MakeSortedPair;
    // Symbol: drake::MaybeGetDrakePath
    struct /* MaybeGetDrakePath */ {
      // Source: drake/common/drake_path.h:18
      const char* doc =
R"""((Advanced) Returns the fully-qualified path to the first folder
containing Drake resources as located by FindResource, or nullopt if
none is found. For example
``${result}/examples/pendulum/Pendulum.urdf`` would be the path to the
Pendulum example's URDF resource.

Most users should prefer FindResource() or FindResourceOrThrow() to
locate Drake resources for a specific resource filename. This method
only exists for legacy compatibility reasons, and might eventually be
removed.)""";
    } MaybeGetDrakePath;
    // Symbol: drake::MultiplyEigenSizes
    struct /* MultiplyEigenSizes */ {
      // Source: drake/common/eigen_types.h:207
      const char* doc =
R"""(MultiplyEigenSizes<a, b> gives a * b if both of a and b are fixed
sizes. Otherwise it gives Eigen::Dynamic.)""";
    } MultiplyEigenSizes;
    // Symbol: drake::NameValue
    struct /* NameValue */ {
      // Source: drake/common/name_value.h:61
      const char* doc =
R"""(A basic implementation of the Name-Value Pair concept as used in the
Serialize / Archive pattern. See, for example:
https://www.boost.org/doc/libs/release/libs/serialization/doc/wrappers.html#nvp

NameValue stores a pointer to a const ``name`` and a pointer to a
mutable ``value``. Both pointers must remain valid throughout the
lifetime of an object. NameValue objects are typically short-lived,
existing only for a transient moment while an Archive is visiting some
Serializable field.)""";
      // Symbol: drake::NameValue::NameValue<T>
      struct /* ctor */ {
        // Source: drake/common/name_value.h:71
        const char* doc =
R"""((Advanced.) Constructs a NameValue. Prefer DRAKE_NVP instead of this
constructor. Both pointers are aliased and must remain valid for the
lifetime of this object. Neither pointer can be nullptr.)""";
      } ctor;
      // Symbol: drake::NameValue::name
      struct /* name */ {
        // Source: drake/common/name_value.h:79
        const char* doc = R"""()""";
      } name;
      // Symbol: drake::NameValue::value
      struct /* value */ {
        // Source: drake/common/name_value.h:80
        const char* doc = R"""()""";
      } value;
      // Symbol: drake::NameValue::value_type
      struct /* value_type */ {
        // Source: drake/common/name_value.h:66
        const char* doc = R"""(Type of the referenced value.)""";
      } value_type;
    } NameValue;
    // Symbol: drake::NiceTypeName
    struct /* NiceTypeName */ {
      // Source: drake/common/nice_type_name.h:44
      const char* doc =
R"""(Obtains canonicalized, platform-independent, human-readable names for
arbitrarily-complicated C++ types.

Usage:


::

    // For types:
    using std::pair; using std::string;
    using MyVectorType = pair<int,string>;
    std::cout << "Type MyVectorType was: "
    << drake::NiceTypeName::Get<MyVectorType>() << std::endl;
    // Output: std::pair<int,std::string>
    
    // For expressions:
    std::unique_ptr<AbstractThing> thing;  // Assume actual type is ConcreteThing.
    std::cout << "Actual type of 'thing' was: "
    << drake::NiceTypeName::Get(*thing) << std::endl;
    // Output: ConcreteThing

We demangle and attempt to canonicalize the compiler-generated type
names as reported by ``typeid(T).name()`` so that the same string is
returned by all supported compilers and platforms. The output of
NiceTypeName::Get<T>() is useful in error and log messages and
testing. It also provides a persistent, platform-independent
identifier for types; ``std::type_info`` cannot provide that.

Warning:
    Don't expect usable names for types that are defined in an
    anonymous namespace or for function-local types. Names will still
    be produced but they won't be unique, pretty, or
    compiler-independent.

This class exists only to group type name-related static methods;
don't try to construct an object of this type.)""";
      // Symbol: drake::NiceTypeName::Canonicalize
      struct /* Canonicalize */ {
        // Source: drake/common/nice_type_name.h:89
        const char* doc =
R"""(Given a compiler-dependent demangled type name string as returned by
Demangle(), attempts to form a canonicalized representation that will
be the same for any compiler. Unnecessary spaces and superfluous
keywords like "class" and "struct" are removed. The
NiceTypeName::Get<T>() method uses this function to produce a
human-friendly type name that is the same on any platform.)""";
      } Canonicalize;
      // Symbol: drake::NiceTypeName::Demangle
      struct /* Demangle */ {
        // Source: drake/common/nice_type_name.h:81
        const char* doc =
R"""(Using the algorithm appropriate to the current compiler, demangles a
type name as returned by ``typeid(T).name()``, with the result
hopefully suitable for meaningful display to a human. The result is
compiler-dependent.

See also:
    Canonicalize())""";
      } Demangle;
      // Symbol: drake::NiceTypeName::Get
      struct /* Get */ {
        // Source: drake/common/nice_type_name.h:53
        const char* doc_0args =
R"""(Attempts to return a nicely demangled and canonicalized type name that
is the same on all platforms, using Canonicalize(). This is an
expensive operation but is only done once per instantiation of
NiceTypeName::Get<T>() for a given type ``T``. The returned reference
will not be deleted even at program termination, so feel free to use
it in error messages even in destructors that may be invoked during
program tear-down.)""";
        // Source: drake/common/nice_type_name.h:66
        const char* doc_1args_constT =
R"""(Returns the type name of the most-derived type of an object of type T,
typically but not necessarily polymorphic. This must be calculated on
the fly so is expensive whenever called, though very reasonable for
use in error messages. For non-polymorphic types this produces the
same result as would ``Get<decltype(thing)>()`` but for polymorphic
types the results will differ.)""";
        // Source: drake/common/nice_type_name.h:73
        const char* doc_1args_info =
R"""(Returns the nicely demangled and canonicalized type name of ``info``.
This must be calculated on the fly so is expensive whenever called,
though very reasonable for use in error messages.)""";
      } Get;
      // Symbol: drake::NiceTypeName::RemoveNamespaces
      struct /* RemoveNamespaces */ {
        // Source: drake/common/nice_type_name.h:99
        const char* doc =
R"""(Given a canonical type name that may include leading namespaces,
attempts to remove those namespaces. For example,
``drake::systems::MyThing<internal::type>`` becomes
``MyThing<internal::type>``. If the last segment ends in ``::``, the
original string is returned unprocessed. Note that this is just string
processing -- a segment that looks like a namespace textually will be
treated as one, even if it is really a class. So
``drake::MyClass::Impl`` will be reduced to ``Impl`` while
``drake::MyClass<T>::Impl`` is reduced to ``MyClass<T>::Impl``.)""";
      } RemoveNamespaces;
    } NiceTypeName;
    // Symbol: drake::Polynomial
    struct /* Polynomial */ {
      // Source: drake/common/polynomial.h:43
      const char* doc =
R"""(A scalar multi-variate polynomial, modeled after the msspoly in
spotless.

Polynomial represents a list of additive Monomials, each one of which
is a product of a constant coefficient (of T, which by default is
double) and any number of distinct Terms (variables raised to positive
integer powers).

Variables are identified by integer indices rather than symbolic
names, but an automatic facility is provided to covert variable names
up to four characters into unique integers, provided those variables
are named using only lowercase letters and the "#_." characters
followed by a number. For example, valid names include "dx4" and
"m_x".

Monomials which have the same variables and powers may be constructed
but will be automatically combined: (3 * a * b * a) + (1.5 * b * a**2)
will be reduced to (4.5 * b * a**2) internally after construction.

Polynomials can be added, subtracted, and multiplied. They may only be
divided by scalars (of T) because Polynomials are not closed under
division.)""";
      // Symbol: drake::Polynomial::CoefficientsAlmostEqual
      struct /* CoefficientsAlmostEqual */ {
        // Source: drake/common/polynomial.h:402
        const char* doc =
R"""(Checks if a Polynomial is approximately equal to this one.

Checks that every coefficient of ``other`` is within ``tol`` of the
corresponding coefficient of this Polynomial.

Note: When ``tol_type`` is kRelative, if any monomials appear in
``this`` or ``other`` but not both, then the method returns false
(since the comparison is relative to a missing zero coefficient). Use
kAbsolute if you want to ignore non-matching monomials with
coefficients less than ``tol``.)""";
      } CoefficientsAlmostEqual;
      // Symbol: drake::Polynomial::Derivative
      struct /* Derivative */ {
        // Source: drake/common/polynomial.h:296
        const char* doc =
R"""(Takes the derivative of this (univariate) Polynomial.

Returns a new Polynomial that is the derivative of this one in its
sole variable.

Raises:
    RuntimeError if this Polynomial is not univariate.

If derivative_order is given, takes the nth derivative of this
Polynomial.)""";
      } Derivative;
      // Symbol: drake::Polynomial::EvaluateMultivariate
      struct /* EvaluateMultivariate */ {
        // Source: drake/common/polynomial.h:250
        const char* doc =
R"""(Evaluate a multivariate Polynomial at a specific point.

Evaluates a Polynomial with the given values for each variable.

Raises:
    ValueError if the Polynomial contains variables for which values
    were not provided.

The provided values may be of any type which is std::is_arithmetic
(supporting the std::pow, *, and + operations) and need not be
CoefficientsType or RealScalar))""";
      } EvaluateMultivariate;
      // Symbol: drake::Polynomial::EvaluatePartial
      struct /* EvaluatePartial */ {
        // Source: drake/common/polynomial.h:277
        const char* doc =
R"""(Substitute values for some but not necessarily all variables of a
Polynomial.

Analogous to EvaluateMultivariate, but: (1) Restricted to T, and (2)
Need not map every variable in var_values.

Returns a Polynomial in which each variable in var_values has been
replaced with its value and constants appropriately combined.)""";
      } EvaluatePartial;
      // Symbol: drake::Polynomial::EvaluateUnivariate
      struct /* EvaluateUnivariate */ {
        // Source: drake/common/polynomial.h:205
        const char* doc =
R"""(Evaluate a univariate Polynomial at a specific point.

Evaluates a univariate Polynomial at the given x.

Raises:
    RuntimeError if this Polynomial is not univariate.

``x`` may be of any type supporting the ** and + operations (which can
be different from both CoefficientsType and RealScalar).

This method may also be used for efficient evaluation of the
derivatives of the univariate polynomial, evaluated at ``x``.
``derivative_order`` = 0 (the default) returns the polynomial value
without differentiation. ``derivative_order`` = 1 returns the first
derivative, etc.

Precondition:
    derivative_order must be non-negative.)""";
      } EvaluateUnivariate;
      // Symbol: drake::Polynomial::FromExpression
      struct /* FromExpression */ {
        // Source: drake/common/polynomial.h:412
        const char* doc =
R"""(Constructs a Polynomial representing the symbolic expression ``e``.
Note that the ID of a variable is preserved in this translation.

Raises:
    RuntimeError if ``e`` is not polynomial-convertible.

Precondition:
    e.is_polynomial() is true.)""";
      } FromExpression;
      // Symbol: drake::Polynomial::GetCoefficients
      struct /* GetCoefficients */ {
        // Source: drake/common/polynomial.h:184
        const char* doc = R"""()""";
      } GetCoefficients;
      // Symbol: drake::Polynomial::GetDegree
      struct /* GetDegree */ {
        // Source: drake/common/polynomial.h:173
        const char* doc =
R"""(Returns the highest degree of any Monomial in this Polynomial.

The degree of a multivariate Monomial is the product of the degrees of
each of its terms.)""";
      } GetDegree;
      // Symbol: drake::Polynomial::GetMonomials
      struct /* GetMonomials */ {
        // Source: drake/common/polynomial.h:182
        const char* doc = R"""()""";
      } GetMonomials;
      // Symbol: drake::Polynomial::GetNumberOfCoefficients
      struct /* GetNumberOfCoefficients */ {
        // Source: drake/common/polynomial.h:167
        const char* doc =
R"""(Returns the number of unique Monomials (and thus the number of
coefficients) in this Polynomial.)""";
      } GetNumberOfCoefficients;
      // Symbol: drake::Polynomial::GetSimpleVariable
      struct /* GetSimpleVariable */ {
        // Source: drake/common/polynomial.h:180
        const char* doc =
R"""(If the polynomial is "simple" -- e.g. just a single term with
coefficient 1 -- then returns that variable; otherwise returns 0.)""";
      } GetSimpleVariable;
      // Symbol: drake::Polynomial::GetVariables
      struct /* GetVariables */ {
        // Source: drake/common/polynomial.h:187
        const char* doc =
R"""(Returns a set of all of the variables present in this Polynomial.)""";
      } GetVariables;
      // Symbol: drake::Polynomial::IdToVariableName
      struct /* IdToVariableName */ {
        // Source: drake/common/polynomial.h:462
        const char* doc = R"""()""";
      } IdToVariableName;
      // Symbol: drake::Polynomial::Integral
      struct /* Integral */ {
        // Source: drake/common/polynomial.h:308
        const char* doc =
R"""(Takes the integral of this (univariate, non-constant) Polynomial.

Returns a new Polynomial that is the indefinite integral of this one
in its sole variable.

Raises:
    RuntimeError if this Polynomial is not univariate, or if it has no
    variables.

If integration_constant is given, adds that constant as the constant
term (zeroth-order coefficient) of the resulting Polynomial.)""";
      } Integral;
      // Symbol: drake::Polynomial::IsAffine
      struct /* IsAffine */ {
        // Source: drake/common/polynomial.h:176
        const char* doc =
R"""(Returns true iff this is a sum of terms of degree 1, plus a constant.)""";
      } IsAffine;
      // Symbol: drake::Polynomial::IsValidVariableName
      struct /* IsValidVariableName */ {
        // Source: drake/common/polynomial.h:457
        const char* doc = R"""(Variable name/ID conversion facility.)""";
      } IsValidVariableName;
      // Symbol: drake::Polynomial::Monomial
      struct /* Monomial */ {
        // Source: drake/common/polynomial.h:80
        const char* doc =
R"""(An additive atom of a Polynomial: The product of any number of Terms
and a coefficient.)""";
        // Symbol: drake::Polynomial::Monomial::Factor
        struct /* Factor */ {
          // Source: drake/common/polynomial.h:102
          const char* doc =
R"""(Factors this by other; returns 0 iff other does not divide this.)""";
        } Factor;
        // Symbol: drake::Polynomial::Monomial::GetDegree
        struct /* GetDegree */ {
          // Source: drake/common/polynomial.h:96
          const char* doc = R"""()""";
        } GetDegree;
        // Symbol: drake::Polynomial::Monomial::GetDegreeOf
        struct /* GetDegreeOf */ {
          // Source: drake/common/polynomial.h:97
          const char* doc = R"""()""";
        } GetDegreeOf;
        // Symbol: drake::Polynomial::Monomial::HasSameExponents
        struct /* HasSameExponents */ {
          // Source: drake/common/polynomial.h:98
          const char* doc = R"""()""";
        } HasSameExponents;
        // Symbol: drake::Polynomial::Monomial::HasVariable
        struct /* HasVariable */ {
          // Source: drake/common/polynomial.h:99
          const char* doc = R"""()""";
        } HasVariable;
        // Symbol: drake::Polynomial::Monomial::coefficient
        struct /* coefficient */ {
          // Source: drake/common/polynomial.h:82
          const char* doc = R"""()""";
        } coefficient;
        // Symbol: drake::Polynomial::Monomial::operator<
        struct /* operator_lt */ {
          // Source: drake/common/polynomial.h:91
          const char* doc =
R"""(A comparison to allow std::lexicographical_compare on this class; does
not reflect any sort of mathematical total order.)""";
        } operator_lt;
        // Symbol: drake::Polynomial::Monomial::terms
        struct /* terms */ {
          // Source: drake/common/polynomial.h:83
          const char* doc = R"""()""";
        } terms;
      } Monomial;
      // Symbol: drake::Polynomial::Polynomial<T>
      struct /* ctor */ {
        // Source: drake/common/polynomial.h:106
        const char* doc_0args = R"""(Construct the vacuous polynomial, "0".)""";
        // Source: drake/common/polynomial.h:112
        const char* doc_1args_scalar =
R"""(Construct a Polynomial of a single constant. e.g. "5".)""";
        // Source: drake/common/polynomial.h:115
        const char* doc_2args_coeff_terms =
R"""(Construct a Polynomial consisting of a single Monomial, e.g. "5xy**3".)""";
        // Source: drake/common/polynomial.h:118
        const char* doc_2args_start_finish =
R"""(Construct a Polynomial from a sequence of Monomials.)""";
        // Source: drake/common/polynomial.h:132
        const char* doc_1args_conststdenableift =
R"""(Constructs a polynomial consisting of a single Monomial of the
variable named ``varname1``.

Note:
    : This constructor is only provided for T = double. For the other
    cases, a user should use the constructor with two arguments below
    (taking std::string and unsigned int). If we provided this
    constructor for T = AutoDiffXd and T = symbolic::Expression, there
    would be compiler errors for ``Polynomial<T>(0)`` as the following
    candidates are ambiguous: - Polynomial(const T& scalar) -
    Polynomial(const std::string& varname, const unsigned int num = 1))""";
        // Source: drake/common/polynomial.h:141
        const char* doc_2args_varname_num =
R"""(Construct a polynomial consisting of a single Monomial of the variable
named varname + num.)""";
        // Source: drake/common/polynomial.h:144
        const char* doc_2args_coeff_v =
R"""(Construct a single Monomial of the given coefficient and variable.)""";
        // Source: drake/common/polynomial.h:149
        const char* doc_1args_constEigenMatrixBase =
R"""(A legacy constructor for univariate polynomials: Takes a vector of
coefficients for the constant, x, x**2, x**3... Monomials.)""";
      } ctor;
      // Symbol: drake::Polynomial::PowerType
      struct /* PowerType */ {
        // Source: drake/common/polynomial.h:50
        const char* doc =
R"""(This should be 'unsigned int' but MSVC considers a call to
std::pow(..., unsigned int) ambiguous because it won't cast unsigned
int to int.)""";
      } PowerType;
      // Symbol: drake::Polynomial::Product
      struct /* Product */ {
        // Source: drake/common/polynomial.h:56
        const char* doc = R"""()""";
        // Symbol: drake::Polynomial::Product::type
        struct /* type */ {
          // Source: drake/common/polynomial.h:57
          const char* doc = R"""()""";
        } type;
      } Product;
      // Symbol: drake::Polynomial::RealScalar
      struct /* RealScalar */ {
        // Source: drake/common/polynomial.h:51
        const char* doc = R"""()""";
      } RealScalar;
      // Symbol: drake::Polynomial::RootType
      struct /* RootType */ {
        // Source: drake/common/polynomial.h:52
        const char* doc = R"""()""";
      } RootType;
      // Symbol: drake::Polynomial::Roots
      struct /* Roots */ {
        // Source: drake/common/polynomial.h:390
        const char* doc =
R"""(Returns the roots of this (univariate) Polynomial.

Returns the roots of a univariate Polynomial as an Eigen column vector
of complex numbers whose components are of the RealScalar type.

Raises:
    RuntimeError of this Polynomial is not univariate.)""";
      } Roots;
      // Symbol: drake::Polynomial::RootsType
      struct /* RootsType */ {
        // Source: drake/common/polynomial.h:53
        const char* doc = R"""()""";
      } RootsType;
      // Symbol: drake::Polynomial::Subs
      struct /* Subs */ {
        // Source: drake/common/polynomial.h:281
        const char* doc =
R"""(Replaces all instances of variable orig with replacement.)""";
      } Subs;
      // Symbol: drake::Polynomial::Substitute
      struct /* Substitute */ {
        // Source: drake/common/polynomial.h:284
        const char* doc =
R"""(Replaces all instances of variable orig with replacement.)""";
      } Substitute;
      // Symbol: drake::Polynomial::Term
      struct /* Term */ {
        // Source: drake/common/polynomial.h:61
        const char* doc =
R"""(An individual variable raised to an integer power; e.g. x**2.)""";
        // Symbol: drake::Polynomial::Term::operator<
        struct /* operator_lt */ {
          // Source: drake/common/polynomial.h:72
          const char* doc =
R"""(A comparison to allow std::lexicographical_compare on this class; does
not reflect any sort of mathematical total order.)""";
        } operator_lt;
        // Symbol: drake::Polynomial::Term::power
        struct /* power */ {
          // Source: drake/common/polynomial.h:64
          const char* doc = R"""()""";
        } power;
        // Symbol: drake::Polynomial::Term::var
        struct /* var */ {
          // Source: drake/common/polynomial.h:63
          const char* doc = R"""()""";
        } var;
      } Term;
      // Symbol: drake::Polynomial::VarType
      struct /* VarType */ {
        // Source: drake/common/polynomial.h:47
        const char* doc = R"""()""";
      } VarType;
      // Symbol: drake::Polynomial::VariableNameToId
      struct /* VariableNameToId */ {
        // Source: drake/common/polynomial.h:459
        const char* doc = R"""()""";
      } VariableNameToId;
      // Symbol: drake::Polynomial::operator*
      struct /* operator_mul */ {
        // Source: drake/common/polynomial.h:332
        const char* doc = R"""()""";
      } operator_mul;
      // Symbol: drake::Polynomial::operator*=
      struct /* operator_imul */ {
        // Source: drake/common/polynomial.h:316
        const char* doc = R"""()""";
      } operator_imul;
      // Symbol: drake::Polynomial::operator+
      struct /* operator_add */ {
        // Source: drake/common/polynomial.h:326
        const char* doc = R"""()""";
      } operator_add;
      // Symbol: drake::Polynomial::operator+=
      struct /* operator_iadd */ {
        // Source: drake/common/polynomial.h:312
        const char* doc = R"""()""";
      } operator_iadd;
      // Symbol: drake::Polynomial::operator-
      struct /* operator_sub */ {
        // Source: drake/common/polynomial.h:328
        const char* doc = R"""()""";
      } operator_sub;
      // Symbol: drake::Polynomial::operator-=
      struct /* operator_isub */ {
        // Source: drake/common/polynomial.h:314
        const char* doc = R"""()""";
      } operator_isub;
      // Symbol: drake::Polynomial::operator/
      struct /* operator_div */ {
        // Source: drake/common/polynomial.h:375
        const char* doc = R"""()""";
      } operator_div;
      // Symbol: drake::Polynomial::operator/=
      struct /* operator_idiv */ {
        // Source: drake/common/polynomial.h:324
        const char* doc = R"""()""";
      } operator_idiv;
      // Symbol: drake::Polynomial::operator<
      struct /* operator_lt */ {
        // Source: drake/common/polynomial.h:379
        const char* doc =
R"""(A comparison to allow std::lexicographical_compare on this class; does
not reflect any sort of mathematical total order.)""";
      } operator_lt;
    } Polynomial;
    // Symbol: drake::Polynomiald
    struct /* Polynomiald */ {
      // Source: drake/common/polynomial.h:512
      const char* doc = R"""()""";
    } Polynomiald;
    // Symbol: drake::RandomDistribution
    struct /* RandomDistribution */ {
      // Source: drake/common/random.h:34
      const char* doc =
R"""(Drake supports explicit reasoning about a few carefully chosen random
distributions.)""";
      // Symbol: drake::RandomDistribution::kExponential
      struct /* kExponential */ {
        // Source: drake/common/random.h:39
        const char* doc =
R"""(Vector elements are independent and drawn from an)""";
      } kExponential;
      // Symbol: drake::RandomDistribution::kGaussian
      struct /* kGaussian */ {
        // Source: drake/common/random.h:37
        const char* doc =
R"""(Vector elements are independent and drawn from a)""";
      } kGaussian;
      // Symbol: drake::RandomDistribution::kUniform
      struct /* kUniform */ {
        // Source: drake/common/random.h:35
        const char* doc =
R"""(Vector elements are independent and uniformly distributed)""";
      } kUniform;
    } RandomDistribution;
    // Symbol: drake::RandomGenerator
    struct /* RandomGenerator */ {
      // Source: drake/common/random.h:13
      const char* doc =
R"""(Defines Drake's canonical implementation of the
UniformRandomBitGenerator C++ concept (as well as a few conventional
extras beyond the concept, e.g., seeds). This uses the 32-bit Mersenne
Twister mt19937 by Matsumoto and Nishimura, 1998. For more
information, see
https://en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine)""";
      // Symbol: drake::RandomGenerator::RandomGenerator
      struct /* ctor */ {
        // Source: drake/common/random.h:15
        const char* doc = R"""()""";
      } ctor;
      // Symbol: drake::RandomGenerator::max
      struct /* max */ {
        // Source: drake/common/random.h:23
        const char* doc = R"""()""";
      } max;
      // Symbol: drake::RandomGenerator::min
      struct /* min */ {
        // Source: drake/common/random.h:22
        const char* doc = R"""()""";
      } min;
      // Symbol: drake::RandomGenerator::operator()
      struct /* operator_call */ {
        // Source: drake/common/random.h:24
        const char* doc = R"""()""";
      } operator_call;
      // Symbol: drake::RandomGenerator::result_type
      struct /* result_type */ {
        // Source: drake/common/random.h:17
        const char* doc = R"""()""";
      } result_type;
    } RandomGenerator;
    // Symbol: drake::RlocationOrError
    struct /* RlocationOrError */ {
      // Source: drake/common/find_runfiles.h:30
      const char* doc =
R"""((Advanced.) The return type of FindRunfile(). Exactly one of the two
strings is non-empty.)""";
      // Symbol: drake::RlocationOrError::abspath
      struct /* abspath */ {
        // Source: drake/common/find_runfiles.h:32
        const char* doc =
R"""(The absolute path to the resource_path runfile.)""";
      } abspath;
      // Symbol: drake::RlocationOrError::error
      struct /* error */ {
        // Source: drake/common/find_runfiles.h:34
        const char* doc = R"""(The error message.)""";
      } error;
    } RlocationOrError;
    // Symbol: drake::ScopeExit
    struct /* ScopeExit */ {
      // Source: drake/common/scope_exit.h:32
      const char* doc =
R"""(Helper class to create a scope exit guard -- an object that when
destroyed runs ``func``. This is useful to apply RAII to third-party
code that only supports manual acquire and release operations.

Example:


::

    void some_function() {
      void* foo = ::malloc(10);
      ScopeExit guard([foo]() {
        ::free(foo);
      });
    
      // ...
      if (condition) { throw RuntimeError("..."); }
      // ...
    }

Here, the allocation of ``foo`` will always be free'd no matter
whether ``some_function`` returns normally or via an exception.)""";
      // Symbol: drake::ScopeExit::Disarm
      struct /* Disarm */ {
        // Source: drake/common/scope_exit.h:53
        const char* doc =
R"""(Disarms this guard, so that the destructor has no effect.)""";
      } Disarm;
      // Symbol: drake::ScopeExit::ScopeExit
      struct /* ctor */ {
        // Source: drake/common/scope_exit.h:39
        const char* doc =
R"""(Creates a resource that will call ``func`` when destroyed. Note that
``func()`` should not throw an exception, since it will typically be
invoked during stack unwinding.)""";
      } ctor;
    } ScopeExit;
    // Symbol: drake::SortedPair
    struct /* SortedPair */ {
      // Source: drake/common/sorted_pair.h:27
      const char* doc =
R"""(This class is similar to the std::pair class. However, this class uses
a pair of homogeneous types (std::pair can use heterogeneous types)
and sorts the first and second values such that the first value is
less than or equal to the second one). Note that the sort is a stable
one. Thus the SortedPair class is able to be used to generate keys
(e.g., for std::map, etc.) from pairs of objects.

Template parameter ``T``:
    A template type that provides ``operator<`` and supports default
    construction.)""";
      // Symbol: drake::SortedPair::SortedPair<T>
      struct /* ctor */ {
        // Source: drake/common/sorted_pair.h:28
        const char* doc_was_unable_to_choose_unambiguous_names = R"""()""";
      } ctor;
      // Symbol: drake::SortedPair::Swap
      struct /* Swap */ {
        // Source: drake/common/sorted_pair.h:76
        const char* doc = R"""(Swaps ``this`` and ``t``.)""";
      } Swap;
      // Symbol: drake::SortedPair::first
      struct /* first */ {
        // Source: drake/common/sorted_pair.h:70
        const char* doc =
R"""(Gets the first (according to ``operator<``) of the objects.)""";
      } first;
      // Symbol: drake::SortedPair::second
      struct /* second */ {
        // Source: drake/common/sorted_pair.h:73
        const char* doc =
R"""(Gets the second (according to ``operator<``) of the objects.)""";
      } second;
      // Symbol: drake::SortedPair::set
      struct /* set */ {
        // Source: drake/common/sorted_pair.h:62
        const char* doc = R"""(Resets the stored objects.)""";
      } set;
    } SortedPair;
    // Symbol: drake::SortedVectorsHaveIntersection
    struct /* SortedVectorsHaveIntersection */ {
      // Source: drake/common/sorted_vectors_have_intersection.h:38
      const char* doc =
R"""(Checks for the existence of a non-empty intersection between two
sorted ``std::vector`'s.

Parameter ``a``:
    First vector.

Parameter ``b``:
    Second vector.

Template parameter ``T``:
    The type of the elements in the input vectors ``a`` and ``b``.
    This is expected to be an integral type or a pointer type.

Returns:
    `true`` if there is a non-empty intersection between vectors;
    ``False`` otherwise.

Elements are compared using ``operator<`` and the vectors must be
sorted with respect to the same operator.

This algorithm only works on ``std::vector`'s to take advantage of
their fast and random access.

Entries can be repeated as long as they are sorted. For vector `a`` of
size ``Na`` and vector ``b`` of size ``Nb`` the complexity is at most
Order(Na + Nb). The algorithm executes in constant time for vectors
with disjoint entries. An example of the worst case scenario is given
below:


::

    a = (10, 20, 30)
    b = (15, 25, 35)

In this case the algorithm needs to scan both vectors from start to
end.)""";
    } SortedVectorsHaveIntersection;
    // Symbol: drake::ToleranceType
    struct /* ToleranceType */ {
      // Source: drake/common/constants.h:19
      const char* doc = R"""()""";
      // Symbol: drake::ToleranceType::kAbsolute
      struct /* kAbsolute */ {
        // Source: drake/common/constants.h:19
        const char* doc = R"""()""";
      } kAbsolute;
      // Symbol: drake::ToleranceType::kRelative
      struct /* kRelative */ {
        // Source: drake/common/constants.h:19
        const char* doc = R"""()""";
      } kRelative;
    } ToleranceType;
    // Symbol: drake::TrigPoly
    struct /* TrigPoly */ {
      // Source: drake/common/trig_poly.h:49
      const char* doc =
R"""(A scalar multi-variate polynomial containing sines and cosines.

TrigPoly represents a Polynomial some of whose variables actually
represent the sines or cosines of other variables. Sines and cosines
of first-order polynomials (affine combinations of variables) are
decomposed into polynomials of the sines and cosines of individual
variables via the Prosthaphaeresis formulae.

Any variables which will appear in the arguments to trigonometric
functions must be declared in the "SinCosMap" (created automatically
by most TrigPoly constructors); attempting to, e.g., use sin(x)
without first creating a SinCosMap mapping for 'x' will result in an
exception.

The same variable may not appear more than once in the sin_cos_map,
regardless of position.

For example:


::

    Polynomial base_x("x"), s("s"), c("c");
    TrigPoly x(base_x, s, c)  // This "x" knows that s = sin(x)
                              // and that c = cos(x)
    cout << sin(x)                     // emits "s1"
    cout << sin(x) * x                 // emits "x1*s1"
    cout << sin(x + x) * x             // emits "x1*s1*c1 + x1*c1*s1"

NOTE: Certain analyses may not succeed when individual Monomials
contain both x and sin(x) or cos(x) terms. This restriction is not
currently enforced programmatically.)""";
      // Symbol: drake::TrigPoly::EvaluateMultivariate
      struct /* EvaluateMultivariate */ {
        // Source: drake/common/trig_poly.h:270
        const char* doc =
R"""(Given a value for every variable in this expression, evaluates it.

By analogy with Polynomial::EvaluateMultivariate(). Values must be
supplied for all base variables; supplying values for sin/cos
variables is an error.)""";
      } EvaluateMultivariate;
      // Symbol: drake::TrigPoly::EvaluatePartial
      struct /* EvaluatePartial */ {
        // Source: drake/common/trig_poly.h:290
        const char* doc =
R"""(Partially evaluates this expression, returning the resulting
expression.

By analogy with Polynomial::evaluatePartial. Values must be supplied
for all base variables only; supplying values for sin/cos variables is
an error.)""";
      } EvaluatePartial;
      // Symbol: drake::TrigPoly::GetVariables
      struct /* GetVariables */ {
        // Source: drake/common/trig_poly.h:253
        const char* doc =
R"""(Returns all of the base (non-sin/cos) variables in this TrigPoly.)""";
      } GetVariables;
      // Symbol: drake::TrigPoly::PolyType
      struct /* PolyType */ {
        // Source: drake/common/trig_poly.h:53
        const char* doc = R"""()""";
      } PolyType;
      // Symbol: drake::TrigPoly::Product
      struct /* Product */ {
        // Source: drake/common/trig_poly.h:66
        const char* doc = R"""()""";
        // Symbol: drake::TrigPoly::Product::type
        struct /* type */ {
          // Source: drake/common/trig_poly.h:67
          const char* doc = R"""()""";
        } type;
      } Product;
      // Symbol: drake::TrigPoly::SinCosMap
      struct /* SinCosMap */ {
        // Source: drake/common/trig_poly.h:63
        const char* doc = R"""()""";
      } SinCosMap;
      // Symbol: drake::TrigPoly::SinCosVars
      struct /* SinCosVars */ {
        // Source: drake/common/trig_poly.h:55
        const char* doc = R"""()""";
        // Symbol: drake::TrigPoly::SinCosVars::c
        struct /* c */ {
          // Source: drake/common/trig_poly.h:57
          const char* doc = R"""()""";
        } c;
        // Symbol: drake::TrigPoly::SinCosVars::s
        struct /* s */ {
          // Source: drake/common/trig_poly.h:56
          const char* doc = R"""()""";
        } s;
      } SinCosVars;
      // Symbol: drake::TrigPoly::TrigPoly<T>
      struct /* ctor */ {
        // Source: drake/common/trig_poly.h:71
        const char* doc_0args = R"""(Constructs a vacuous TrigPoly.)""";
        // Source: drake/common/trig_poly.h:75
        const char* doc_1args_scalar = R"""(Constructs a constant TrigPoly.)""";
        // Source: drake/common/trig_poly.h:81
        const char* doc_1args_p =
R"""(Constructs a TrigPoly on the associated Polynomial p with no
associated trigonometric correspondences.)""";
        // Source: drake/common/trig_poly.h:87
        const char* doc_2args_p__sin_cos_map =
R"""(Constructs a TrigPoly on the associated Polynomial p, but with the
additional information about sin and cos relations in _sin_cos_map.)""";
        // Source: drake/common/trig_poly.h:111
        const char* doc_3args_q_s_c =
R"""(Constructs a TrigPoly version of q, but with the additional
information that the variables s and c represent the sine and cosine
of q.)""";
      } ctor;
      // Symbol: drake::TrigPoly::VarType
      struct /* VarType */ {
        // Source: drake/common/trig_poly.h:54
        const char* doc = R"""()""";
      } VarType;
      // Symbol: drake::TrigPoly::operator*
      struct /* operator_mul */ {
        // Source: drake/common/trig_poly.h:378
        const char* doc = R"""()""";
      } operator_mul;
      // Symbol: drake::TrigPoly::operator*=
      struct /* operator_imul */ {
        // Source: drake/common/trig_poly.h:335
        const char* doc = R"""()""";
      } operator_imul;
      // Symbol: drake::TrigPoly::operator+
      struct /* operator_add */ {
        // Source: drake/common/trig_poly.h:361
        const char* doc = R"""()""";
      } operator_add;
      // Symbol: drake::TrigPoly::operator+=
      struct /* operator_iadd */ {
        // Source: drake/common/trig_poly.h:323
        const char* doc = R"""()""";
      } operator_iadd;
      // Symbol: drake::TrigPoly::operator-
      struct /* operator_sub */ {
        // Source: drake/common/trig_poly.h:367
        const char* doc = R"""()""";
      } operator_sub;
      // Symbol: drake::TrigPoly::operator-=
      struct /* operator_isub */ {
        // Source: drake/common/trig_poly.h:329
        const char* doc = R"""()""";
      } operator_isub;
      // Symbol: drake::TrigPoly::operator/
      struct /* operator_div */ {
        // Source: drake/common/trig_poly.h:425
        const char* doc = R"""()""";
      } operator_div;
      // Symbol: drake::TrigPoly::operator/=
      struct /* operator_idiv */ {
        // Source: drake/common/trig_poly.h:356
        const char* doc = R"""()""";
      } operator_idiv;
      // Symbol: drake::TrigPoly::poly
      struct /* poly */ {
        // Source: drake/common/trig_poly.h:126
        const char* doc =
R"""(Returns the underlying Polynomial for this TrigPoly.)""";
      } poly;
      // Symbol: drake::TrigPoly::sin_cos_map
      struct /* sin_cos_map */ {
        // Source: drake/common/trig_poly.h:129
        const char* doc =
R"""(Returns the SinCosMap for this TrigPoly.)""";
      } sin_cos_map;
    } TrigPoly;
    // Symbol: drake::TrigPolyd
    struct /* TrigPolyd */ {
      // Source: drake/common/trig_poly.h:465
      const char* doc = R"""()""";
    } TrigPolyd;
    // Symbol: drake::TypeSafeIndex
    struct /* TypeSafeIndex */ {
      // Source: drake/common/type_safe_index.h:131
      const char* doc =
R"""(A type-safe non-negative index class.

Note:
    This is *purposely* a separate class from geometry::Identifier.
    For more information, see TypeSafeIndexVsIndentifier "this
    section".

This class serves as an upgrade to the standard practice of passing
``int`s around as indices. In the common practice, a method that takes
indices into multiple collections would have an interface like:


::

    void foo(int bar_index, int thing_index);

It is possible for a programmer to accidentally switch the two index
values in an invocation. This mistake would still be *syntactically*
correct; it will successfully compile but lead to inscrutable run-time
errors. The type-safe index provides the same speed and efficiency of
passing `int`s, but provides compile-time checking. The function would
now look like:


::

    void foo(BarIndex bar_index, ThingIndex thing_index);

and the compiler will catch instances where the order is reversed.

The type-safe index is a *stripped down* `int``. Each uniquely
declared index type has the following properties:

- Valid index values are *explicitly* constructed from ``int`` values.
- The index is implicitly convertible to an ``int`` (to serve as an index).
- The index supports increment, decrement, and in-place addition and
  subtraction to support standard index-like operations.
- An index *cannot* be constructed or compared to an index of another
  type.
- In general, indices of different types are *not* interconvertible.
- Binary integer operators (e.g., +, -, |, *, etc.) *always* produce ``int``
  return values. One can even use operands of different index types in
  such a binary expression. It is the *programmer's* responsibility to
  confirm that the resultant ``int`` value has meaning.

While there *is* the concept of an "invalid" index, this only exists
to support default construction *where appropriate* (e.g., using
indices in STL containers). Using an invalid index in *any* operation
is considered an error. In Debug build, attempts to compare,
increment, decrement, etc. an invalid index will throw an exception.

A function that returns TypeSafeIndex values which need to communicate
failure should *not* use an invalid index. It should return an
``std::optional<Index>`` instead.

It is the designed intent of this class, that indices derived from
this class can be passed and returned by value. (Drake's typical
calling convention requires passing input arguments by const
reference, or by value when moved from. That convention does not apply
to this class.)

This is the recommended method to create a unique index type
associated with class ``Foo``:


::

    using FooIndex = TypeSafeIndex<class FooTag>;

This references a non-existent, and ultimately anonymous, class
``FooTag``. This is sufficient to create a unique index type. It is
certainly possible to use an existing class (e.g., ``Foo``). But this
provides no functional benefit.

**Construction from integral types**

C++ will do `implicit integer conversions
<https://en.cppreference.com/w/cpp/language/implicit_conversion#Integral_conversions>`_.
This allows construction of TypeSafeIndex values with arbitrary
integral types. Index values must lie in the range of [0, 2³¹). The
constructor will validate the input value (in Debug mode). Ultimately,
the caller is responsible for confirming that the values provided lie
in the valid range.

**Examples of valid and invalid operations**

The TypeSafeIndex guarantees that index instances of different types
can't be compared or combined. Efforts to do so will cause a
compile-time failure. However, comparisons or operations on *other*
types that are convertible to an int will succeed. For example:


::

    using AIndex = TypeSafeIndex<class A>;
       using BIndex = TypeSafeIndex<class B>;
       AIndex a(1);
       BIndex b(1);
       if (a == 2) { ... }      // Ok.
       size_t sz = 7;
       if (a == sz) { ... }     // Ok.
       if (a == b) { ... }      // <-- Compiler error.
       AIndex invalid;          // Creates an invalid index.
       ++invalid;               // Runtime error in Debug build.

As previously stated, the intent of this class is to seamlessly serve
as an index into indexed objects (e.g., vector, array, etc.). At the
same time, we want to avoid implicit conversions *from* int to an
index. These two design constraints combined lead to a limitation in
how TypeSafeIndex instances can be used. Specifically, we've lost a
common index pattern:


::

    for (MyIndex a = 0; a < N; ++a) { ... }

This pattern no longer works because it requires implicit conversion
of int to TypeSafeIndex. Instead, the following pattern needs to be
used:


::

    for (MyIndex a(0); a < N; ++a) { ... }

See also:
    drake::geometry::Identifier

Template parameter ``Tag``:
    The name of the tag associated with a class type. The class need
    not be a defined class.)""";
      // Symbol: drake::TypeSafeIndex::TypeSafeIndex<Tag>
      struct /* ctor */ {
        // Source: drake/common/type_safe_index.h:138
        const char* doc_0args =
R"""(Default constructor; the result is an *invalid* index. This only
exists to serve applications which require a default constructor.)""";
        // Source: drake/common/type_safe_index.h:143
        const char* doc_1args_index =
R"""(Construction from a non-negative ``int`` value. The value must lie in
the range of [0, 2³¹). Constructor only promises to test validity in
Debug build.)""";
        // Source: drake/common/type_safe_index.h:152
        const char* doc_1args_constTypeSafeIndex =
R"""(Disallow construction from another index type.)""";
      } ctor;
      // Symbol: drake::TypeSafeIndex::is_valid
      struct /* is_valid */ {
        // Source: drake/common/type_safe_index.h:185
        const char* doc =
R"""(Reports if the index is valid--the only operation on an invalid index
that doesn't throw an exception in Debug builds.)""";
      } is_valid;
      // Symbol: drake::TypeSafeIndex::operator int
      struct /* operator_int */ {
        // Source: drake/common/type_safe_index.h:178
        const char* doc = R"""(Implicit conversion-to-int operator.)""";
      } operator_int;
      // Symbol: drake::TypeSafeIndex::operator!=
      struct /* operator_ne */ {
        // Source: drake/common/type_safe_index.h:360
        const char* doc_1args_other =
R"""(Allow inequality test with indices of this tag.)""";
        // Source: drake/common/type_safe_index.h:371
        const char* doc_1args_constU =
R"""(Allow inequality test with unsigned integers.)""";
        // Source: drake/common/type_safe_index.h:379
        const char* doc_1args_constTypeSafeIndex =
R"""(Prevent inequality test with indices of other tags.)""";
      } operator_ne;
      // Symbol: drake::TypeSafeIndex::operator++
      struct /* operator_inc */ {
        // Source: drake/common/type_safe_index.h:199
        const char* doc_0args = R"""(Prefix increment operator.)""";
        // Source: drake/common/type_safe_index.h:209
        const char* doc_1args = R"""(Postfix increment operator.)""";
      } operator_inc;
      // Symbol: drake::TypeSafeIndex::operator+=
      struct /* operator_iadd */ {
        // Source: drake/common/type_safe_index.h:249
        const char* doc_1args_i =
R"""(Addition assignment operator. In Debug builds, this method asserts
that the resulting index is non-negative.)""";
        // Source: drake/common/type_safe_index.h:262
        const char* doc_1args_other =
R"""(Allow addition for indices with the same tag.)""";
        // Source: drake/common/type_safe_index.h:279
        const char* doc_1args_constTypeSafeIndex =
R"""(Prevent addition for indices of different tags.)""";
      } operator_iadd;
      // Symbol: drake::TypeSafeIndex::operator--
      struct /* operator_dec */ {
        // Source: drake/common/type_safe_index.h:221
        const char* doc_0args =
R"""(Prefix decrement operator. In Debug builds, this method asserts that
the resulting index is non-negative.)""";
        // Source: drake/common/type_safe_index.h:233
        const char* doc_1args =
R"""(Postfix decrement operator. In Debug builds, this method asserts that
the resulting index is non-negative.)""";
      } operator_dec;
      // Symbol: drake::TypeSafeIndex::operator-=
      struct /* operator_isub */ {
        // Source: drake/common/type_safe_index.h:284
        const char* doc_1args_i =
R"""(Subtraction assignment operator. In Debug builds, this method asserts
that the resulting index is non-negative.)""";
        // Source: drake/common/type_safe_index.h:296
        const char* doc_1args_other =
R"""(Allow subtraction for indices with the same tag.)""";
        // Source: drake/common/type_safe_index.h:313
        const char* doc_1args_constTypeSafeIndex =
R"""(Prevent subtraction for indices of different tags.)""";
      } operator_isub;
      // Symbol: drake::TypeSafeIndex::operator<
      struct /* operator_lt */ {
        // Source: drake/common/type_safe_index.h:382
        const char* doc_1args_other =
R"""(Allow less than test with indices of this tag.)""";
        // Source: drake/common/type_safe_index.h:393
        const char* doc_1args_constU =
R"""(Allow less than test with unsigned integers.)""";
        // Source: drake/common/type_safe_index.h:401
        const char* doc_1args_constTypeSafeIndex =
R"""(Prevent less than test with indices of other tags.)""";
      } operator_lt;
      // Symbol: drake::TypeSafeIndex::operator<=
      struct /* operator_le */ {
        // Source: drake/common/type_safe_index.h:404
        const char* doc_1args_other =
R"""(Allow less than or equals test with indices of this tag.)""";
        // Source: drake/common/type_safe_index.h:415
        const char* doc_1args_constU =
R"""(Allow less than or equals test test with unsigned integers.)""";
        // Source: drake/common/type_safe_index.h:423
        const char* doc_1args_constTypeSafeIndex =
R"""(Prevent less than or equals test with indices of other tags.)""";
      } operator_le;
      // Symbol: drake::TypeSafeIndex::operator>
      struct /* operator_gt */ {
        // Source: drake/common/type_safe_index.h:426
        const char* doc_1args_other =
R"""(Allow greater than test with indices of this tag.)""";
        // Source: drake/common/type_safe_index.h:437
        const char* doc_1args_constU =
R"""(Allow greater than test with unsigned integers.)""";
        // Source: drake/common/type_safe_index.h:445
        const char* doc_1args_constTypeSafeIndex =
R"""(Prevent greater than test with indices of other tags.)""";
      } operator_gt;
      // Symbol: drake::TypeSafeIndex::operator>=
      struct /* operator_ge */ {
        // Source: drake/common/type_safe_index.h:448
        const char* doc_1args_other =
R"""(Allow greater than or equals test with indices of this tag.)""";
        // Source: drake/common/type_safe_index.h:459
        const char* doc_1args_constU =
R"""(Allow greater than or equals test with unsigned integers.)""";
        // Source: drake/common/type_safe_index.h:467
        const char* doc_1args_constTypeSafeIndex =
R"""(Prevent greater than or equals test with indices of other tags.)""";
      } operator_ge;
    } TypeSafeIndex;
    // Symbol: drake::Value
    struct /* Value */ {
      // Source: drake/common/value.h:173
      const char* doc =
R"""(A container class for an arbitrary type T (with some restrictions).
This class inherits from AbstractValue and therefore at runtime can be
passed between functions without mentioning T.

Example:


::

    void print_string(const AbstractValue& arg) {
      const std::string& message = arg.get_value<std::string>();
      std::cerr << message;
    }
    void meow() {
      const Value<std::string> value("meow");
      print_string(value);
    }

(Advanced.) User-defined classes with additional features may subclass
Value, but should take care to override Clone().

Template parameter ``T``:
    Must be copy-constructible or cloneable. Must not be a pointer,
    array, nor have const, volatile, or reference qualifiers.)""";
      // Symbol: drake::Value::Clone
      struct /* Clone */ {
        // Source: drake/common/value.h:233
        const char* doc = R"""()""";
      } Clone;
      // Symbol: drake::Value::SetFrom
      struct /* SetFrom */ {
        // Source: drake/common/value.h:234
        const char* doc = R"""()""";
      } SetFrom;
      // Symbol: drake::Value::Value<T>
      struct /* ctor */ {
        // Source: drake/common/value.h:175
        const char* doc_was_unable_to_choose_unambiguous_names = R"""()""";
      } ctor;
      // Symbol: drake::Value::get_mutable_value
      struct /* get_mutable_value */ {
        // Source: drake/common/value.h:227
        const char* doc =
R"""(Returns a mutable reference to the stored value. The reference remains
valid only until this object is set or destroyed.)""";
      } get_mutable_value;
      // Symbol: drake::Value::get_value
      struct /* get_value */ {
        // Source: drake/common/value.h:223
        const char* doc =
R"""(Returns a const reference to the stored value. The reference remains
valid only until this object is set or destroyed.)""";
      } get_value;
      // Symbol: drake::Value::set_value
      struct /* set_value */ {
        // Source: drake/common/value.h:230
        const char* doc =
R"""(Replaces the stored value with a new one.)""";
      } set_value;
      // Symbol: drake::Value::static_type_info
      struct /* static_type_info */ {
        // Source: drake/common/value.h:236
        const char* doc = R"""()""";
      } static_type_info;
      // Symbol: drake::Value::type_info
      struct /* type_info */ {
        // Source: drake/common/value.h:235
        const char* doc = R"""()""";
      } type_info;
    } Value;
    // Symbol: drake::Vector1d
    struct /* Vector1d */ {
      // Source: drake/common/eigen_types.h:31
      const char* doc = R"""(A column vector of size 1 of doubles.)""";
    } Vector1d;
    // Symbol: drake::VectorXPoly
    struct /* VectorXPoly */ {
      // Source: drake/common/polynomial.h:515
      const char* doc =
R"""(A column vector of polynomials; used in several optimization classes.)""";
    } VectorXPoly;
    // Symbol: drake::VectorXTrigPoly
    struct /* VectorXTrigPoly */ {
      // Source: drake/common/trig_poly.h:468
      const char* doc =
R"""(A column vector of TrigPoly; used in several optimization classes.)""";
    } VectorXTrigPoly;
    // Symbol: drake::all
    struct /* all */ {
      // Source: drake/common/drake_bool.h:36
      const char* doc =
R"""(Checks truth for all elements in matrix ``m``. This is identical to
``Eigen::DenseBase::all()``, except this function allows for lazy
evaluation, so works even when scalar_predicate<>::is_bool does not
hold. An empty matrix returns true.)""";
    } all;
    // Symbol: drake::all_of
    struct /* all_of */ {
      // Source: drake/common/drake_bool.h:48
      const char* doc =
R"""(Checks if unary predicate ``pred`` holds for all elements in the
matrix ``m``. An empty matrix returns true.)""";
    } all_of;
    // Symbol: drake::any
    struct /* any */ {
      // Source: drake/common/drake_bool.h:60
      const char* doc =
R"""(Checks truth for at least one element in matrix ``m``. This is
identical to ``Eigen::DenseBase::any()``, except this function allows
for lazy evaluation, so works even when scalar_predicate<>::is_bool
does not hold. An empty matrix returns false.)""";
    } any;
    // Symbol: drake::any_of
    struct /* any_of */ {
      // Source: drake/common/drake_bool.h:72
      const char* doc =
R"""(Checks if unary predicate ``pred`` holds for at least one element in
the matrix ``m``. An empty matrix returns false.)""";
    } any_of;
    // Symbol: drake::assert
    struct /* assert */ {
      // Symbol: drake::assert::ConditionTraits
      struct /* ConditionTraits */ {
        // Source: drake/common/drake_assert.h:100
        const char* doc = R"""()""";
        // Symbol: drake::assert::ConditionTraits::Evaluate
        struct /* Evaluate */ {
          // Source: drake/common/drake_assert.h:102
          const char* doc = R"""()""";
        } Evaluate;
      } ConditionTraits;
    } assert;
    // Symbol: drake::autodiffxd_make_coherent
    struct /* autodiffxd_make_coherent */ {
      // Source: drake/common/autodiffxd_make_coherent.h:13
      const char* doc =
R"""(Makes the derviatives of the recipient coherent with respect to those
of the donor variable (see drake/common/autodiffxd.h). If the
recipient's derivatives are already populated with a vector of the
same size as that of the donor, variables pass through unchanged. An
exception is thrown when there are nonempty vectors of different
sizes.)""";
    } autodiffxd_make_coherent;
    // Symbol: drake::common
    struct /* common */ {
      // Symbol: drake::common::CallPython
      struct /* CallPython */ {
        // Source: drake/common/proto/call_python.h:30
        const char* doc =
R"""(Calls a Python client with a given function and arguments, returning a
handle to the result. For example uses, see ``call_python_test.cc``.)""";
      } CallPython;
      // Symbol: drake::common::CallPythonInit
      struct /* CallPythonInit */ {
        // Source: drake/common/proto/call_python.h:22
        const char* doc =
R"""(Initializes ``CallPython`` for a given file. If this function is not
called, then the filename defaults to ``/tmp/python_rpc``.

Raises:
    RuntimeError If either this function or ``CallPython`` have
    already been called.)""";
      } CallPythonInit;
      // Symbol: drake::common::GetRpcPipeTempDirectory
      struct /* GetRpcPipeTempDirectory */ {
        // Source: drake/common/proto/rpc_pipe_temp_directory.h:14
        const char* doc =
R"""(Returns a directory location suitable for temporary files for the
call_* clients and libraries.

Returns:
    The value of the environment variable TEST_TMPDIR if defined or
    otherwise /tmp. Any trailing / will be stripped from the output.

Raises:
    RuntimeError If the path referred to by TEST_TMPDIR or /tmp does
    not exist or is not a directory.)""";
      } GetRpcPipeTempDirectory;
      // Symbol: drake::common::PythonRemoteVariable
      struct /* PythonRemoteVariable */ {
        // Source: drake/common/proto/call_python.h:86
        const char* doc =
R"""(A proxy to a variable stored in Python side.)""";
        // Symbol: drake::common::PythonRemoteVariable::PythonRemoteVariable
        struct /* ctor */ {
          // Source: drake/common/proto/call_python.h:88
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::common::PythonRemoteVariable::unique_id
        struct /* unique_id */ {
          // Source: drake/common/proto/call_python.h:91
          const char* doc = R"""()""";
        } unique_id;
      } PythonRemoteVariable;
      // Symbol: drake::common::ToPythonKwargs
      struct /* ToPythonKwargs */ {
        // Source: drake/common/proto/call_python.h:40
        const char* doc =
R"""(Creates a keyword-argument list to be unpacked.

Parameter ``args``:
    Argument list in the form of (key1, value1, key2, value2, ...).)""";
      } ToPythonKwargs;
      // Symbol: drake::common::ToPythonTuple
      struct /* ToPythonTuple */ {
        // Source: drake/common/proto/call_python.h:35
        const char* doc = R"""(Creates a tuple in Python.)""";
      } ToPythonTuple;
    } common;
    // Symbol: drake::cond
    struct /* cond */ {
      // Source: drake/common/autodiff_overloads.h:199
      const char* doc_3args_bool_constEigenAutoDiffScalar_Rest =
R"""(Provides special case of cond expression for Eigen::AutoDiffScalar
type.)""";
      // Source: drake/common/cond.h:35
      const char* doc_1args_constScalarType =
R"""(@name cond Constructs conditional expression (similar to Lisp's cond).


::

    cond(cond_1, expr_1,
    cond_2, expr_2,
    ...,   ...,
    cond_n, expr_n,
    expr_{n+1})

The value returned by the above cond expression is ``expr_1`` if
``cond_1`` is true; else if ``cond_2`` is true then ``expr_2``; ... ;
else if ``cond_n`` is true then ``expr_n``. If none of the conditions
are true, it returns ``expr_``{n+1}.

Note:
    This functions assumes that ``ScalarType`` provides ``operator``<
    and the type of ``f_cond`` is the type of the return type of
    ``operator<(ScalarType, ScalarType)``. For example,
    ``symbolic::Expression`` can be used as a ``ScalarType`` because
    it provides ``symbolic::Formula operator<(symbolic::Expression,
    symbolic::Expression)``.)""";
      // Source: drake/common/symbolic_expression.h:1467
      const char* doc_3args_constsymbolicFormula_double_Rest =
R"""(Provides specialization of ``cond`` function defined in
drake/common/cond.h file. This specialization is required to handle
``double`` to ``symbolic::Expression`` conversion so that we can write
one such as ``cond(x > 0.0, 1.0, -1.0)``.)""";
    } cond;
    // Symbol: drake::copyable_unique_ptr
    struct /* copyable_unique_ptr */ {
      // Source: drake/common/copyable_unique_ptr.h:109
      const char* doc =
R"""(A smart pointer with deep copy semantics.

This is *similar* to ``std::unique_ptr`` in that it does not permit
shared ownership of the contained object. However, unlike
``std::unique_ptr``, copyable_unique_ptr supports copy and assignment
operations, by insisting that the contained object be "copyable". To
be copyable, the class must have either an accessible copy
constructor, or it must have an accessible clone method with signature


::

    std::unique_ptr<Foo> Clone() const;

where Foo is the type of the managed object. By "accessible" we mean
either that the copy constructor or clone method is public, or
``friend copyable_unique_ptr<Foo>;`` appears in Foo's class
declaration.

Generally, the API is modeled as closely as possible on the C++
standard ``std::unique_ptr`` API and copyable_unique_ptr<T> is
interoperable with ``unique_ptr<T>`` wherever that makes sense.
However, there are some differences:

1. It always uses a default deleter.
2. There is no array version.
3. To allow for future copy-on-write optimizations, there is a distinction
between writable and const access, the get() method is modified to return
only a const pointer, with get_mutable() added to return a writable pointer.

This class is entirely inline and has no computational or space
overhead except when copying is required; it contains just a single
pointer and does no reference counting.

**Usage**

In the simplest use case, the instantiation type will match the type
of object it references, e.g.:


::

    copyable_unique_ptr<Foo> ptr = make_unique<Foo>(...);

In this case, as long ``Foo`` is deemed compatible, the behavior will
be as expected, i.e., when ``ptr`` copies, it will contain a reference
to a new instance of ``Foo``.

copyable_unique_ptr can also be used with polymorphic classes -- a
copyable_unique_ptr, instantiated on a *base* class, references an
instance of a *derived* class. When copying the object, we would want
the copy to likewise contain an instance of the derived class. For
example:


::

    copyable_unique_ptr<Base> cu_ptr = make_unique<Derived>();
    copyable_unique_ptr<Base> other_cu_ptr = cu_ptr;           // Triggers a copy.
    is_dynamic_castable<Derived>(cu_other_ptr.get());          // Should be true.

This works for well-designed polymorphic classes.

Warning:
    Ill-formed polymorphic classes can lead to fatal type slicing of
    the referenced object, such that the new copy contains an instance
    of ``Base`` instead of ``Derived``. Some mistakes that would lead
    to this degenerate behavior:

- The ``Base`` class has a public copy constructor.
- The ``Base`` class's Clone() implementation does not invoke the ``Derived``
class's implementation of a suitable virtual method.

Warning:
    One important difference between unique_ptr and
    copyable_unique_ptr is that a unique_ptr can be declared on a
    forward-declared class type. The copyable_unique_ptr *cannot*. The
    class must be fully defined so that the copyable_unique_ptr is
    able to determine if the type meets the requirements (i.e., public
    copy constructible or cloneable).

Template parameter ``T``:
    The type of the contained object, which *must* be copyable as
    defined above. May be an abstract or concrete type.)""";
      // Symbol: drake::copyable_unique_ptr::copyable_unique_ptr<T>
      struct /* ctor */ {
        // Source: drake/common/copyable_unique_ptr.h:117
        const char* doc_0args =
R"""(Default constructor stores a ``nullptr``. No heap allocation is
performed. The empty() method will return true when called on a
default-constructed copyable_unique_ptr.)""";
        // Source: drake/common/copyable_unique_ptr.h:121
        const char* doc_1args_ptr =
R"""(Given a pointer to a writable heap-allocated object, take over
ownership of that object. No copying occurs.)""";
        // Source: drake/common/copyable_unique_ptr.h:127
        const char* doc_copy =
R"""(Copy constructor is deep; the new copyable_unique_ptr object contains
a new copy of the object in the source, created via the source
object's copy constructor or ``Clone()`` method. If the source
container is empty this one will be empty also.)""";
        // Source: drake/common/copyable_unique_ptr.h:136
        const char* doc_1args_conststduniqueptr =
R"""(Copy constructor from a standard ``unique_ptr`` of *compatible* type.
The copy is deep; the new copyable_unique_ptr object contains a new
copy of the object in the source, created via the source object's copy
constructor or ``Clone()`` method. If the source container is empty
this one will be empty also.)""";
        // Source: drake/common/copyable_unique_ptr.h:142
        const char* doc_move =
R"""(Move constructor is very fast and leaves the source empty. Ownership
is transferred from the source to the new copyable_unique_ptr. If the
source was empty this one will be empty also. No heap activity occurs.)""";
        // Source: drake/common/copyable_unique_ptr.h:149
        const char* doc_1args_u_ptr =
R"""(Move constructor from a standard ``unique_ptr``. The move is very fast
and leaves the source empty. Ownership is transferred from the source
to the new copyable_unique_ptr. If the source was empty this one will
be empty also. No heap activity occurs.)""";
        // Source: drake/common/copyable_unique_ptr.h:157
        const char* doc_1args_stduniqueptr =
R"""(Move construction from a compatible standard ``unique_ptr``. Type
``U*`` must be implicitly convertible to type ``T*``. Ownership is
transferred from the source to the new copyable_unique_ptr. If the
source was empty this one will be empty also. No heap activity occurs.)""";
      } ctor;
      // Symbol: drake::copyable_unique_ptr::empty
      struct /* empty */ {
        // Source: drake/common/copyable_unique_ptr.h:278
        const char* doc =
R"""(Return true if this container is empty, which is the state the
container is in immediately after default construction and various
other operations.)""";
      } empty;
      // Symbol: drake::copyable_unique_ptr::get
      struct /* get */ {
        // Source: drake/common/copyable_unique_ptr.h:284
        const char* doc =
R"""(Return a const pointer to the contained object if any, or ``nullptr``.
Note that this is different than ``%get()`` for the standard smart
pointers like ``std::unique_ptr`` which return a writable pointer. Use
get_mutable() here for that purpose.)""";
      } get;
      // Symbol: drake::copyable_unique_ptr::get_mutable
      struct /* get_mutable */ {
        // Source: drake/common/copyable_unique_ptr.h:293
        const char* doc =
R"""(Return a writable pointer to the contained object if any, or
``nullptr``. Note that you need write access to this container in
order to get write access to the object it contains.

Warning:
    If copyable_unique_ptr is instantiated on a const template
    parameter (e.g., ``copyable_unique_ptr<const Foo>``), then
    get_mutable() returns a const pointer.)""";
      } get_mutable;
    } copyable_unique_ptr;
    // Symbol: drake::dummy_value
    struct /* dummy_value */ {
      // Source: drake/common/dummy_value.h:17
      const char* doc_was_unable_to_choose_unambiguous_names =
R"""(Provides a "dummy" value for a ScalarType -- a value that is unlikely
to be mistaken for a purposefully-computed value, useful for
initializing a value before the true result is available.

Defaults to using std::numeric_limits::quiet_NaN when available; it is
a compile-time error to call the unspecialized dummy_value::get() when
quiet_NaN is unavailable.

See autodiff_overloads.h to use this with Eigen's AutoDiffScalar.)""";
      // Symbol: drake::dummy_value::get
      struct /* get */ {
        // Source: drake/common/dummy_value.h:18
        const char* doc = R"""()""";
      } get;
    } dummy_value;
    // Symbol: drake::dynamic_pointer_cast
    struct /* dynamic_pointer_cast */ {
      // Source: drake/common/pointer_cast.h:38
      const char* doc =
R"""(Casts the object owned by the std::unique_ptr ``other`` from type
``U`` to ``T``; if the cast fails, returns nullptr. Casting is
performed using ``dynamic_cast`` on the managed value (i.e., the
result of ``other.get()``). On success, ``other`'s managed value is
transferred to the result and `other`` is empty; on failure, ``other``
will retain its original managed value and the result is empty. As
with ``dynamic_cast``, casting nullptr to anything always succeeds, so
a nullptr result could indicate either that the argument was nullptr
or that the cast failed.

This method is analogous to the built-in std::dynamic_pointer_cast
that operates on a std::shared_ptr.

Note that this function only supports default deleters.)""";
    } dynamic_pointer_cast;
    // Symbol: drake::dynamic_pointer_cast_or_throw
    struct /* dynamic_pointer_cast_or_throw */ {
      // Source: drake/common/pointer_cast.h:56
      const char* doc =
R"""(Casts the object owned by the std::unique_ptr ``other`` from type
``U`` to ``T``; if ``other`` is nullptr or the cast fails, throws a
RuntimeError. Casting is performed using ``dynamic_cast`` on the
managed value (i.e., the result of ``other.get()``). On success,
``other`'s managed value is transferred to the result and `other`` is
empty; on failure, ``other`` will retain its original managed value.

Raises:
    RuntimeError if the cast fails.

Note that this function only supports default deleters.)""";
    } dynamic_pointer_cast_or_throw;
    // Symbol: drake::examples
    struct /* examples */ {
      // Symbol: drake::examples::acrobot
      struct /* acrobot */ {
        // Symbol: drake::examples::acrobot::AcrobotGeometry
        struct /* AcrobotGeometry */ {
          // Source: drake/examples/acrobot/acrobot_geometry.h:26
          const char* doc =
R"""(Expresses an AcrobotPlant's geometry to a SceneGraph.

.. pydrake_system::

    name: AcrobotGeometry
    input_ports:
    - state
    output_ports:
    - geometry_pose

This class has no public constructor; instead use the AddToBuilder()
static method to create and add it to a DiagramBuilder directly.)""";
          // Symbol: drake::examples::acrobot::AcrobotGeometry::AcrobotGeometry
          struct /* ctor */ {
            // Source: drake/examples/acrobot/acrobot_geometry.h:28
            const char* doc = R"""()""";
          } ctor;
          // Symbol: drake::examples::acrobot::AcrobotGeometry::AddToBuilder
          struct /* AddToBuilder */ {
            // Source: drake/examples/acrobot/acrobot_geometry.h:41
            const char* doc_4args =
R"""(Creates, adds, and connects an AcrobotGeometry system into the given
``builder``. Both the ``acrobot_state.get_system()`` and
``scene_graph`` systems must have been added to the given ``builder``
already.

Parameter ``acrobot_params``:
    sets the parameters of the geometry registered with
    ``scene_graph``.

The ``scene_graph`` pointer is not retained by the AcrobotGeometry
system. The return value pointer is an alias of the new
AcrobotGeometry system that is owned by the ``builder``.)""";
            // Source: drake/examples/acrobot/acrobot_geometry.h:56
            const char* doc_3args =
R"""(Creates, adds, and connects an AcrobotGeometry system into the given
``builder``. Both the ``acrobot_state.get_system()`` and
``scene_graph`` systems must have been added to the given ``builder``
already.

Acrobot parameters are set to their default values.

The ``scene_graph`` pointer is not retained by the AcrobotGeometry
system. The return value pointer is an alias of the new
AcrobotGeometry system that is owned by the ``builder``.)""";
          } AddToBuilder;
        } AcrobotGeometry;
        // Symbol: drake::examples::acrobot::AcrobotInput
        struct /* AcrobotInput */ {
          // Source: drake/examples/acrobot/gen/acrobot_input.h:43
          const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";
          // Symbol: drake::examples::acrobot::AcrobotInput::AcrobotInput<T>
          struct /* ctor */ {
            // Source: drake/examples/acrobot/gen/acrobot_input.h:50
            const char* doc =
R"""(Default constructor. Sets all rows to their default value:

* ``tau`` defaults to 0.0 Nm.)""";
          } ctor;
          // Symbol: drake::examples::acrobot::AcrobotInput::DoClone
          struct /* DoClone */ {
            // Source: drake/examples/acrobot/gen/acrobot_input.h:82
            const char* doc = R"""()""";
          } DoClone;
          // Symbol: drake::examples::acrobot::AcrobotInput::GetCoordinateNames
          struct /* GetCoordinateNames */ {
            // Source: drake/examples/acrobot/gen/acrobot_input.h:118
            const char* doc =
R"""(See AcrobotInputIndices::GetCoordinateNames().)""";
          } GetCoordinateNames;
          // Symbol: drake::examples::acrobot::AcrobotInput::IsValid
          struct /* IsValid */ {
            // Source: drake/examples/acrobot/gen/acrobot_input.h:123
            const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";
          } IsValid;
          // Symbol: drake::examples::acrobot::AcrobotInput::K
          struct /* K */ {
            // Source: drake/examples/acrobot/gen/acrobot_input.h:46
            const char* doc =
R"""(An abbreviation for our row index constants.)""";
          } K;
          // Symbol: drake::examples::acrobot::AcrobotInput::Serialize
          struct /* Serialize */ {
            // Source: drake/examples/acrobot/gen/acrobot_input.h:112
            const char* doc =
R"""(Visit each field of this named vector, passing them (in order) to the
given Archive. The archive can read and/or write to the vector values.
One common use of Serialize is the //common/yaml tools.)""";
          } Serialize;
          // Symbol: drake::examples::acrobot::AcrobotInput::SetToNamedVariables
          struct /* SetToNamedVariables */ {
            // Source: drake/examples/acrobot/gen/acrobot_input.h:78
            const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";
          } SetToNamedVariables;
          // Symbol: drake::examples::acrobot::AcrobotInput::set_tau
          struct /* set_tau */ {
            // Source: drake/examples/acrobot/gen/acrobot_input.h:95
            const char* doc = R"""(Setter that matches tau().)""";
          } set_tau;
          // Symbol: drake::examples::acrobot::AcrobotInput::tau
          struct /* tau */ {
            // Source: drake/examples/acrobot/gen/acrobot_input.h:90
            const char* doc =
R"""(Torque at the elbow

Note:
    ``tau`` is expressed in units of Nm.)""";
          } tau;
          // Symbol: drake::examples::acrobot::AcrobotInput::with_tau
          struct /* with_tau */ {
            // Source: drake/examples/acrobot/gen/acrobot_input.h:101
            const char* doc =
R"""(Fluent setter that matches tau(). Returns a copy of ``this`` with tau
set to a new value.)""";
          } with_tau;
        } AcrobotInput;
        // Symbol: drake::examples::acrobot::AcrobotInputIndices
        struct /* AcrobotInputIndices */ {
          // Source: drake/examples/acrobot/gen/acrobot_input.h:27
          const char* doc =
R"""(Describes the row indices of a AcrobotInput.)""";
          // Symbol: drake::examples::acrobot::AcrobotInputIndices::GetCoordinateNames
          struct /* GetCoordinateNames */ {
            // Source: drake/examples/acrobot/gen/acrobot_input.h:38
            const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words,
``AcrobotInputIndices::GetCoordinateNames()[i]`` is the name for
``BasicVector::GetAtIndex(i)``.)""";
          } GetCoordinateNames;
        } AcrobotInputIndices;
        // Symbol: drake::examples::acrobot::AcrobotParams
        struct /* AcrobotParams */ {
          // Source: drake/examples/acrobot/gen/acrobot_params.h:53
          const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";
          // Symbol: drake::examples::acrobot::AcrobotParams::AcrobotParams<T>
          struct /* ctor */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:70
            const char* doc =
R"""(Default constructor. Sets all rows to their default value:

* ``m1`` defaults to 1.0 kg.

* ``m2`` defaults to 1.0 kg.

* ``l1`` defaults to 1.0 m.

* ``l2`` defaults to 2.0 m.

* ``lc1`` defaults to 0.5 m.

* ``lc2`` defaults to 1.0 m.

* ``Ic1`` defaults to 0.083 kg*m^2.

* ``Ic2`` defaults to 0.33 kg*m^2.

* ``b1`` defaults to 0.1 kg*m^2/s.

* ``b2`` defaults to 0.1 kg*m^2/s.

* ``gravity`` defaults to 9.81 m/s^2.)""";
          } ctor;
          // Symbol: drake::examples::acrobot::AcrobotParams::DoClone
          struct /* DoClone */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:122
            const char* doc = R"""()""";
          } DoClone;
          // Symbol: drake::examples::acrobot::AcrobotParams::GetCoordinateNames
          struct /* GetCoordinateNames */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:369
            const char* doc =
R"""(See AcrobotParamsIndices::GetCoordinateNames().)""";
          } GetCoordinateNames;
          // Symbol: drake::examples::acrobot::AcrobotParams::GetElementBounds
          struct /* GetElementBounds */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:402
            const char* doc = R"""()""";
          } GetElementBounds;
          // Symbol: drake::examples::acrobot::AcrobotParams::Ic1
          struct /* Ic1 */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:245
            const char* doc =
R"""(Inertia of link 1 about the center of mass of link 1.

Note:
    ``Ic1`` is expressed in units of kg*m^2.

Note:
    ``Ic1`` has a limited domain of [0.0, +Inf].)""";
          } Ic1;
          // Symbol: drake::examples::acrobot::AcrobotParams::Ic2
          struct /* Ic2 */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:264
            const char* doc =
R"""(Inertia of link 2 about the center of mass of link 2.

Note:
    ``Ic2`` is expressed in units of kg*m^2.

Note:
    ``Ic2`` has a limited domain of [0.0, +Inf].)""";
          } Ic2;
          // Symbol: drake::examples::acrobot::AcrobotParams::IsValid
          struct /* IsValid */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:374
            const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";
          } IsValid;
          // Symbol: drake::examples::acrobot::AcrobotParams::K
          struct /* K */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:56
            const char* doc =
R"""(An abbreviation for our row index constants.)""";
          } K;
          // Symbol: drake::examples::acrobot::AcrobotParams::Serialize
          struct /* Serialize */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:343
            const char* doc =
R"""(Visit each field of this named vector, passing them (in order) to the
given Archive. The archive can read and/or write to the vector values.
One common use of Serialize is the //common/yaml tools.)""";
          } Serialize;
          // Symbol: drake::examples::acrobot::AcrobotParams::SetToNamedVariables
          struct /* SetToNamedVariables */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:108
            const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";
          } SetToNamedVariables;
          // Symbol: drake::examples::acrobot::AcrobotParams::b1
          struct /* b1 */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:283
            const char* doc =
R"""(Damping coefficient of the shoulder joint.

Note:
    ``b1`` is expressed in units of kg*m^2/s.

Note:
    ``b1`` has a limited domain of [0.0, +Inf].)""";
          } b1;
          // Symbol: drake::examples::acrobot::AcrobotParams::b2
          struct /* b2 */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:302
            const char* doc =
R"""(Damping coefficient of the elbow joint.

Note:
    ``b2`` is expressed in units of kg*m^2/s.

Note:
    ``b2`` has a limited domain of [0.0, +Inf].)""";
          } b2;
          // Symbol: drake::examples::acrobot::AcrobotParams::gravity
          struct /* gravity */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:321
            const char* doc =
R"""(Gravitational constant.

Note:
    ``gravity`` is expressed in units of m/s^2.

Note:
    ``gravity`` has a limited domain of [0.0, +Inf].)""";
          } gravity;
          // Symbol: drake::examples::acrobot::AcrobotParams::l1
          struct /* l1 */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:169
            const char* doc =
R"""(Length of link 1.

Note:
    ``l1`` is expressed in units of m.

Note:
    ``l1`` has a limited domain of [0.0, +Inf].)""";
          } l1;
          // Symbol: drake::examples::acrobot::AcrobotParams::l2
          struct /* l2 */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:188
            const char* doc =
R"""(Length of link 2.

Note:
    ``l2`` is expressed in units of m.

Note:
    ``l2`` has a limited domain of [0.0, +Inf].)""";
          } l2;
          // Symbol: drake::examples::acrobot::AcrobotParams::lc1
          struct /* lc1 */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:207
            const char* doc =
R"""(Vertical distance from shoulder joint to center of mass of link 1.

Note:
    ``lc1`` is expressed in units of m.

Note:
    ``lc1`` has a limited domain of [0.0, +Inf].)""";
          } lc1;
          // Symbol: drake::examples::acrobot::AcrobotParams::lc2
          struct /* lc2 */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:226
            const char* doc =
R"""(Vertical distance from elbow joint to center of mass of link 1.

Note:
    ``lc2`` is expressed in units of m.

Note:
    ``lc2`` has a limited domain of [0.0, +Inf].)""";
          } lc2;
          // Symbol: drake::examples::acrobot::AcrobotParams::m1
          struct /* m1 */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:131
            const char* doc =
R"""(Mass of link 1.

Note:
    ``m1`` is expressed in units of kg.

Note:
    ``m1`` has a limited domain of [0.0, +Inf].)""";
          } m1;
          // Symbol: drake::examples::acrobot::AcrobotParams::m2
          struct /* m2 */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:150
            const char* doc =
R"""(Mass of link 2.

Note:
    ``m2`` is expressed in units of kg.

Note:
    ``m2`` has a limited domain of [0.0, +Inf].)""";
          } m2;
          // Symbol: drake::examples::acrobot::AcrobotParams::set_Ic1
          struct /* set_Ic1 */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:250
            const char* doc = R"""(Setter that matches Ic1().)""";
          } set_Ic1;
          // Symbol: drake::examples::acrobot::AcrobotParams::set_Ic2
          struct /* set_Ic2 */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:269
            const char* doc = R"""(Setter that matches Ic2().)""";
          } set_Ic2;
          // Symbol: drake::examples::acrobot::AcrobotParams::set_b1
          struct /* set_b1 */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:288
            const char* doc = R"""(Setter that matches b1().)""";
          } set_b1;
          // Symbol: drake::examples::acrobot::AcrobotParams::set_b2
          struct /* set_b2 */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:307
            const char* doc = R"""(Setter that matches b2().)""";
          } set_b2;
          // Symbol: drake::examples::acrobot::AcrobotParams::set_gravity
          struct /* set_gravity */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:326
            const char* doc = R"""(Setter that matches gravity().)""";
          } set_gravity;
          // Symbol: drake::examples::acrobot::AcrobotParams::set_l1
          struct /* set_l1 */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:174
            const char* doc = R"""(Setter that matches l1().)""";
          } set_l1;
          // Symbol: drake::examples::acrobot::AcrobotParams::set_l2
          struct /* set_l2 */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:193
            const char* doc = R"""(Setter that matches l2().)""";
          } set_l2;
          // Symbol: drake::examples::acrobot::AcrobotParams::set_lc1
          struct /* set_lc1 */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:212
            const char* doc = R"""(Setter that matches lc1().)""";
          } set_lc1;
          // Symbol: drake::examples::acrobot::AcrobotParams::set_lc2
          struct /* set_lc2 */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:231
            const char* doc = R"""(Setter that matches lc2().)""";
          } set_lc2;
          // Symbol: drake::examples::acrobot::AcrobotParams::set_m1
          struct /* set_m1 */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:136
            const char* doc = R"""(Setter that matches m1().)""";
          } set_m1;
          // Symbol: drake::examples::acrobot::AcrobotParams::set_m2
          struct /* set_m2 */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:155
            const char* doc = R"""(Setter that matches m2().)""";
          } set_m2;
          // Symbol: drake::examples::acrobot::AcrobotParams::with_Ic1
          struct /* with_Ic1 */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:256
            const char* doc =
R"""(Fluent setter that matches Ic1(). Returns a copy of ``this`` with Ic1
set to a new value.)""";
          } with_Ic1;
          // Symbol: drake::examples::acrobot::AcrobotParams::with_Ic2
          struct /* with_Ic2 */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:275
            const char* doc =
R"""(Fluent setter that matches Ic2(). Returns a copy of ``this`` with Ic2
set to a new value.)""";
          } with_Ic2;
          // Symbol: drake::examples::acrobot::AcrobotParams::with_b1
          struct /* with_b1 */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:294
            const char* doc =
R"""(Fluent setter that matches b1(). Returns a copy of ``this`` with b1
set to a new value.)""";
          } with_b1;
          // Symbol: drake::examples::acrobot::AcrobotParams::with_b2
          struct /* with_b2 */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:313
            const char* doc =
R"""(Fluent setter that matches b2(). Returns a copy of ``this`` with b2
set to a new value.)""";
          } with_b2;
          // Symbol: drake::examples::acrobot::AcrobotParams::with_gravity
          struct /* with_gravity */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:332
            const char* doc =
R"""(Fluent setter that matches gravity(). Returns a copy of ``this`` with
gravity set to a new value.)""";
          } with_gravity;
          // Symbol: drake::examples::acrobot::AcrobotParams::with_l1
          struct /* with_l1 */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:180
            const char* doc =
R"""(Fluent setter that matches l1(). Returns a copy of ``this`` with l1
set to a new value.)""";
          } with_l1;
          // Symbol: drake::examples::acrobot::AcrobotParams::with_l2
          struct /* with_l2 */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:199
            const char* doc =
R"""(Fluent setter that matches l2(). Returns a copy of ``this`` with l2
set to a new value.)""";
          } with_l2;
          // Symbol: drake::examples::acrobot::AcrobotParams::with_lc1
          struct /* with_lc1 */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:218
            const char* doc =
R"""(Fluent setter that matches lc1(). Returns a copy of ``this`` with lc1
set to a new value.)""";
          } with_lc1;
          // Symbol: drake::examples::acrobot::AcrobotParams::with_lc2
          struct /* with_lc2 */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:237
            const char* doc =
R"""(Fluent setter that matches lc2(). Returns a copy of ``this`` with lc2
set to a new value.)""";
          } with_lc2;
          // Symbol: drake::examples::acrobot::AcrobotParams::with_m1
          struct /* with_m1 */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:142
            const char* doc =
R"""(Fluent setter that matches m1(). Returns a copy of ``this`` with m1
set to a new value.)""";
          } with_m1;
          // Symbol: drake::examples::acrobot::AcrobotParams::with_m2
          struct /* with_m2 */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:161
            const char* doc =
R"""(Fluent setter that matches m2(). Returns a copy of ``this`` with m2
set to a new value.)""";
          } with_m2;
        } AcrobotParams;
        // Symbol: drake::examples::acrobot::AcrobotParamsIndices
        struct /* AcrobotParamsIndices */ {
          // Source: drake/examples/acrobot/gen/acrobot_params.h:27
          const char* doc =
R"""(Describes the row indices of a AcrobotParams.)""";
          // Symbol: drake::examples::acrobot::AcrobotParamsIndices::GetCoordinateNames
          struct /* GetCoordinateNames */ {
            // Source: drake/examples/acrobot/gen/acrobot_params.h:48
            const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words,
``AcrobotParamsIndices::GetCoordinateNames()[i]`` is the name for
``BasicVector::GetAtIndex(i)``.)""";
          } GetCoordinateNames;
        } AcrobotParamsIndices;
        // Symbol: drake::examples::acrobot::AcrobotPlant
        struct /* AcrobotPlant */ {
          // Source: drake/examples/acrobot/acrobot_plant.h:38
          const char* doc =
R"""(The Acrobot - a canonical underactuated system as described in <a
href="http://underactuated.mit.edu/underactuated.html?chapter=3">Chapter
3 of Underactuated Robotics</a>.

.. pydrake_system::

    name: AcrobotPlant
    input_ports:
    - elbow_torque
    output_ports:
    - acrobot_state)""";
          // Symbol: drake::examples::acrobot::AcrobotPlant::AcrobotPlant<T>
          struct /* ctor */ {
            // Source: drake/examples/acrobot/acrobot_plant.h:44
            const char* doc =
R"""(Constructs the plant. The parameters of the system are stored as
Parameters in the Context (see acrobot_params_named_vector.yaml).)""";
            // Source: drake/examples/acrobot/acrobot_plant.h:48
            const char* doc_copyconvert =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";
          } ctor;
          // Symbol: drake::examples::acrobot::AcrobotPlant::DynamicsBiasTerm
          struct /* DynamicsBiasTerm */ {
            // Source: drake/examples/acrobot/acrobot_plant.h:61
            const char* doc =
R"""(Manipulator equation of Acrobot: M(q)q̈ + bias(q,q̇) = B*u.

- M[2x2] is the mass matrix. - bias[2x1] includes the Coriolis term,
gravity term and the damping term, i.e. bias[2x1] = C(q,v)*v - τ_g(q)
+ [b1*q̇₁;b2*q̇₂].)""";
          } DynamicsBiasTerm;
          // Symbol: drake::examples::acrobot::AcrobotPlant::MassMatrix
          struct /* MassMatrix */ {
            // Source: drake/examples/acrobot/acrobot_plant.h:62
            const char* doc = R"""()""";
          } MassMatrix;
          // Symbol: drake::examples::acrobot::AcrobotPlant::SetMITAcrobotParameters
          struct /* SetMITAcrobotParameters */ {
            // Source: drake/examples/acrobot/acrobot_plant.h:52
            const char* doc =
R"""(Sets the parameters to describe MIT Robot Locomotion Group's hardware
acrobot.)""";
          } SetMITAcrobotParameters;
          // Symbol: drake::examples::acrobot::AcrobotPlant::get_mutable_parameters
          struct /* get_mutable_parameters */ {
            // Source: drake/examples/acrobot/acrobot_plant.h:94
            const char* doc = R"""()""";
          } get_mutable_parameters;
          // Symbol: drake::examples::acrobot::AcrobotPlant::get_mutable_state
          struct /* get_mutable_state */ {
            // Source: drake/examples/acrobot/acrobot_plant.h:80
            const char* doc = R"""()""";
          } get_mutable_state;
          // Symbol: drake::examples::acrobot::AcrobotPlant::get_parameters
          struct /* get_parameters */ {
            // Source: drake/examples/acrobot/acrobot_plant.h:89
            const char* doc = R"""()""";
          } get_parameters;
          // Symbol: drake::examples::acrobot::AcrobotPlant::get_state
          struct /* get_state */ {
            // Source: drake/examples/acrobot/acrobot_plant.h:71
            const char* doc = R"""()""";
          } get_state;
          // Symbol: drake::examples::acrobot::AcrobotPlant::get_tau
          struct /* get_tau */ {
            // Source: drake/examples/acrobot/acrobot_plant.h:67
            const char* doc =
R"""(Evaluates the input port and returns the scalar value of the commanded
torque.)""";
          } get_tau;
        } AcrobotPlant;
        // Symbol: drake::examples::acrobot::AcrobotSpongController
        struct /* AcrobotSpongController */ {
          // Source: drake/examples/acrobot/spong_controller.h:38
          const char* doc =
R"""(The Spong acrobot swing-up controller as described in: Spong, Mark W.
"Swing up control of the acrobot." Robotics and Automation, 1994.
Proceedings., 1994 IEEE International Conference on. IEEE, 1994.

Note that the Spong controller works well on the default set of
parameters, which Spong used in his paper. In contrast, it is
difficult to find a functional set of gains to stabilize the robot
about its upright fixed point using the parameters of the physical
robot we have in lab.

.. pydrake_system::

    name: AcrobotSpongController
    input_ports:
    - acrobot_state
    output_ports:
    - elbow_torque)""";
          // Symbol: drake::examples::acrobot::AcrobotSpongController::AcrobotSpongController<T>
          struct /* ctor */ {
            // Source: drake/examples/acrobot/spong_controller.h:40
            const char* doc = R"""()""";
          } ctor;
          // Symbol: drake::examples::acrobot::AcrobotSpongController::CalcControlTorque
          struct /* CalcControlTorque */ {
            // Source: drake/examples/acrobot/spong_controller.h:89
            const char* doc = R"""()""";
          } CalcControlTorque;
          // Symbol: drake::examples::acrobot::AcrobotSpongController::get_mutable_parameters
          struct /* get_mutable_parameters */ {
            // Source: drake/examples/acrobot/spong_controller.h:83
            const char* doc = R"""()""";
          } get_mutable_parameters;
          // Symbol: drake::examples::acrobot::AcrobotSpongController::get_parameters
          struct /* get_parameters */ {
            // Source: drake/examples/acrobot/spong_controller.h:77
            const char* doc = R"""()""";
          } get_parameters;
        } AcrobotSpongController;
        // Symbol: drake::examples::acrobot::AcrobotState
        struct /* AcrobotState */ {
          // Source: drake/examples/acrobot/gen/acrobot_state.h:46
          const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";
          // Symbol: drake::examples::acrobot::AcrobotState::AcrobotState<T>
          struct /* ctor */ {
            // Source: drake/examples/acrobot/gen/acrobot_state.h:56
            const char* doc =
R"""(Default constructor. Sets all rows to their default value:

* ``theta1`` defaults to 0.0 rad.

* ``theta2`` defaults to 0.0 rad.

* ``theta1dot`` defaults to 0.0 rad/s.

* ``theta2dot`` defaults to 0.0 rad/s.)""";
          } ctor;
          // Symbol: drake::examples::acrobot::AcrobotState::DoClone
          struct /* DoClone */ {
            // Source: drake/examples/acrobot/gen/acrobot_state.h:94
            const char* doc = R"""()""";
          } DoClone;
          // Symbol: drake::examples::acrobot::AcrobotState::GetCoordinateNames
          struct /* GetCoordinateNames */ {
            // Source: drake/examples/acrobot/gen/acrobot_state.h:190
            const char* doc =
R"""(See AcrobotStateIndices::GetCoordinateNames().)""";
          } GetCoordinateNames;
          // Symbol: drake::examples::acrobot::AcrobotState::IsValid
          struct /* IsValid */ {
            // Source: drake/examples/acrobot/gen/acrobot_state.h:195
            const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";
          } IsValid;
          // Symbol: drake::examples::acrobot::AcrobotState::K
          struct /* K */ {
            // Source: drake/examples/acrobot/gen/acrobot_state.h:49
            const char* doc =
R"""(An abbreviation for our row index constants.)""";
          } K;
          // Symbol: drake::examples::acrobot::AcrobotState::Serialize
          struct /* Serialize */ {
            // Source: drake/examples/acrobot/gen/acrobot_state.h:178
            const char* doc =
R"""(Visit each field of this named vector, passing them (in order) to the
given Archive. The archive can read and/or write to the vector values.
One common use of Serialize is the //common/yaml tools.)""";
          } Serialize;
          // Symbol: drake::examples::acrobot::AcrobotState::SetToNamedVariables
          struct /* SetToNamedVariables */ {
            // Source: drake/examples/acrobot/gen/acrobot_state.h:87
            const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";
          } SetToNamedVariables;
          // Symbol: drake::examples::acrobot::AcrobotState::set_theta1
          struct /* set_theta1 */ {
            // Source: drake/examples/acrobot/gen/acrobot_state.h:107
            const char* doc = R"""(Setter that matches theta1().)""";
          } set_theta1;
          // Symbol: drake::examples::acrobot::AcrobotState::set_theta1dot
          struct /* set_theta1dot */ {
            // Source: drake/examples/acrobot/gen/acrobot_state.h:143
            const char* doc = R"""(Setter that matches theta1dot().)""";
          } set_theta1dot;
          // Symbol: drake::examples::acrobot::AcrobotState::set_theta2
          struct /* set_theta2 */ {
            // Source: drake/examples/acrobot/gen/acrobot_state.h:125
            const char* doc = R"""(Setter that matches theta2().)""";
          } set_theta2;
          // Symbol: drake::examples::acrobot::AcrobotState::set_theta2dot
          struct /* set_theta2dot */ {
            // Source: drake/examples/acrobot/gen/acrobot_state.h:161
            const char* doc = R"""(Setter that matches theta2dot().)""";
          } set_theta2dot;
          // Symbol: drake::examples::acrobot::AcrobotState::theta1
          struct /* theta1 */ {
            // Source: drake/examples/acrobot/gen/acrobot_state.h:102
            const char* doc =
R"""(The shoulder joint angle

Note:
    ``theta1`` is expressed in units of rad.)""";
          } theta1;
          // Symbol: drake::examples::acrobot::AcrobotState::theta1dot
          struct /* theta1dot */ {
            // Source: drake/examples/acrobot/gen/acrobot_state.h:138
            const char* doc =
R"""(The shoulder joint velocity

Note:
    ``theta1dot`` is expressed in units of rad/s.)""";
          } theta1dot;
          // Symbol: drake::examples::acrobot::AcrobotState::theta2
          struct /* theta2 */ {
            // Source: drake/examples/acrobot/gen/acrobot_state.h:120
            const char* doc =
R"""(The elbow joint angle

Note:
    ``theta2`` is expressed in units of rad.)""";
          } theta2;
          // Symbol: drake::examples::acrobot::AcrobotState::theta2dot
          struct /* theta2dot */ {
            // Source: drake/examples/acrobot/gen/acrobot_state.h:156
            const char* doc =
R"""(The elbow joint velocity

Note:
    ``theta2dot`` is expressed in units of rad/s.)""";
          } theta2dot;
          // Symbol: drake::examples::acrobot::AcrobotState::with_theta1
          struct /* with_theta1 */ {
            // Source: drake/examples/acrobot/gen/acrobot_state.h:113
            const char* doc =
R"""(Fluent setter that matches theta1(). Returns a copy of ``this`` with
theta1 set to a new value.)""";
          } with_theta1;
          // Symbol: drake::examples::acrobot::AcrobotState::with_theta1dot
          struct /* with_theta1dot */ {
            // Source: drake/examples/acrobot/gen/acrobot_state.h:149
            const char* doc =
R"""(Fluent setter that matches theta1dot(). Returns a copy of ``this``
with theta1dot set to a new value.)""";
          } with_theta1dot;
          // Symbol: drake::examples::acrobot::AcrobotState::with_theta2
          struct /* with_theta2 */ {
            // Source: drake/examples/acrobot/gen/acrobot_state.h:131
            const char* doc =
R"""(Fluent setter that matches theta2(). Returns a copy of ``this`` with
theta2 set to a new value.)""";
          } with_theta2;
          // Symbol: drake::examples::acrobot::AcrobotState::with_theta2dot
          struct /* with_theta2dot */ {
            // Source: drake/examples/acrobot/gen/acrobot_state.h:167
            const char* doc =
R"""(Fluent setter that matches theta2dot(). Returns a copy of ``this``
with theta2dot set to a new value.)""";
          } with_theta2dot;
        } AcrobotState;
        // Symbol: drake::examples::acrobot::AcrobotStateIndices
        struct /* AcrobotStateIndices */ {
          // Source: drake/examples/acrobot/gen/acrobot_state.h:27
          const char* doc =
R"""(Describes the row indices of a AcrobotState.)""";
          // Symbol: drake::examples::acrobot::AcrobotStateIndices::GetCoordinateNames
          struct /* GetCoordinateNames */ {
            // Source: drake/examples/acrobot/gen/acrobot_state.h:41
            const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words,
``AcrobotStateIndices::GetCoordinateNames()[i]`` is the name for
``BasicVector::GetAtIndex(i)``.)""";
          } GetCoordinateNames;
        } AcrobotStateIndices;
        // Symbol: drake::examples::acrobot::AcrobotWEncoder
        struct /* AcrobotWEncoder */ {
          // Source: drake/examples/acrobot/acrobot_plant.h:130
          const char* doc =
R"""(Constructs the Acrobot with (only) encoder outputs.

.. pydrake_system::

    name: AcrobotWEncoder
    input_ports:
    - elbow_torque
    output_ports:
    - measured_joint_positions
    - acrobot_state (optional))""";
          // Symbol: drake::examples::acrobot::AcrobotWEncoder::AcrobotWEncoder<T>
          struct /* ctor */ {
            // Source: drake/examples/acrobot/acrobot_plant.h:132
            const char* doc = R"""()""";
          } ctor;
          // Symbol: drake::examples::acrobot::AcrobotWEncoder::acrobot_plant
          struct /* acrobot_plant */ {
            // Source: drake/examples/acrobot/acrobot_plant.h:134
            const char* doc = R"""()""";
          } acrobot_plant;
          // Symbol: drake::examples::acrobot::AcrobotWEncoder::get_mutable_acrobot_state
          struct /* get_mutable_acrobot_state */ {
            // Source: drake/examples/acrobot/acrobot_plant.h:136
            const char* doc = R"""()""";
          } get_mutable_acrobot_state;
        } AcrobotWEncoder;
        // Symbol: drake::examples::acrobot::BalancingLQRController
        struct /* BalancingLQRController */ {
          // Source: drake/examples/acrobot/acrobot_plant.h:146
          const char* doc =
R"""(Constructs the LQR controller for stabilizing the upright fixed point
using default LQR cost matrices which have been tested for this
system.)""";
        } BalancingLQRController;
        // Symbol: drake::examples::acrobot::SpongControllerParams
        struct /* SpongControllerParams */ {
          // Source: drake/examples/acrobot/gen/spong_controller_params.h:46
          const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";
          // Symbol: drake::examples::acrobot::SpongControllerParams::DoClone
          struct /* DoClone */ {
            // Source: drake/examples/acrobot/gen/spong_controller_params.h:94
            const char* doc = R"""()""";
          } DoClone;
          // Symbol: drake::examples::acrobot::SpongControllerParams::GetCoordinateNames
          struct /* GetCoordinateNames */ {
            // Source: drake/examples/acrobot/gen/spong_controller_params.h:196
            const char* doc =
R"""(See SpongControllerParamsIndices::GetCoordinateNames().)""";
          } GetCoordinateNames;
          // Symbol: drake::examples::acrobot::SpongControllerParams::GetElementBounds
          struct /* GetElementBounds */ {
            // Source: drake/examples/acrobot/gen/spong_controller_params.h:215
            const char* doc = R"""()""";
          } GetElementBounds;
          // Symbol: drake::examples::acrobot::SpongControllerParams::IsValid
          struct /* IsValid */ {
            // Source: drake/examples/acrobot/gen/spong_controller_params.h:201
            const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";
          } IsValid;
          // Symbol: drake::examples::acrobot::SpongControllerParams::K
          struct /* K */ {
            // Source: drake/examples/acrobot/gen/spong_controller_params.h:49
            const char* doc =
R"""(An abbreviation for our row index constants.)""";
          } K;
          // Symbol: drake::examples::acrobot::SpongControllerParams::Serialize
          struct /* Serialize */ {
            // Source: drake/examples/acrobot/gen/spong_controller_params.h:183
            const char* doc =
R"""(Visit each field of this named vector, passing them (in order) to the
given Archive. The archive can read and/or write to the vector values.
One common use of Serialize is the //common/yaml tools.)""";
          } Serialize;
          // Symbol: drake::examples::acrobot::SpongControllerParams::SetToNamedVariables
          struct /* SetToNamedVariables */ {
            // Source: drake/examples/acrobot/gen/spong_controller_params.h:87
            const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";
          } SetToNamedVariables;
          // Symbol: drake::examples::acrobot::SpongControllerParams::SpongControllerParams<T>
          struct /* ctor */ {
            // Source: drake/examples/acrobot/gen/spong_controller_params.h:56
            const char* doc =
R"""(Default constructor. Sets all rows to their default value:

* ``k_e`` defaults to 5.0 s.

* ``k_p`` defaults to 50.0 s^-2.

* ``k_d`` defaults to 5.0 s^-1.

* ``balancing_threshold`` defaults to 1e3 None.)""";
          } ctor;
          // Symbol: drake::examples::acrobot::SpongControllerParams::balancing_threshold
          struct /* balancing_threshold */ {
            // Source: drake/examples/acrobot/gen/spong_controller_params.h:160
            const char* doc =
R"""(Cost value at which to switch from swing up to balancing.

Note:
    ``balancing_threshold`` is expressed in units of None.

Note:
    ``balancing_threshold`` has a limited domain of [0.0, +Inf].)""";
          } balancing_threshold;
          // Symbol: drake::examples::acrobot::SpongControllerParams::k_d
          struct /* k_d */ {
            // Source: drake/examples/acrobot/gen/spong_controller_params.h:141
            const char* doc =
R"""(Partial feedback linearization derivative gain.

Note:
    ``k_d`` is expressed in units of s^-1.

Note:
    ``k_d`` has a limited domain of [0.0, +Inf].)""";
          } k_d;
          // Symbol: drake::examples::acrobot::SpongControllerParams::k_e
          struct /* k_e */ {
            // Source: drake/examples/acrobot/gen/spong_controller_params.h:103
            const char* doc =
R"""(Energy shaping gain.

Note:
    ``k_e`` is expressed in units of s.

Note:
    ``k_e`` has a limited domain of [0.0, +Inf].)""";
          } k_e;
          // Symbol: drake::examples::acrobot::SpongControllerParams::k_p
          struct /* k_p */ {
            // Source: drake/examples/acrobot/gen/spong_controller_params.h:122
            const char* doc =
R"""(Partial feedback linearization proportional gain.

Note:
    ``k_p`` is expressed in units of s^-2.

Note:
    ``k_p`` has a limited domain of [0.0, +Inf].)""";
          } k_p;
          // Symbol: drake::examples::acrobot::SpongControllerParams::set_balancing_threshold
          struct /* set_balancing_threshold */ {
            // Source: drake/examples/acrobot/gen/spong_controller_params.h:165
            const char* doc =
R"""(Setter that matches balancing_threshold().)""";
          } set_balancing_threshold;
          // Symbol: drake::examples::acrobot::SpongControllerParams::set_k_d
          struct /* set_k_d */ {
            // Source: drake/examples/acrobot/gen/spong_controller_params.h:146
            const char* doc = R"""(Setter that matches k_d().)""";
          } set_k_d;
          // Symbol: drake::examples::acrobot::SpongControllerParams::set_k_e
          struct /* set_k_e */ {
            // Source: drake/examples/acrobot/gen/spong_controller_params.h:108
            const char* doc = R"""(Setter that matches k_e().)""";
          } set_k_e;
          // Symbol: drake::examples::acrobot::SpongControllerParams::set_k_p
          struct /* set_k_p */ {
            // Source: drake/examples/acrobot/gen/spong_controller_params.h:127
            const char* doc = R"""(Setter that matches k_p().)""";
          } set_k_p;
          // Symbol: drake::examples::acrobot::SpongControllerParams::with_balancing_threshold
          struct /* with_balancing_threshold */ {
            // Source: drake/examples/acrobot/gen/spong_controller_params.h:171
            const char* doc =
R"""(Fluent setter that matches balancing_threshold(). Returns a copy of
``this`` with balancing_threshold set to a new value.)""";
          } with_balancing_threshold;
          // Symbol: drake::examples::acrobot::SpongControllerParams::with_k_d
          struct /* with_k_d */ {
            // Source: drake/examples/acrobot/gen/spong_controller_params.h:152
            const char* doc =
R"""(Fluent setter that matches k_d(). Returns a copy of ``this`` with k_d
set to a new value.)""";
          } with_k_d;
          // Symbol: drake::examples::acrobot::SpongControllerParams::with_k_e
          struct /* with_k_e */ {
            // Source: drake/examples/acrobot/gen/spong_controller_params.h:114
            const char* doc =
R"""(Fluent setter that matches k_e(). Returns a copy of ``this`` with k_e
set to a new value.)""";
          } with_k_e;
          // Symbol: drake::examples::acrobot::SpongControllerParams::with_k_p
          struct /* with_k_p */ {
            // Source: drake/examples/acrobot/gen/spong_controller_params.h:133
            const char* doc =
R"""(Fluent setter that matches k_p(). Returns a copy of ``this`` with k_p
set to a new value.)""";
          } with_k_p;
        } SpongControllerParams;
        // Symbol: drake::examples::acrobot::SpongControllerParamsIndices
        struct /* SpongControllerParamsIndices */ {
          // Source: drake/examples/acrobot/gen/spong_controller_params.h:27
          const char* doc =
R"""(Describes the row indices of a SpongControllerParams.)""";
          // Symbol: drake::examples::acrobot::SpongControllerParamsIndices::GetCoordinateNames
          struct /* GetCoordinateNames */ {
            // Source: drake/examples/acrobot/gen/spong_controller_params.h:41
            const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words,
``SpongControllerParamsIndices::GetCoordinateNames()[i]`` is the name
for ``BasicVector::GetAtIndex(i)``.)""";
          } GetCoordinateNames;
        } SpongControllerParamsIndices;
      } acrobot;
      // Symbol: drake::examples::compass_gait
      struct /* compass_gait */ {
        // Symbol: drake::examples::compass_gait::CompassGait
        struct /* CompassGait */ {
          // Source: drake/examples/compass_gait/compass_gait.h:50
          const char* doc =
R"""(Dynamical representation of the idealized hybrid dynamics of a
"compass gait", as described in
http://underactuated.mit.edu/underactuated.html?chapter=simple_legs .
This implementation has two additional state variables that are not
required in the mathematical model:

- a discrete state for the position of the stance toe along the ramp
- a Boolean indicator for "left support" (true when the stance leg is
  the left leg).

These are helpful for outputting the floating-base model coordinate,
e.g. for visualization.

Note:
    This model only supports walking downhill on the ramp, because
    that restriction enables a clean / numerically robust
    implementation of the foot collision witness function that avoids
    fall detection on the "foot scuffing" collision.

.. pydrake_system::

    name: CompassGait
    input_ports:
    - hip_torque
    output_ports:
    - minimal_state
    - floating_base_state

Continuous States: stance, swing, stancedot, swingdot.

Discrete State: stance toe position.

Abstract State: left support indicator.)""";
          // Symbol: drake::examples::compass_gait::CompassGait::CompassGait<T>
          struct /* ctor */ {
            // Source: drake/examples/compass_gait/compass_gait.h:55
            const char* doc = R"""(Constructs the plant.)""";
            // Source: drake/examples/compass_gait/compass_gait.h:59
            const char* doc_copyconvert =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";
          } ctor;
          // Symbol: drake::examples::compass_gait::CompassGait::DynamicsBiasTerm
          struct /* DynamicsBiasTerm */ {
            // Source: drake/examples/compass_gait/compass_gait.h:116
            const char* doc =
R"""(Manipulator equation of CompassGait: M(q)v̇ + bias(q,v) = 0.

- M is the 2x2 mass matrix. - bias is a 2x1 vector that includes the
Coriolis term and gravity term, i.e. bias = C(q,v)*v - τ_g(q).)""";
          } DynamicsBiasTerm;
          // Symbol: drake::examples::compass_gait::CompassGait::MassMatrix
          struct /* MassMatrix */ {
            // Source: drake/examples/compass_gait/compass_gait.h:117
            const char* doc = R"""()""";
          } MassMatrix;
          // Symbol: drake::examples::compass_gait::CompassGait::get_continuous_state
          struct /* get_continuous_state */ {
            // Source: drake/examples/compass_gait/compass_gait.h:75
            const char* doc = R"""(Returns the CompassGaitContinuousState.)""";
          } get_continuous_state;
          // Symbol: drake::examples::compass_gait::CompassGait::get_floating_base_state_output_port
          struct /* get_floating_base_state_output_port */ {
            // Source: drake/examples/compass_gait/compass_gait.h:70
            const char* doc =
R"""(Returns reference to the output port that provides the state in the
floating-base coordinates (described via left leg xyz & rpy + hip
angle + derivatives).)""";
          } get_floating_base_state_output_port;
          // Symbol: drake::examples::compass_gait::CompassGait::get_minimal_state_output_port
          struct /* get_minimal_state_output_port */ {
            // Source: drake/examples/compass_gait/compass_gait.h:63
            const char* doc =
R"""(Returns reference to the output port that publishes only
[theta_stance, theta_swing, thetatdot_stance, thetadot_swing].)""";
          } get_minimal_state_output_port;
          // Symbol: drake::examples::compass_gait::CompassGait::get_mutable_continuous_state
          struct /* get_mutable_continuous_state */ {
            // Source: drake/examples/compass_gait/compass_gait.h:81
            const char* doc =
R"""(Returns the mutable CompassGaitContinuousState.)""";
          } get_mutable_continuous_state;
          // Symbol: drake::examples::compass_gait::CompassGait::get_parameters
          struct /* get_parameters */ {
            // Source: drake/examples/compass_gait/compass_gait.h:105
            const char* doc = R"""(Access the CompassGaitParams.)""";
          } get_parameters;
          // Symbol: drake::examples::compass_gait::CompassGait::get_toe_position
          struct /* get_toe_position */ {
            // Source: drake/examples/compass_gait/compass_gait.h:87
            const char* doc = R"""()""";
          } get_toe_position;
          // Symbol: drake::examples::compass_gait::CompassGait::left_leg_is_stance
          struct /* left_leg_is_stance */ {
            // Source: drake/examples/compass_gait/compass_gait.h:96
            const char* doc = R"""()""";
          } left_leg_is_stance;
          // Symbol: drake::examples::compass_gait::CompassGait::set_left_leg_is_stance
          struct /* set_left_leg_is_stance */ {
            // Source: drake/examples/compass_gait/compass_gait.h:100
            const char* doc = R"""()""";
          } set_left_leg_is_stance;
          // Symbol: drake::examples::compass_gait::CompassGait::set_toe_position
          struct /* set_toe_position */ {
            // Source: drake/examples/compass_gait/compass_gait.h:91
            const char* doc = R"""()""";
          } set_toe_position;
        } CompassGait;
        // Symbol: drake::examples::compass_gait::CompassGaitContinuousState
        struct /* CompassGaitContinuousState */ {
          // Source: drake/examples/compass_gait/gen/compass_gait_continuous_state.h:47
          const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";
          // Symbol: drake::examples::compass_gait::CompassGaitContinuousState::CompassGaitContinuousState<T>
          struct /* ctor */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_continuous_state.h:57
            const char* doc =
R"""(Default constructor. Sets all rows to their default value:

* ``stance`` defaults to 0.0 radians.

* ``swing`` defaults to 0.0 radians.

* ``stancedot`` defaults to 0.0 rad/sec.

* ``swingdot`` defaults to 0.0 rad/sec.)""";
          } ctor;
          // Symbol: drake::examples::compass_gait::CompassGaitContinuousState::DoClone
          struct /* DoClone */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_continuous_state.h:98
            const char* doc = R"""()""";
          } DoClone;
          // Symbol: drake::examples::compass_gait::CompassGaitContinuousState::GetCoordinateNames
          struct /* GetCoordinateNames */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_continuous_state.h:199
            const char* doc =
R"""(See CompassGaitContinuousStateIndices::GetCoordinateNames().)""";
          } GetCoordinateNames;
          // Symbol: drake::examples::compass_gait::CompassGaitContinuousState::IsValid
          struct /* IsValid */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_continuous_state.h:204
            const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";
          } IsValid;
          // Symbol: drake::examples::compass_gait::CompassGaitContinuousState::K
          struct /* K */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_continuous_state.h:50
            const char* doc =
R"""(An abbreviation for our row index constants.)""";
          } K;
          // Symbol: drake::examples::compass_gait::CompassGaitContinuousState::Serialize
          struct /* Serialize */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_continuous_state.h:187
            const char* doc =
R"""(Visit each field of this named vector, passing them (in order) to the
given Archive. The archive can read and/or write to the vector values.
One common use of Serialize is the //common/yaml tools.)""";
          } Serialize;
          // Symbol: drake::examples::compass_gait::CompassGaitContinuousState::SetToNamedVariables
          struct /* SetToNamedVariables */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_continuous_state.h:91
            const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";
          } SetToNamedVariables;
          // Symbol: drake::examples::compass_gait::CompassGaitContinuousState::set_stance
          struct /* set_stance */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_continuous_state.h:112
            const char* doc = R"""(Setter that matches stance().)""";
          } set_stance;
          // Symbol: drake::examples::compass_gait::CompassGaitContinuousState::set_stancedot
          struct /* set_stancedot */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_continuous_state.h:150
            const char* doc = R"""(Setter that matches stancedot().)""";
          } set_stancedot;
          // Symbol: drake::examples::compass_gait::CompassGaitContinuousState::set_swing
          struct /* set_swing */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_continuous_state.h:132
            const char* doc = R"""(Setter that matches swing().)""";
          } set_swing;
          // Symbol: drake::examples::compass_gait::CompassGaitContinuousState::set_swingdot
          struct /* set_swingdot */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_continuous_state.h:169
            const char* doc = R"""(Setter that matches swingdot().)""";
          } set_swingdot;
          // Symbol: drake::examples::compass_gait::CompassGaitContinuousState::stance
          struct /* stance */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_continuous_state.h:107
            const char* doc =
R"""(The orientation of the stance leg, measured clockwise from the
vertical axis.

Note:
    ``stance`` is expressed in units of radians.)""";
          } stance;
          // Symbol: drake::examples::compass_gait::CompassGaitContinuousState::stancedot
          struct /* stancedot */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_continuous_state.h:145
            const char* doc =
R"""(The angular velocity of the stance leg.

Note:
    ``stancedot`` is expressed in units of rad/sec.)""";
          } stancedot;
          // Symbol: drake::examples::compass_gait::CompassGaitContinuousState::swing
          struct /* swing */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_continuous_state.h:127
            const char* doc =
R"""(The orientation of the swing leg, measured clockwise from the vertical
axis.

Note:
    ``swing`` is expressed in units of radians.)""";
          } swing;
          // Symbol: drake::examples::compass_gait::CompassGaitContinuousState::swingdot
          struct /* swingdot */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_continuous_state.h:164
            const char* doc =
R"""(The angular velocity of the swing leg.

Note:
    ``swingdot`` is expressed in units of rad/sec.)""";
          } swingdot;
          // Symbol: drake::examples::compass_gait::CompassGaitContinuousState::with_stance
          struct /* with_stance */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_continuous_state.h:118
            const char* doc =
R"""(Fluent setter that matches stance(). Returns a copy of ``this`` with
stance set to a new value.)""";
          } with_stance;
          // Symbol: drake::examples::compass_gait::CompassGaitContinuousState::with_stancedot
          struct /* with_stancedot */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_continuous_state.h:156
            const char* doc =
R"""(Fluent setter that matches stancedot(). Returns a copy of ``this``
with stancedot set to a new value.)""";
          } with_stancedot;
          // Symbol: drake::examples::compass_gait::CompassGaitContinuousState::with_swing
          struct /* with_swing */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_continuous_state.h:138
            const char* doc =
R"""(Fluent setter that matches swing(). Returns a copy of ``this`` with
swing set to a new value.)""";
          } with_swing;
          // Symbol: drake::examples::compass_gait::CompassGaitContinuousState::with_swingdot
          struct /* with_swingdot */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_continuous_state.h:175
            const char* doc =
R"""(Fluent setter that matches swingdot(). Returns a copy of ``this`` with
swingdot set to a new value.)""";
          } with_swingdot;
        } CompassGaitContinuousState;
        // Symbol: drake::examples::compass_gait::CompassGaitContinuousStateIndices
        struct /* CompassGaitContinuousStateIndices */ {
          // Source: drake/examples/compass_gait/gen/compass_gait_continuous_state.h:27
          const char* doc =
R"""(Describes the row indices of a CompassGaitContinuousState.)""";
          // Symbol: drake::examples::compass_gait::CompassGaitContinuousStateIndices::GetCoordinateNames
          struct /* GetCoordinateNames */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_continuous_state.h:42
            const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words,
``CompassGaitContinuousStateIndices::GetCoordinateNames()[i]`` is the
name for ``BasicVector::GetAtIndex(i)``.)""";
          } GetCoordinateNames;
        } CompassGaitContinuousStateIndices;
        // Symbol: drake::examples::compass_gait::CompassGaitGeometry
        struct /* CompassGaitGeometry */ {
          // Source: drake/examples/compass_gait/compass_gait_geometry.h:24
          const char* doc =
R"""(Expresses a CompassGait's geometry to a SceneGraph.

.. pydrake_system::

    name: CompassGaitGeometry
    input_ports:
    - floating_base_state
    output_ports:
    - geometry_pose

This class has no public constructor; instead use the AddToBuilder()
static method to create and add it to a DiagramBuilder directly.)""";
          // Symbol: drake::examples::compass_gait::CompassGaitGeometry::AddToBuilder
          struct /* AddToBuilder */ {
            // Source: drake/examples/compass_gait/compass_gait_geometry.h:40
            const char* doc_4args =
R"""(Creates, adds, and connects a CompassGaitGeometry system into the
given ``builder``. Both the ``floating_base_state_port.get_system()``
and ``scene_graph`` systems must have been added to the given
``builder`` already. The ``compass_gait_params`` sets the parameters
of the geometry registered with ``scene_graph``; the visualization
changes based on the leg length and the ration of leg mass to hip mass
(the leg mass sphere is scaled assuming a constant density).

The ``scene_graph`` pointer is not retained by the CompassGaitGeometry
system. The return value pointer is an alias of the new
CompassGaitGeometry system that is owned by the ``builder``.)""";
            // Source: drake/examples/compass_gait/compass_gait_geometry.h:54
            const char* doc_3args =
R"""(Creates, adds, and connects a CompassGaitGeometry system into the
given ``builder``. Both the ``floating_base_state_port.get_system()``
and ``scene_graph`` systems must have been added to the given
``builder`` already. CompassGaitParams are set to their default
values.

The ``scene_graph`` pointer is not retained by the CompassGaitGeometry
system. The return value pointer is an alias of the new
CompassGaitGeometry system that is owned by the ``builder``.)""";
          } AddToBuilder;
          // Symbol: drake::examples::compass_gait::CompassGaitGeometry::CompassGaitGeometry
          struct /* ctor */ {
            // Source: drake/examples/compass_gait/compass_gait_geometry.h:26
            const char* doc = R"""()""";
          } ctor;
        } CompassGaitGeometry;
        // Symbol: drake::examples::compass_gait::CompassGaitParams
        struct /* CompassGaitParams */ {
          // Source: drake/examples/compass_gait/gen/compass_gait_params.h:48
          const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";
          // Symbol: drake::examples::compass_gait::CompassGaitParams::CompassGaitParams<T>
          struct /* ctor */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_params.h:60
            const char* doc =
R"""(Default constructor. Sets all rows to their default value:

* ``mass_hip`` defaults to 10.0 kg.

* ``mass_leg`` defaults to 5.0 kg.

* ``length_leg`` defaults to 1.0 m.

* ``center_of_mass_leg`` defaults to 0.5 m.

* ``gravity`` defaults to 9.81 m/s^2.

* ``slope`` defaults to 0.0525 radians.)""";
          } ctor;
          // Symbol: drake::examples::compass_gait::CompassGaitParams::DoClone
          struct /* DoClone */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_params.h:102
            const char* doc = R"""()""";
          } DoClone;
          // Symbol: drake::examples::compass_gait::CompassGaitParams::GetCoordinateNames
          struct /* GetCoordinateNames */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_params.h:249
            const char* doc =
R"""(See CompassGaitParamsIndices::GetCoordinateNames().)""";
          } GetCoordinateNames;
          // Symbol: drake::examples::compass_gait::CompassGaitParams::GetElementBounds
          struct /* GetElementBounds */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_params.h:273
            const char* doc = R"""()""";
          } GetElementBounds;
          // Symbol: drake::examples::compass_gait::CompassGaitParams::IsValid
          struct /* IsValid */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_params.h:254
            const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";
          } IsValid;
          // Symbol: drake::examples::compass_gait::CompassGaitParams::K
          struct /* K */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_params.h:51
            const char* doc =
R"""(An abbreviation for our row index constants.)""";
          } K;
          // Symbol: drake::examples::compass_gait::CompassGaitParams::Serialize
          struct /* Serialize */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_params.h:232
            const char* doc =
R"""(Visit each field of this named vector, passing them (in order) to the
given Archive. The archive can read and/or write to the vector values.
One common use of Serialize is the //common/yaml tools.)""";
          } Serialize;
          // Symbol: drake::examples::compass_gait::CompassGaitParams::SetToNamedVariables
          struct /* SetToNamedVariables */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_params.h:93
            const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";
          } SetToNamedVariables;
          // Symbol: drake::examples::compass_gait::CompassGaitParams::center_of_mass_leg
          struct /* center_of_mass_leg */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_params.h:169
            const char* doc =
R"""(Distance from the hip to the center of mass of each leg.

Note:
    ``center_of_mass_leg`` is expressed in units of m.

Note:
    ``center_of_mass_leg`` has a limited domain of [0.0, +Inf].)""";
          } center_of_mass_leg;
          // Symbol: drake::examples::compass_gait::CompassGaitParams::gravity
          struct /* gravity */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_params.h:189
            const char* doc =
R"""(An approximate value for gravitational acceleration.

Note:
    ``gravity`` is expressed in units of m/s^2.

Note:
    ``gravity`` has a limited domain of [0.0, +Inf].)""";
          } gravity;
          // Symbol: drake::examples::compass_gait::CompassGaitParams::length_leg
          struct /* length_leg */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_params.h:149
            const char* doc =
R"""(The length of each leg.

Note:
    ``length_leg`` is expressed in units of m.

Note:
    ``length_leg`` has a limited domain of [0.0, +Inf].)""";
          } length_leg;
          // Symbol: drake::examples::compass_gait::CompassGaitParams::mass_hip
          struct /* mass_hip */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_params.h:111
            const char* doc =
R"""(Point mass at the hip.

Note:
    ``mass_hip`` is expressed in units of kg.

Note:
    ``mass_hip`` has a limited domain of [0.0, +Inf].)""";
          } mass_hip;
          // Symbol: drake::examples::compass_gait::CompassGaitParams::mass_leg
          struct /* mass_leg */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_params.h:130
            const char* doc =
R"""(Mass of each leg (modeled as a point mass at the center of mass).

Note:
    ``mass_leg`` is expressed in units of kg.

Note:
    ``mass_leg`` has a limited domain of [0.0, +Inf].)""";
          } mass_leg;
          // Symbol: drake::examples::compass_gait::CompassGaitParams::set_center_of_mass_leg
          struct /* set_center_of_mass_leg */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_params.h:174
            const char* doc =
R"""(Setter that matches center_of_mass_leg().)""";
          } set_center_of_mass_leg;
          // Symbol: drake::examples::compass_gait::CompassGaitParams::set_gravity
          struct /* set_gravity */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_params.h:194
            const char* doc = R"""(Setter that matches gravity().)""";
          } set_gravity;
          // Symbol: drake::examples::compass_gait::CompassGaitParams::set_length_leg
          struct /* set_length_leg */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_params.h:154
            const char* doc = R"""(Setter that matches length_leg().)""";
          } set_length_leg;
          // Symbol: drake::examples::compass_gait::CompassGaitParams::set_mass_hip
          struct /* set_mass_hip */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_params.h:116
            const char* doc = R"""(Setter that matches mass_hip().)""";
          } set_mass_hip;
          // Symbol: drake::examples::compass_gait::CompassGaitParams::set_mass_leg
          struct /* set_mass_leg */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_params.h:135
            const char* doc = R"""(Setter that matches mass_leg().)""";
          } set_mass_leg;
          // Symbol: drake::examples::compass_gait::CompassGaitParams::set_slope
          struct /* set_slope */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_params.h:215
            const char* doc = R"""(Setter that matches slope().)""";
          } set_slope;
          // Symbol: drake::examples::compass_gait::CompassGaitParams::slope
          struct /* slope */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_params.h:210
            const char* doc =
R"""(The angle of the ramp on which the compass gait is walking. Must have
0 <= slope < PI/2 so that forward == downhill (an assumption used in
the foot collision witness function).

Note:
    ``slope`` is expressed in units of radians.

Note:
    ``slope`` has a limited domain of [0.0, 1.5707].)""";
          } slope;
          // Symbol: drake::examples::compass_gait::CompassGaitParams::with_center_of_mass_leg
          struct /* with_center_of_mass_leg */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_params.h:180
            const char* doc =
R"""(Fluent setter that matches center_of_mass_leg(). Returns a copy of
``this`` with center_of_mass_leg set to a new value.)""";
          } with_center_of_mass_leg;
          // Symbol: drake::examples::compass_gait::CompassGaitParams::with_gravity
          struct /* with_gravity */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_params.h:200
            const char* doc =
R"""(Fluent setter that matches gravity(). Returns a copy of ``this`` with
gravity set to a new value.)""";
          } with_gravity;
          // Symbol: drake::examples::compass_gait::CompassGaitParams::with_length_leg
          struct /* with_length_leg */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_params.h:160
            const char* doc =
R"""(Fluent setter that matches length_leg(). Returns a copy of ``this``
with length_leg set to a new value.)""";
          } with_length_leg;
          // Symbol: drake::examples::compass_gait::CompassGaitParams::with_mass_hip
          struct /* with_mass_hip */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_params.h:122
            const char* doc =
R"""(Fluent setter that matches mass_hip(). Returns a copy of ``this`` with
mass_hip set to a new value.)""";
          } with_mass_hip;
          // Symbol: drake::examples::compass_gait::CompassGaitParams::with_mass_leg
          struct /* with_mass_leg */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_params.h:141
            const char* doc =
R"""(Fluent setter that matches mass_leg(). Returns a copy of ``this`` with
mass_leg set to a new value.)""";
          } with_mass_leg;
          // Symbol: drake::examples::compass_gait::CompassGaitParams::with_slope
          struct /* with_slope */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_params.h:221
            const char* doc =
R"""(Fluent setter that matches slope(). Returns a copy of ``this`` with
slope set to a new value.)""";
          } with_slope;
        } CompassGaitParams;
        // Symbol: drake::examples::compass_gait::CompassGaitParamsIndices
        struct /* CompassGaitParamsIndices */ {
          // Source: drake/examples/compass_gait/gen/compass_gait_params.h:27
          const char* doc =
R"""(Describes the row indices of a CompassGaitParams.)""";
          // Symbol: drake::examples::compass_gait::CompassGaitParamsIndices::GetCoordinateNames
          struct /* GetCoordinateNames */ {
            // Source: drake/examples/compass_gait/gen/compass_gait_params.h:43
            const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words,
``CompassGaitParamsIndices::GetCoordinateNames()[i]`` is the name for
``BasicVector::GetAtIndex(i)``.)""";
          } GetCoordinateNames;
        } CompassGaitParamsIndices;
      } compass_gait;
      // Symbol: drake::examples::manipulation_station
      struct /* manipulation_station */ {
        // Symbol: drake::examples::manipulation_station::IiwaCollisionModel
        struct /* IiwaCollisionModel */ {
          // Source: drake/examples/manipulation_station/manipulation_station.h:22
          const char* doc =
R"""(Determines which sdf is loaded for the IIWA in the
ManipulationStation.)""";
          // Symbol: drake::examples::manipulation_station::IiwaCollisionModel::kBoxCollision
          struct /* kBoxCollision */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:22
            const char* doc = R"""()""";
          } kBoxCollision;
          // Symbol: drake::examples::manipulation_station::IiwaCollisionModel::kNoCollision
          struct /* kNoCollision */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:22
            const char* doc = R"""()""";
          } kNoCollision;
        } IiwaCollisionModel;
        // Symbol: drake::examples::manipulation_station::ManipulationStation
        struct /* ManipulationStation */ {
          // Source: drake/examples/manipulation_station/manipulation_station.h:139
          const char* doc =
R"""(A system that represents the complete manipulation station, including
exactly one robotic arm (a Kuka IIWA LWR), one gripper (a Schunk WSG
50), and anything a user might want to load into the model.
SetupDefaultStation() provides the setup that is used in the MIT
Intelligent Robot Manipulation class, which includes the supporting
structure for IIWA and several RGBD cameras. Alternative Setup___()
methods are provided, as well.

.. pydrake_system::

    name: ManipulationStation
    input_ports:
    - iiwa_position
    - iiwa_feedforward_torque (optional)
    - wsg_position
    - wsg_force_limit (optional)
    output_ports:
    - iiwa_position_commanded
    - iiwa_position_measured
    - iiwa_velocity_estimated
    - iiwa_state_estimated
    - iiwa_torque_commanded
    - iiwa_torque_measured
    - iiwa_torque_external
    - wsg_state_measured
    - wsg_force_measured
    - camera_[NAME]_rgb_image
    - camera_[NAME]_depth_image
    - <b style="color:orange">camera_[NAME]_label_image</b>
    - ...
    - camera_[NAME]_rgb_image
    - camera_[NAME]_depth_image
    - <b style="color:orange">camera_[NAME]_label_image</b>
    - <b style="color:orange">pose_bundle</b>
    - <b style="color:orange">query_object</b>
    - <b style="color:orange">contact_results</b>
    - <b style="color:orange">plant_continuous_state</b>
    - <b style="color:orange">geometry_poses</b>

Each pixel in the output image from ``depth_image`` is a 16bit
unsigned short in millimeters.

Note that outputs in <b style="color:orange">orange</b> are available
in the simulation, but not on the real robot. The distinction between
q_measured and v_estimated is because the Kuka FRI reports positions
directly, but we have estimated v in our code that wraps the FRI.

Consider the robot dynamics M(q)vdot + C(q,v)v = τ_g(q) + τ_commanded
+ τ_joint_friction + τ_external, where q == position, v == velocity,
and τ == torque.

This model of the IIWA internal controller in the FRI software's
``JointImpedanceControlMode`` is:


::

    τ_commanded = Mₑ(qₑ)vdot_desired + Cₑ(qₑ, vₑ)vₑ - τₑ_g(q) -
                    τₑ_joint_friction + τ_feedforward
      vdot_desired = PID(q_commanded, qₑ, v_commanded, vₑ)

where Mₑ, Cₑ, τₑ_g, and τₑ_friction terms are now (Kuka's) estimates
of the true model, qₑ and vₑ are measured/estimation, and v_commanded
must be obtained from an online (causal) derivative of q_commanded.
The result is


::

    M(q)vdot ≈ Mₑ(q)vdot_desired + τ_feedforward + τ_external,

where the "approximately equal" comes from the differences due to the
estimated model/state.

The model implemented in this System assumes that M, C, and τ_friction
terms are perfect (except that they contain only a lumped mass
approximation of the gripper), and that the measured signals are
noise/bias free (e.g. q_measured = q, v_estimated = v, τ_measured =
τ_commanded). What remains for τ_external is the generalized forces
due to contact (note that they could also include the missing
contributions from the gripper fingers, which the controller assumes
are welded).

See also:
    lcmt_iiwa_status.lcm for additional details/documentation.

To add objects into the environment for the robot to manipulate, use,
e.g.:


::

    ManipulationStation<double> station;
    Parser parser(&station.get_mutable_multibody_plant(),
                   &station.get_mutable_scene_graph());
    parser.AddModelFromFile("my.sdf", "my_model");
    ...
    // coming soon -- sugar API for adding additional objects.
    station.Finalize()

Note that you *must* call Finalize() before you can use this class as
a System.)""";
          // Symbol: drake::examples::manipulation_station::ManipulationStation::AddManipulandFromFile
          struct /* AddManipulandFromFile */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:314
            const char* doc =
R"""(Adds a single object for the robot to manipulate

Note:
    Must be called before Finalize().

Parameter ``model_file``:
    The path to the .sdf model file of the object.

Parameter ``X_WObject``:
    The pose of the object in world frame.)""";
          } AddManipulandFromFile;
          // Symbol: drake::examples::manipulation_station::ManipulationStation::Finalize
          struct /* Finalize */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:328
            const char* doc_0args =
R"""(Users *must* call Finalize() after making any additions to the
multibody plant and before using this class in the Systems framework.
This should be called exactly once. This assumes an IIWA and WSG have
been added to the MultibodyPlant, and RegisterIiwaControllerModel()
and RegisterWsgControllerModel() have been called.

See also:
    multibody::MultibodyPlant<T>::Finalize())""";
            // Source: drake/examples/manipulation_station/manipulation_station.h:333
            const char* doc_1args =
R"""(Finalizes the station with the option of specifying the renderers the
manipulation station uses. Calling this method with an empty map is
equivalent to calling Finalize(). See Finalize() for more details.)""";
          } Finalize;
          // Symbol: drake::examples::manipulation_station::ManipulationStation::GetIiwaPosition
          struct /* GetIiwaPosition */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:381
            const char* doc =
R"""(Convenience method for getting all of the joint angles of the Kuka
IIWA. This does not include the gripper.)""";
          } GetIiwaPosition;
          // Symbol: drake::examples::manipulation_station::ManipulationStation::GetIiwaVelocity
          struct /* GetIiwaVelocity */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:402
            const char* doc =
R"""(Convenience method for getting all of the joint velocities of the Kuka)""";
          } GetIiwaVelocity;
          // Symbol: drake::examples::manipulation_station::ManipulationStation::GetStaticCameraPosesInWorld
          struct /* GetStaticCameraPosesInWorld */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:458
            const char* doc =
R"""(Returns a map from camera name to X_WCameraBody for all the static
(rigidly attached to the world body) cameras that have been
registered.)""";
          } GetStaticCameraPosesInWorld;
          // Symbol: drake::examples::manipulation_station::ManipulationStation::GetWsgPosition
          struct /* GetWsgPosition */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:422
            const char* doc =
R"""(Convenience method for getting the position of the Schunk WSG. Note
that the WSG position is the signed distance between the two fingers
(not the state of the fingers individually).)""";
          } GetWsgPosition;
          // Symbol: drake::examples::manipulation_station::ManipulationStation::GetWsgVelocity
          struct /* GetWsgVelocity */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:425
            const char* doc =
R"""(Convenience method for getting the velocity of the Schunk WSG.)""";
          } GetWsgVelocity;
          // Symbol: drake::examples::manipulation_station::ManipulationStation::ManipulationStation<T>
          struct /* ctor */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:148
            const char* doc =
R"""(Construct the EMPTY station model.

Parameter ``time_step``:
    The time step used by MultibodyPlant<T>, and by the discrete
    derivative used to approximate velocity from the position command
    inputs.)""";
          } ctor;
          // Symbol: drake::examples::manipulation_station::ManipulationStation::RegisterIiwaControllerModel
          struct /* RegisterIiwaControllerModel */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:228
            const char* doc = R"""()""";
          } RegisterIiwaControllerModel;
          // Symbol: drake::examples::manipulation_station::ManipulationStation::RegisterRgbdSensor
          struct /* RegisterRgbdSensor */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:278
            const char* doc_single_properties =
R"""(Registers an RGBD sensor. Must be called before Finalize().

Parameter ``name``:
    Name for the camera.

Parameter ``parent_frame``:
    The parent frame (frame P). The body that ``parent_frame`` is
    attached to must have a corresponding geometry::FrameId.
    Otherwise, an exception will be thrown in Finalize().

Parameter ``X_PCameraBody``:
    Transformation between frame P and the camera body. see
    systems::sensors:::RgbdSensor for descriptions about how the
    camera body, RGB, and depth image frames are related.

Parameter ``properties``:
    Properties for the RGBD camera.
     (Deprecated.)

Deprecated:
    CameraProperties are being deprecated. Please use the
    DepthRenderCamera variant. This will be removed from Drake on or
    after 2021-04-01.)""";
            // Source: drake/examples/manipulation_station/manipulation_station.h:296
            const char* doc_single_camera =
R"""(Registers an RGBD sensor. Must be called before Finalize().

Parameter ``name``:
    Name for the camera.

Parameter ``parent_frame``:
    The parent frame (frame P). The body that ``parent_frame`` is
    attached to must have a corresponding geometry::FrameId.
    Otherwise, an exception will be thrown in Finalize().

Parameter ``X_PCameraBody``:
    Transformation between frame P and the camera body. see
    systems::sensors:::RgbdSensor for descriptions about how the
    camera body, RGB, and depth image frames are related.

Parameter ``depth_camera``:
    Specification for the RGBD camera. The color render camera is
    inferred from the depth_camera. The color camera will share the
    RenderCameraCore and be configured to *not* show its window.)""";
            // Source: drake/examples/manipulation_station/manipulation_station.h:304
            const char* doc_dual_camera =
R"""(Registers an RGBD sensor with uniquely characterized color/label and
depth cameras.)""";
          } RegisterRgbdSensor;
          // Symbol: drake::examples::manipulation_station::ManipulationStation::RegisterWsgControllerModel
          struct /* RegisterWsgControllerModel */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:256
            const char* doc = R"""()""";
          } RegisterWsgControllerModel;
          // Symbol: drake::examples::manipulation_station::ManipulationStation::SetDefaultState
          struct /* SetDefaultState */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:192
            const char* doc =
R"""(Sets the default State for the chosen setup.

Parameter ``context``:
    A const reference to the ManipulationStation context.

Parameter ``state``:
    A pointer to the State of the ManipulationStation system.

Precondition:
    ``state`` must be the systems::State<T> object contained in
    ``station_context``.)""";
          } SetDefaultState;
          // Symbol: drake::examples::manipulation_station::ManipulationStation::SetIiwaIntegralGains
          struct /* SetIiwaIntegralGains */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:483
            const char* doc =
R"""(Set the integral gains for the IIWA controller.

Raises:
    exception if Finalize() has been called.)""";
          } SetIiwaIntegralGains;
          // Symbol: drake::examples::manipulation_station::ManipulationStation::SetIiwaPosition
          struct /* SetIiwaPosition */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:388
            const char* doc_3args =
R"""(Convenience method for setting all of the joint angles of the Kuka
IIWA. Also sets the position history in the velocity command
generator. ``q`` must have size num_iiwa_joints().

Precondition:
    ``state`` must be the systems::State<T> object contained in
    ``station_context``.)""";
            // Source: drake/examples/manipulation_station/manipulation_station.h:395
            const char* doc_2args =
R"""(Convenience method for setting all of the joint angles of the Kuka
IIWA. Also sets the position history in the velocity command
generator. ``q`` must have size num_iiwa_joints().)""";
          } SetIiwaPosition;
          // Symbol: drake::examples::manipulation_station::ManipulationStation::SetIiwaPositionGains
          struct /* SetIiwaPositionGains */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:469
            const char* doc =
R"""(Set the position gains for the IIWA controller.

Raises:
    exception if Finalize() has been called.)""";
          } SetIiwaPositionGains;
          // Symbol: drake::examples::manipulation_station::ManipulationStation::SetIiwaVelocity
          struct /* SetIiwaVelocity */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:408
            const char* doc_3args =
R"""(Convenience method for setting all of the joint velocities of the Kuka
IIWA. @v must have size num_iiwa_joints().

Precondition:
    ``state`` must be the systems::State<T> object contained in
    ``station_context``.)""";
            // Source: drake/examples/manipulation_station/manipulation_station.h:414
            const char* doc_2args =
R"""(Convenience method for setting all of the joint velocities of the Kuka
IIWA. @v must have size num_iiwa_joints().)""";
          } SetIiwaVelocity;
          // Symbol: drake::examples::manipulation_station::ManipulationStation::SetIiwaVelocityGains
          struct /* SetIiwaVelocityGains */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:476
            const char* doc =
R"""(Set the velocity gains for the IIWA controller.

Raises:
    exception if Finalize() has been called.)""";
          } SetIiwaVelocityGains;
          // Symbol: drake::examples::manipulation_station::ManipulationStation::SetRandomState
          struct /* SetRandomState */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:201
            const char* doc =
R"""(Sets a random State for the chosen setup.

Parameter ``context``:
    A const reference to the ManipulationStation context.

Parameter ``state``:
    A pointer to the State of the ManipulationStation system.

Parameter ``generator``:
    is the random number generator.

Precondition:
    ``state`` must be the systems::State<T> object contained in
    ``station_context``.)""";
          } SetRandomState;
          // Symbol: drake::examples::manipulation_station::ManipulationStation::SetWsgGains
          struct /* SetWsgGains */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:465
            const char* doc =
R"""(Set the gains for the WSG controller.

Raises:
    exception if Finalize() has been called.)""";
          } SetWsgGains;
          // Symbol: drake::examples::manipulation_station::ManipulationStation::SetWsgPosition
          struct /* SetWsgPosition */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:433
            const char* doc_3args =
R"""(Convenience method for setting the position of the Schunk WSG. Also
sets the position history in the velocity interpolator. Note that the
WSG position is the signed distance between the two fingers (not the
state of the fingers individually).

Precondition:
    ``state`` must be the systems::State<T> object contained in
    ``station_context``.)""";
            // Source: drake/examples/manipulation_station/manipulation_station.h:440
            const char* doc_2args =
R"""(Convenience method for setting the position of the Schunk WSG. Also
sets the position history in the velocity interpolator. Note that the
WSG position is the signed distance between the two fingers (not the
state of the fingers individually).)""";
          } SetWsgPosition;
          // Symbol: drake::examples::manipulation_station::ManipulationStation::SetWsgVelocity
          struct /* SetWsgVelocity */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:447
            const char* doc_3args =
R"""(Convenience method for setting the velocity of the Schunk WSG.

Precondition:
    ``state`` must be the systems::State<T> object contained in
    ``station_context``.)""";
            // Source: drake/examples/manipulation_station/manipulation_station.h:451
            const char* doc_2args =
R"""(Convenience method for setting the velocity of the Schunk WSG.)""";
          } SetWsgVelocity;
          // Symbol: drake::examples::manipulation_station::ManipulationStation::SetupClutterClearingStation
          struct /* SetupClutterClearingStation */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:158
            const char* doc =
R"""(Adds a default iiwa, wsg, two bins, and a camera, then calls
RegisterIiwaControllerModel() and RegisterWsgControllerModel() with
the appropriate arguments.

Note:
    Must be called before Finalize().

Note:
    Only one of the ``Setup___()`` methods should be called.

Parameter ``X_WCameraBody``:
    Transformation between the world and the camera body.

Parameter ``collision_model``:
    Determines which sdf is loaded for the IIWA.

Parameter ``schunk_model``:
    Determines which sdf is loaded for the Schunk.)""";
          } SetupClutterClearingStation;
          // Symbol: drake::examples::manipulation_station::ManipulationStation::SetupManipulationClassStation
          struct /* SetupManipulationClassStation */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:171
            const char* doc =
R"""(Adds a default iiwa, wsg, cupboard, and 80/20 frame for the MIT
Intelligent Robot Manipulation class, then calls
RegisterIiwaControllerModel() and RegisterWsgControllerModel() with
the appropriate arguments.

Note:
    Must be called before Finalize().

Note:
    Only one of the ``Setup___()`` methods should be called.

Parameter ``collision_model``:
    Determines which sdf is loaded for the IIWA.

Parameter ``schunk_model``:
    Determines which sdf is loaded for the Schunk.)""";
          } SetupManipulationClassStation;
          // Symbol: drake::examples::manipulation_station::ManipulationStation::SetupPlanarIiwaStation
          struct /* SetupPlanarIiwaStation */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:184
            const char* doc =
R"""(Adds a version of the iiwa with joints that would result in
out-of-plane rotations welded in a fixed orientation, reducing the
total degrees of freedom of the arm to 3. This arm lives in the X-Z
plane. Also adds the WSG planar gripper and two tables to form the
workspace. Note that additional floating base objects (aka
manipulands) will still potentially move in 3D.

Note:
    Must be called before Finalize().

Note:
    Only one of the ``Setup___()`` methods should be called.

Parameter ``schunk_model``:
    Determines which sdf is loaded for the Schunk.)""";
          } SetupPlanarIiwaStation;
          // Symbol: drake::examples::manipulation_station::ManipulationStation::default_renderer_name
          struct /* default_renderer_name */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:364
            const char* doc =
R"""(Returns the name of the station's default renderer.)""";
          } default_renderer_name;
          // Symbol: drake::examples::manipulation_station::ManipulationStation::get_camera_names
          struct /* get_camera_names */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:461
            const char* doc = R"""(Get the camera names / unique ids.)""";
          } get_camera_names;
          // Symbol: drake::examples::manipulation_station::ManipulationStation::get_controller_plant
          struct /* get_controller_plant */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:369
            const char* doc =
R"""(Return a reference to the plant used by the inverse dynamics
controller (which contains only a model of the iiwa + equivalent mass
of the gripper).)""";
          } get_controller_plant;
          // Symbol: drake::examples::manipulation_station::ManipulationStation::get_multibody_plant
          struct /* get_multibody_plant */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:340
            const char* doc =
R"""(Returns a reference to the main plant responsible for the dynamics of
the robot and the environment. This can be used to, e.g., add
additional elements into the world before calling Finalize().)""";
          } get_multibody_plant;
          // Symbol: drake::examples::manipulation_station::ManipulationStation::get_mutable_multibody_plant
          struct /* get_mutable_multibody_plant */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:347
            const char* doc =
R"""(Returns a mutable reference to the main plant responsible for the
dynamics of the robot and the environment. This can be used to, e.g.,
add additional elements into the world before calling Finalize().)""";
          } get_mutable_multibody_plant;
          // Symbol: drake::examples::manipulation_station::ManipulationStation::get_mutable_scene_graph
          struct /* get_mutable_scene_graph */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:361
            const char* doc =
R"""(Returns a mutable reference to the SceneGraph responsible for all of
the geometry for the robot and the environment. This can be used to,
e.g., add additional elements into the world before calling
Finalize().)""";
          } get_mutable_scene_graph;
          // Symbol: drake::examples::manipulation_station::ManipulationStation::get_scene_graph
          struct /* get_scene_graph */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:354
            const char* doc =
R"""(Returns a reference to the SceneGraph responsible for all of the
geometry for the robot and the environment. This can be used to, e.g.,
add additional elements into the world before calling Finalize().)""";
          } get_scene_graph;
          // Symbol: drake::examples::manipulation_station::ManipulationStation::num_iiwa_joints
          struct /* num_iiwa_joints */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:377
            const char* doc =
R"""(Gets the number of joints in the IIWA (only -- does not include the
gripper).

Precondition:
    must call one of the "setup" methods first to register an IIWA
    model.)""";
          } num_iiwa_joints;
        } ManipulationStation;
        // Symbol: drake::examples::manipulation_station::ManipulationStationHardwareInterface
        struct /* ManipulationStationHardwareInterface */ {
          // Source: drake/examples/manipulation_station/manipulation_station_hardware_interface.h:50
          const char* doc =
R"""(A System that connects via message-passing to the hardware
manipulation station.

Note: Users must call Connect() after initialization.

.. pydrake_system::

    name: ManipulationStationHardwareInterface
    input_ports:
    - iiwa_position
    - iiwa_feedforward_torque
    - wsg_position
    - wsg_force_limit (optional)
    output_ports:
    - iiwa_position_commanded
    - iiwa_position_measured
    - iiwa_velocity_estimated
    - iiwa_torque_commanded
    - iiwa_torque_measured
    - iiwa_torque_external
    - wsg_state_measured
    - wsg_force_measured
    - camera_[NAME]_rgb_image
    - camera_[NAME]_depth_image
    - ...
    - camera_[NAME]_rgb_image
    - camera_[NAME]_depth_image)""";
          // Symbol: drake::examples::manipulation_station::ManipulationStationHardwareInterface::Connect
          struct /* Connect */ {
            // Source: drake/examples/manipulation_station/manipulation_station_hardware_interface.h:64
            const char* doc =
R"""(Starts a thread to receive network messages, and blocks execution
until the first messages have been received.)""";
          } Connect;
          // Symbol: drake::examples::manipulation_station::ManipulationStationHardwareInterface::ManipulationStationHardwareInterface
          struct /* ctor */ {
            // Source: drake/examples/manipulation_station/manipulation_station_hardware_interface.h:59
            const char* doc =
R"""(Subscribes to an incoming camera message on the channel
DRAKE_RGBD_CAMERA_IMAGES_<camera_id> where ``camera_name`` contains
the names/unique ids, typically serial numbers, and declares the
output ports camera_%s_rgb_image and camera_%s_depth_image, where s is
the camera name.)""";
          } ctor;
          // Symbol: drake::examples::manipulation_station::ManipulationStationHardwareInterface::get_camera_names
          struct /* get_camera_names */ {
            // Source: drake/examples/manipulation_station/manipulation_station_hardware_interface.h:74
            const char* doc = R"""()""";
          } get_camera_names;
          // Symbol: drake::examples::manipulation_station::ManipulationStationHardwareInterface::get_controller_plant
          struct /* get_controller_plant */ {
            // Source: drake/examples/manipulation_station/manipulation_station_hardware_interface.h:70
            const char* doc =
R"""(For parity with ManipulationStation, we maintain a MultibodyPlant of
the IIWA arm, with the lumped-mass equivalent spatial inertia of the
Schunk WSG gripper.)""";
          } get_controller_plant;
          // Symbol: drake::examples::manipulation_station::ManipulationStationHardwareInterface::num_iiwa_joints
          struct /* num_iiwa_joints */ {
            // Source: drake/examples/manipulation_station/manipulation_station_hardware_interface.h:80
            const char* doc =
R"""(Gets the number of joints in the IIWA (only -- does not include the
gripper).)""";
          } num_iiwa_joints;
        } ManipulationStationHardwareInterface;
        // Symbol: drake::examples::manipulation_station::SchunkCollisionModel
        struct /* SchunkCollisionModel */ {
          // Source: drake/examples/manipulation_station/manipulation_station.h:30
          const char* doc =
R"""(Determines which schunk model is used for the ManipulationStation. -
kBox loads a model with a box collision geometry. This model is for
those who want simplified collision behavior. -
kBoxPlusFingertipSpheres loads a Schunk model with collision spheres
that models the indentations at tip of the fingers, in addition to the
box collision geometry on the fingers.)""";
          // Symbol: drake::examples::manipulation_station::SchunkCollisionModel::kBox
          struct /* kBox */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:30
            const char* doc = R"""()""";
          } kBox;
          // Symbol: drake::examples::manipulation_station::SchunkCollisionModel::kBoxPlusFingertipSpheres
          struct /* kBoxPlusFingertipSpheres */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:30
            const char* doc = R"""()""";
          } kBoxPlusFingertipSpheres;
        } SchunkCollisionModel;
        // Symbol: drake::examples::manipulation_station::Setup
        struct /* Setup */ {
          // Source: drake/examples/manipulation_station/manipulation_station.h:33
          const char* doc =
R"""(Determines which manipulation station is simulated.)""";
          // Symbol: drake::examples::manipulation_station::Setup::kClutterClearing
          struct /* kClutterClearing */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:33
            const char* doc = R"""()""";
          } kClutterClearing;
          // Symbol: drake::examples::manipulation_station::Setup::kManipulationClass
          struct /* kManipulationClass */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:33
            const char* doc = R"""()""";
          } kManipulationClass;
          // Symbol: drake::examples::manipulation_station::Setup::kNone
          struct /* kNone */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:33
            const char* doc = R"""()""";
          } kNone;
          // Symbol: drake::examples::manipulation_station::Setup::kPlanarIiwa
          struct /* kPlanarIiwa */ {
            // Source: drake/examples/manipulation_station/manipulation_station.h:33
            const char* doc = R"""()""";
          } kPlanarIiwa;
        } Setup;
      } manipulation_station;
      // Symbol: drake::examples::pendulum
      struct /* pendulum */ {
        // Symbol: drake::examples::pendulum::PendulumGeometry
        struct /* PendulumGeometry */ {
          // Source: drake/examples/pendulum/pendulum_geometry.h:23
          const char* doc =
R"""(Expresses a PendulumPlants's geometry to a SceneGraph.

.. pydrake_system::

    name: PendulumGeometry
    input_ports:
    - state
    output_ports:
    - geometry_pose

This class has no public constructor; instead use the AddToBuilder()
static method to create and add it to a DiagramBuilder directly.)""";
          // Symbol: drake::examples::pendulum::PendulumGeometry::AddToBuilder
          struct /* AddToBuilder */ {
            // Source: drake/examples/pendulum/pendulum_geometry.h:35
            const char* doc =
R"""(Creates, adds, and connects a PendulumGeometry system into the given
``builder``. Both the ``pendulum_state.get_system()`` and
``scene_graph`` systems must have been added to the given ``builder``
already.

The ``scene_graph`` pointer is not retained by the PendulumGeometry
system. The return value pointer is an alias of the new
PendulumGeometry system that is owned by the ``builder``.)""";
          } AddToBuilder;
          // Symbol: drake::examples::pendulum::PendulumGeometry::PendulumGeometry
          struct /* ctor */ {
            // Source: drake/examples/pendulum/pendulum_geometry.h:25
            const char* doc = R"""()""";
          } ctor;
        } PendulumGeometry;
        // Symbol: drake::examples::pendulum::PendulumInput
        struct /* PendulumInput */ {
          // Source: drake/examples/pendulum/gen/pendulum_input.h:43
          const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";
          // Symbol: drake::examples::pendulum::PendulumInput::DoClone
          struct /* DoClone */ {
            // Source: drake/examples/pendulum/gen/pendulum_input.h:82
            const char* doc = R"""()""";
          } DoClone;
          // Symbol: drake::examples::pendulum::PendulumInput::GetCoordinateNames
          struct /* GetCoordinateNames */ {
            // Source: drake/examples/pendulum/gen/pendulum_input.h:118
            const char* doc =
R"""(See PendulumInputIndices::GetCoordinateNames().)""";
          } GetCoordinateNames;
          // Symbol: drake::examples::pendulum::PendulumInput::IsValid
          struct /* IsValid */ {
            // Source: drake/examples/pendulum/gen/pendulum_input.h:123
            const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";
          } IsValid;
          // Symbol: drake::examples::pendulum::PendulumInput::K
          struct /* K */ {
            // Source: drake/examples/pendulum/gen/pendulum_input.h:46
            const char* doc =
R"""(An abbreviation for our row index constants.)""";
          } K;
          // Symbol: drake::examples::pendulum::PendulumInput::PendulumInput<T>
          struct /* ctor */ {
            // Source: drake/examples/pendulum/gen/pendulum_input.h:50
            const char* doc =
R"""(Default constructor. Sets all rows to their default value:

* ``tau`` defaults to 0.0 Newton-meters.)""";
          } ctor;
          // Symbol: drake::examples::pendulum::PendulumInput::Serialize
          struct /* Serialize */ {
            // Source: drake/examples/pendulum/gen/pendulum_input.h:112
            const char* doc =
R"""(Visit each field of this named vector, passing them (in order) to the
given Archive. The archive can read and/or write to the vector values.
One common use of Serialize is the //common/yaml tools.)""";
          } Serialize;
          // Symbol: drake::examples::pendulum::PendulumInput::SetToNamedVariables
          struct /* SetToNamedVariables */ {
            // Source: drake/examples/pendulum/gen/pendulum_input.h:78
            const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";
          } SetToNamedVariables;
          // Symbol: drake::examples::pendulum::PendulumInput::set_tau
          struct /* set_tau */ {
            // Source: drake/examples/pendulum/gen/pendulum_input.h:95
            const char* doc = R"""(Setter that matches tau().)""";
          } set_tau;
          // Symbol: drake::examples::pendulum::PendulumInput::tau
          struct /* tau */ {
            // Source: drake/examples/pendulum/gen/pendulum_input.h:90
            const char* doc =
R"""(Torque at the joint.

Note:
    ``tau`` is expressed in units of Newton-meters.)""";
          } tau;
          // Symbol: drake::examples::pendulum::PendulumInput::with_tau
          struct /* with_tau */ {
            // Source: drake/examples/pendulum/gen/pendulum_input.h:101
            const char* doc =
R"""(Fluent setter that matches tau(). Returns a copy of ``this`` with tau
set to a new value.)""";
          } with_tau;
        } PendulumInput;
        // Symbol: drake::examples::pendulum::PendulumInputIndices
        struct /* PendulumInputIndices */ {
          // Source: drake/examples/pendulum/gen/pendulum_input.h:27
          const char* doc =
R"""(Describes the row indices of a PendulumInput.)""";
          // Symbol: drake::examples::pendulum::PendulumInputIndices::GetCoordinateNames
          struct /* GetCoordinateNames */ {
            // Source: drake/examples/pendulum/gen/pendulum_input.h:38
            const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words,
``PendulumInputIndices::GetCoordinateNames()[i]`` is the name for
``BasicVector::GetAtIndex(i)``.)""";
          } GetCoordinateNames;
        } PendulumInputIndices;
        // Symbol: drake::examples::pendulum::PendulumParams
        struct /* PendulumParams */ {
          // Source: drake/examples/pendulum/gen/pendulum_params.h:46
          const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";
          // Symbol: drake::examples::pendulum::PendulumParams::DoClone
          struct /* DoClone */ {
            // Source: drake/examples/pendulum/gen/pendulum_params.h:94
            const char* doc = R"""()""";
          } DoClone;
          // Symbol: drake::examples::pendulum::PendulumParams::GetCoordinateNames
          struct /* GetCoordinateNames */ {
            // Source: drake/examples/pendulum/gen/pendulum_params.h:194
            const char* doc =
R"""(See PendulumParamsIndices::GetCoordinateNames().)""";
          } GetCoordinateNames;
          // Symbol: drake::examples::pendulum::PendulumParams::GetElementBounds
          struct /* GetElementBounds */ {
            // Source: drake/examples/pendulum/gen/pendulum_params.h:213
            const char* doc = R"""()""";
          } GetElementBounds;
          // Symbol: drake::examples::pendulum::PendulumParams::IsValid
          struct /* IsValid */ {
            // Source: drake/examples/pendulum/gen/pendulum_params.h:199
            const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";
          } IsValid;
          // Symbol: drake::examples::pendulum::PendulumParams::K
          struct /* K */ {
            // Source: drake/examples/pendulum/gen/pendulum_params.h:49
            const char* doc =
R"""(An abbreviation for our row index constants.)""";
          } K;
          // Symbol: drake::examples::pendulum::PendulumParams::PendulumParams<T>
          struct /* ctor */ {
            // Source: drake/examples/pendulum/gen/pendulum_params.h:56
            const char* doc =
R"""(Default constructor. Sets all rows to their default value:

* ``mass`` defaults to 1.0 kg.

* ``length`` defaults to 0.5 m.

* ``damping`` defaults to 0.1 kg m^2/s.

* ``gravity`` defaults to 9.81 m/s^2.)""";
          } ctor;
          // Symbol: drake::examples::pendulum::PendulumParams::Serialize
          struct /* Serialize */ {
            // Source: drake/examples/pendulum/gen/pendulum_params.h:182
            const char* doc =
R"""(Visit each field of this named vector, passing them (in order) to the
given Archive. The archive can read and/or write to the vector values.
One common use of Serialize is the //common/yaml tools.)""";
          } Serialize;
          // Symbol: drake::examples::pendulum::PendulumParams::SetToNamedVariables
          struct /* SetToNamedVariables */ {
            // Source: drake/examples/pendulum/gen/pendulum_params.h:87
            const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";
          } SetToNamedVariables;
          // Symbol: drake::examples::pendulum::PendulumParams::damping
          struct /* damping */ {
            // Source: drake/examples/pendulum/gen/pendulum_params.h:141
            const char* doc =
R"""(The damping friction coefficient relating angular velocity to torque.

Note:
    ``damping`` is expressed in units of kg m^2/s.

Note:
    ``damping`` has a limited domain of [0.0, +Inf].)""";
          } damping;
          // Symbol: drake::examples::pendulum::PendulumParams::gravity
          struct /* gravity */ {
            // Source: drake/examples/pendulum/gen/pendulum_params.h:160
            const char* doc =
R"""(An approximate value for gravitational acceleration.

Note:
    ``gravity`` is expressed in units of m/s^2.

Note:
    ``gravity`` has a limited domain of [0.0, +Inf].)""";
          } gravity;
          // Symbol: drake::examples::pendulum::PendulumParams::length
          struct /* length */ {
            // Source: drake/examples/pendulum/gen/pendulum_params.h:122
            const char* doc =
R"""(The length of the pendulum arm.

Note:
    ``length`` is expressed in units of m.

Note:
    ``length`` has a limited domain of [0.0, +Inf].)""";
          } length;
          // Symbol: drake::examples::pendulum::PendulumParams::mass
          struct /* mass */ {
            // Source: drake/examples/pendulum/gen/pendulum_params.h:103
            const char* doc =
R"""(The simple pendulum has a single point mass at the end of the arm.

Note:
    ``mass`` is expressed in units of kg.

Note:
    ``mass`` has a limited domain of [0.0, +Inf].)""";
          } mass;
          // Symbol: drake::examples::pendulum::PendulumParams::set_damping
          struct /* set_damping */ {
            // Source: drake/examples/pendulum/gen/pendulum_params.h:146
            const char* doc = R"""(Setter that matches damping().)""";
          } set_damping;
          // Symbol: drake::examples::pendulum::PendulumParams::set_gravity
          struct /* set_gravity */ {
            // Source: drake/examples/pendulum/gen/pendulum_params.h:165
            const char* doc = R"""(Setter that matches gravity().)""";
          } set_gravity;
          // Symbol: drake::examples::pendulum::PendulumParams::set_length
          struct /* set_length */ {
            // Source: drake/examples/pendulum/gen/pendulum_params.h:127
            const char* doc = R"""(Setter that matches length().)""";
          } set_length;
          // Symbol: drake::examples::pendulum::PendulumParams::set_mass
          struct /* set_mass */ {
            // Source: drake/examples/pendulum/gen/pendulum_params.h:108
            const char* doc = R"""(Setter that matches mass().)""";
          } set_mass;
          // Symbol: drake::examples::pendulum::PendulumParams::with_damping
          struct /* with_damping */ {
            // Source: drake/examples/pendulum/gen/pendulum_params.h:152
            const char* doc =
R"""(Fluent setter that matches damping(). Returns a copy of ``this`` with
damping set to a new value.)""";
          } with_damping;
          // Symbol: drake::examples::pendulum::PendulumParams::with_gravity
          struct /* with_gravity */ {
            // Source: drake/examples/pendulum/gen/pendulum_params.h:171
            const char* doc =
R"""(Fluent setter that matches gravity(). Returns a copy of ``this`` with
gravity set to a new value.)""";
          } with_gravity;
          // Symbol: drake::examples::pendulum::PendulumParams::with_length
          struct /* with_length */ {
            // Source: drake/examples/pendulum/gen/pendulum_params.h:133
            const char* doc =
R"""(Fluent setter that matches length(). Returns a copy of ``this`` with
length set to a new value.)""";
          } with_length;
          // Symbol: drake::examples::pendulum::PendulumParams::with_mass
          struct /* with_mass */ {
            // Source: drake/examples/pendulum/gen/pendulum_params.h:114
            const char* doc =
R"""(Fluent setter that matches mass(). Returns a copy of ``this`` with
mass set to a new value.)""";
          } with_mass;
        } PendulumParams;
        // Symbol: drake::examples::pendulum::PendulumParamsIndices
        struct /* PendulumParamsIndices */ {
          // Source: drake/examples/pendulum/gen/pendulum_params.h:27
          const char* doc =
R"""(Describes the row indices of a PendulumParams.)""";
          // Symbol: drake::examples::pendulum::PendulumParamsIndices::GetCoordinateNames
          struct /* GetCoordinateNames */ {
            // Source: drake/examples/pendulum/gen/pendulum_params.h:41
            const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words,
``PendulumParamsIndices::GetCoordinateNames()[i]`` is the name for
``BasicVector::GetAtIndex(i)``.)""";
          } GetCoordinateNames;
        } PendulumParamsIndices;
        // Symbol: drake::examples::pendulum::PendulumPlant
        struct /* PendulumPlant */ {
          // Source: drake/examples/pendulum/pendulum_plant.h:25
          const char* doc =
R"""(A model of a simple pendulum

.. math:: ml^2 \ddot\theta + b\dot\theta + mgl\sin\theta = \tau

.. pydrake_system::

name: PendulumPlant input_ports: - tau output_ports: - state)""";
          // Symbol: drake::examples::pendulum::PendulumPlant::CalcTotalEnergy
          struct /* CalcTotalEnergy */ {
            // Source: drake/examples/pendulum/pendulum_plant.h:42
            const char* doc =
R"""(Calculates the kinetic + potential energy.)""";
          } CalcTotalEnergy;
          // Symbol: drake::examples::pendulum::PendulumPlant::PendulumPlant<T>
          struct /* ctor */ {
            // Source: drake/examples/pendulum/pendulum_plant.h:30
            const char* doc = R"""(Constructs a default plant.)""";
            // Source: drake/examples/pendulum/pendulum_plant.h:34
            const char* doc_copyconvert =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";
          } ctor;
          // Symbol: drake::examples::pendulum::PendulumPlant::get_mutable_parameters
          struct /* get_mutable_parameters */ {
            // Source: drake/examples/pendulum/pendulum_plant.h:73
            const char* doc = R"""()""";
          } get_mutable_parameters;
          // Symbol: drake::examples::pendulum::PendulumPlant::get_mutable_state
          struct /* get_mutable_state */ {
            // Source: drake/examples/pendulum/pendulum_plant.h:59
            const char* doc = R"""()""";
          } get_mutable_state;
          // Symbol: drake::examples::pendulum::PendulumPlant::get_parameters
          struct /* get_parameters */ {
            // Source: drake/examples/pendulum/pendulum_plant.h:68
            const char* doc = R"""()""";
          } get_parameters;
          // Symbol: drake::examples::pendulum::PendulumPlant::get_state
          struct /* get_state */ {
            // Source: drake/examples/pendulum/pendulum_plant.h:50
            const char* doc = R"""()""";
          } get_state;
          // Symbol: drake::examples::pendulum::PendulumPlant::get_state_output_port
          struct /* get_state_output_port */ {
            // Source: drake/examples/pendulum/pendulum_plant.h:39
            const char* doc = R"""(Returns the port to output state.)""";
          } get_state_output_port;
          // Symbol: drake::examples::pendulum::PendulumPlant::get_tau
          struct /* get_tau */ {
            // Source: drake/examples/pendulum/pendulum_plant.h:46
            const char* doc =
R"""(Evaluates the input port and returns the scalar value of the commanded
torque.)""";
          } get_tau;
        } PendulumPlant;
        // Symbol: drake::examples::pendulum::PendulumState
        struct /* PendulumState */ {
          // Source: drake/examples/pendulum/gen/pendulum_state.h:44
          const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";
          // Symbol: drake::examples::pendulum::PendulumState::DoClone
          struct /* DoClone */ {
            // Source: drake/examples/pendulum/gen/pendulum_state.h:86
            const char* doc = R"""()""";
          } DoClone;
          // Symbol: drake::examples::pendulum::PendulumState::GetCoordinateNames
          struct /* GetCoordinateNames */ {
            // Source: drake/examples/pendulum/gen/pendulum_state.h:142
            const char* doc =
R"""(See PendulumStateIndices::GetCoordinateNames().)""";
          } GetCoordinateNames;
          // Symbol: drake::examples::pendulum::PendulumState::IsValid
          struct /* IsValid */ {
            // Source: drake/examples/pendulum/gen/pendulum_state.h:147
            const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";
          } IsValid;
          // Symbol: drake::examples::pendulum::PendulumState::K
          struct /* K */ {
            // Source: drake/examples/pendulum/gen/pendulum_state.h:47
            const char* doc =
R"""(An abbreviation for our row index constants.)""";
          } K;
          // Symbol: drake::examples::pendulum::PendulumState::PendulumState<T>
          struct /* ctor */ {
            // Source: drake/examples/pendulum/gen/pendulum_state.h:52
            const char* doc =
R"""(Default constructor. Sets all rows to their default value:

* ``theta`` defaults to 0.0 radians.

* ``thetadot`` defaults to 0.0 radians/sec.)""";
          } ctor;
          // Symbol: drake::examples::pendulum::PendulumState::Serialize
          struct /* Serialize */ {
            // Source: drake/examples/pendulum/gen/pendulum_state.h:134
            const char* doc =
R"""(Visit each field of this named vector, passing them (in order) to the
given Archive. The archive can read and/or write to the vector values.
One common use of Serialize is the //common/yaml tools.)""";
          } Serialize;
          // Symbol: drake::examples::pendulum::PendulumState::SetToNamedVariables
          struct /* SetToNamedVariables */ {
            // Source: drake/examples/pendulum/gen/pendulum_state.h:81
            const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";
          } SetToNamedVariables;
          // Symbol: drake::examples::pendulum::PendulumState::set_theta
          struct /* set_theta */ {
            // Source: drake/examples/pendulum/gen/pendulum_state.h:99
            const char* doc = R"""(Setter that matches theta().)""";
          } set_theta;
          // Symbol: drake::examples::pendulum::PendulumState::set_thetadot
          struct /* set_thetadot */ {
            // Source: drake/examples/pendulum/gen/pendulum_state.h:117
            const char* doc = R"""(Setter that matches thetadot().)""";
          } set_thetadot;
          // Symbol: drake::examples::pendulum::PendulumState::theta
          struct /* theta */ {
            // Source: drake/examples/pendulum/gen/pendulum_state.h:94
            const char* doc =
R"""(The angle of the pendulum.

Note:
    ``theta`` is expressed in units of radians.)""";
          } theta;
          // Symbol: drake::examples::pendulum::PendulumState::thetadot
          struct /* thetadot */ {
            // Source: drake/examples/pendulum/gen/pendulum_state.h:112
            const char* doc =
R"""(The angular velocity of the pendulum.

Note:
    ``thetadot`` is expressed in units of radians/sec.)""";
          } thetadot;
          // Symbol: drake::examples::pendulum::PendulumState::with_theta
          struct /* with_theta */ {
            // Source: drake/examples/pendulum/gen/pendulum_state.h:105
            const char* doc =
R"""(Fluent setter that matches theta(). Returns a copy of ``this`` with
theta set to a new value.)""";
          } with_theta;
          // Symbol: drake::examples::pendulum::PendulumState::with_thetadot
          struct /* with_thetadot */ {
            // Source: drake/examples/pendulum/gen/pendulum_state.h:123
            const char* doc =
R"""(Fluent setter that matches thetadot(). Returns a copy of ``this`` with
thetadot set to a new value.)""";
          } with_thetadot;
        } PendulumState;
        // Symbol: drake::examples::pendulum::PendulumStateIndices
        struct /* PendulumStateIndices */ {
          // Source: drake/examples/pendulum/gen/pendulum_state.h:27
          const char* doc =
R"""(Describes the row indices of a PendulumState.)""";
          // Symbol: drake::examples::pendulum::PendulumStateIndices::GetCoordinateNames
          struct /* GetCoordinateNames */ {
            // Source: drake/examples/pendulum/gen/pendulum_state.h:39
            const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words,
``PendulumStateIndices::GetCoordinateNames()[i]`` is the name for
``BasicVector::GetAtIndex(i)``.)""";
          } GetCoordinateNames;
        } PendulumStateIndices;
      } pendulum;
      // Symbol: drake::examples::quadrotor
      struct /* quadrotor */ {
        // Symbol: drake::examples::quadrotor::QuadrotorGeometry
        struct /* QuadrotorGeometry */ {
          // Source: drake/examples/quadrotor/quadrotor_geometry.h:23
          const char* doc =
R"""(Expresses a QuadrotorPlant's geometry to a SceneGraph.

.. pydrake_system::

    name: QuadrotorGeometry
    input_ports:
    - state
    output_ports:
    - geometry_pose

This class has no public constructor; instead use the AddToBuilder()
static method to create and add it to a DiagramBuilder directly.)""";
          // Symbol: drake::examples::quadrotor::QuadrotorGeometry::AddToBuilder
          struct /* AddToBuilder */ {
            // Source: drake/examples/quadrotor/quadrotor_geometry.h:35
            const char* doc =
R"""(Creates, adds, and connects a QuadrotorGeometry system into the given
``builder``. Both the ``quadrotor_state.get_system()`` and
``scene_graph`` systems must have been added to the given ``builder``
already.

The ``scene_graph`` pointer is not retained by the QuadrotorGeometry
system. The return value pointer is an alias of the new
QuadrotorGeometry system that is owned by the ``builder``.)""";
          } AddToBuilder;
          // Symbol: drake::examples::quadrotor::QuadrotorGeometry::QuadrotorGeometry
          struct /* ctor */ {
            // Source: drake/examples/quadrotor/quadrotor_geometry.h:25
            const char* doc = R"""()""";
          } ctor;
        } QuadrotorGeometry;
        // Symbol: drake::examples::quadrotor::QuadrotorPlant
        struct /* QuadrotorPlant */ {
          // Source: drake/examples/quadrotor/quadrotor_plant.h:29
          const char* doc =
R"""(The Quadrotor - an underactuated aerial vehicle. This version of the
Quadrotor is implemented to match the dynamics of the plant specified
in the ``quadrotor.urdf`` model file.

.. pydrake_system::

    name: QuadrotorPlant
    input_ports:
    - propellor_force
    output_ports:
    - state)""";
          // Symbol: drake::examples::quadrotor::QuadrotorPlant::QuadrotorPlant<T>
          struct /* ctor */ {
            // Source: drake/examples/quadrotor/quadrotor_plant.h:31
            const char* doc = R"""()""";
            // Source: drake/examples/quadrotor/quadrotor_plant.h:37
            const char* doc_copyconvert =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";
          } ctor;
          // Symbol: drake::examples::quadrotor::QuadrotorPlant::g
          struct /* g */ {
            // Source: drake/examples/quadrotor/quadrotor_plant.h:42
            const char* doc = R"""()""";
          } g;
          // Symbol: drake::examples::quadrotor::QuadrotorPlant::m
          struct /* m */ {
            // Source: drake/examples/quadrotor/quadrotor_plant.h:41
            const char* doc = R"""()""";
          } m;
        } QuadrotorPlant;
        // Symbol: drake::examples::quadrotor::StabilizingLQRController
        struct /* StabilizingLQRController */ {
          // Source: drake/examples/quadrotor/quadrotor_plant.h:67
          const char* doc =
R"""(Generates an LQR controller to move to ``nominal_position``.
Internally computes the nominal input corresponding to a hover at
position ``x0``.

See also:
    systems::LinearQuadraticRegulator.)""";
        } StabilizingLQRController;
      } quadrotor;
      // Symbol: drake::examples::rimless_wheel
      struct /* rimless_wheel */ {
        // Symbol: drake::examples::rimless_wheel::RimlessWheel
        struct /* RimlessWheel */ {
          // Source: drake/examples/rimless_wheel/rimless_wheel.h:43
          const char* doc =
R"""(Dynamical representation of the idealized hybrid dynamics of a
"rimless wheel", as described in
http://underactuated.mit.edu/underactuated.html?chapter=simple_legs In
addition, this model has two additional (discrete) state variables
that are not required in the mathematical model:

- the position of the stance toe along the ramp (helpful for outputting
  a floating-base model coordinate, e.g. for visualization),
- a boolean indicator for "double support" (to avoid the numerical
  challenges of simulation around the Zeno phenomenon at the standing
  fixed point).

.. pydrake_system::

    name: RimlessWheel
    output_ports:
    - minimal_state (theta and thetadot only)
    - floating_base_state

Continuous States: theta, thetadot. Discrete States: stance toe
position, double support indicator. Parameters: mass, length, number
of spokes, etc, are all set as Context parameters using
RimlessWheelParams.)""";
          // Symbol: drake::examples::rimless_wheel::RimlessWheel::CalcTotalEnergy
          struct /* CalcTotalEnergy */ {
            // Source: drake/examples/rimless_wheel/rimless_wheel.h:126
            const char* doc =
R"""(Calculates the kinetic + potential energy.)""";
          } CalcTotalEnergy;
          // Symbol: drake::examples::rimless_wheel::RimlessWheel::RimlessWheel<T>
          struct /* ctor */ {
            // Source: drake/examples/rimless_wheel/rimless_wheel.h:48
            const char* doc = R"""(Constructs the plant.)""";
            // Source: drake/examples/rimless_wheel/rimless_wheel.h:52
            const char* doc_copyconvert =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";
          } ctor;
          // Symbol: drake::examples::rimless_wheel::RimlessWheel::calc_alpha
          struct /* calc_alpha */ {
            // Source: drake/examples/rimless_wheel/rimless_wheel.h:121
            const char* doc =
R"""(Alpha is half the interleg angle, and is used frequently.)""";
          } calc_alpha;
          // Symbol: drake::examples::rimless_wheel::RimlessWheel::get_continuous_state
          struct /* get_continuous_state */ {
            // Source: drake/examples/rimless_wheel/rimless_wheel.h:71
            const char* doc = R"""(Access the RimlessWheelContinuousState.)""";
          } get_continuous_state;
          // Symbol: drake::examples::rimless_wheel::RimlessWheel::get_double_support
          struct /* get_double_support */ {
            // Source: drake/examples/rimless_wheel/rimless_wheel.h:106
            const char* doc = R"""()""";
          } get_double_support;
          // Symbol: drake::examples::rimless_wheel::RimlessWheel::get_floating_base_state_output_port
          struct /* get_floating_base_state_output_port */ {
            // Source: drake/examples/rimless_wheel/rimless_wheel.h:66
            const char* doc =
R"""(Returns reference to the output port that provides a 12 dimensional
state (FloatingBaseType::kRollPitchYaw positions then velocities).
This is useful, e.g., for visualization. θ of the rimless wheel is the
pitch of the floating base (rotation around global y), and downhill
moves toward positive x. As always, we use vehicle coordinates (x-y on
the ground, z is up).)""";
          } get_floating_base_state_output_port;
          // Symbol: drake::examples::rimless_wheel::RimlessWheel::get_minimal_state_output_port
          struct /* get_minimal_state_output_port */ {
            // Source: drake/examples/rimless_wheel/rimless_wheel.h:56
            const char* doc =
R"""(Return reference to the output port that publishes only [theta,
thetatdot].)""";
          } get_minimal_state_output_port;
          // Symbol: drake::examples::rimless_wheel::RimlessWheel::get_mutable_continuous_state
          struct /* get_mutable_continuous_state */ {
            // Source: drake/examples/rimless_wheel/rimless_wheel.h:84
            const char* doc =
R"""(Access the mutable RimlessWheelContinuousState.)""";
          } get_mutable_continuous_state;
          // Symbol: drake::examples::rimless_wheel::RimlessWheel::get_mutable_double_support
          struct /* get_mutable_double_support */ {
            // Source: drake/examples/rimless_wheel/rimless_wheel.h:110
            const char* doc = R"""()""";
          } get_mutable_double_support;
          // Symbol: drake::examples::rimless_wheel::RimlessWheel::get_mutable_toe_position
          struct /* get_mutable_toe_position */ {
            // Source: drake/examples/rimless_wheel/rimless_wheel.h:101
            const char* doc = R"""()""";
          } get_mutable_toe_position;
          // Symbol: drake::examples::rimless_wheel::RimlessWheel::get_parameters
          struct /* get_parameters */ {
            // Source: drake/examples/rimless_wheel/rimless_wheel.h:115
            const char* doc = R"""(Access the RimlessWheelParams.)""";
          } get_parameters;
          // Symbol: drake::examples::rimless_wheel::RimlessWheel::get_toe_position
          struct /* get_toe_position */ {
            // Source: drake/examples/rimless_wheel/rimless_wheel.h:97
            const char* doc = R"""()""";
          } get_toe_position;
        } RimlessWheel;
        // Symbol: drake::examples::rimless_wheel::RimlessWheelContinuousState
        struct /* RimlessWheelContinuousState */ {
          // Source: drake/examples/rimless_wheel/gen/rimless_wheel_continuous_state.h:45
          const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";
          // Symbol: drake::examples::rimless_wheel::RimlessWheelContinuousState::DoClone
          struct /* DoClone */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_continuous_state.h:91
            const char* doc = R"""()""";
          } DoClone;
          // Symbol: drake::examples::rimless_wheel::RimlessWheelContinuousState::GetCoordinateNames
          struct /* GetCoordinateNames */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_continuous_state.h:150
            const char* doc =
R"""(See RimlessWheelContinuousStateIndices::GetCoordinateNames().)""";
          } GetCoordinateNames;
          // Symbol: drake::examples::rimless_wheel::RimlessWheelContinuousState::IsValid
          struct /* IsValid */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_continuous_state.h:155
            const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";
          } IsValid;
          // Symbol: drake::examples::rimless_wheel::RimlessWheelContinuousState::K
          struct /* K */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_continuous_state.h:49
            const char* doc =
R"""(An abbreviation for our row index constants.)""";
          } K;
          // Symbol: drake::examples::rimless_wheel::RimlessWheelContinuousState::RimlessWheelContinuousState<T>
          struct /* ctor */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_continuous_state.h:54
            const char* doc =
R"""(Default constructor. Sets all rows to their default value:

* ``theta`` defaults to 0.0 radians.

* ``thetadot`` defaults to 0.0 rad/sec.)""";
          } ctor;
          // Symbol: drake::examples::rimless_wheel::RimlessWheelContinuousState::Serialize
          struct /* Serialize */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_continuous_state.h:142
            const char* doc =
R"""(Visit each field of this named vector, passing them (in order) to the
given Archive. The archive can read and/or write to the vector values.
One common use of Serialize is the //common/yaml tools.)""";
          } Serialize;
          // Symbol: drake::examples::rimless_wheel::RimlessWheelContinuousState::SetToNamedVariables
          struct /* SetToNamedVariables */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_continuous_state.h:86
            const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";
          } SetToNamedVariables;
          // Symbol: drake::examples::rimless_wheel::RimlessWheelContinuousState::set_theta
          struct /* set_theta */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_continuous_state.h:105
            const char* doc = R"""(Setter that matches theta().)""";
          } set_theta;
          // Symbol: drake::examples::rimless_wheel::RimlessWheelContinuousState::set_thetadot
          struct /* set_thetadot */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_continuous_state.h:124
            const char* doc = R"""(Setter that matches thetadot().)""";
          } set_thetadot;
          // Symbol: drake::examples::rimless_wheel::RimlessWheelContinuousState::theta
          struct /* theta */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_continuous_state.h:100
            const char* doc =
R"""(The orientation of the stance leg, measured clockwise from the
vertical axis.

Note:
    ``theta`` is expressed in units of radians.)""";
          } theta;
          // Symbol: drake::examples::rimless_wheel::RimlessWheelContinuousState::thetadot
          struct /* thetadot */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_continuous_state.h:119
            const char* doc =
R"""(The angular velocity of the stance leg.

Note:
    ``thetadot`` is expressed in units of rad/sec.)""";
          } thetadot;
          // Symbol: drake::examples::rimless_wheel::RimlessWheelContinuousState::with_theta
          struct /* with_theta */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_continuous_state.h:111
            const char* doc =
R"""(Fluent setter that matches theta(). Returns a copy of ``this`` with
theta set to a new value.)""";
          } with_theta;
          // Symbol: drake::examples::rimless_wheel::RimlessWheelContinuousState::with_thetadot
          struct /* with_thetadot */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_continuous_state.h:130
            const char* doc =
R"""(Fluent setter that matches thetadot(). Returns a copy of ``this`` with
thetadot set to a new value.)""";
          } with_thetadot;
        } RimlessWheelContinuousState;
        // Symbol: drake::examples::rimless_wheel::RimlessWheelContinuousStateIndices
        struct /* RimlessWheelContinuousStateIndices */ {
          // Source: drake/examples/rimless_wheel/gen/rimless_wheel_continuous_state.h:27
          const char* doc =
R"""(Describes the row indices of a RimlessWheelContinuousState.)""";
          // Symbol: drake::examples::rimless_wheel::RimlessWheelContinuousStateIndices::GetCoordinateNames
          struct /* GetCoordinateNames */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_continuous_state.h:40
            const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words,
``RimlessWheelContinuousStateIndices::GetCoordinateNames()[i]`` is the
name for ``BasicVector::GetAtIndex(i)``.)""";
          } GetCoordinateNames;
        } RimlessWheelContinuousStateIndices;
        // Symbol: drake::examples::rimless_wheel::RimlessWheelGeometry
        struct /* RimlessWheelGeometry */ {
          // Source: drake/examples/rimless_wheel/rimless_wheel_geometry.h:24
          const char* doc =
R"""(Expresses a RimlessWheel's geometry to a SceneGraph.

.. pydrake_system::

    name: RimlessWheelGeometry
    input_ports:
    - floating_base_state
    output_ports:
    - geometry_pose

This class has no public constructor; instead use the AddToBuilder()
static method to create and add it to a DiagramBuilder directly.)""";
          // Symbol: drake::examples::rimless_wheel::RimlessWheelGeometry::AddToBuilder
          struct /* AddToBuilder */ {
            // Source: drake/examples/rimless_wheel/rimless_wheel_geometry.h:38
            const char* doc_4args =
R"""(Creates, adds, and connects a RimlessWheelGeometry system into the
given ``builder``. Both the ``floating_base_state_port.get_system()``
and ``scene_graph`` systems must have been added to the given
``builder`` already. The ``rimless_wheel_params`` sets the parameters
of the geometry registered with ``scene_graph``.

The ``scene_graph`` pointer is not retained by the
RimlessWheelGeometry system. The return value pointer is an alias of
the new RimlessWheelGeometry system that is owned by the ``builder``.)""";
            // Source: drake/examples/rimless_wheel/rimless_wheel_geometry.h:52
            const char* doc_3args =
R"""(Creates, adds, and connects a RimlessWheelGeometry system into the
given ``builder``. Both the ``floating_base_state_port.get_system()``
and ``scene_graph`` systems must have been added to the given
``builder`` already. RimlessWheelParams are set to their default
values.

The ``scene_graph`` pointer is not retained by the
RimlessWheelGeometry system. The return value pointer is an alias of
the new RimlessWheelGeometry system that is owned by the ``builder``.)""";
          } AddToBuilder;
          // Symbol: drake::examples::rimless_wheel::RimlessWheelGeometry::RimlessWheelGeometry
          struct /* ctor */ {
            // Source: drake/examples/rimless_wheel/rimless_wheel_geometry.h:26
            const char* doc = R"""()""";
          } ctor;
        } RimlessWheelGeometry;
        // Symbol: drake::examples::rimless_wheel::RimlessWheelParams
        struct /* RimlessWheelParams */ {
          // Source: drake/examples/rimless_wheel/gen/rimless_wheel_params.h:47
          const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";
          // Symbol: drake::examples::rimless_wheel::RimlessWheelParams::DoClone
          struct /* DoClone */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_params.h:98
            const char* doc = R"""()""";
          } DoClone;
          // Symbol: drake::examples::rimless_wheel::RimlessWheelParams::GetCoordinateNames
          struct /* GetCoordinateNames */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_params.h:219
            const char* doc =
R"""(See RimlessWheelParamsIndices::GetCoordinateNames().)""";
          } GetCoordinateNames;
          // Symbol: drake::examples::rimless_wheel::RimlessWheelParams::GetElementBounds
          struct /* GetElementBounds */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_params.h:239
            const char* doc = R"""()""";
          } GetElementBounds;
          // Symbol: drake::examples::rimless_wheel::RimlessWheelParams::IsValid
          struct /* IsValid */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_params.h:224
            const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";
          } IsValid;
          // Symbol: drake::examples::rimless_wheel::RimlessWheelParams::K
          struct /* K */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_params.h:50
            const char* doc =
R"""(An abbreviation for our row index constants.)""";
          } K;
          // Symbol: drake::examples::rimless_wheel::RimlessWheelParams::RimlessWheelParams<T>
          struct /* ctor */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_params.h:58
            const char* doc =
R"""(Default constructor. Sets all rows to their default value:

* ``mass`` defaults to 1.0 kg.

* ``length`` defaults to 1.0 m.

* ``gravity`` defaults to 9.81 m/s^2.

* ``number_of_spokes`` defaults to 8 integer.

* ``slope`` defaults to 0.08 radians.)""";
          } ctor;
          // Symbol: drake::examples::rimless_wheel::RimlessWheelParams::Serialize
          struct /* Serialize */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_params.h:205
            const char* doc =
R"""(Visit each field of this named vector, passing them (in order) to the
given Archive. The archive can read and/or write to the vector values.
One common use of Serialize is the //common/yaml tools.)""";
          } Serialize;
          // Symbol: drake::examples::rimless_wheel::RimlessWheelParams::SetToNamedVariables
          struct /* SetToNamedVariables */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_params.h:90
            const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";
          } SetToNamedVariables;
          // Symbol: drake::examples::rimless_wheel::RimlessWheelParams::gravity
          struct /* gravity */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_params.h:145
            const char* doc =
R"""(An approximate value for gravitational acceleration.

Note:
    ``gravity`` is expressed in units of m/s^2.

Note:
    ``gravity`` has a limited domain of [0.0, +Inf].)""";
          } gravity;
          // Symbol: drake::examples::rimless_wheel::RimlessWheelParams::length
          struct /* length */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_params.h:126
            const char* doc =
R"""(The length of each spoke.

Note:
    ``length`` is expressed in units of m.

Note:
    ``length`` has a limited domain of [0.0, +Inf].)""";
          } length;
          // Symbol: drake::examples::rimless_wheel::RimlessWheelParams::mass
          struct /* mass */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_params.h:107
            const char* doc =
R"""(The rimless wheel has a single point mass at the hub.

Note:
    ``mass`` is expressed in units of kg.

Note:
    ``mass`` has a limited domain of [0.0, +Inf].)""";
          } mass;
          // Symbol: drake::examples::rimless_wheel::RimlessWheelParams::number_of_spokes
          struct /* number_of_spokes */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_params.h:164
            const char* doc =
R"""(Total number of spokes on the wheel

Note:
    ``number_of_spokes`` is expressed in units of integer.

Note:
    ``number_of_spokes`` has a limited domain of [4, +Inf].)""";
          } number_of_spokes;
          // Symbol: drake::examples::rimless_wheel::RimlessWheelParams::set_gravity
          struct /* set_gravity */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_params.h:150
            const char* doc = R"""(Setter that matches gravity().)""";
          } set_gravity;
          // Symbol: drake::examples::rimless_wheel::RimlessWheelParams::set_length
          struct /* set_length */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_params.h:131
            const char* doc = R"""(Setter that matches length().)""";
          } set_length;
          // Symbol: drake::examples::rimless_wheel::RimlessWheelParams::set_mass
          struct /* set_mass */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_params.h:112
            const char* doc = R"""(Setter that matches mass().)""";
          } set_mass;
          // Symbol: drake::examples::rimless_wheel::RimlessWheelParams::set_number_of_spokes
          struct /* set_number_of_spokes */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_params.h:169
            const char* doc = R"""(Setter that matches number_of_spokes().)""";
          } set_number_of_spokes;
          // Symbol: drake::examples::rimless_wheel::RimlessWheelParams::set_slope
          struct /* set_slope */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_params.h:188
            const char* doc = R"""(Setter that matches slope().)""";
          } set_slope;
          // Symbol: drake::examples::rimless_wheel::RimlessWheelParams::slope
          struct /* slope */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_params.h:183
            const char* doc =
R"""(The angle of the ramp on which the rimless wheel is walking.

Note:
    ``slope`` is expressed in units of radians.)""";
          } slope;
          // Symbol: drake::examples::rimless_wheel::RimlessWheelParams::with_gravity
          struct /* with_gravity */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_params.h:156
            const char* doc =
R"""(Fluent setter that matches gravity(). Returns a copy of ``this`` with
gravity set to a new value.)""";
          } with_gravity;
          // Symbol: drake::examples::rimless_wheel::RimlessWheelParams::with_length
          struct /* with_length */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_params.h:137
            const char* doc =
R"""(Fluent setter that matches length(). Returns a copy of ``this`` with
length set to a new value.)""";
          } with_length;
          // Symbol: drake::examples::rimless_wheel::RimlessWheelParams::with_mass
          struct /* with_mass */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_params.h:118
            const char* doc =
R"""(Fluent setter that matches mass(). Returns a copy of ``this`` with
mass set to a new value.)""";
          } with_mass;
          // Symbol: drake::examples::rimless_wheel::RimlessWheelParams::with_number_of_spokes
          struct /* with_number_of_spokes */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_params.h:175
            const char* doc =
R"""(Fluent setter that matches number_of_spokes(). Returns a copy of
``this`` with number_of_spokes set to a new value.)""";
          } with_number_of_spokes;
          // Symbol: drake::examples::rimless_wheel::RimlessWheelParams::with_slope
          struct /* with_slope */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_params.h:194
            const char* doc =
R"""(Fluent setter that matches slope(). Returns a copy of ``this`` with
slope set to a new value.)""";
          } with_slope;
        } RimlessWheelParams;
        // Symbol: drake::examples::rimless_wheel::RimlessWheelParamsIndices
        struct /* RimlessWheelParamsIndices */ {
          // Source: drake/examples/rimless_wheel/gen/rimless_wheel_params.h:27
          const char* doc =
R"""(Describes the row indices of a RimlessWheelParams.)""";
          // Symbol: drake::examples::rimless_wheel::RimlessWheelParamsIndices::GetCoordinateNames
          struct /* GetCoordinateNames */ {
            // Source: drake/examples/rimless_wheel/gen/rimless_wheel_params.h:42
            const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words,
``RimlessWheelParamsIndices::GetCoordinateNames()[i]`` is the name for
``BasicVector::GetAtIndex(i)``.)""";
          } GetCoordinateNames;
        } RimlessWheelParamsIndices;
      } rimless_wheel;
      // Symbol: drake::examples::van_der_pol
      struct /* van_der_pol */ {
        // Symbol: drake::examples::van_der_pol::VanDerPolOscillator
        struct /* VanDerPolOscillator */ {
          // Source: drake/examples/van_der_pol/van_der_pol.h:25
          const char* doc =
R"""(van der Pol oscillator

The van der Pol oscillator, governed by the following equations: q̈ +
μ(q² - 1)q̇ + q = 0, μ > 0 y₀ = q y₁ = [q,q̇]' is a canonical example
of a nonlinear system that exhibits a limit cycle stability. As such
it serves as an important for examining nonlinear stability and
stochastic stability.

(Examples involving region of attraction analysis and analyzing the
stationary distribution of the oscillator under process noise are
coming soon).)""";
          // Symbol: drake::examples::van_der_pol::VanDerPolOscillator::CalcLimitCycle
          struct /* CalcLimitCycle */ {
            // Source: drake/examples/van_der_pol/van_der_pol.h:54
            const char* doc =
R"""(Returns a 2-row matrix containing the result of simulating the
oscillator with the default mu=1 from (approximately) one point on the
limit cycle for (approximately) one period. The first row is q, and
the second row is q̇.)""";
          } CalcLimitCycle;
          // Symbol: drake::examples::van_der_pol::VanDerPolOscillator::VanDerPolOscillator<T>
          struct /* ctor */ {
            // Source: drake/examples/van_der_pol/van_der_pol.h:30
            const char* doc = R"""(Constructs a default oscillator.)""";
            // Source: drake/examples/van_der_pol/van_der_pol.h:34
            const char* doc_copyconvert = R"""(Scalar-converting copy constructor.)""";
          } ctor;
          // Symbol: drake::examples::van_der_pol::VanDerPolOscillator::get_full_state_output_port
          struct /* get_full_state_output_port */ {
            // Source: drake/examples/van_der_pol/van_der_pol.h:44
            const char* doc =
R"""(Returns the output port containing the full state. This is provided
primarily as a tool for debugging/visualization.)""";
          } get_full_state_output_port;
          // Symbol: drake::examples::van_der_pol::VanDerPolOscillator::get_position_output_port
          struct /* get_position_output_port */ {
            // Source: drake/examples/van_der_pol/van_der_pol.h:38
            const char* doc =
R"""(Returns the output port containing the output configuration (only).)""";
          } get_position_output_port;
        } VanDerPolOscillator;
      } van_der_pol;
    } examples;
    // Symbol: drake::geometry
    struct /* geometry */ {
      // Symbol: drake::geometry::AddContactMaterial
      struct /* AddContactMaterial */ {
        // Source: drake/geometry/proximity_properties.h:119
        const char* doc_5args =
R"""(@name Contact Material Utility Functions AddContactMaterial() adds
contact material properties to the given set of proximity
``properties``. Only the parameters that carry values will be added to
the given set of ``properties``; no default values will be provided.
Downstream consumers of the contact materials can optionally provide
defaults for missing properties.

For legacy and backwards compatibility purposes, two overloads for
AddContactMaterial() are provided. One supports all contact material
properties **except** ``point_stiffness``, and the other includes it.
Users are encouraged to use the overload that contains the argument
for ``point_stiffness``.

These functions will throw an error if: - ``elastic_modulus`` is not
positive - ``dissipation`` is negative - ``point_stiffness`` is not
positive - Any of the contact material properties have already been
defined in ``properties``.

Raises:
    RuntimeError if any parameter doesn't satisfy the requirements
    listed in contact_material_utility_functions "Contact Material
    Utility Functions".)""";
        // Source: drake/geometry/proximity_properties.h:130
        const char* doc_4args =
R"""(Warning:
    Please use the overload of AddContactMaterial() that includes the
    argument for ``point_stiffness`` rather than this one.)""";
      } AddContactMaterial;
      // Symbol: drake::geometry::AddRigidHydroelasticProperties
      struct /* AddRigidHydroelasticProperties */ {
        // Source: drake/geometry/proximity_properties.h:149
        const char* doc_2args =
R"""(Adds properties to the given set of proximity properties sufficient to
cause the associated geometry to generate a rigid hydroelastic
representation.

Parameter ``resolution_hint``:
    If the geometry is to be tessellated, it is the parameter that
    guides the level of mesh refinement. See MODULE_NOT_WRITTEN_YET.
    This will be ignored for geometry types that don't require
    tessellation.

Parameter ``properties``:
    The properties will be added to this property set.

Raises:
    RuntimeError If ``properties`` already has properties with the
    names that this function would need to add.

Precondition:
    0 < ``resolution_hint`` < ∞ and ``properties`` is not nullptr.)""";
        // Source: drake/geometry/proximity_properties.h:155
        const char* doc_1args =
R"""(Overload, intended for shapes that don't get tessellated in their
hydroelastic representation (e.g., HalfSpace and Mesh). See
MODULE_NOT_WRITTEN_YET.)""";
      } AddRigidHydroelasticProperties;
      // Symbol: drake::geometry::AddSoftHydroelasticProperties
      struct /* AddSoftHydroelasticProperties */ {
        // Source: drake/geometry/proximity_properties.h:173
        const char* doc_2args =
R"""(Adds properties to the given set of proximity properties sufficient to
cause the associated geometry to generate a soft hydroelastic
representation. The geometry's pressure field will be the function
p(e) = Ee, where E is the elastic modulus stored in the given
``properties``.

Parameter ``resolution_hint``:
    If the geometry is to be tessellated, it is the parameter that
    guides the level of mesh refinement. This will be ignored for
    geometry types that don't require tessellation.

Parameter ``properties``:
    The properties will be added to this property set.

Raises:
    RuntimeError If ``properties`` already has properties with the
    names that this function would need to add.

Precondition:
    0 < ``resolution_hint`` < ∞, ``properties`` is not nullptr, and
    ``properties`` contains a valid elastic modulus value.)""";
        // Source: drake/geometry/proximity_properties.h:179
        const char* doc_1args =
R"""(Overload, intended for shapes that don't get tessellated in their
hydroelastic representation (e.g., HalfSpace). See
MODULE_NOT_WRITTEN_YET.)""";
      } AddSoftHydroelasticProperties;
      // Symbol: drake::geometry::AddSoftHydroelasticPropertiesForHalfSpace
      struct /* AddSoftHydroelasticPropertiesForHalfSpace */ {
        // Source: drake/geometry/proximity_properties.h:192
        const char* doc =
R"""(Soft half spaces are handled as a special case; they do not get
tessellated. Instead, they are treated as infinite slabs with a finite
thickness. This variant is required for hydroelastic half spaces.

Parameter ``slab_thickness``:
    The distance from the half space boundary to its rigid core (this
    helps define the extent field of the half space).

Parameter ``properties``:
    The properties will be added to this property set.

Raises:
    RuntimeError If ``properties`` already has properties with the
    names that this function would need to add.

Precondition:
    0 < ``slab_thickness`` < ∞ .)""";
      } AddSoftHydroelasticPropertiesForHalfSpace;
      // Symbol: drake::geometry::Box
      struct /* Box */ {
        // Source: drake/geometry/shape_specification.h:141
        const char* doc =
R"""(Definition of a box. The box is centered on the origin of its
canonical frame with its dimensions aligned with the frame's axes. The
size of the box is given by three sizes.)""";
        // Symbol: drake::geometry::Box::Box
        struct /* ctor */ {
          // Source: drake/geometry/shape_specification.h:150
          const char* doc =
R"""(Constructs a box with the given ``width``, `depth`, and ``height``,
which specify the box's dimension along the canonical x-, y-, and
z-axes, respectively.

Raises:
    RuntimeError if ``width``, `depth` or ``height`` are not strictly
    positive.)""";
        } ctor;
        // Symbol: drake::geometry::Box::MakeCube
        struct /* MakeCube */ {
          // Source: drake/geometry/shape_specification.h:154
          const char* doc =
R"""(Constructs a cube with the given ``edge_size`` for its width, depth,
and height.)""";
        } MakeCube;
        // Symbol: drake::geometry::Box::depth
        struct /* depth */ {
          // Source: drake/geometry/shape_specification.h:160
          const char* doc =
R"""(Returns the box's dimension along the y axis.)""";
        } depth;
        // Symbol: drake::geometry::Box::height
        struct /* height */ {
          // Source: drake/geometry/shape_specification.h:163
          const char* doc =
R"""(Returns the box's dimension along the z axis.)""";
        } height;
        // Symbol: drake::geometry::Box::size
        struct /* size */ {
          // Source: drake/geometry/shape_specification.h:166
          const char* doc = R"""(Returns the box's dimensions.)""";
        } size;
        // Symbol: drake::geometry::Box::width
        struct /* width */ {
          // Source: drake/geometry/shape_specification.h:157
          const char* doc =
R"""(Returns the box's dimension along the x axis.)""";
        } width;
      } Box;
      // Symbol: drake::geometry::Capsule
      struct /* Capsule */ {
        // Source: drake/geometry/shape_specification.h:174
        const char* doc =
R"""(Definition of a capsule. It is centered in its canonical frame with
the length of the capsule parallel with the frame's z-axis.)""";
        // Symbol: drake::geometry::Capsule::Capsule
        struct /* ctor */ {
          // Source: drake/geometry/shape_specification.h:181
          const char* doc =
R"""(Constructs a capsule with the given ``radius`` and ``length``.

Raises:
    RuntimeError if ``radius`` or ``length`` are not strictly
    positive.)""";
        } ctor;
        // Symbol: drake::geometry::Capsule::length
        struct /* length */ {
          // Source: drake/geometry/shape_specification.h:184
          const char* doc = R"""()""";
        } length;
        // Symbol: drake::geometry::Capsule::radius
        struct /* radius */ {
          // Source: drake/geometry/shape_specification.h:183
          const char* doc = R"""()""";
        } radius;
      } Capsule;
      // Symbol: drake::geometry::ConnectDrakeVisualizer
      struct /* ConnectDrakeVisualizer */ {
        // Source: drake/geometry/geometry_visualization.h:101
        const char* doc_deprecated_4args =
R"""(Extends a Diagram with the required components to interface with
drake_visualizer. This must be called *during* Diagram building and
uses the given ``builder`` to add relevant subsystems and connections.

This is a convenience method to simplify some common boilerplate for
adding visualization capability to a Diagram. What it does is:

- adds an initialization event that sends the required load message to set up
the visualizer with the relevant geometry,
- adds systems PoseBundleToDrawMessage and LcmPublisherSystem to
the Diagram and connects the draw message output to the publisher input,
- connects the ``scene_graph`` pose bundle output to the PoseBundleToDrawMessage
system, and
- sets the publishing rate to 1/60 of a second (simulated time).

The visualization mechanism depends on the illustration role (see
geometry_roles for details). Specifically, only geometries with the
illustration role assigned will be included. The visualization
function looks for the following properties in the
IllustrationProperties instance.

| Group name | Required | Property Name | Property Type | Property
Description | | :--------: | :------: | :-----------: |
:-------------: | :------------------- | | phong | no | diffuse |
Eigen::Vector4d | The rgba value of the object surface |

See MakePhongIllustrationProperties() to facilitate making a compliant
set of illustration properties.

You can then connect source output ports for visualization like this:


::

    builder->Connect(pose_output_port,
    scene_graph.get_source_pose_port(source_id));

Note:
    The initialization event occurs when Simulator::Initialize() is
    called (explicitly or implicitly at the start of a simulation). If
    you aren't going to be using a Simulator, use
    DispatchLoadMessage() to send the message yourself.

Parameter ``builder``:
    The diagram builder being used to construct the Diagram.

Parameter ``scene_graph``:
    The System in ``builder`` containing the geometry to be
    visualized.

Parameter ``lcm``:
    An optional lcm interface through which lcm messages will be
    dispatched. Will be allocated internally if none is supplied.

Parameter ``role``:
    An optional flag to indicate the role of the geometries to be
    visualized; defaults to the illustration role.

Precondition:
    This method has not been previously called while building the
    builder's current Diagram.

Precondition:
    The given ``scene_graph`` must be contained within the supplied
    DiagramBuilder.

Returns:
    the LcmPublisherSystem (in case callers, e.g., need to change the
    default publishing rate).

See also:
    geometry::DispatchLoadMessage() / (Deprecated.)

Deprecated:
    Please use DrakeVisualizerd::AddToBuilder(). This will be removed
    from Drake on or after 2021-04-01.)""";
        // Source: drake/geometry/geometry_visualization.h:117
        const char* doc_deprecated_5args =
R"""(Implements ConnectDrakeVisualizer, but using
``pose_bundle_output_port`` to explicitly specify the output port used
to get pose bundles for ``scene_graph``. This is required, for
instance, when the SceneGraph is inside a Diagram, and the Diagram
exports the pose bundle port.

Precondition:
    pose_bundle_output_port must be connected directly to the
    pose_bundle_output_port of ``scene_graph``.

See also:
    ConnectDrakeVisualizer(). / (Deprecated.)

Deprecated:
    Please use DrakeVisualizerd::AddToBuilder(). This will be removed
    from Drake on or after 2021-04-01.)""";
      } ConnectDrakeVisualizer;
      // Symbol: drake::geometry::ContactSurface
      struct /* ContactSurface */ {
        // Source: drake/geometry/query_results/contact_surface.h:130
        const char* doc =
R"""(The ContactSurface characterizes the intersection of two geometries M
and N as a contact surface with a scalar field and a vector field,
whose purpose is to support the hydroelastic pressure field contact
model as described in:

R. Elandt, E. Drumwright, M. Sherman, and Andy Ruina. A pressure field
model for fast, robust approximation of net contact force and moment
between nominally rigid objects. IROS 2019: 8238-8245.

Mathematical Concepts -----------------------

In this section, we give motivation for the concept of contact surface
from the hydroelastic pressure field contact model. Here the
mathematical discussion is coordinate-free (treatment of the topic
without reference to any particular coordinate system); however, our
implementation heavily relies on coordinate frames. We borrow
terminology from differential geometry.

In this section, the mathematical term *compact set* (a subset of
Euclidean space that is closed and bounded) corresponds to the term
*geometry* (or the space occupied by the geometry) in SceneGraph.

We describe the contact surface 𝕊ₘₙ between two intersecting compact
subsets 𝕄 and ℕ of ℝ³ with the scalar fields eₘ and eₙ defined on 𝕄 ⊂
ℝ³ and ℕ ⊂ ℝ³ respectively:

eₘ : 𝕄 → ℝ, eₙ : ℕ → ℝ.

The *contact surface* 𝕊ₘₙ is the surface of equilibrium eₘ = eₙ. It is
the locus of points Q where eₘ(Q) equals eₙ(Q):

𝕊ₘₙ = { Q ∈ 𝕄 ∩ ℕ : eₘ(Q) = eₙ(Q) }.

We can define the scalar field eₘₙ on the surface 𝕊ₘₙ as a scalar
function that assigns Q ∈ 𝕊ₘₙ the value of eₘ(Q), which is the same as
eₙ(Q):

eₘₙ : 𝕊ₘₙ → ℝ, eₘₙ(Q) = eₘ(Q) = eₙ(Q).

We can also define the scalar field hₘₙ on 𝕄 ∩ ℕ as the difference
between eₘ and eₙ:

hₘₙ : 𝕄 ∩ ℕ → ℝ, hₘₙ(Q) = eₘ(Q) - eₙ(Q).

It follows that the gradient vector field ∇hₘₙ on 𝕄 ∩ ℕ equals the
difference between the the gradient vector fields ∇eₘ and ∇eₙ:

∇hₘₙ : 𝕄 ∩ ℕ → ℝ³, ∇hₘₙ(Q) = ∇eₘ(Q) - ∇eₙ(Q).

By construction, Q ∈ 𝕊ₘₙ if and only if hₘₙ(Q) = 0. In other words,
𝕊ₘₙ is the zero level set of hₘₙ. It follows that, for Q ∈ 𝕊ₘₙ,
∇hₘₙ(Q) is orthogonal to the surface 𝕊ₘₙ at Q in the direction of
increasing eₘ - eₙ.

Notice that the domain of eₘₙ is the two-dimensional surface 𝕊ₘₙ,
while the domain of ∇hₘₙ is the three-dimensional compact set 𝕄 ∩ ℕ.
Even though eₘₙ and ∇hₘₙ are defined on different domains (𝕊ₘₙ and 𝕄 ∩
ℕ), our implementation only represents them on their common domain,
i.e., 𝕊ₘₙ.

Discrete Representation -------------------------

In practice, the contact surface is approximated with a discrete
triangle mesh. The triangle mesh's normals are defined *per face*. The
normal of each face is guaranteed to point "out of" N and "into" M.
They can be accessed via ``mesh_W().face_normal(face_index)``.

The pressure values on the contact surface are represented as a
continuous, piecewise-linear function, accessed via e_MN().

The normals of the mesh are discontinuous at triangle boundaries, but
the pressure can be meaningfully evaluated over the entire domain of
the mesh.

When available, the values of ∇eₘ and ∇eₙ are represented as a
discontinuous, piecewise-constant function over the triangles -- one
vector per triangle. These quantities are accessed via
EvaluateGradE_M_W() and EvaluateGradE_N_W(), respectively.

Barycentric Coordinates -------------------------

For Point Q on the surface mesh of the contact surface between
Geometry M and Geometry N, r_WQ = (x,y,z) is the displacement vector
from the origin of the world frame to Q expressed in the coordinate
frame of W. We also have the *barycentric coordinates* (b0, b1, b2) on
a triangle of the surface mesh that contains Q. With vertices of the
triangle labeled as v₀, v₁, v₂, we can map (b0, b1, b2) to r_WQ by:

r_WQ = b0 * r_Wv₀ + b1 * r_Wv₁ + b2 * r_Wv₂, b0 + b1 + b2 = 1, bᵢ ∈
[0,1],

where r_Wvᵢ is the displacement vector of the vertex labeled as vᵢ
from the origin of the world frame, expressed in the world frame.

We use the barycentric coordinates to evaluate the field values.)""";
        // Symbol: drake::geometry::ContactSurface::ContactSurface<T>
        struct /* ctor */ {
          // Source: drake/geometry/query_results/contact_surface.h:176
          const char* doc_4args =
R"""(Constructs a ContactSurface.

Parameter ``id_M``:
    The id of the first geometry M.

Parameter ``id_N``:
    The id of the second geometry N.

Parameter ``mesh_W``:
    The surface mesh of the contact surface 𝕊ₘₙ between M and N. The
    mesh vertices are defined in the world frame.

Parameter ``e_MN``:
    Represents the scalar field eₘₙ on the surface mesh.

Precondition:
    The face normals in ``mesh_W`` point *out of* geometry N and
    *into* M.

Note:
    If ``id_M > id_N``, the labels will be swapped and the normals of
    the mesh reversed (to maintain the documented invariants).
    Comparing the input parameters with the members of the resulting
    ContactSurface will reveal if such a swap has occurred.)""";
          // Source: drake/geometry/query_results/contact_surface.h:200
          const char* doc_6args =
R"""(Constructs a ContactSurface with the optional gradients of the
constituent scalar fields.

Parameter ``id_M``:
    The id of the first geometry M.

Parameter ``id_N``:
    The id of the second geometry N.

Parameter ``mesh_W``:
    The surface mesh of the contact surface 𝕊ₘₙ between M and N. The
    mesh vertices are defined in the world frame.

Parameter ``e_MN``:
    Represents the scalar field eₘₙ on the surface mesh.

Parameter ``grad_eM_W``:
    ∇eₘ sampled once per face, expressed in the world frame.

Parameter ``grad_eN_W``:
    ∇eₙ sampled once per face, expressed in the world frame.

Precondition:
    The face normals in ``mesh_W`` point *out of* geometry N and
    *into* M.

Precondition:
    If given, ``grad_eM_W`` and ``grad_eN_W`` must have as many
    entries as ``mesh_W`` has faces and the ith entry in each should
    correspond to the ith face in ``mesh_W``.

Note:
    If ``id_M > id_N``, the labels will be swapped and the normals of
    the mesh reversed (to maintain the documented invariants).
    Comparing the input parameters with the members of the resulting
    ContactSurface will reveal if such a swap has occurred.)""";
        } ctor;
        // Symbol: drake::geometry::ContactSurface::Equal
        struct /* Equal */ {
          // Source: drake/geometry/query_results/contact_surface.h:321
          const char* doc =
R"""(Checks to see whether the given ContactSurface object is equal via
deep exact comparison. NaNs are treated as not equal as per the IEEE
standard.

Note:
    Currently requires the fields of the objects to be of type
    MeshFieldLinear, otherwise the current simple checking of equal
    values at vertices is insufficient.

Parameter ``surface``:
    The contact surface for comparison.

Returns:
    ``True`` if the given contact surface is equal.)""";
        } Equal;
        // Symbol: drake::geometry::ContactSurface::EvaluateE_MN
        struct /* EvaluateE_MN */ {
          // Source: drake/geometry/query_results/contact_surface.h:235
          const char* doc_2args =
R"""(Evaluates the scalar field eₘₙ at Point Q in a triangle. Point Q is
specified by its barycentric coordinates.

Parameter ``face``:
    The face index of the triangle.

Parameter ``barycentric``:
    The barycentric coordinates of Q on the triangle.)""";
          // Source: drake/geometry/query_results/contact_surface.h:245
          const char* doc_1args =
R"""(Evaluates the scalar field eₘₙ at the given vertex on the contact
surface mesh.

Parameter ``vertex``:
    The index of the vertex in the mesh.)""";
        } EvaluateE_MN;
        // Symbol: drake::geometry::ContactSurface::EvaluateGradE_M_W
        struct /* EvaluateGradE_M_W */ {
          // Source: drake/geometry/query_results/contact_surface.h:277
          const char* doc =
R"""(Returns the value of ∇eₘ for the triangle with index ``index``.

Raises:
    RuntimeError if HasGradE_M() returns false.)""";
        } EvaluateGradE_M_W;
        // Symbol: drake::geometry::ContactSurface::EvaluateGradE_N_W
        struct /* EvaluateGradE_N_W */ {
          // Source: drake/geometry/query_results/contact_surface.h:289
          const char* doc =
R"""(Returns the value of ∇eₙ for the triangle with index ``index``.

Raises:
    RuntimeError if HasGradE_N() returns false.)""";
        } EvaluateGradE_N_W;
        // Symbol: drake::geometry::ContactSurface::HasGradE_M
        struct /* HasGradE_M */ {
          // Source: drake/geometry/query_results/contact_surface.h:270
          const char* doc =
R"""(Returns:
    ``True`` if ``this`` contains values for ∇eₘ.)""";
        } HasGradE_M;
        // Symbol: drake::geometry::ContactSurface::HasGradE_N
        struct /* HasGradE_N */ {
          // Source: drake/geometry/query_results/contact_surface.h:273
          const char* doc =
R"""(Returns:
    ``True`` if ``this`` contains values for ∇eₙ.)""";
        } HasGradE_N;
        // Symbol: drake::geometry::ContactSurface::e_MN
        struct /* e_MN */ {
          // Source: drake/geometry/query_results/contact_surface.h:310
          const char* doc =
R"""(Returns a reference to the scalar field eₘₙ.)""";
        } e_MN;
        // Symbol: drake::geometry::ContactSurface::id_M
        struct /* id_M */ {
          // Source: drake/geometry/query_results/contact_surface.h:222
          const char* doc = R"""(Returns the geometry id of Geometry M.)""";
        } id_M;
        // Symbol: drake::geometry::ContactSurface::id_N
        struct /* id_N */ {
          // Source: drake/geometry/query_results/contact_surface.h:225
          const char* doc = R"""(Returns the geometry id of Geometry N.)""";
        } id_N;
        // Symbol: drake::geometry::ContactSurface::mesh_W
        struct /* mesh_W */ {
          // Source: drake/geometry/query_results/contact_surface.h:304
          const char* doc =
R"""(Returns a reference to the surface mesh whose vertex positions are
measured and expressed in the world frame.)""";
        } mesh_W;
      } ContactSurface;
      // Symbol: drake::geometry::Convex
      struct /* Convex */ {
        // Source: drake/geometry/shape_specification.h:275
        const char* doc = R"""(Support for convex shapes.)""";
        // Symbol: drake::geometry::Convex::Convex
        struct /* ctor */ {
          // Source: drake/geometry/shape_specification.h:298
          const char* doc =
R"""(Constructs a convex shape specification from the file located at the
given *absolute* file path. Optionally uniformly scaled by the given
scale factor.

Parameter ``absolute_filename``:
    The file name with absolute path. We only support an .obj file
    with only one polyhedron. We assume that the polyhedron is convex.

Parameter ``scale``:
    An optional scale to coordinates.

Raises:
    RuntimeError if the .obj file doesn't define a single object. This
    can happen if it is empty, if there are multiple object-name
    statements (e.g., "o object_name"), or if there are faces defined
    outside a single object-name statement.

Raises:
    RuntimeError if |scale| < 1e-8. Note that a negative scale is
    considered valid. We want to preclude scales near zero but
    recognise that scale is a convenience tool for "tweaking" models.
    8 orders of magnitude should be plenty without considering
    revisiting the model itself.)""";
        } ctor;
        // Symbol: drake::geometry::Convex::filename
        struct /* filename */ {
          // Source: drake/geometry/shape_specification.h:300
          const char* doc = R"""()""";
        } filename;
        // Symbol: drake::geometry::Convex::scale
        struct /* scale */ {
          // Source: drake/geometry/shape_specification.h:301
          const char* doc = R"""()""";
        } scale;
      } Convex;
      // Symbol: drake::geometry::Cylinder
      struct /* Cylinder */ {
        // Source: drake/geometry/shape_specification.h:121
        const char* doc =
R"""(Definition of a cylinder. It is centered in its canonical frame with
the length of the cylinder parallel with the frame's z-axis.)""";
        // Symbol: drake::geometry::Cylinder::Cylinder
        struct /* ctor */ {
          // Source: drake/geometry/shape_specification.h:128
          const char* doc =
R"""(Constructs a cylinder with the given ``radius`` and ``length``.

Raises:
    RuntimeError if ``radius`` or ``length`` are not strictly
    positive.)""";
        } ctor;
        // Symbol: drake::geometry::Cylinder::length
        struct /* length */ {
          // Source: drake/geometry/shape_specification.h:131
          const char* doc = R"""()""";
        } length;
        // Symbol: drake::geometry::Cylinder::radius
        struct /* radius */ {
          // Source: drake/geometry/shape_specification.h:130
          const char* doc = R"""()""";
        } radius;
      } Cylinder;
      // Symbol: drake::geometry::DispatchLoadMessage
      struct /* DispatchLoadMessage */ {
        // Source: drake/geometry/geometry_visualization.h:134
        const char* doc_deprecated =
R"""((Advanced) Explicitly dispatches an LCM load message based on the
registered geometry. Normally this is done automatically at Simulator
initialization. But if you have to do it yourself (likely because you
are not using a Simulator), it should be invoked *after* registration
is complete. Typically this is used after ConnectDrakeVisualizer() has
been used to add visualization to the Diagram that contains the given
``scene_graph``. The message goes to LCM channel
"DRAKE_VIEWER_LOAD_ROBOT".

See also:
    geometry::ConnectDrakeVisualizer() */ (Deprecated.)

Deprecated:
    Please use DrakeVisualizerd::SendLoadMessage(). This will be
    removed from Drake on or after 2021-04-01.)""";
      } DispatchLoadMessage;
      // Symbol: drake::geometry::DrakeVisualizer
      struct /* DrakeVisualizer */ {
        // Source: drake/geometry/drake_visualizer.h:132
        const char* doc =
R"""(A system that publishes LCM messages compatible with the
``drake_visualizer`` application representing the current state of a
SceneGraph instance (whose QueryObject-valued output port is connected
to this system's input port).

.. pydrake_system::

    name: DrakeVisualizer
    input_ports:
    - query_object

The DrakeVisualizer system broadcasts two kinds of LCM messages:

- a message that defines the geometry in the world on the lcm channel named
"DRAKE_VIEWER_DRAW",
- a message that updates the poses of those geometries on the lcm channel
named "DRAKE_VIEWER_LOAD_ROBOT"

The system uses the versioning mechanism provided by SceneGraph to
detect changes to the geometry so that a change in SceneGraph's data
will propagate to ``drake_visualizer``.

**Visualization by Role**

By default, DrakeVisualizer visualizes geometries with the
illustration role (see geometry_roles for more details). It can be
configured to visualize geometries with other roles (see
DrakeVisualizerParams). Only one role can be specified.

The appearance of the geometry in the visualizer is typically defined
by the the geometry's properties for the visualized role.

- For the visualized role, if a geometry has the ("phong", "diffuse")
property described in the table below, that value is used.
- Otherwise, if the geometry *also* has the illustration properties, those
properties are likewise tested for the ("phong", "diffuse") property. This
rule only has significance is the visualized role is *not* the illustration
role.
- Otherwise, the configured default color will be applied (see
DrakeVisualizerParams).

| Group name | Required | Property Name | Property Type | Property
Description | | :--------: | :------: | :-----------: |
:-------------: | :------------------- | | phong | no | diffuse | Rgba
| The rgba value of the object surface. |

*Appearance of OBJ files*

Meshes represented by OBJ are special. The OBJ file can reference a
material file (.mtl). If found by ``drake_visualizer``, the values in
the .mtl will take precedence over the ("phong", "diffuse") geometry
property.

It's worth emphasizing that these rules permits control over the
appearance of collision geometry on a per-geometry basis by assigning
an explicit Rgba value to the ("phong", "diffuse") property in the
geometry's ProximityProperties.

Note:
    If collision geometries are added to SceneGraph by parsing
    URDF/SDF files, they will not have diffuse values. Even if
    elements were added to the specification files, they would not be
    parsed. They must be added to the geometries after parsing.

**Effective visualization**

The best visualization is when draw messages have been preceded by a
compatible load message (i.e., a "coherent" message sequence). While
LCM doesn't guarantee that messages will be received/processed in the
same order as they are broadcast, your results will be best if
DrakeVisualizer is allowed to broadcast coherent messages. Practices
that interfere with that will likely produce undesirable results.
E.g.,

- Evaluating a single instance of DrakeVisualizer across several threads,
such that the data in the per-thread systems::Context varies.
- Evaluating multiple instances of DrakeVisualizer in a single thread that
share the same lcm::DrakeLcmInterface.

**Scalar support and conversion**

DrakeVisualizer is templated on ``T`` and can be used in a ``double``-
or AutoDiffXd-valued Diagram. However, the diagram can only be
converted from one scalar type to another if the DrakeVisualizer
*owns* its lcm::DrakeLcmInterface instance. Attempts to scalar convert
the system otherwise will throw an exception.)""";
        // Symbol: drake::geometry::DrakeVisualizer::AddToBuilder
        struct /* AddToBuilder */ {
          // Source: drake/geometry/drake_visualizer.h:180
          const char* doc_4args_builder_scene_graph_lcm_params =
R"""(Connects the newly added DrakeVisualizer to the given SceneGraph's
QueryObject-valued output port.)""";
          // Source: drake/geometry/drake_visualizer.h:186
          const char* doc_4args_builder_query_object_port_lcm_params =
R"""(Connects the newly added DrakeVisualizer to the given
QueryObject-valued output port.)""";
        } AddToBuilder;
        // Symbol: drake::geometry::DrakeVisualizer::DispatchLoadMessage
        struct /* DispatchLoadMessage */ {
          // Source: drake/geometry/drake_visualizer.h:203
          const char* doc =
R"""((Advanced) Dispatches a load message built on the *model* geometry for
the given SceneGraph instance. This should be used sparingly. When we
have a starightforward method for binding lcmtypes in python, this
will be replaced with an API that will simply generate the lcm
*messages* that the caller can then do whatever they like with.

Precondition:
    ``lcm != nullptr``.)""";
        } DispatchLoadMessage;
        // Symbol: drake::geometry::DrakeVisualizer::DrakeVisualizer<T>
        struct /* ctor */ {
          // Source: drake/geometry/drake_visualizer.h:144
          const char* doc =
R"""(Creates an instance of DrakeVisualizer.

Parameter ``lcm``:
    An optional LCM interface. If none is provided, this system will
    allocate its own instance. If one is provided it must remain valid
    for the lifetime of this object.

Parameter ``params``:
    The set of parameters to control this system's behavior.

Raises:
    RuntimeError if ``params.publish_period <= 0``.

Raises:
    RuntimeError if ``params.role == Role::kUnassigned``.)""";
          // Source: drake/geometry/drake_visualizer.h:152
          const char* doc_copyconvert =
R"""(Scalar-converting copy constructor. See system_scalar_conversion. It
should only be used to convert *from* double *to* other scalar types.

Raises:
    RuntimeError if ``other`` does not *own* its
    lcm::DrakeLcmInterface.)""";
        } ctor;
        // Symbol: drake::geometry::DrakeVisualizer::query_object_input_port
        struct /* query_object_input_port */ {
          // Source: drake/geometry/drake_visualizer.h:157
          const char* doc =
R"""(Returns the QueryObject-valued input port. It should be connected to
SceneGraph's QueryObject-valued output port. Failure to do so will
cause a runtime error when attempting to broadcast messages.)""";
        } query_object_input_port;
      } DrakeVisualizer;
      // Symbol: drake::geometry::DrakeVisualizerParams
      struct /* DrakeVisualizerParams */ {
        // Source: drake/geometry/drake_visualizer.h:26
        const char* doc =
R"""(The set of parameters for configuring DrakeVisualizer.)""";
        // Symbol: drake::geometry::DrakeVisualizerParams::default_color
        struct /* default_color */ {
          // Source: drake/geometry/drake_visualizer.h:35
          const char* doc =
R"""(The color to apply to any geometry that hasn't defined one.)""";
        } default_color;
        // Symbol: drake::geometry::DrakeVisualizerParams::publish_period
        struct /* publish_period */ {
          // Source: drake/geometry/drake_visualizer.h:29
          const char* doc =
R"""(The duration (in seconds) between published LCM messages that update
the poses of the scene's geometry.)""";
        } publish_period;
        // Symbol: drake::geometry::DrakeVisualizerParams::role
        struct /* role */ {
          // Source: drake/geometry/drake_visualizer.h:32
          const char* doc = R"""()""";
        } role;
      } DrakeVisualizerParams;
      // Symbol: drake::geometry::DrakeVisualizerd
      struct /* DrakeVisualizerd */ {
        // Source: drake/geometry/drake_visualizer.h:299
        const char* doc =
R"""(A convenient alias for the DrakeVisualizer class when using the
``double`` scalar type.)""";
      } DrakeVisualizerd;
      // Symbol: drake::geometry::Ellipsoid
      struct /* Ellipsoid */ {
        // Source: drake/geometry/shape_specification.h:199
        const char* doc =
R"""(Definition of an ellipsoid. It is centered on the origin of its
canonical frame with its dimensions aligned with the frame's axes. The
standard equation for the ellipsoid is:

x²/a² + y²/b² + z²/c² = 1, where a,b,c are the lengths of the
principal semi-axes of the ellipsoid. The bounding box of the
ellipsoid is [-a,a]x[-b,b]x[-c,c].)""";
        // Symbol: drake::geometry::Ellipsoid::Ellipsoid
        struct /* ctor */ {
          // Source: drake/geometry/shape_specification.h:207
          const char* doc =
R"""(Constructs an ellipsoid with the given lengths of its principal
semi-axes.

Raises:
    RuntimeError if ``a``, `b`, or ``c`` are not strictly positive.)""";
        } ctor;
        // Symbol: drake::geometry::Ellipsoid::a
        struct /* a */ {
          // Source: drake/geometry/shape_specification.h:209
          const char* doc = R"""()""";
        } a;
        // Symbol: drake::geometry::Ellipsoid::b
        struct /* b */ {
          // Source: drake/geometry/shape_specification.h:210
          const char* doc = R"""()""";
        } b;
        // Symbol: drake::geometry::Ellipsoid::c
        struct /* c */ {
          // Source: drake/geometry/shape_specification.h:211
          const char* doc = R"""()""";
        } c;
      } Ellipsoid;
      // Symbol: drake::geometry::FrameId
      struct /* FrameId */ {
        // Source: drake/geometry/geometry_ids.h:17
        const char* doc =
R"""(Type used to identify geometry frames in SceneGraph.)""";
      } FrameId;
      // Symbol: drake::geometry::FrameIdSet
      struct /* FrameIdSet */ {
        // Source: drake/geometry/geometry_state.h:49
        const char* doc = R"""(Collection of unique frame ids.)""";
      } FrameIdSet;
      // Symbol: drake::geometry::FrameIndex
      struct /* FrameIndex */ {
        // Source: drake/geometry/geometry_index.h:11
        const char* doc =
R"""(Index into the ordered vector of all registered frames -- by
convention, the world frame's index is always zero.)""";
      } FrameIndex;
      // Symbol: drake::geometry::FrameKinematicsVector
      struct /* FrameKinematicsVector */ {
        // Source: drake/geometry/frame_kinematics_vector.h:94
        const char* doc =
R"""(A FrameKinematicsVector is used to report kinematics data for
registered frames (identified by unique FrameId values) to SceneGraph.
It serves as the basis of FramePoseVector, FrameVelocityVector, and
FrameAccelerationVector.


::

    template <typename T>
    class MySystem : public LeafSystem<T> {
    public:
    MySystem() {
    ...
    this->DeclareAbstractOutputPort(
    &AllocInConstructorSystem::CalcFramePoseOutput);
    ...
    }
    
    private:
    void CalcFramePoseOutput(const Context<T>& context,
    geometry::FramePoseVector<T>* poses) const {
    poses->clear();
    for (int i = 0; i < static_cast<int>(frame_ids_.size()); ++i) {
    poses->set_value(frame_ids_[i], poses_[i]);
    }
    }
    
    std::vector<FrameId> frame_ids_;
    std::vector<RigidTransform<T>> poses_;
    };

If a System only ever emits a single frame (or small-constant-number
of frames), then there's a shorter alternative way to write a Calc
method, using an initializer_list:


::

    void CalcFramePoseOutput(const Context<T>& context,
    geometry::FramePoseVector<T>* poses) const {
    const RigidTransform<T>& pose = ...;
    poses = {{frame_id_, pose}};
    }

N.B. When the systems framework calls the ``Calc`` method, the value
pointed to by ``poses`` is in an unspecified state. The implementation
of ``Calc`` must always ensure that ``poses`` contains the correct
value upon return, no matter what value it started with. The easy ways
to do this are to call either ``poses->clear()`` or the assignment
operator ``*poses = ...``.

Template parameter ``KinematicsValue``:
    The underlying data type of for the order of kinematics data
    (e.g., pose, velocity, or acceleration).

One should never interact with the FrameKinematicsVector class
directly. Instead, the FramePoseVector, FrameVelocityVector, and
FrameAccelerationVector classes are aliases of the
FrameKinematicsVector instantiated on specific data types
(RigidTransform, SpatialVector, and SpatialAcceleration,
respectively). Each of these data types are templated on Eigen
scalars. All supported combinations of data type and scalar type are
already available to link against in the containing library. No other
values for KinematicsValue are supported.

Currently, the following data types with the following scalar types
are supported:

Alias | Instantiation | Scalar types
-----------------|-----------------------------------------------|-------------
FramePoseVector | FrameKinematicsVector<RigidTransform<Scalar>> |
double FramePoseVector | FrameKinematicsVector<RigidTransform<Scalar>>
| AutoDiffXd FramePoseVector |
FrameKinematicsVector<RigidTransform<Scalar>> | Expression)""";
        // Symbol: drake::geometry::FrameKinematicsVector::FrameKinematicsVector<KinematicsValue>
        struct /* ctor */ {
          // Source: drake/geometry/frame_kinematics_vector.h:99
          const char* doc_0args =
R"""(Initializes the vector using an invalid SourceId with no frames .)""";
          // Source: drake/geometry/frame_kinematics_vector.h:103
          const char* doc_1args =
R"""(Initializes the vector using an invalid SourceId and the given frames
and kinematics values.)""";
        } ctor;
        // Symbol: drake::geometry::FrameKinematicsVector::clear
        struct /* clear */ {
          // Source: drake/geometry/frame_kinematics_vector.h:111
          const char* doc =
R"""(Clears all values, resetting the size to zero.)""";
        } clear;
        // Symbol: drake::geometry::FrameKinematicsVector::frame_ids
        struct /* frame_ids */ {
          // Source: drake/geometry/frame_kinematics_vector.h:139
          const char* doc =
R"""(Provides a range object for all of the frame ids in the vector. This
is intended to be used as:


::

    for (FrameId id : this_vector.frame_ids()) {
    ...
    // Obtain the KinematicsValue of an id by ``this_vector.value(id)``
    ...
    })""";
        } frame_ids;
        // Symbol: drake::geometry::FrameKinematicsVector::has_id
        struct /* has_id */ {
          // Source: drake/geometry/frame_kinematics_vector.h:127
          const char* doc =
R"""(Reports true if the given id is a member of this data.)""";
        } has_id;
        // Symbol: drake::geometry::FrameKinematicsVector::set_value
        struct /* set_value */ {
          // Source: drake/geometry/frame_kinematics_vector.h:114
          const char* doc =
R"""(Sets the kinematics ``value`` for the frame indicated by the given
``id``.)""";
        } set_value;
        // Symbol: drake::geometry::FrameKinematicsVector::size
        struct /* size */ {
          // Source: drake/geometry/frame_kinematics_vector.h:117
          const char* doc = R"""(Returns number of frame_ids().)""";
        } size;
        // Symbol: drake::geometry::FrameKinematicsVector::value
        struct /* value */ {
          // Source: drake/geometry/frame_kinematics_vector.h:124
          const char* doc =
R"""(Returns the value associated with the given ``id``.

Raises:
    RuntimeError if ``id`` is not in the specified set of ids.)""";
        } value;
      } FrameKinematicsVector;
      // Symbol: drake::geometry::GeometryFrame
      struct /* GeometryFrame */ {
        // Source: drake/geometry/geometry_frame.h:30
        const char* doc =
R"""(This simple class carries the definition of a frame used in the
SceneGraph. To register moving frames with SceneGraph (see
SceneGraph::RegisterFrame()), a geometry source (see
SceneGraph::RegisterSource()) instantiates a frame and passes
ownership over to SceneGraph.

A frame is defined by two pieces of information:

- the name, which must be unique within a single geometry source and
- the "frame group", an integer identifier that can be used to group frames
together within a geometry source.

The "frame group" is intended as a generic synonym for the model
instance id defined by the RigidBodyTree.

See also:
    SceneGraph)""";
        // Symbol: drake::geometry::GeometryFrame::GeometryFrame
        struct /* ctor */ {
          // Source: drake/geometry/geometry_frame.h:39
          const char* doc =
R"""(Constructor.

Parameter ``frame_name``:
    The name of the frame.

Parameter ``frame_group_id``:
    The optional frame group identifier. If unspecified, defaults to
    the common, 0 group. Must be non-negative.)""";
        } ctor;
        // Symbol: drake::geometry::GeometryFrame::frame_group
        struct /* frame_group */ {
          // Source: drake/geometry/geometry_frame.h:55
          const char* doc = R"""()""";
        } frame_group;
        // Symbol: drake::geometry::GeometryFrame::id
        struct /* id */ {
          // Source: drake/geometry/geometry_frame.h:51
          const char* doc =
R"""(Returns the globally unique id for this geometry specification. Every
instantiation of FrameInstance will contain a unique id value. The id
value is preserved across copies. After successfully registering this
FrameInstance, this id will serve as the identifier for the registered
representation as well.)""";
        } id;
        // Symbol: drake::geometry::GeometryFrame::name
        struct /* name */ {
          // Source: drake/geometry/geometry_frame.h:53
          const char* doc = R"""()""";
        } name;
      } GeometryFrame;
      // Symbol: drake::geometry::GeometryId
      struct /* GeometryId */ {
        // Source: drake/geometry/geometry_ids.h:20
        const char* doc =
R"""(Type used to identify geometry instances in SceneGraph.)""";
        // Symbol: drake::geometry::GeometryId::GeometryId
        struct /* ctor */ {
          // Source: drake/geometry/geometry_ids.h:23
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::geometry::GeometryId::get_new_id
        struct /* get_new_id */ {
          // Source: drake/geometry/geometry_ids.h:27
          const char* doc = R"""()""";
        } get_new_id;
      } GeometryId;
      // Symbol: drake::geometry::GeometryInstance
      struct /* GeometryInstance */ {
        // Source: drake/geometry/geometry_instance.h:81
        const char* doc =
R"""(A geometry instance combines a geometry definition (i.e., a shape of
some sort), a pose (relative to a parent "frame" P), material
information, and an opaque collection of metadata. The parent frame
can be a registered frame or another registered geometry.

Every GeometryInstance must be named. The naming convention mirrors
that of valid names in SDF files. Specifically, any user-specified
name will have all leading and trailing space and tab characters
trimmed off. The trimmed name will have to satisfy the following
requirements:

- cannot be empty, and
- the name should be unique in the scope of its frame and role. For example,
two GeometryInstances can both be called "ball" as long as they are
affixed to different frames or if one is a collision geometry and the
other is an illustration geometry. This is enforced when a role is assigned
to the geometry.

If valid, the trimmed name will be assigned to the instance.

Names *can* have internal whitespace (e.g., "my geometry name").

**Canonicalized names**

The silent transformation of a user-defined name to canonical name
mirrors that of specifying geometry names in an SDF file. Consider the
following SDF snippet:


::

    {xml}
    ...
    <visual name="  visual">
    <geometry>
    <sphere>
    <radius>1.0</radius>
    </sphere>
    </geometry>
    </visual>
    ...

The name has two leading whitespace characters. The parsing process
will consider this name as equivalent to "visual" and tests for
uniqueness and non-emptiness will be applied to that trimmed result.
The following code has an analogous effect:


::

    scene_graph->RegisterGeometry(
    source_id, frame_id,
    make_unique<GeometryInstance>(pose, make_unique<Sphere>(1.0), "  visual"));

The specified name includes leading whitespace. That name will be
trimmed and the *result* will be stored in the GeometryInstance (to be
later validated by SceneGraph as part of geometry registration).
Querying the instance of its name will return this *canonicalized*
name.)""";
        // Symbol: drake::geometry::GeometryInstance::GeometryInstance
        struct /* ctor */ {
          // Source: drake/geometry/geometry_instance.h:91
          const char* doc =
R"""(Constructs a geometry instance specification.

Parameter ``X_PG``:
    The pose of this geometry (``G``) in its parent's frame (``P``).

Parameter ``shape``:
    The underlying shape for this geometry instance.

Parameter ``name``:
    The name of the geometry (must satisfy the name requirements).

Raises:
    RuntimeError if the canonicalized version of ``name`` is empty.)""";
        } ctor;
        // Symbol: drake::geometry::GeometryInstance::id
        struct /* id */ {
          // Source: drake/geometry/geometry_instance.h:99
          const char* doc =
R"""(Returns the globally unique id for this geometry specification. Every
instantiation of GeometryInstance will contain a unique id value. The
id value is preserved across copies. After successfully registering
this GeometryInstance, this id will serve as the identifier for the
registered representation as well.)""";
        } id;
        // Symbol: drake::geometry::GeometryInstance::illustration_properties
        struct /* illustration_properties */ {
          // Source: drake/geometry/geometry_instance.h:161
          const char* doc =
R"""(Returns a pointer to the geometry's const illustration properties (if
they are defined). Nullptr otherwise.)""";
        } illustration_properties;
        // Symbol: drake::geometry::GeometryInstance::mutable_illustration_properties
        struct /* mutable_illustration_properties */ {
          // Source: drake/geometry/geometry_instance.h:154
          const char* doc =
R"""(Returns a pointer to the geometry's mutable illustration properties
(if they are defined). Nullptr otherwise.)""";
        } mutable_illustration_properties;
        // Symbol: drake::geometry::GeometryInstance::mutable_perception_properties
        struct /* mutable_perception_properties */ {
          // Source: drake/geometry/geometry_instance.h:168
          const char* doc =
R"""(Returns a pointer to the geometry's mutable perception properties (if
they are defined). Nullptr otherwise.)""";
        } mutable_perception_properties;
        // Symbol: drake::geometry::GeometryInstance::mutable_proximity_properties
        struct /* mutable_proximity_properties */ {
          // Source: drake/geometry/geometry_instance.h:140
          const char* doc =
R"""(Returns a pointer to the geometry's mutable proximity properties (if
they are defined). Nullptr otherwise.)""";
        } mutable_proximity_properties;
        // Symbol: drake::geometry::GeometryInstance::name
        struct /* name */ {
          // Source: drake/geometry/geometry_instance.h:117
          const char* doc =
R"""(Returns the *canonicalized* name for the instance.

See also:
    canonicalized_geometry_names "Canonicalized names")""";
        } name;
        // Symbol: drake::geometry::GeometryInstance::perception_properties
        struct /* perception_properties */ {
          // Source: drake/geometry/geometry_instance.h:175
          const char* doc =
R"""(Returns a pointer to the geometry's const perception properties (if
they are defined). Nullptr otherwise.)""";
        } perception_properties;
        // Symbol: drake::geometry::GeometryInstance::pose
        struct /* pose */ {
          // Source: drake/geometry/geometry_instance.h:102
          const char* doc =
R"""(Returns the instance geometry's pose in its parent frame.)""";
        } pose;
        // Symbol: drake::geometry::GeometryInstance::proximity_properties
        struct /* proximity_properties */ {
          // Source: drake/geometry/geometry_instance.h:147
          const char* doc =
R"""(Returns a pointer to the geometry's const proximity properties (if
they are defined). Nullptr otherwise.)""";
        } proximity_properties;
        // Symbol: drake::geometry::GeometryInstance::release_shape
        struct /* release_shape */ {
          // Source: drake/geometry/geometry_instance.h:113
          const char* doc = R"""(Releases the shape from the instance.)""";
        } release_shape;
        // Symbol: drake::geometry::GeometryInstance::set_illustration_properties
        struct /* set_illustration_properties */ {
          // Source: drake/geometry/geometry_instance.h:129
          const char* doc =
R"""(Sets the illustration properties for the given instance.)""";
        } set_illustration_properties;
        // Symbol: drake::geometry::GeometryInstance::set_name
        struct /* set_name */ {
          // Source: drake/geometry/geometry_instance.h:121
          const char* doc =
R"""(Sets the *canonicalized* name for the instance.

See also:
    canonicalized_geometry_names "Canonicalized names")""";
        } set_name;
        // Symbol: drake::geometry::GeometryInstance::set_perception_properties
        struct /* set_perception_properties */ {
          // Source: drake/geometry/geometry_instance.h:134
          const char* doc =
R"""(Sets the perception properties for the given instance.)""";
        } set_perception_properties;
        // Symbol: drake::geometry::GeometryInstance::set_pose
        struct /* set_pose */ {
          // Source: drake/geometry/geometry_instance.h:105
          const char* doc =
R"""(Sets the pose of this instance in its parent's frame.)""";
        } set_pose;
        // Symbol: drake::geometry::GeometryInstance::set_proximity_properties
        struct /* set_proximity_properties */ {
          // Source: drake/geometry/geometry_instance.h:124
          const char* doc =
R"""(Sets the proximity properties for the given instance.)""";
        } set_proximity_properties;
        // Symbol: drake::geometry::GeometryInstance::shape
        struct /* shape */ {
          // Source: drake/geometry/geometry_instance.h:107
          const char* doc = R"""()""";
        } shape;
      } GeometryInstance;
      // Symbol: drake::geometry::GeometryProperties
      struct /* GeometryProperties */ {
        // Source: drake/geometry/geometry_properties.h:224
        const char* doc =
R"""(The base class for defining a set of geometry properties.

Each property consists of a ``(group, property)`` name-pair and a
typed value. The name pair allows for reuse of common property names
(e.g., "diffuse") to be differentiated in interpretation by
associating them with different groups. The only restriction on the
value type is that it must be either cloneable or copy-constructible.

A set of geometry property values are defined when geometry is
registered with SceneGraph by an instantiator and accessed by some
downstream consumer entity. Each consumer specifies what properties it
expects to find and what default values (if any) it provides. For
example, the consumer could document that a particular property is
always required and its absence would throw an exception.
Alternatively, it could indicate that a property is optional and a
default value will be used in its absence. It is the responsibility of
the instantiator to make sure that the geometry property values are
*correctly* defined according to the expected consumer's
specification. Correctness includes such issues as key-value pairs
placed into a *correctly*-spelled group, property keys being likewise
correctly spelled, and values of the expected type. Correct spelling
includes correct case. The instantiator uses the AddProperty() method
to add new properties to the set.

To read the property (``some_group``, `some_property`) from a property
set:

1. Optionally test to see if the property exists by confirming the group
``some_group`` is in the set via HasGroup() and that the property
``some_property`` is in ``some_group`` via HasProperty(). Attempting to access
a property with a non-existent (group, property) pair may lead to an
exception (see API documentation below).
2. Acquire a property value via the GetProperty() or GetPropertyOrDefault()
methods.
NOTE: Reading a property requires a compile-time declaration of the *type*
of value being read. If the stored value is of a different type, an
exception will be thrown.

Common workflows
----------------

The following examples outline a number of ways to create and consume
geometry properties. By design, GeometryProperties cannot be
constructed, copied, or moved directly. Only derived classes can do
so. This facilitates *strongly typed* sets of properties associated
with particular geometry roles. So, for these examples we'll exercise
the derived class associated with proximity queries:
ProximityProperties.

The string-based structure of GeometryProperties provides a great deal
of flexibility at the cost of spelling sensitivity. It would be easy
to introduce typos that would then "hide" property values in some
group a consumer wouldn't look. In these examples, we avoid using
string literals as group or property names (at least in the cases
where the same name is used multiple times) to help avoid the
possibility of typo-induced errors. That is not required and certainly
not the only way to avoid such bugs.

**Creating properties**

*Creating properties in a new group*

This is a simple example in which a single group is added with
properties of various types.


::

    const std::string group_name("my_group");
    ProximityProperties properties;
    // This first invocation implicitly creates the group "my_group".
    properties.AddProperty(group_name, "count", 7);     // int type
    properties.AddProperty(group_name, "length", 7.);   // double type
    properties.AddProperty(group_name, "name", "7");    // std::string type

*Creating properties in the default group*

Similar to the previous examples, the properties are added to the
default group. Just be aware that if multiple sites in your code add
properties to the default group, the possibility that names get
repeated increases. Property names *must* be unique within a single
group, including the default group.


::

    ProximityProperties properties;
    properties.AddProperty(ProximityProperties::default_group_name(), "count", 7);
    properties.AddProperty(ProximityProperties::default_group_name(), "width", 7.);
    properties.AddProperty(ProximityProperties::default_group_name(), "name", "7");

*Aggregate properties in a struct*

In some cases, there is a set of values that will *always* be accessed
together (specified with coordinated semantics). In these cases, it
makes sense to aggregate them into a struct and store that as a single
value. This reduces the number of lookups required.

It's worth noting, that if the data value is a struct, calls to
GetPropertyOrDefault() still operate as an "all-or-nothing" basis. If
the property *struct* exists, it will be returned, if it's missing the
default struct will be returned. There is no concept of a "partial"
struct in which some undefined values in the struct will be replaced
with their corresponding values in the default struct.


::

    struct MyData {
    int i{};
    double d{};
    std::string s;
    };
    
    ProximityProperties properties;
    const std::string group_name("my_group");
    MyData data{7, 7., "7"};
    properties.AddProperty(group_name, "data1", data);
    // These alternate forms are also acceptable (but not in succession, as the
    // property name has already been used by the first invocation).
    properties.AddProperty(group_name, "data2", MyData{6, 6., "6"});
    properties.AddProperty<MyData>(group_name, "data2", {6, 6., "6"});

**Reading properties**

This section describes how to read properties under several different
scenarios: (a) when specific properties are required, (b) when the
consumer provides a default value for missing properties, and (c) when
the consumer needs to inspect what properties are available.

*Look up specific, *required* properties*

In this case, the consumer of the properties is looking for one or
more specific properties. It will ignore any other properties. More
particularly, if those properties are missing, it is considered a
runtime error and an exception is thrown.

The error can be handled in one of two ways: simply let the generic
exception generated by GeometryProperties propagate upward, or detect
the missing property and throw an exception with a custom message. The
example below shows both approaches.


::

    const IllustrationProperties& properties = FunctionThatReturnsProperties();
    // Looking for a Rgba of rgba colors named "rgba" - send generic error that
    // the property set is missing the required property.
    const Rgba rgba =
    properties.GetProperty<Rgba>("MyGroup", "rgba");
    
    // Explicitly detect missing property and throw exception with custom message.
    if (!properties.HasProperty("MyGroup", "rgba")) {
    throw RuntimeError(
    "ThisClass: Missing the necessary 'rgba' property; the object cannot be "
    "rendered");
    }
    // Otherwise acquire value, confident that no exception will be thrown.
    const Rgba rgba =
    properties.GetProperty<Rgba>("MyGroup", "rgba");

Note:
    calls to ``GetProperty()`` always require the return type template
    value (e.g., ``Rgba``) to be specified in the call.

*Look up specific properties with default property values*

As with the previous case, the consumer is looking for one or more
specific properties. However, in this case, the consumer provides a
default value to use in case the target property is not defined. In
this invocation, the template parameter need not be explicitly
declared -- the inferred return type will be the same as the default
value.


::

    const IllustrationProperties& properties = FunctionThatReturnsProperties();
    // Looking for a Rgba of rgba colors named "rgba".
    const Rgba default_color{0.9, 0.9, 0.9};
    const Rgba rgba =
    properties.GetPropertyOrDefault("MyGroup", "rgba", default_color);

Alternatively, the default value can be provided in one of the
following forms:


::

    properties.GetPropertyOrDefault("MyGroup", "rgba",
    Rgba{0.9, 0.9, 0.9});
    properties.GetPropertyOrDefault<Rgba>("MyGroup", "rgba",
    {0.9, 0.9, 0.9});

*Iterating through provided properties*

Another alternative is to iterate through the properties that *have*
been provided. This might be done for several reasons, e.g.:

- the consumer wants to validate the set of properties, giving the user
feedback if an unsupported property has been provided, and/or
- the consumer has a default value for every property and allows the
registering code to define only those properties that deviate from the
specified default.

Working with properties in this manner requires knowledge of how to
work with AbstractValue.


::

    const IllustrationProperties& properties = FunctionThatReturnsProperties();
    for (const auto& pair : properties.GetGroupProperties("MyGroup") {
    const std::string& name = pair.first;
    if (name == "rgba") {
    // Throws an exception if the named parameter is of the wrong type.
    const Rgba& rgba =
    pair.second->GetValueOrThrow<Rgba>();
    }
    })""";
        // Symbol: drake::geometry::GeometryProperties::AddProperty
        struct /* AddProperty */ {
          // Source: drake/geometry/geometry_properties.h:258
          const char* doc =
R"""(Adds the named property (``group_name``, `name`) with the given
``value``. Adds the group if it doesn't already exist.

Parameter ``group_name``:
    The group name.

Parameter ``name``:
    The name of the property -- must be unique in the group.

Parameter ``value``:
    The value to assign to the property.

Raises:
    RuntimeError if the property already exists.

Template parameter ``ValueType``:
    The type of data to store with the attribute -- must be copy
    constructible or cloneable (see Value).)""";
        } AddProperty;
        // Symbol: drake::geometry::GeometryProperties::AddPropertyAbstract
        struct /* AddPropertyAbstract */ {
          // Source: drake/geometry/geometry_properties.h:291
          const char* doc =
R"""(Adds the named property (``group_name``, `name`) with the given
type-erased ``value``. Adds the group if it doesn't already exist.

Parameter ``group_name``:
    The group name.

Parameter ``name``:
    The name of the property -- must be unique in the group.

Parameter ``value``:
    The value to assign to the property.

Raises:
    RuntimeError if the property already exists.)""";
        } AddPropertyAbstract;
        // Symbol: drake::geometry::GeometryProperties::GeometryProperties
        struct /* ctor */ {
          // Source: drake/geometry/geometry_properties.h:442
          const char* doc =
R"""(Constructs a property set with the default group. Only invoked by
final subclasses.)""";
        } ctor;
        // Symbol: drake::geometry::GeometryProperties::GetGroupNames
        struct /* GetGroupNames */ {
          // Source: drake/geometry/geometry_properties.h:246
          const char* doc = R"""(Returns all of the defined group names.)""";
        } GetGroupNames;
        // Symbol: drake::geometry::GeometryProperties::GetPropertiesInGroup
        struct /* GetPropertiesInGroup */ {
          // Source: drake/geometry/geometry_properties.h:243
          const char* doc =
R"""(Retrieves the indicated property group. The returned group is valid
for as long as this instance.

Raises:
    RuntimeError if there is no group with the given name.)""";
        } GetPropertiesInGroup;
        // Symbol: drake::geometry::GeometryProperties::GetProperty
        struct /* GetProperty */ {
          // Source: drake/geometry/geometry_properties.h:331
          const char* doc =
R"""(Retrieves the typed value for the property (``group_name``, `name`)
from this set of properties.

Parameter ``group_name``:
    The name of the group to which the property belongs.

Parameter ``name``:
    The name of the desired property.

Raises:
    RuntimeError if a) the group name is invalid, b) the property name
    is invalid, or c) the property type is not that specified.

Template parameter ``ValueType``:
    The expected type of the desired property.

Returns:
    const ValueType& of stored value. If ValueType is Eigen::Vector4d,
    the return type will be a copy translated from Rgba.)""";
        } GetProperty;
        // Symbol: drake::geometry::GeometryProperties::GetPropertyAbstract
        struct /* GetPropertyAbstract */ {
          // Source: drake/geometry/geometry_properties.h:352
          const char* doc =
R"""(Retrieves the type-erased value for the property (``group_name``,
`name`) from this set of properties.

Parameter ``group_name``:
    The name of the group to which the property belongs.

Parameter ``name``:
    The name of the desired property.

Raises:
    RuntimeError if a) the group name is invalid, or b) the property
    name is invalid.)""";
        } GetPropertyAbstract;
        // Symbol: drake::geometry::GeometryProperties::GetPropertyOrDefault
        struct /* GetPropertyOrDefault */ {
          // Source: drake/geometry/geometry_properties.h:380
          const char* doc =
R"""(Retrieves the typed value for the property (``group_name``, `name`)
from the set of properties (if it exists), otherwise returns the given
default value. The given ``default_value`` is returned only if the
property is missing. If the property exists and is of a *different*
type, an exception will be thrown. If it is of the expected type, the
stored value will be returned.

Generally, it is unnecessary to explicitly declare the ``ValueType``
of the property value; it will be inferred from the provided default
value. Sometimes it is convenient to provide the default value in a
form that can be implicitly converted to the final type. In that case,
it is necessary to explicitly declare the desired ``ValueType`` so the
compiler does not infer the wrong type, e.g.:


::

    // Note the *integer* value as default value.
    const double my_value = properties.GetPropertyOrDefault<double>("g", "p", 2);

Parameter ``group_name``:
    The name of the group to which the property belongs.

Parameter ``name``:
    The name of the desired property.

Parameter ``default_value``:
    The alternate value to return if the property cannot be acquired.

Raises:
    RuntimeError if a property of the given name exists but is not of
    ``ValueType``.)""";
        } GetPropertyOrDefault;
        // Symbol: drake::geometry::GeometryProperties::Group
        struct /* Group */ {
          // Source: drake/geometry/geometry_properties.h:229
          const char* doc =
R"""(The properties for a single group as a property name-value map.)""";
        } Group;
        // Symbol: drake::geometry::GeometryProperties::HasGroup
        struct /* HasGroup */ {
          // Source: drake/geometry/geometry_properties.h:233
          const char* doc =
R"""(Reports if the given named group is part of this property set.)""";
        } HasGroup;
        // Symbol: drake::geometry::GeometryProperties::HasProperty
        struct /* HasProperty */ {
          // Source: drake/geometry/geometry_properties.h:314
          const char* doc =
R"""(Reports if the property (``group_name``, `name`) exists in the group.

Parameter ``group_name``:
    The name of the group to which the tested property should belong.

Parameter ``name``:
    The name of the property under question.

Returns:
    true iff the group exists and a property with the given ``name``
    exists in that group.)""";
        } HasProperty;
        // Symbol: drake::geometry::GeometryProperties::RemoveProperty
        struct /* RemoveProperty */ {
          // Source: drake/geometry/geometry_properties.h:412
          const char* doc =
R"""(Removes the (``group_name``, `name`) property (if it exists). Upon
completion the property will not be in the set.

Returns:
    ``True`` if the property existed prior to the call.)""";
        } RemoveProperty;
        // Symbol: drake::geometry::GeometryProperties::UpdateProperty
        struct /* UpdateProperty */ {
          // Source: drake/geometry/geometry_properties.h:279
          const char* doc =
R"""(Updates the named property (``group_name``, `name`) with the given
``value``. If the property doesn't already exist, it is equivalent to
calling ``AddProperty``. If the property does exist, its value (which
must have the same type as ``value``) will be replaced.

Parameter ``group_name``:
    The group name.

Parameter ``name``:
    The name of the property -- must be unique in the group.

Parameter ``value``:
    The value to assign to the property.

Raises:
    RuntimeError if the property exists with a different type.

Template parameter ``ValueType``:
    The type of data to store with the attribute -- must be copy
    constructible or cloneable (see Value).)""";
        } UpdateProperty;
        // Symbol: drake::geometry::GeometryProperties::UpdatePropertyAbstract
        struct /* UpdatePropertyAbstract */ {
          // Source: drake/geometry/geometry_properties.h:303
          const char* doc =
R"""(Updates the named property (``group_name``, `name`) with the given
type-erased ``value``. If the property doesn't already exist, it is
equivalent to calling ``AddPropertyAbstract``. If the property does
exist, its value (which must have the same type as ``value``) will be
replaced.

Parameter ``group_name``:
    The group name.

Parameter ``name``:
    The name of the property -- must be unique in the group.

Parameter ``value``:
    The value to assign to the property.

Raises:
    RuntimeError if the property exists with a different type.)""";
        } UpdatePropertyAbstract;
        // Symbol: drake::geometry::GeometryProperties::default_group_name
        struct /* default_group_name */ {
          // Source: drake/geometry/geometry_properties.h:404
          const char* doc =
R"""(Returns the default group name. There is no guarantee as to *what*
string corresponds to the default group. Therefore it should always be
accessed via this method.)""";
        } default_group_name;
        // Symbol: drake::geometry::GeometryProperties::num_groups
        struct /* num_groups */ {
          // Source: drake/geometry/geometry_properties.h:238
          const char* doc =
R"""(Reports the number of property groups in this set.)""";
        } num_groups;
      } GeometryProperties;
      // Symbol: drake::geometry::GeometrySet
      struct /* GeometrySet */ {
        // Source: drake/geometry/geometry_set.h:36
        const char* doc =
R"""(The GeometrySet, as its name implies, is a convenience class for
defining a set of geometries. What makes it unique from a simple
``std::set<GeometryId>`` instance is that membership doesn't require
explicit GeometryId enumeration; GeometryId values can be added to the
set by adding the ``FrameId`` for the frame to which the geometries
are rigidly affixed.

This class does no validation; it is a simple collection. Ultimately,
it serves as the operand of SceneGraph operations (e.g.,
SceneGraph::ExcludeCollisionsWithin()). If the *operation* has a
particular prerequisite on the members of a GeometrySet, it is the
operation's responsibility to enforce that requirement.

More formally, the SceneGraph consists of a set of geometries, each
associated with a unique identifier. As such, we can consider the set
of all identifiers ``SG = {g₀, g₁, ..., gₙ}`` that belong to a
SceneGraph. A GeometrySet should represent a subset of those
identifiers, ``Gₛ ⊆ SG``. The convenience of the GeometrySet class is
*how* the subset is defined. Given a set of frame ids ``F = {f₀, f₁,
..., fₙ}`` and geometry ids ``G = {g₀, g₁, ..., gₘ}``, `Gₛ = G ⋃
geometry(f₀) ⋃ ... ⋃ geometry(fₙ)` (where ``geometry(f)`` is the set
of geometries rigidly affixed to frame f).)""";
        // Symbol: drake::geometry::GeometrySet::Add
        struct /* Add */ {
          // Source: drake/geometry/geometry_set.h:189
          const char* doc = R"""()""";
        } Add;
        // Symbol: drake::geometry::GeometrySet::GeometrySet
        struct /* ctor */ {
          // Source: drake/geometry/geometry_set.h:38
          const char* doc = R"""()""";
        } ctor;
      } GeometrySet;
      // Symbol: drake::geometry::GeometryState
      struct /* GeometryState */ {
        // Source: drake/geometry/geometry_state.h:68
        const char* doc =
R"""(The context-dependent state of SceneGraph. This serves as an
AbstractValue in the context. SceneGraph's time-dependent state
includes more than just values; objects can be added to or removed
from the world over time. Therefore, SceneGraph's context-dependent
state includes values (the poses) and structure (the topology of the
world).

Note:
    This is intended as an internal class only.)""";
        // Symbol: drake::geometry::GeometryState::AddRenderer
        struct /* AddRenderer */ {
          // Source: drake/geometry/geometry_state.h:478
          const char* doc =
R"""(Implementation of SceneGraph::AddRenderer().)""";
        } AddRenderer;
        // Symbol: drake::geometry::GeometryState::AssignRole
        struct /* AssignRole */ {
          // Source: drake/geometry/geometry_state.h:320
          const char* doc_was_unable_to_choose_unambiguous_names =
R"""(Implementation of SceneGraph::AssignRole(SourceId, GeometryId,
ProximityProperties) "SceneGraph::AssignRole()".)""";
        } AssignRole;
        // Symbol: drake::geometry::GeometryState::BelongsToSource
        struct /* BelongsToSource */ {
          // Source: drake/geometry/geometry_state.h:162
          const char* doc_2args_frame_id_source_id =
R"""(Implementation of SceneGraphInspector::BelongsToSource(FrameId,
SourceId) const.)""";
          // Source: drake/geometry/geometry_state.h:203
          const char* doc_2args_geometry_id_source_id =
R"""(Implementation of SceneGraphInspector::BelongsToSource(GeometryId,
SourceId) const.)""";
        } BelongsToSource;
        // Symbol: drake::geometry::GeometryState::CollisionFiltered
        struct /* CollisionFiltered */ {
          // Source: drake/geometry/geometry_state.h:236
          const char* doc =
R"""(Implementation of SceneGraphInspector::CollisionFiltered().)""";
        } CollisionFiltered;
        // Symbol: drake::geometry::GeometryState::ComputeContactSurfaces
        struct /* ComputeContactSurfaces */ {
          // Source: drake/geometry/geometry_state.h:392
          const char* doc =
R"""(Implementation of QueryObject::ComputeContactSurfaces().)""";
        } ComputeContactSurfaces;
        // Symbol: drake::geometry::GeometryState::ComputeContactSurfacesWithFallback
        struct /* ComputeContactSurfacesWithFallback */ {
          // Source: drake/geometry/geometry_state.h:397
          const char* doc =
R"""(Implementation of QueryObject::ComputeContactSurfacesWithFallback().)""";
        } ComputeContactSurfacesWithFallback;
        // Symbol: drake::geometry::GeometryState::ComputePointPairPenetration
        struct /* ComputePointPairPenetration */ {
          // Source: drake/geometry/geometry_state.h:387
          const char* doc =
R"""(Implementation of QueryObject::ComputePointPairPenetration().)""";
        } ComputePointPairPenetration;
        // Symbol: drake::geometry::GeometryState::ComputeSignedDistancePairClosestPoints
        struct /* ComputeSignedDistancePairClosestPoints */ {
          // Source: drake/geometry/geometry_state.h:457
          const char* doc =
R"""(Implementation of
QueryObject::ComputeSignedDistancePairClosestPoints().)""";
        } ComputeSignedDistancePairClosestPoints;
        // Symbol: drake::geometry::GeometryState::ComputeSignedDistancePairwiseClosestPoints
        struct /* ComputeSignedDistancePairwiseClosestPoints */ {
          // Source: drake/geometry/geometry_state.h:449
          const char* doc =
R"""(Implementation of
QueryObject::ComputeSignedDistancePairwiseClosestPoints().)""";
        } ComputeSignedDistancePairwiseClosestPoints;
        // Symbol: drake::geometry::GeometryState::ComputeSignedDistanceToPoint
        struct /* ComputeSignedDistanceToPoint */ {
          // Source: drake/geometry/geometry_state.h:464
          const char* doc =
R"""(Implementation of QueryObject::ComputeSignedDistanceToPoint().)""";
        } ComputeSignedDistanceToPoint;
        // Symbol: drake::geometry::GeometryState::ExcludeCollisionsBetween
        struct /* ExcludeCollisionsBetween */ {
          // Source: drake/geometry/geometry_state.h:435
          const char* doc =
R"""(Implementation of SceneGraph::ExcludeCollisionsBetween().)""";
        } ExcludeCollisionsBetween;
        // Symbol: drake::geometry::GeometryState::ExcludeCollisionsWithin
        struct /* ExcludeCollisionsWithin */ {
          // Source: drake/geometry/geometry_state.h:432
          const char* doc =
R"""(Implementation of SceneGraph::ExcludeCollisionsWithin().)""";
        } ExcludeCollisionsWithin;
        // Symbol: drake::geometry::GeometryState::FindCollisionCandidates
        struct /* FindCollisionCandidates */ {
          // Source: drake/geometry/geometry_state.h:407
          const char* doc =
R"""(Implementation of QueryObject::FindCollisionCandidates().)""";
        } FindCollisionCandidates;
        // Symbol: drake::geometry::GeometryState::FrameIdRange
        struct /* FrameIdRange */ {
          // Source: drake/geometry/geometry_state.h:74
          const char* doc =
R"""(An object that represents the range of FrameId values in the state. It
is used in range-based for loops to iterate through registered frames.)""";
        } FrameIdRange;
        // Symbol: drake::geometry::GeometryState::FramesForSource
        struct /* FramesForSource */ {
          // Source: drake/geometry/geometry_state.h:153
          const char* doc =
R"""(Implementation of SceneGraphInspector::FramesForSource().)""";
        } FramesForSource;
        // Symbol: drake::geometry::GeometryState::GeometryState<T>
        struct /* ctor */ {
          // Source: drake/geometry/geometry_state.h:77
          const char* doc = R"""(Default constructor.)""";
        } ctor;
        // Symbol: drake::geometry::GeometryState::GetAllGeometryIds
        struct /* GetAllGeometryIds */ {
          // Source: drake/geometry/geometry_state.h:113
          const char* doc =
R"""(Implementation of SceneGraphInspector::GetAllGeometryIds().)""";
        } GetAllGeometryIds;
        // Symbol: drake::geometry::GeometryState::GetCollisionCandidates
        struct /* GetCollisionCandidates */ {
          // Source: drake/geometry/geometry_state.h:132
          const char* doc =
R"""(Implementation of SceneGraphInspector::GetCollisionCandidates().)""";
        } GetCollisionCandidates;
        // Symbol: drake::geometry::GeometryState::GetFrameGroup
        struct /* GetFrameGroup */ {
          // Source: drake/geometry/geometry_state.h:172
          const char* doc =
R"""(Implementation of SceneGraphInspector::GetFrameGroup().)""";
        } GetFrameGroup;
        // Symbol: drake::geometry::GeometryState::GetFrameId
        struct /* GetFrameId */ {
          // Source: drake/geometry/geometry_state.h:210
          const char* doc =
R"""(Implementation of SceneGraphInspector::GetFrameId().)""";
        } GetFrameId;
        // Symbol: drake::geometry::GeometryState::GetGeometries
        struct /* GetGeometries */ {
          // Source: drake/geometry/geometry_state.h:182
          const char* doc =
R"""(Implementation of SceneGraphInspector::GetGeometries.)""";
        } GetGeometries;
        // Symbol: drake::geometry::GeometryState::GetGeometryIdByName
        struct /* GetGeometryIdByName */ {
          // Source: drake/geometry/geometry_state.h:193
          const char* doc =
R"""(Implementation of SceneGraphInspector::GetGeometryIdByName().)""";
        } GetGeometryIdByName;
        // Symbol: drake::geometry::GeometryState::GetIllustrationProperties
        struct /* GetIllustrationProperties */ {
          // Source: drake/geometry/geometry_state.h:230
          const char* doc =
R"""(Implementation of SceneGraphInspector::GetIllustrationProperties().)""";
        } GetIllustrationProperties;
        // Symbol: drake::geometry::GeometryState::GetName
        struct /* GetName */ {
          // Source: drake/geometry/geometry_state.h:147
          const char* doc_1args_id =
R"""(Implementation of SceneGraphInspector::GetName().)""";
          // Source: drake/geometry/geometry_state.h:169
          const char* doc_1args_frame_id =
R"""(Implementation of SceneGraphInspector::GetName(FrameId) const.)""";
          // Source: drake/geometry/geometry_state.h:213
          const char* doc_1args_geometry_id =
R"""(Implementation of SceneGraphInspector::GetName(GeometryId) const.)""";
        } GetName;
        // Symbol: drake::geometry::GeometryState::GetOwningSourceName
        struct /* GetOwningSourceName */ {
          // Source: drake/geometry/geometry_state.h:166
          const char* doc_was_unable_to_choose_unambiguous_names =
R"""(Implementation of SceneGraphInspector::GetOwningSourceName(FrameId)
const.)""";
        } GetOwningSourceName;
        // Symbol: drake::geometry::GeometryState::GetPerceptionProperties
        struct /* GetPerceptionProperties */ {
          // Source: drake/geometry/geometry_state.h:233
          const char* doc =
R"""(Implementation of SceneGraphInspector::GetPerceptionProperties().)""";
        } GetPerceptionProperties;
        // Symbol: drake::geometry::GeometryState::GetPoseInFrame
        struct /* GetPoseInFrame */ {
          // Source: drake/geometry/geometry_state.h:219
          const char* doc =
R"""(Implementation of SceneGraphInspector::X_FG().)""";
        } GetPoseInFrame;
        // Symbol: drake::geometry::GeometryState::GetPoseInParent
        struct /* GetPoseInParent */ {
          // Source: drake/geometry/geometry_state.h:223
          const char* doc =
R"""(Implementation of SceneGraphInspector::X_PG().)""";
        } GetPoseInParent;
        // Symbol: drake::geometry::GeometryState::GetProximityProperties
        struct /* GetProximityProperties */ {
          // Source: drake/geometry/geometry_state.h:227
          const char* doc =
R"""(Implementation of SceneGraphInspector::GetProximityProperties().)""";
        } GetProximityProperties;
        // Symbol: drake::geometry::GeometryState::GetRenderEngineByName
        struct /* GetRenderEngineByName */ {
          // Source: drake/geometry/geometry_state.h:487
          const char* doc =
R"""(Implementation of QueryObject::GetRenderEngineByName.)""";
        } GetRenderEngineByName;
        // Symbol: drake::geometry::GeometryState::GetShape
        struct /* GetShape */ {
          // Source: drake/geometry/geometry_state.h:216
          const char* doc =
R"""(Support for SceneGraphInspector::Reify().)""";
        } GetShape;
        // Symbol: drake::geometry::GeometryState::HasCollisions
        struct /* HasCollisions */ {
          // Source: drake/geometry/geometry_state.h:412
          const char* doc =
R"""(Implementation of QueryObject::HasCollisions().)""";
        } HasCollisions;
        // Symbol: drake::geometry::GeometryState::HasRenderer
        struct /* HasRenderer */ {
          // Source: drake/geometry/geometry_state.h:482
          const char* doc =
R"""(Implementation of SceneGraph::HasRenderer().)""";
        } HasRenderer;
        // Symbol: drake::geometry::GeometryState::IsValidGeometryName
        struct /* IsValidGeometryName */ {
          // Source: drake/geometry/geometry_state.h:314
          const char* doc =
R"""(Reports whether the canonicalized version of the given candidate
geometry name is considered valid. This tests the requirements
described in the documentation of canonicalized_geometry_names
"GeometryInstance". When adding a geometry to a frame, if there is
doubt if a proposed name is valid, the name can be tested prior to
registering the geometry.

Parameter ``frame_id``:
    The id of the frame to which the geometry would be assigned.

Parameter ``role``:
    The role for the candidate name.

Parameter ``candidate_name``:
    The name to validate.

Returns:
    true if the ``candidate_name`` can be given to a
    ``GeometryInstance`` assigned to the indicated frame with the
    indicated role.

Raises:
    RuntimeError if ``frame_id`` does not refer to a valid frame.)""";
        } IsValidGeometryName;
        // Symbol: drake::geometry::GeometryState::NumAnchoredGeometries
        struct /* NumAnchoredGeometries */ {
          // Source: drake/geometry/geometry_state.h:129
          const char* doc =
R"""(Implementation of SceneGraphInspector::NumAnchoredGeometries().)""";
        } NumAnchoredGeometries;
        // Symbol: drake::geometry::GeometryState::NumDynamicGeometries
        struct /* NumDynamicGeometries */ {
          // Source: drake/geometry/geometry_state.h:126
          const char* doc =
R"""(Implementation of SceneGraphInspector::NumDynamicGeometries().)""";
        } NumDynamicGeometries;
        // Symbol: drake::geometry::GeometryState::NumFramesForSource
        struct /* NumFramesForSource */ {
          // Source: drake/geometry/geometry_state.h:150
          const char* doc =
R"""(Implementation of SceneGraphInspector::NumFramesForSource().)""";
        } NumFramesForSource;
        // Symbol: drake::geometry::GeometryState::NumGeometriesForFrame
        struct /* NumGeometriesForFrame */ {
          // Source: drake/geometry/geometry_state.h:175
          const char* doc =
R"""(Implementation of SceneGraphInspector::NumGeometriesForFrame().)""";
        } NumGeometriesForFrame;
        // Symbol: drake::geometry::GeometryState::NumGeometriesForFrameWithRole
        struct /* NumGeometriesForFrameWithRole */ {
          // Source: drake/geometry/geometry_state.h:179
          const char* doc =
R"""(Implementation of
SceneGraphInspector::NumGeometriesForFrameWithRole().)""";
        } NumGeometriesForFrameWithRole;
        // Symbol: drake::geometry::GeometryState::NumGeometriesWithRole
        struct /* NumGeometriesWithRole */ {
          // Source: drake/geometry/geometry_state.h:123
          const char* doc_1args =
R"""(Implementation of SceneGraphInspector::NumGeometriesWithRole().)""";
          // Source: drake/geometry/geometry_state.h:190
          const char* doc_2args =
R"""(Reports the number of child geometries for this frame that have the
indicated role assigned. This only includes the immediate child
geometries of this* frame, and not those of child frames.

Raises:
    RuntimeError if the ``frame_id`` does not map to a valid frame.)""";
        } NumGeometriesWithRole;
        // Symbol: drake::geometry::GeometryState::RegisterAnchoredGeometry
        struct /* RegisterAnchoredGeometry */ {
          // Source: drake/geometry/geometry_state.h:296
          const char* doc =
R"""(Implementation of SceneGraph::RegisterAnchoredGeometry().)""";
        } RegisterAnchoredGeometry;
        // Symbol: drake::geometry::GeometryState::RegisterFrame
        struct /* RegisterFrame */ {
          // Source: drake/geometry/geometry_state.h:270
          const char* doc_2args =
R"""(Implementation of SceneGraph::RegisterFrame().)""";
          // Source: drake/geometry/geometry_state.h:275
          const char* doc_3args =
R"""(Implementation of SceneGraph::RegisterFrame(SourceId,FrameId,const
GeometryFrame&) "SceneGraph::RegisterFrame()" with parent FrameId.)""";
        } RegisterFrame;
        // Symbol: drake::geometry::GeometryState::RegisterGeometry
        struct /* RegisterGeometry */ {
          // Source: drake/geometry/geometry_state.h:282
          const char* doc =
R"""(Implementation of SceneGraph::RegisterGeometry(SourceId,FrameId,
std::unique_ptr<GeometryInstance>) "SceneGraph::RegisterGeometry()"
with parent FrameId.)""";
        } RegisterGeometry;
        // Symbol: drake::geometry::GeometryState::RegisterGeometryWithParent
        struct /* RegisterGeometryWithParent */ {
          // Source: drake/geometry/geometry_state.h:289
          const char* doc =
R"""(Implementation of SceneGraph::RegisterGeometry(SourceId,GeometryId,
std::unique_ptr<GeometryInstance>) "SceneGraph::RegisterGeometry()"
with parent GeometryId.)""";
        } RegisterGeometryWithParent;
        // Symbol: drake::geometry::GeometryState::RegisterNewSource
        struct /* RegisterNewSource */ {
          // Source: drake/geometry/geometry_state.h:267
          const char* doc =
R"""(Implementation of SceneGraph::RegisterSource(). The default logic is
to define name as "Source_##" where the number is the value of the
returned SourceId.)""";
        } RegisterNewSource;
        // Symbol: drake::geometry::GeometryState::RegisteredRendererNames
        struct /* RegisteredRendererNames */ {
          // Source: drake/geometry/geometry_state.h:499
          const char* doc =
R"""(Implementation of SceneGraph::RegisteredRendererNames().)""";
        } RegisteredRendererNames;
        // Symbol: drake::geometry::GeometryState::RemoveFromRenderer
        struct /* RemoveFromRenderer */ {
          // Source: drake/geometry/geometry_state.h:365
          const char* doc_3args_renderer_name_source_id_frame_id =
R"""(For every geometry directly registered to the frame with the given
``frame_id``, if it has been added to the renderer with the given
``renderer_name`` it is removed from that renderer.

Returns:
    The number of geometries affected by the removal.

Raises:
    RuntimeError if a) ``source_id`` does not map to a registered
    source, b) ``frame_id`` does not map to a registered frame, c)
    ``frame_id`` does not belong to ``source_id`` (unless ``frame_id``
    is the world frame id), or d) the context has already been
    allocated.)""";
          // Source: drake/geometry/geometry_state.h:377
          const char* doc_3args_renderer_name_source_id_geometry_id =
R"""(Removes the geometry with the given ``geometry_id`` from the renderer
with the given ``renderer_name``, *if* it has previously been added.

Returns:
    The number of geometries affected by the removal (0 or 1).

Raises:
    RuntimeError if a) ``source_id`` does not map to a registered
    source, b) ``geometry_id`` does not map to a registered geometry,
    c) ``geometry_id`` does not belong to ``source_id``, or d) the
    context has already been allocated.)""";
        } RemoveFromRenderer;
        // Symbol: drake::geometry::GeometryState::RemoveGeometry
        struct /* RemoveGeometry */ {
          // Source: drake/geometry/geometry_state.h:300
          const char* doc =
R"""(Implementation of SceneGraph::RemoveGeometry().)""";
        } RemoveGeometry;
        // Symbol: drake::geometry::GeometryState::RemoveRole
        struct /* RemoveRole */ {
          // Source: drake/geometry/geometry_state.h:341
          const char* doc_3args_source_id_frame_id_role =
R"""(Implementation of SceneGraph::RemoveRole(SourceId, FrameId, Role)
"SceneGraph::RemoveRole()".)""";
          // Source: drake/geometry/geometry_state.h:346
          const char* doc_3args_source_id_geometry_id_role =
R"""(Implementation of SceneGraph::RemoveRole(SourceId, GeometryId, Role)
"SceneGraph::RemoveRole()".)""";
        } RemoveRole;
        // Symbol: drake::geometry::GeometryState::RenderColorImage
        struct /* RenderColorImage */ {
          // Source: drake/geometry/geometry_state.h:508
          const char* doc_deprecated =
R"""(Implementation of QueryObject::RenderColorImage().

Precondition:
    All poses have already been updated. */ (Deprecated.)

Deprecated:
    CameraProperties are being deprecated. Please use the
    ColorRenderCamera variant. This will be removed from Drake on or
    after 2021-04-01.)""";
          // Source: drake/geometry/geometry_state.h:536
          const char* doc =
R"""(Implementation of QueryObject::RenderColorImage().

Precondition:
    All poses have already been updated.)""";
        } RenderColorImage;
        // Symbol: drake::geometry::GeometryState::RenderDepthImage
        struct /* RenderDepthImage */ {
          // Source: drake/geometry/geometry_state.h:518
          const char* doc_deprecated =
R"""(Implementation of QueryObject::RenderDepthImage().

Precondition:
    All poses have already been updated. */ (Deprecated.)

Deprecated:
    CameraProperties are being deprecated. Please use the
    DepthRenderCamera variant. This will be removed from Drake on or
    after 2021-04-01.)""";
          // Source: drake/geometry/geometry_state.h:542
          const char* doc =
R"""(Implementation of QueryObject::RenderDepthImage().

Precondition:
    All poses have already been updated.)""";
        } RenderDepthImage;
        // Symbol: drake::geometry::GeometryState::RenderLabelImage
        struct /* RenderLabelImage */ {
          // Source: drake/geometry/geometry_state.h:527
          const char* doc_deprecated =
R"""(Implementation of QueryObject::RenderLabelImage().

Precondition:
    All poses have already been updated. */ (Deprecated.)

Deprecated:
    CameraProperties are being deprecated. Please use the
    ColorRenderCamera variant. This will be removed from Drake on or
    after 2021-04-01.)""";
          // Source: drake/geometry/geometry_state.h:548
          const char* doc =
R"""(Implementation of QueryObject::RenderLabelImage().

Precondition:
    All poses have already been updated.)""";
        } RenderLabelImage;
        // Symbol: drake::geometry::GeometryState::RendererCount
        struct /* RendererCount */ {
          // Source: drake/geometry/geometry_state.h:496
          const char* doc =
R"""(Implementation of SceneGraph::RendererCount().)""";
        } RendererCount;
        // Symbol: drake::geometry::GeometryState::SourceIsRegistered
        struct /* SourceIsRegistered */ {
          // Source: drake/geometry/geometry_state.h:144
          const char* doc =
R"""(Implementation of SceneGraphInspector::SourceIsRegistered().)""";
        } SourceIsRegistered;
        // Symbol: drake::geometry::GeometryState::ToAutoDiffXd
        struct /* ToAutoDiffXd */ {
          // Source: drake/geometry/geometry_state.h:561
          const char* doc =
R"""(Returns a deep copy of this state using the AutoDiffXd scalar with all
scalar values initialized from the current values. If this is invoked
on an instance already instantiated on AutoDiffXd, it is equivalent to
cloning the instance.)""";
        } ToAutoDiffXd;
        // Symbol: drake::geometry::GeometryState::geometry_version
        struct /* geometry_version */ {
          // Source: drake/geometry/geometry_state.h:135
          const char* doc =
R"""(Implementation of SceneGraphInspector::GetGeometryVersion().)""";
        } geometry_version;
        // Symbol: drake::geometry::GeometryState::get_frame_ids
        struct /* get_frame_ids */ {
          // Source: drake/geometry/geometry_state.h:105
          const char* doc =
R"""(Implementation of SceneGraphInspector::all_frame_ids().)""";
        } get_frame_ids;
        // Symbol: drake::geometry::GeometryState::get_num_frames
        struct /* get_num_frames */ {
          // Source: drake/geometry/geometry_state.h:102
          const char* doc =
R"""(Implementation of SceneGraphInspector::num_frames().)""";
        } get_num_frames;
        // Symbol: drake::geometry::GeometryState::get_num_geometries
        struct /* get_num_geometries */ {
          // Source: drake/geometry/geometry_state.h:108
          const char* doc =
R"""(Implementation of SceneGraphInspector::num_geometries().)""";
        } get_num_geometries;
        // Symbol: drake::geometry::GeometryState::get_num_sources
        struct /* get_num_sources */ {
          // Source: drake/geometry/geometry_state.h:97
          const char* doc =
R"""(Implementation of SceneGraphInspector::num_sources().)""";
        } get_num_sources;
        // Symbol: drake::geometry::GeometryState::get_pose_in_parent
        struct /* get_pose_in_parent */ {
          // Source: drake/geometry/geometry_state.h:254
          const char* doc =
R"""(Implementation of QueryObject::GetPoseInParent().)""";
        } get_pose_in_parent;
        // Symbol: drake::geometry::GeometryState::get_pose_in_world
        struct /* get_pose_in_world */ {
          // Source: drake/geometry/geometry_state.h:247
          const char* doc_1args_frame_id =
R"""(Implementation of QueryObject::GetPoseInWorld(FrameId).)""";
          // Source: drake/geometry/geometry_state.h:250
          const char* doc_1args_geometry_id =
R"""(Implementation of QueryObject::GetPoseInWorld(GeometryId).)""";
        } get_pose_in_world;
      } GeometryState;
      // Symbol: drake::geometry::GeometryVersion
      struct /* GeometryVersion */ {
        // Source: drake/geometry/geometry_version.h:31
        const char* doc =
R"""(A version numbering class that reports revisions of SceneGraph's
geometric data.

Other Systems can use this version number to perform updates when they
detect changes to the geometric data they consume. The version of the
geometry data is made available through SceneGraphInspector.

The geometry data is partitioned by geometric role and have
independent role version values. Some of SceneGraph's API (as
variously documented) will cause one or more role versions to change.
This class provides the API ``IsSameAs`` that takes another
GeometryVersion as well as a Role to help detect whether the provided
role of the geometries may have changed. For example:


::

    // Downstream system holds an instance of GeometryVersion ``old_version`` as a
    // reference to compare against.
    // Get the version under test from SceneGraphInspector.
    const GeometryVersion& test_version = scene_graph_inspector.geometry_version();
    // Determine if two versions have the same proximity data.
    bool same_proximity = old_version.IsSameAs(test_version, Role::kProximity);)""";
        // Symbol: drake::geometry::GeometryVersion::GeometryVersion
        struct /* ctor */ {
          // Source: drake/geometry/geometry_version.h:37
          const char* doc =
R"""(Constructs a default-initialized instance; guaranteed to be different
from every other instance.)""";
        } ctor;
        // Symbol: drake::geometry::GeometryVersion::IsSameAs
        struct /* IsSameAs */ {
          // Source: drake/geometry/geometry_version.h:41
          const char* doc =
R"""(Returns true if ``this`` GeometryVersion has the same ``role`` version
as the ``other`` GeometryVersion.)""";
        } IsSameAs;
      } GeometryVersion;
      // Symbol: drake::geometry::HalfSpace
      struct /* HalfSpace */ {
        // Source: drake/geometry/shape_specification.h:223
        const char* doc =
R"""(Definition of a half space. In its canonical frame, the plane defining
the boundary of the half space is that frame's z = 0 plane. By
implication, the plane's normal points in the +z direction and the
origin lies on the plane. Other shapes are considered to be
penetrating the half space if there exists a point on the test shape
that lies on the side of the plane opposite the normal.)""";
        // Symbol: drake::geometry::HalfSpace::HalfSpace
        struct /* ctor */ {
          // Source: drake/geometry/shape_specification.h:225
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::geometry::HalfSpace::MakePose
        struct /* MakePose */ {
          // Source: drake/geometry/shape_specification.h:243
          const char* doc =
R"""(Creates the pose of a canonical half space in frame F. The half
space's normal is aligned to the positive z-axis of its canonical
frame H. Given a vector that points in the same direction, measured in
the F frame (Hz_dir_F) and a position vector to a point on the half
space's boundary* expressed in the same frame, ``p_FB``, creates the
pose of the half space in frame F: ``X_FH``.

Parameter ``Hz_dir_F``:
    A vector in the direction of the positive z-axis of the canonical
    frame expressed in frame F. It must be a non-zero vector but need
    not be unit length.

Parameter ``p_FB``:
    A point B lying on the half space's boundary measured and
    expressed in frame F.

Returns ``X_FH``:
    The pose of the canonical half-space in frame F.

Raises:
    RuntimeError if the normal is *close* to a zero-vector (e.g.,
    ‖normal_F‖₂ < ε).)""";
        } MakePose;
      } HalfSpace;
      // Symbol: drake::geometry::IllustrationProperties
      struct /* IllustrationProperties */ {
        // Source: drake/geometry/geometry_roles.h:180
        const char* doc =
R"""(The set of properties for geometry used in an "illustration" role.

Examples of functionality that depends on the illustration role: -
drake_visualizer_role_consumer "drake::geometry::DrakeVisualizer" -
geometry_visualization_role_dependency
"drake::geometry::ConnectDrakeVisualizer()")""";
        // Symbol: drake::geometry::IllustrationProperties::IllustrationProperties
        struct /* ctor */ {
          // Source: drake/geometry/geometry_roles.h:182
          const char* doc = R"""()""";
        } ctor;
      } IllustrationProperties;
      // Symbol: drake::geometry::MakePhongIllustrationProperties
      struct /* MakePhongIllustrationProperties */ {
        // Source: drake/geometry/geometry_roles.h:225
        const char* doc =
R"""(Constructs an IllustrationProperties instance compatible with a simple
"phong" material using only the given ``diffuse`` color.)""";
      } MakePhongIllustrationProperties;
      // Symbol: drake::geometry::Mesh
      struct /* Mesh */ {
        // Source: drake/geometry/shape_specification.h:253
        const char* doc =
R"""(Limited support for meshes. Meshes are supported in Rendering and
Illustration roles. For Proximity role, Meshes are supported in
ComputeContactSurfaces() query only. No other proximity queries are
supported.)""";
        // Symbol: drake::geometry::Mesh::Mesh
        struct /* ctor */ {
          // Source: drake/geometry/shape_specification.h:263
          const char* doc =
R"""(Constructs a mesh specification from the mesh file located at the
given *absolute* file path. Optionally uniformly scaled by the given
scale factor.

Raises:
    RuntimeError if |scale| < 1e-8. Note that a negative scale is
    considered valid. We want to preclude scales near zero but
    recognise that scale is a convenience tool for "tweaking" models.
    8 orders of magnitude should be plenty without considering
    revisiting the model itself.)""";
        } ctor;
        // Symbol: drake::geometry::Mesh::filename
        struct /* filename */ {
          // Source: drake/geometry/shape_specification.h:265
          const char* doc = R"""()""";
        } filename;
        // Symbol: drake::geometry::Mesh::scale
        struct /* scale */ {
          // Source: drake/geometry/shape_specification.h:266
          const char* doc = R"""()""";
        } scale;
      } Mesh;
      // Symbol: drake::geometry::MeshField
      struct /* MeshField */ {
        // Source: drake/geometry/proximity/mesh_field.h:23
        const char* doc =
R"""(MeshField is an abstract class that represents a field variable
defined on a mesh M. It can evaluate the field value at any location
on any element of the mesh.

Template parameter ``FieldValue``:
    a valid Eigen scalar or Vector of Eigen scalar for the field
    value.

Template parameter ``MeshType``:
    the type of the mesh: SurfaceMesh or VolumeMesh.)""";
        // Symbol: drake::geometry::MeshField::CloneAndSetMesh
        struct /* CloneAndSetMesh */ {
          // Source: drake/geometry/proximity/mesh_field.h:56
          const char* doc =
R"""(Copy to a new MeshField and set the new MeshField to use a new
compatible mesh. MeshField needs a mesh to operate; however, MeshField
does not own the mesh. In fact, several MeshField objects can use the
same mesh.)""";
        } CloneAndSetMesh;
        // Symbol: drake::geometry::MeshField::CloneWithNullMesh
        struct /* CloneWithNullMesh */ {
          // Source: drake/geometry/proximity/mesh_field.h:76
          const char* doc = R"""()""";
        } CloneWithNullMesh;
        // Symbol: drake::geometry::MeshField::DoCloneWithNullMesh
        struct /* DoCloneWithNullMesh */ {
          // Source: drake/geometry/proximity/mesh_field.h:82
          const char* doc =
R"""(Derived classes must implement this method to clone themselves given
that the pointer to the mesh is null.)""";
        } DoCloneWithNullMesh;
        // Symbol: drake::geometry::MeshField::Evaluate
        struct /* Evaluate */ {
          // Source: drake/geometry/proximity/mesh_field.h:36
          const char* doc =
R"""(Evaluates the field value at a location on an element.

Parameter ``e``:
    The index of the element.

Parameter ``b``:
    The barycentric coordinates.)""";
        } Evaluate;
        // Symbol: drake::geometry::MeshField::EvaluateAtVertex
        struct /* EvaluateAtVertex */ {
          // Source: drake/geometry/proximity/mesh_field.h:29
          const char* doc =
R"""(Evaluates the field value at a vertex.

Parameter ``v``:
    The index of the vertex.)""";
        } EvaluateAtVertex;
        // Symbol: drake::geometry::MeshField::EvaluateCartesian
        struct /* EvaluateCartesian */ {
          // Source: drake/geometry/proximity/mesh_field.h:47
          const char* doc =
R"""(Evaluates the field at a point Qp on an element. If the element is a
tetrahedron, Qp is the input point Q. If the element is a triangle, Qp
is the projection of Q on the triangle's plane.

Parameter ``e``:
    The index of the element.

Parameter ``p_MQ``:
    The position of point Q expressed in frame M, in Cartesian
    coordinates. M is the frame of the mesh.)""";
        } EvaluateCartesian;
        // Symbol: drake::geometry::MeshField::MeshField<FieldValue, MeshType>
        struct /* ctor */ {
          // Source: drake/geometry/proximity/mesh_field.h:70
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::geometry::MeshField::mesh
        struct /* mesh */ {
          // Source: drake/geometry/proximity/mesh_field.h:67
          const char* doc = R"""()""";
        } mesh;
      } MeshField;
      // Symbol: drake::geometry::MeshFieldLinear
      struct /* MeshFieldLinear */ {
        // Source: drake/geometry/proximity/mesh_field_linear.h:94
        const char* doc =
R"""(MeshFieldLinear represents a continuous piecewise-linear scalar field
f defined on a (triangular or tetrahedral) mesh; the field value
changes linearly within each element E (triangle or tetrahedron), and
the gradient ∇f is constant within each element. The field is
continuous across adjacent elements, but its gradient is discontinuous
from one element to the other.

To represent a piecewise linear field f, we store one field value per
vertex of the mesh. Each element E (triangle or tetrahedron) has (d+1)
vertices, where d is the dimension of the element. For triangle, d =
2, and for tetrahedron, d = 3.

On each element E, we define a linear function fᵉ:ℝ³→ℝ using the field
values at vertices of E. The gradient ∇fᵉ:ℝ³→ℝ³ is a constant map, so
we write ∇fᵉ for the constant gradient vector on E as well. For a
point Q in element E, we have:

f(Q) = fᵉ(Q) for Q ∈ E, ∇f(Q) = ∇fᵉ for Q ∈ E.

Notice that the domain of fᵉ is the entire space of ℝ³, while the
domain of f is the underlying space of the mesh.

The following sections are details for interested readers.

** Barycentric coordinate **

For a linear triangle or tetrahedron element E in 3-D, we use
barycentric coordinate:

(b₀, b₁, b₂) for triangle, (b₀, b₁, b₂, b₃) for tetrahedron, ∑bᵢ = 1,
bᵢ ≥ 0,

to identify a point Q that lies in the simplicial element E. The
coefficient bᵢ is the weight of vertex Vᵉᵢ of the element E, where the
index i is a local index within the element E, not the global index of
the entire mesh. In other words, vertex Vᵉᵢ is the iᵗʰ vertex of E,
not the iᵗʰ vertex among all vertices in the mesh. The point Q in E
can be expressed as:

Q = ∑bᵉᵢ(Q)Vᵉᵢ,

where we indicate the barycentric coordinate of a point Q on an
element E as bᵉᵢ(Q).

** Field value from barycentric coordinates **

At a point Q in element E, the piecewise linear field f has value:

f(Q) = fᵉ(Q) = ∑bᵉᵢ(Q)Fᵉᵢ

where Fᵉᵢ is the field value at the iᵗʰ vertex of element E.

** Gradient **

Consider each bᵉᵢ:ℝ³→ℝ as a linear function, its gradient ∇bᵉᵢ:ℝ³→ℝ³
is a constant map, and we write ∇bᵉᵢ for the constant gradient vector.
The gradient of the piecewise linear field f at a point Q in an
element E is:

∇f(Q) = ∇fᵉ = ∑Fᵉᵢ∇bᵉᵢ.

** Field value from Cartesian coordinates **

At a point Q in element E, the piecewise linear field f has value:

f(Q) = ∇fᵉ⋅Q + fᵉ(0,0,0).

Notice that (0,0,0) may or may not lie in element E.

Template parameter ``T``:
    a valid Eigen scalar for field values.

Template parameter ``MeshType``:
    the type of the meshes: SurfaceMesh or VolumeMesh.)""";
        // Symbol: drake::geometry::MeshFieldLinear::Equal
        struct /* Equal */ {
          // Source: drake/geometry/proximity/mesh_field_linear.h:235
          const char* doc =
R"""(Checks to see whether the given MeshFieldLinear object is equal via
deep exact comparison. The name of the objects are exempt from this
comparison. NaNs are treated as not equal as per the IEEE standard.

Parameter ``field``:
    The field for comparison.

Returns:
    ``True`` if the given field is equal.

Note:
    Requires ``MeshField field`` to be MeshFieldLinear.)""";
        } Equal;
        // Symbol: drake::geometry::MeshFieldLinear::Evaluate
        struct /* Evaluate */ {
          // Source: drake/geometry/proximity/mesh_field_linear.h:165
          const char* doc = R"""()""";
        } Evaluate;
        // Symbol: drake::geometry::MeshFieldLinear::EvaluateAtVertex
        struct /* EvaluateAtVertex */ {
          // Source: drake/geometry/proximity/mesh_field_linear.h:161
          const char* doc = R"""()""";
        } EvaluateAtVertex;
        // Symbol: drake::geometry::MeshFieldLinear::EvaluateCartesian
        struct /* EvaluateCartesian */ {
          // Source: drake/geometry/proximity/mesh_field_linear.h:186
          const char* doc =
R"""(Evaluates the field at a point Qp on an element. If the element is a
tetrahedron, Qp is the input point Q. If the element is a triangle, Qp
is the projection of Q on the triangle's plane.

If gradients have been calculated, it evaluates the field value
directly. Otherwise, it converts Cartesian coordinates to barycentric
coordinates for barycentric interpolation.

Parameter ``e``:
    The index of the element.

Parameter ``p_MQ``:
    The position of point Q expressed in frame M, in Cartesian
    coordinates. M is the frame of the mesh.)""";
        } EvaluateCartesian;
        // Symbol: drake::geometry::MeshFieldLinear::EvaluateGradient
        struct /* EvaluateGradient */ {
          // Source: drake/geometry/proximity/mesh_field_linear.h:202
          const char* doc =
R"""(Evaluates the gradient in the domain of the element indicated by
``e``. The gradient is a vector in R³ expressed in frame M. For
surface meshes, it will particularly lie parallel to the plane of the
corresponding triangle.

Raises:
    RuntimeError if the gradient vector was not calculated.)""";
        } EvaluateGradient;
        // Symbol: drake::geometry::MeshFieldLinear::MeshFieldLinear<T, MeshType>
        struct /* ctor */ {
          // Source: drake/geometry/proximity/mesh_field_linear.h:146
          const char* doc =
R"""(Constructs a MeshFieldLinear.

Parameter ``name``:
    The name of the field variable.

Parameter ``values``:
    The field value at each vertex of the mesh.

Parameter ``mesh``:
    The mesh M to which this MeshField refers.

Parameter ``calculate_gradient``:
    Calculate gradient field when true, default is true. Calculating
    gradient allows EvaluateCartesian() to evaluate the field directly
    instead of converting Cartesian coordinates to barycentric
    coordinates first. If calculate_gradient is false,
    EvaluateCartesian() will be slower. On the other hand, calculating
    gradient requires certain quality from mesh elements. If the mesh
    quality is very poor, calculating gradient may throw.

You can use the parameter ``calculate_gradient`` to trade time and
space of this constructor for speed of EvaluateCartesian(). For
``calculate_gradient`` = true (by default), this constructor will take
longer time to compute and will store one field-gradient vector for
each element in the mesh, but the interpolation by EvaluateCartesian()
will be faster because we will use a dot product with the Cartesian
coordinates directly, instead of solving a linear system to convert
Cartesian coordinates to barycentric coordinates first. For
``calculate_gradient`` = false, this constructor will be faster and
use less memory, but EvaluateCartesian() will be slower.

When ``calculate_gradient`` = true, EvaluateGradient() on a mesh
element will be available. Otherwise, EvaluateGradient() will
``throw``.

The following features are independent of the choice of
``calculate_gradient``.

- Evaluating the field at a vertex.
- Evaluating the field at a user-given barycentric coordinate.

Note:
    When ``calculate_gradient`` = true, a poor quality element can
    cause ``throw`` due to numerical errors in calculating field
    gradients. A poor quality element is defined as having an
    extremely large aspect ratio R=E/h, where E is the longest edge
    length and h is the shortest height. A height of a triangular
    element is the distance between a vertex and its opposite edge. A
    height of a tetrahedral element is the distance between a vertex
    and its opposite triangular face. For example, an extremely skinny
    triangle has poor quality, and a tetrahedron with four vertices
    almost co-planar also has poor quality. The exact threshold of the
    acceptable aspect ratio depends on many factors including the
    underlying scalar type and the exact shape and size of the
    element; however, a rough conservative estimation is 1e12.

Precondition:
    The ``mesh`` is non-null, and the number of entries in ``values``
    is the same as the number of vertices of the mesh.)""";
        } ctor;
        // Symbol: drake::geometry::MeshFieldLinear::TransformGradients
        struct /* TransformGradients */ {
          // Source: drake/geometry/proximity/mesh_field_linear.h:214
          const char* doc =
R"""(Transforms the gradient vectors of this field from its initial frame M
to the new frame N.

Warning:
    Use this function when the reference mesh of this field changes
    its frame in the same way.)""";
        } TransformGradients;
        // Symbol: drake::geometry::MeshFieldLinear::name
        struct /* name */ {
          // Source: drake/geometry/proximity/mesh_field_linear.h:221
          const char* doc = R"""()""";
        } name;
        // Symbol: drake::geometry::MeshFieldLinear::values
        struct /* values */ {
          // Source: drake/geometry/proximity/mesh_field_linear.h:222
          const char* doc = R"""()""";
        } values;
      } MeshFieldLinear;
      // Symbol: drake::geometry::PenetrationAsPointPair
      struct /* PenetrationAsPointPair */ {
        // Source: drake/geometry/query_results/penetration_as_point_pair.h:25
        const char* doc =
R"""(A characterization of the intersection of two penetrating geometries.
The characterization consists of a pair of points and a normal. The
points represent a point on each geometry that most deeply penetrates
the other geometry (in the normal direction). For convenience, the
penetration depth is provided and is equal to:

depth = ``(p_WCb - p_WCa) ⋅ nhat_BA_W``

(`depth` is strictly positive when there is penetration and otherwise
not defined.)

Template parameter ``T``:
    The underlying scalar type. Must be a valid Eigen scalar.)""";
        // Symbol: drake::geometry::PenetrationAsPointPair::PenetrationAsPointPair<T>
        struct /* ctor */ {
          // Source: drake/geometry/query_results/penetration_as_point_pair.h:26
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::geometry::PenetrationAsPointPair::SwapAAndB
        struct /* SwapAAndB */ {
          // Source: drake/geometry/query_results/penetration_as_point_pair.h:30
          const char* doc =
R"""(Swaps the interpretation of geometries A and B.)""";
        } SwapAAndB;
        // Symbol: drake::geometry::PenetrationAsPointPair::depth
        struct /* depth */ {
          // Source: drake/geometry/query_results/penetration_as_point_pair.h:52
          const char* doc = R"""(The penetration depth.)""";
        } depth;
        // Symbol: drake::geometry::PenetrationAsPointPair::id_A
        struct /* id_A */ {
          // Source: drake/geometry/query_results/penetration_as_point_pair.h:38
          const char* doc =
R"""(The id of the first geometry in the contact.)""";
        } id_A;
        // Symbol: drake::geometry::PenetrationAsPointPair::id_B
        struct /* id_B */ {
          // Source: drake/geometry/query_results/penetration_as_point_pair.h:40
          const char* doc =
R"""(The id of the second geometry in the contact.)""";
        } id_B;
        // Symbol: drake::geometry::PenetrationAsPointPair::nhat_BA_W
        struct /* nhat_BA_W */ {
          // Source: drake/geometry/query_results/penetration_as_point_pair.h:50
          const char* doc =
R"""(The unit-length normal which defines the penetration direction,
pointing from geometry B into geometry A, measured and expressed in
the world frame. It *approximates* the normal to the plane on which
the contact patch lies.)""";
        } nhat_BA_W;
        // Symbol: drake::geometry::PenetrationAsPointPair::p_WCa
        struct /* p_WCa */ {
          // Source: drake/geometry/query_results/penetration_as_point_pair.h:43
          const char* doc =
R"""(The point on A that most deeply penetrates B, measured and expressed
in the world frame.)""";
        } p_WCa;
        // Symbol: drake::geometry::PenetrationAsPointPair::p_WCb
        struct /* p_WCb */ {
          // Source: drake/geometry/query_results/penetration_as_point_pair.h:46
          const char* doc =
R"""(The point on B that most deeply penetrates A, measured and expressed
in the world frame.)""";
        } p_WCb;
      } PenetrationAsPointPair;
      // Symbol: drake::geometry::PerceptionProperties
      struct /* PerceptionProperties */ {
        // Source: drake/geometry/geometry_roles.h:166
        const char* doc =
R"""(The set of properties for geometry used in a "perception" role.

Examples of functionality that depends on the perception role: -
render::RenderEngineVtk)""";
        // Symbol: drake::geometry::PerceptionProperties::PerceptionProperties
        struct /* ctor */ {
          // Source: drake/geometry/geometry_roles.h:168
          const char* doc = R"""()""";
        } ctor;
      } PerceptionProperties;
      // Symbol: drake::geometry::ProximityProperties
      struct /* ProximityProperties */ {
        // Source: drake/geometry/geometry_roles.h:154
        const char* doc =
R"""(The set of properties for geometry used in a *proximity* role.

Examples of functionality that depends on the proximity role:)""";
        // Symbol: drake::geometry::ProximityProperties::ProximityProperties
        struct /* ctor */ {
          // Source: drake/geometry/geometry_roles.h:156
          const char* doc = R"""()""";
        } ctor;
      } ProximityProperties;
      // Symbol: drake::geometry::QueryObject
      struct /* QueryObject */ {
        // Source: drake/geometry/query_object.h:68
        const char* doc =
R"""(The QueryObject serves as a mechanism to perform geometry queries on
the world's geometry. The SceneGraph has an abstract-valued port that
contains a QueryObject (i.e., a QueryObject-valued output port).

To perform geometry queries on SceneGraph: - a LeafSystem must have a
QueryObject-valued input port and connect it to the corresponding
query output port on SceneGraph, - the querying LeafSystem can
evaluate the input port, retrieving a ``const QueryObject&`` in
return, and, finally, - invoke the appropriate method on the
QueryObject.

The const reference returned by the input port is considered "live" -
it is linked to the context, system, and cache (making full use of all
of those mechanisms). This const reference should *never* be
persisted; doing so can lead to erroneous query results. It is simpler
and more advisable to acquire it for evaluation in a limited scope
(e.g., CalcTimeDerivatives()) and then discard it. If a QueryObject is
needed for many separate functions in a LeafSystem, each should
re-evaluate the input port. The underlying caching mechanism should
make the cost of this negligible.

The QueryObject *can* be copied. The copied instance is no longer
"live"; it is now "baked". Essentially, it freezes the state of the
live scene graph in its current configuration and disconnects it from
the system and context. This means, even if the original context
changes values, the copied/baked instance will always reproduce the
same query results. This baking process is not cheap and should not be
done without consideration.

Queries and scalar type
-----------------------

A QueryObject *cannot* be converted to a different scalar type. A
QueryObject of scalar type T can only be acquired from the output port
of a SceneGraph of type T evaluated on a corresponding Context, also
of type T.

QueryObject's support for arbitrary scalar type is incomplete. Not all
queries support all scalar types to the same degree. In some cases the
level of support is obvious (such as when the query is declared
*explicitly* in terms of a double-valued scalar -- see
ComputePointPairPenetration()). In other cases, where the query is
expressed in terms of scalar ``T``, the query may have restrictions.
If a query has restricted scalar support, it is included in the
query's documentation.)""";
        // Symbol: drake::geometry::QueryObject::ComputeContactSurfaces
        struct /* ComputeContactSurfaces */ {
          // Source: drake/geometry/query_object.h:243
          const char* doc =
R"""(Reports pairwise intersections and characterizes each non-empty
intersection as a ContactSurface for hydroelastic contact model. The
computation is subject to collision filtering.

For two intersecting geometries g_A and g_B, it is guaranteed that
they will map to ``id_A`` and ``id_B`` in a fixed, repeatable manner,
where ``id_A`` and ``id_B`` are GeometryId's of geometries g_A and g_B
respectively.

In the current incarnation, this function represents a simple
implementation.

- This table shows the supported shapes and compliance modes.

| Shape | Soft | Rigid | | :-------: | :---: | :---- | | Sphere | yes
| yes | | Cylinder | yes | yes | | Box | yes | yes | | Capsule | no |
no | | Ellipsoid | yes | yes | | HalfSpace | yes | yes | | Mesh | no |
yes | | Convex | no | yes |

- One geometry must be soft, and the other must be rigid. There is no
support for soft-soft collision or rigid-rigid collision. If such
pairs collide, an exception will be thrown. More particularly, if such
a pair *cannot be culled* an exception will be thrown. No exception
is thrown if the pair has been filtered.
- The elasticity modulus E (N/m^2) of each geometry is set in
ProximityProperties (see AddContactMaterial()).
- The tessellation of the corresponding meshes is controlled by the
resolution hint, as defined by AddSoftHydroelasticProperties() and
AddRigidHydroelasticProperties().

**Scalar support**

This method provides support only for double. Attempting to invoke
this method with T = AutoDiffXd will throw an exception if there are
unsupported geometry pairs (like box-to-box) that couldn't be culled.

Returns:
    A vector populated with all detected intersections characterized
    as contact surfaces. The ordering of the results is guaranteed to
    be consistent -- for fixed geometry poses, the results will remain
    the same.)""";
        } ComputeContactSurfaces;
        // Symbol: drake::geometry::QueryObject::ComputeContactSurfacesWithFallback
        struct /* ComputeContactSurfacesWithFallback */ {
          // Source: drake/geometry/query_object.h:289
          const char* doc =
R"""(Reports pair-wise intersections and characterizes each non-empty
intersection as a ContactSurface *where possible* and as a
PenetrationAsPointPair where not.

This is a hybrid contact algorithm. It allows for the contact surface
penetration result where possible, but automatically provides a
fallback for where a ContactSurface cannot be defined.

The fallback cannot guarantee success in all cases. Meshes have
limited support in the proximity role; they are supported in the
contact surface computation but *ignored* in the point pair collision
query. If a mesh is in contact with another shape that *cannot* be
resolved as a contact surface (e.g., rigid mesh vs another rigid
shape), this computation will throw as there is no fallback
functionality for mesh-shape.

Because point pairs can only be computed for double-valued systems,
this can also only support double-valued ContactSurface instances.

The ordering of the *added* results is guaranteed to be consistent --
for fixed geometry poses, the results will remain the same.

Warning:
    Invoking this with T = AutoDiffXd may throw an exception. The
    logic controlling when this throws is subtle; it is dependent on
    the behavior when T = double. For T = double, contact between a
    colliding pair of geometries (g1, g2) will be reported as either
    ContactSurface or PenetrationAsPointPair (depending on the
    geometry properties). The guiding principle is that a contact
    should always be characterized with the same collision type
    (regardless of scalar type). If that collision type is not
    supported for a particular scalar, this query throws. - If (g1,
    g2) produces a ContactSurface for T = double, T = AutoDiffXd will
    definitely throw. - If (g1, g2) produces a PenetrationAsPointPair
    for T = double, T = AutoDiffXd will throw under the same
    conditions as documented in ComputePointPairPenetration().

Parameter ``surfaces``:
    The vector that contact surfaces will be added to. The vector will
    *not* be cleared.

Parameter ``point_pairs``:
    The vector that fall back point pair data will be added to. The
    vector will *not* be cleared.

Precondition:
    Neither ``surfaces`` nor ``point_pairs`` is nullptr.

Raises:
    if T = AutoDiffXd and unsupported object (like box-to-box)
    actually collides.)""";
        } ComputeContactSurfacesWithFallback;
        // Symbol: drake::geometry::QueryObject::ComputePointPairPenetration
        struct /* ComputePointPairPenetration */ {
          // Source: drake/geometry/query_object.h:196
          const char* doc =
R"""(Computes the penetrations across all pairs of geometries in the world
with the penetrations characterized by pairs of points (see
PenetrationAsPointPair), providing some measure of the penetration
"depth" of the two objects, but *not* the overlapping volume.

Only reports results for *penetrating* geometries; if two geometries
are separated, there will be no result for that pair. Geometries whose
surfaces are just touching (osculating) are not considered in
penetration. Surfaces whose penetration is within an epsilon of
osculation, are likewise not considered penetrating. Pairs of
*anchored* geometry are also not reported. This method is affected by
collision filtering.

For two penetrating geometries g_A and g_B, it is guaranteed that they
will map to ``id_A`` and ``id_B`` in a fixed, repeatable manner.

**Scalar and Shape Support**

- For scalar type ``double``, we support all Shape-Shape pairs *except* for
HalfSpace-HalfSpace. In that case, half spaces are either non-colliding or
have an infinite amount of penetration.
- For scalar type AutoDiffXd, we only support query pairs Sphere-Box,
Sphere-Capsule, Sphere-Cylinder, Sphere-HalfSpace, and Sphere-Sphere.

For a Shape-Shape pair in collision that is *not* supported for a
given scalar type, an exception is thrown.

Returns:
    A vector populated with all detected penetrations characterized as
    point pairs. The ordering of the results is guaranteed to be
    consistent -- for fixed geometry poses, the results will remain
    the same.

Warning:
    For Mesh shapes, their convex hulls are used in this query. It is
    not* computationally efficient or particularly accurate.

Raises:
    RuntimeError if unsupported pairs are in contact (see "Scalar and
    Shape Support" for description of "unsupported pairs").)""";
        } ComputePointPairPenetration;
        // Symbol: drake::geometry::QueryObject::ComputeSignedDistancePairClosestPoints
        struct /* ComputeSignedDistancePairClosestPoints */ {
          // Source: drake/geometry/query_object.h:409
          const char* doc =
R"""(A variant of ComputeSignedDistancePairwiseClosestPoints() which
computes the signed distance (and witnesses) between a specific pair
of geometries indicated by id. This function has the same restrictions
on scalar report as ComputeSignedDistancePairwiseClosestPoints().

Raises:
    RuntimeError if either geometry id is invalid, or if the pair (A,
    B) has been marked as filtered.

Warning:
    For Mesh shapes, their convex hulls are used in this query. It is
    not* computationally efficient or particularly accurate.)""";
        } ComputeSignedDistancePairClosestPoints;
        // Symbol: drake::geometry::QueryObject::ComputeSignedDistancePairwiseClosestPoints
        struct /* ComputeSignedDistancePairwiseClosestPoints */ {
          // Source: drake/geometry/query_object.h:396
          const char* doc =
R"""(Computes the signed distance together with the nearest points across
all pairs of geometries in the world. Reports both the separating
geometries and penetrating geometries.

This query provides φ(A, B), the signed distance between two objects A
and B.

If the objects do not overlap (i.e., A ⋂ B = ∅), φ > 0 and represents
the minimal distance between the two objects. More formally: φ =
min(|Aₚ - Bₚ|) ∀ Aₚ ∈ A and Bₚ ∈ B.

Note:
    The pair (Aₚ, Bₚ) is a "witness" of the distance. The pair need
    not be unique (think of two parallel planes).

If the objects touch or overlap (i.e., A ⋂ B ≠ ∅), φ ≤ 0 and can be
interpreted as the negative penetration depth. It is the smallest
length of the vector v, such that by shifting one object along that
vector relative to the other, the two objects will no longer be
overlapping. More formally, φ(A, B) = -min |v|. s.t (Tᵥ · A) ⋂ B = ∅
where Tᵥ is a rigid transformation that displaces A by the vector v,
namely Tᵥ · A = {u + v | ∀ u ∈ A}. By implication, there exist points
Aₚ and Bₚ on the surfaces of objects A and B, respectively, such that
Aₚ + v = Bₚ, Aₚ ∈ A ∩ B, Bₚ ∈ A ∩ B. These points are the witnesses to
the penetration.

This method is affected by collision filtering; geometry pairs that
have been filtered will not produce signed distance query results.

For a geometry pair (A, B), the returned results will always be
reported in a fixed order (e.g., always (A, B) and never (B, A)). The
*basis* for the ordering is arbitrary (and therefore undocumented),
but guaranteed to be fixed and repeatable.

Notice that this is an O(N²) operation, where N is the number of
geometries remaining in the world after applying collision filter. We
report the distance between dynamic objects, and between dynamic and
anchored objects. We DO NOT report the distance between two anchored
objects.

**Scalar support**

This function does not support halfspaces. If an unfiltered pair
contains a halfspace, an exception will be thrown for all scalar
types. Otherwise, this query supports all other pairs of Drake
geometry types for ``double``. For ``AutoDiffXd``, it only supports
distance between sphere-box and sphere-sphere. If there are any
unfiltered geometry pairs that include other geometries, the AutoDiff
throws an exception.

Parameter ``max_distance``:
    The maximum distance at which distance data is reported.

Returns:
    The signed distance (and supporting data) for all unfiltered
    geometry pairs whose distance is less than or equal to
    ``max_distance``.

Warning:
    For Mesh shapes, their convex hulls are used in this query. It is
    not* computationally efficient or particularly accurate.)""";
        } ComputeSignedDistancePairwiseClosestPoints;
        // Symbol: drake::geometry::QueryObject::ComputeSignedDistanceToPoint
        struct /* ComputeSignedDistanceToPoint */ {
          // Source: drake/geometry/query_object.h:489
          const char* doc =
R"""(Computes the signed distances and gradients to a query point from each
geometry in the scene.

Warning:
    Currently supports spheres, boxes, and cylinders only. Silently
    ignores other kinds of geometries, which will be added later.

This query provides φᵢ(p), φᵢ:ℝ³→ℝ, the signed distance to the
position p of a query point from geometry Gᵢ in the scene. It returns
an array of the signed distances from all geometries.

Optionally you can specify a threshold distance that will filter out
any object beyond the threshold. By default, we report distances from
the query point to every object.

This query also provides the gradient vector ∇φᵢ(p) of the signed
distance function from geometry Gᵢ. Note that, in general, if p is
outside Gᵢ, then ∇φᵢ(p) equals the unit vector in the direction from
the nearest point Nᵢ on Gᵢ's surface to p. If p is inside Gᵢ, then
∇φᵢ(p) is in the direction from p to Nᵢ. This observation is written
formally as:

∇φᵢ(p) = (p - Nᵢ)/|p - Nᵢ| if p is outside Gᵢ

∇φᵢ(p) = -(p - Nᵢ)/|p - Nᵢ| if p is inside Gᵢ

Note that ∇φᵢ(p) is also defined on Gᵢ's surface, but we cannot use
the above formula.

**Scalar support**

This query only supports computing distances from the point to
spheres, boxes, and cylinders for both ``double`` and ``AutoDiffXd``
scalar types. If the SceneGraph contains any other geometry shapes,
they will be silently ignored.

Note:
    For a sphere G, the signed distance function φᵢ(p) has an
    undefined gradient vector at the center of the sphere--every point
    on the sphere's surface has the same distance to the center. In
    this case, we will assign ∇φᵢ(p) the unit vector Gx (x-directional
    vector of G's frame) expressed in World frame.

Note:
    For a box, at a point p on an edge or a corner of the box, the
    signed distance function φᵢ(p) has an undefined gradient vector.
    In this case, we will assign a unit vector in the direction of the
    average of the outward face unit normals of the incident faces of
    the edge or the corner. A point p is considered being on a face,
    or an edge, or a corner of the box if it lies within a certain
    tolerance from them.

Note:
    For a box B, if a point p is inside the box, and it is equidistant
    to to multiple nearest faces, the signed distance function φᵢ(p)
    at p will have an undefined gradient vector. There is a nearest
    point candidate associated with each nearest face. In this case,
    we arbitrarily pick the point Nᵢ associated with one of the
    nearest faces. Please note that, due to the possible round off
    error arising from applying a pose X_WG to B, there is no
    guarantee which of the nearest faces will be used.

Note:
    The signed distance function is a continuous function with respect
    to the position of the query point, but its gradient vector field
    may not be continuous. Specifically at a position equidistant to
    multiple nearest points, its gradient vector field is not
    continuous.

Note:
    For a convex object, outside the object at positive distance from
    the boundary, the signed distance function is smooth (having
    continuous first-order partial derivatives).

Parameter ``p_WQ``:
    Position of a query point Q in world frame W.

Parameter ``threshold``:
    We ignore any object beyond this distance. By default, it is
    infinity, so we report distances from the query point to every
    object.

Returns ``signed_distances``:
    A vector populated with per-object signed distance values (and
    supporting data). See SignedDistanceToPoint.)""";
        } ComputeSignedDistanceToPoint;
        // Symbol: drake::geometry::QueryObject::FindCollisionCandidates
        struct /* FindCollisionCandidates */ {
          // Source: drake/geometry/query_object.h:302
          const char* doc =
R"""(Applies a conservative culling mechanism to create a subset of all
possible geometry pairs based on non-zero intersections. A geometry
pair that is *absent* from the results is either a) culled by
collision filters or b) *known* to be separated. The caller is
responsible for confirming that the remaining, unculled geometry pairs
are *actually* in collision.

Returns:
    A vector populated with collision pair candidates (the order will
    remain constant for a fixed population but can change as geometry
    ids are added/removed).)""";
        } FindCollisionCandidates;
        // Symbol: drake::geometry::QueryObject::GetPoseInParent
        struct /* GetPoseInParent */ {
          // Source: drake/geometry/query_object.h:124
          const char* doc =
R"""(Reports the position of the frame indicated by ``frame_id`` relative
to its parent frame. If the frame was registered with the world frame
as its parent frame, this value will be identical to that returned by
GetPoseInWorld().

Note:
    This is analogous to but distinct from
    SceneGraphInspector::GetPoseInParent(). In this case, the pose
    will *always* be relative to another frame.

Raises:
    RuntimeError if the frame ``frame_id`` is not valid.)""";
        } GetPoseInParent;
        // Symbol: drake::geometry::QueryObject::GetPoseInWorld
        struct /* GetPoseInWorld */ {
          // Source: drake/geometry/query_object.h:111
          const char* doc_1args_frame_id =
R"""(Reports the position of the frame indicated by ``frame_id`` relative
to the world frame.

Raises:
    RuntimeError if the frame ``frame_id`` is not valid.)""";
          // Source: drake/geometry/query_object.h:133
          const char* doc_1args_geometry_id =
R"""(Reports the position of the geometry indicated by ``geometry_id``
relative to the world frame.

Raises:
    RuntimeError if the geometry ``geometry_id`` is not valid.)""";
        } GetPoseInWorld;
        // Symbol: drake::geometry::QueryObject::GetRenderEngineByName
        struct /* GetRenderEngineByName */ {
          // Source: drake/geometry/query_object.h:614
          const char* doc =
R"""(Returns the named render engine, if it exists. The RenderEngine is
guaranteed to be up to date w.r.t. the poses and data in the context.)""";
        } GetRenderEngineByName;
        // Symbol: drake::geometry::QueryObject::HasCollisions
        struct /* HasCollisions */ {
          // Source: drake/geometry/query_object.h:308
          const char* doc =
R"""(Reports true if there are *any* collisions between unfiltered pairs in
the world.

Warning:
    For Mesh shapes, their convex hulls are used in this query. It is
    not* computationally efficient or particularly accurate.)""";
        } HasCollisions;
        // Symbol: drake::geometry::QueryObject::QueryObject<T>
        struct /* ctor */ {
          // Source: drake/geometry/query_object.h:71
          const char* doc =
R"""(Constructs a default QueryObject (all pointers are null).)""";
        } ctor;
        // Symbol: drake::geometry::QueryObject::RenderColorImage
        struct /* RenderColorImage */ {
          // Source: drake/geometry/query_object.h:525
          const char* doc_deprecated =
R"""(Renders an RGB image for the given ``camera`` posed with respect to
the indicated parent frame P.

Parameter ``camera``:
    The intrinsic properties of the camera.

Parameter ``parent_frame``:
    The id for the camera's parent frame.

Parameter ``X_PC``:
    The pose of the camera body in the parent frame.

Parameter ``show_window``:
    If true, the render window will be displayed.

Parameter ``color_image_out``:
    The rendered color image. */ (Deprecated.)

Deprecated:
    CameraProperties are being deprecated. Please use the
    ColorRenderCamera variant. This will be removed from Drake on or
    after 2021-04-01.)""";
          // Source: drake/geometry/query_object.h:539
          const char* doc =
R"""(Renders an RGB image for the given ``camera`` posed with respect to
the indicated parent frame P.

Parameter ``camera``:
    The camera to render from.

Parameter ``parent_frame``:
    The id for the camera's parent frame.

Parameter ``X_PC``:
    The pose of the camera body in the parent frame.

Parameter ``color_image_out``:
    The rendered color image.)""";
        } RenderColorImage;
        // Symbol: drake::geometry::QueryObject::RenderDepthImage
        struct /* RenderDepthImage */ {
          // Source: drake/geometry/query_object.h:559
          const char* doc_deprecated =
R"""(Renders a depth image for the given ``camera`` posed with respect to
the indicated parent frame P.

In contrast to the other rendering methods, rendering depth images
doesn't provide the option to display the window; generally, basic
depth images are not readily communicative to humans.

Parameter ``camera``:
    The intrinsic properties of the camera.

Parameter ``parent_frame``:
    The id for the camera's parent frame.

Parameter ``X_PC``:
    The pose of the camera body in the parent frame.

Parameter ``depth_image_out``:
    The rendered depth image. */ (Deprecated.)

Deprecated:
    CameraProperties are being deprecated. Please use the
    DepthRenderCamera variant. This will be removed from Drake on or
    after 2021-04-01.)""";
          // Source: drake/geometry/query_object.h:576
          const char* doc =
R"""(Renders a depth image for the given ``camera`` posed with respect to
the indicated parent frame P.

In contrast to the other rendering methods, rendering depth images
doesn't provide the option to display the window; generally, basic
depth images are not readily communicative to humans.

Parameter ``camera``:
    The camera to render from.

Parameter ``parent_frame``:
    The id for the camera's parent frame.

Parameter ``X_PC``:
    The pose of the camera body in the parent frame.

Parameter ``depth_image_out``:
    The rendered depth image.)""";
        } RenderDepthImage;
        // Symbol: drake::geometry::QueryObject::RenderLabelImage
        struct /* RenderLabelImage */ {
          // Source: drake/geometry/query_object.h:593
          const char* doc_deprecated =
R"""(Renders a label image for the given ``camera`` posed with respect to
the indicated parent frame P.

Parameter ``camera``:
    The intrinsic properties of the camera.

Parameter ``parent_frame``:
    The id for the camera's parent frame.

Parameter ``X_PC``:
    The pose of the camera body in the parent frame.

Parameter ``show_window``:
    If true, the render window will be displayed.

Parameter ``label_image_out``:
    The rendered label image. */ (Deprecated.)

Deprecated:
    CameraProperties are being deprecated. Please use the
    ColorRenderCamera variant. This will be removed from Drake on or
    after 2021-04-01.)""";
          // Source: drake/geometry/query_object.h:607
          const char* doc =
R"""(Renders a label image for the given ``camera`` posed with respect to
the indicated parent frame P.

Parameter ``camera``:
    The camera to render from.

Parameter ``parent_frame``:
    The id for the camera's parent frame.

Parameter ``X_PC``:
    The pose of the camera body in the parent frame.

Parameter ``label_image_out``:
    The rendered label image.)""";
        } RenderLabelImage;
        // Symbol: drake::geometry::QueryObject::X_PF
        struct /* X_PF */ {
          // Source: drake/geometry/query_object.h:128
          const char* doc_deprecated =
R"""(Deprecated variant of GetPoseInParent(). */ (Deprecated.)

Deprecated:
    Please use GetPoseInParent(FrameId) instead. This will be removed
    from Drake on or after 2021-04-01.)""";
        } X_PF;
        // Symbol: drake::geometry::QueryObject::X_WF
        struct /* X_WF */ {
          // Source: drake/geometry/query_object.h:115
          const char* doc_deprecated =
R"""(Deprecated variant of GetPoseInWorld(FrameId). */ (Deprecated.)

Deprecated:
    Please use GetPoseInWorld(FrameId) instead. This will be removed
    from Drake on or after 2021-04-01.)""";
        } X_WF;
        // Symbol: drake::geometry::QueryObject::X_WG
        struct /* X_WG */ {
          // Source: drake/geometry/query_object.h:138
          const char* doc_deprecated =
R"""(Deprecated variant of GetPoseInWorld(GeometryId). */ (Deprecated.)

Deprecated:
    Please use GetPoseInWorld(GeometryId) instead. This will be
    removed from Drake on or after 2021-04-01.)""";
        } X_WG;
        // Symbol: drake::geometry::QueryObject::inspector
        struct /* inspector */ {
          // Source: drake/geometry/query_object.h:96
          const char* doc =
R"""(Provides an inspector for the topological structure of the underlying
scene graph data (see SceneGraphInspector for details).)""";
        } inspector;
      } QueryObject;
      // Symbol: drake::geometry::ReadObjToSurfaceMesh
      struct /* ReadObjToSurfaceMesh */ {
        // Source: drake/geometry/proximity/obj_to_surface_mesh.h:26
        const char* doc_2args_filename_scale =
R"""(Constructs a surface mesh from a Wavefront .obj file and optionally
scales coordinates by the given scale factor. Polygons will be
triangulated if they are not triangles already. All objects in the
.obj file will be merged into the surface mesh. See
https://en.wikipedia.org/wiki/Wavefront_.obj_file for the file format.

Parameter ``filename``:
    A valid file name with absolute path or relative path.

Parameter ``scale``:
    An optional scale to coordinates.

Raises:
    RuntimeError if ``filename`` doesn't have a valid file path, or
    the file has no faces.

Returns:
    surface mesh)""";
        // Source: drake/geometry/proximity/obj_to_surface_mesh.h:33
        const char* doc_2args_input_stream_scale =
R"""(Overload of ReadObjToSurfaceMesh(const std::string&, double) with the
Wavefront .obj file given in std::istream.)""";
      } ReadObjToSurfaceMesh;
      // Symbol: drake::geometry::Rgba
      struct /* Rgba */ {
        // Source: drake/geometry/rgba.h:13
        const char* doc =
R"""(Defines RGBA (red, green, blue, alpha) values on the range [0, 1].)""";
        // Symbol: drake::geometry::Rgba::Rgba
        struct /* ctor */ {
          // Source: drake/geometry/rgba.h:19
          const char* doc =
R"""(Constructs with given (r, g, b, a) values.

Precondition:
    All values are within the range of [0, 1].)""";
        } ctor;
        // Symbol: drake::geometry::Rgba::a
        struct /* a */ {
          // Source: drake/geometry/rgba.h:33
          const char* doc = R"""(Alpha.)""";
        } a;
        // Symbol: drake::geometry::Rgba::b
        struct /* b */ {
          // Source: drake/geometry/rgba.h:30
          const char* doc = R"""(Blue.)""";
        } b;
        // Symbol: drake::geometry::Rgba::g
        struct /* g */ {
          // Source: drake/geometry/rgba.h:27
          const char* doc = R"""(Green.)""";
        } g;
        // Symbol: drake::geometry::Rgba::operator!=
        struct /* operator_ne */ {
          // Source: drake/geometry/rgba.h:58
          const char* doc = R"""()""";
        } operator_ne;
        // Symbol: drake::geometry::Rgba::r
        struct /* r */ {
          // Source: drake/geometry/rgba.h:24
          const char* doc = R"""(Red.)""";
        } r;
        // Symbol: drake::geometry::Rgba::set
        struct /* set */ {
          // Source: drake/geometry/rgba.h:38
          const char* doc =
R"""(Sets (r, g, b, a) values.

Precondition:
    All values are within the range of [0, 1]. The values are not
    updated if this precondition is not met.)""";
        } set;
      } Rgba;
      // Symbol: drake::geometry::Role
      struct /* Role */ {
        // Source: drake/geometry/geometry_roles.h:188
        const char* doc =
R"""(General enumeration for indicating geometry role.)""";
        // Symbol: drake::geometry::Role::kIllustration
        struct /* kIllustration */ {
          // Source: drake/geometry/geometry_roles.h:192
          const char* doc = R"""()""";
        } kIllustration;
        // Symbol: drake::geometry::Role::kPerception
        struct /* kPerception */ {
          // Source: drake/geometry/geometry_roles.h:193
          const char* doc = R"""()""";
        } kPerception;
        // Symbol: drake::geometry::Role::kProximity
        struct /* kProximity */ {
          // Source: drake/geometry/geometry_roles.h:191
          const char* doc = R"""()""";
        } kProximity;
        // Symbol: drake::geometry::Role::kUnassigned
        struct /* kUnassigned */ {
          // Source: drake/geometry/geometry_roles.h:190
          const char* doc = R"""()""";
        } kUnassigned;
      } Role;
      // Symbol: drake::geometry::RoleAssign
      struct /* RoleAssign */ {
        // Source: drake/geometry/geometry_roles.h:200
        const char* doc =
R"""(The operations that can be performed on the given properties when
assigning roles to geometry.)""";
        // Symbol: drake::geometry::RoleAssign::kNew
        struct /* kNew */ {
          // Source: drake/geometry/geometry_roles.h:201
          const char* doc =
R"""(Assign the properties to a geometry that doesn't already have the
role.)""";
        } kNew;
        // Symbol: drake::geometry::RoleAssign::kReplace
        struct /* kReplace */ {
          // Source: drake/geometry/geometry_roles.h:203
          const char* doc =
R"""(Replace the existing role properties completely.)""";
        } kReplace;
      } RoleAssign;
      // Symbol: drake::geometry::SceneGraph
      struct /* SceneGraph */ {
        // Source: drake/geometry/scene_graph.h:279
        const char* doc =
R"""(SceneGraph serves as the nexus for all geometry (and geometry-based
operations) in a Diagram. Through SceneGraph, other systems that
introduce geometry can *register* that geometry as part of a common
global domain, including it in geometric queries (e.g., cars
controlled by one LeafSystem can be observed by a different sensor
system). SceneGraph provides the interface for registering the
geometry, updating its position based on the current context, and
performing geometric queries.

.. pydrake_system::

    name: SceneGraph
    input_ports:
    - source_pose{0}
    - ...
    - source_pose{N-1}
    output_ports:
    - lcm_visualization
    - query

Only registered "geometry sources" can introduce geometry into
SceneGraph. Geometry sources will typically be other leaf systems,
but, in the case of *anchored* (i.e., stationary) geometry, it could
also be some other block of code (e.g., adding a common ground plane
with which all systems' geometries interact). For dynamic geometry
(geometry whose pose depends on a Context), the geometry source must
also provide pose values for all of the geometries the source owns,
via a port connection on SceneGraph. For N geometry sources, the
SceneGraph instance will have N pose input ports.

The basic workflow for interacting with SceneGraph is:

- Register as a geometry source, acquiring a unique SourceId.
- Register geometry (anchored and dynamic) with the system.
- Connect source's geometry output ports to the corresponding SceneGraph
input ports.
- Implement appropriate ``Calc*`` methods on the geometry output ports to
update geometry pose values.

Inputs
======

For each registered geometry source, there is one input port for each
order of kinematics values (e.g., pose, velocity, and acceleration).
If a source registers a frame, it must connect to these ports
(although, in the current version, only pose is supported). Failure to
connect to the port (or to provide valid kinematics values) will lead
to runtime exceptions.

**pose port**: An abstract-valued port providing an instance of
FramePoseVector. For each registered frame, this "pose vector" maps
the registered FrameId to a pose value. All registered frames must be
accounted for and only frames registered by a source can be included
in its output port. See the details in FrameKinematicsVector for
details on how to provide values for this port.

Outputs
=======

SceneGraph has two output ports:

**query port**: An abstract-valued port containing an instance of
QueryObject. It provides a "ticket" for downstream LeafSystem
instances to perform geometric queries on the SceneGraph. To perform
geometric queries, downstream LeafSystem instances acquire the
QueryObject from SceneGraph's output port and provide it as a
parameter to one of SceneGraph's query methods (e.g.,
SceneGraph::ComputeContact()). This assumes that the querying system
has access to a const pointer to the connected SceneGraph instance.
Use get_query_output_port() to acquire the output port for the query
handle.

**lcm visualization port**: An abstract-valued port containing an
instance of PoseBundle. This is a convenience port designed to feed
LCM update messages to drake_visualizer for the purpose of visualizing
the state of the world's geometry. Additional uses of this port are
strongly discouraged; instead, use an appropriate geometric query to
obtain the state of the world's geometry.

Working with SceneGraph
=======================

LeafSystem instances can relate to SceneGraph in one of two ways: as a
*consumer* that performs queries, or as a *producer* that introduces
geometry into the shared world and defines its context-dependent
kinematics values. It is reasonable for systems to perform either role
singly, or both.

**Consumer**

Consumers perform geometric queries upon the world geometry.
SceneGraph *serves* those queries. As indicated above, in order for a
LeafSystem to act as a consumer, it must: 1. define a
QueryObject-valued input port and connect it to SceneGraph's
corresponding output port, and 2. have a reference to the connected
SceneGraph instance.

With those two requirements satisfied, a LeafSystem can perform
geometry queries by: 1. evaluating the QueryObject input port, and 2.
passing the returned query object into the appropriate query method on
SceneGraph (e.g., SceneGraph::ComputeContact()).

**Producer**

All producers introduce geometry into the shared geometric world. This
is called *registering* geometry. Depending on what exactly has been
registered, a producer may also have to *update kinematics*. Producers
themselves must be registered with SceneGraph as producers (a.k.a.
*geometry sources*). They do this by acquiring a SourceId (via
SceneGraph::RegisterSource()). The SourceId serves as a unique handle
through which the producer's identity is validated and its ownership
of its registered geometry is maintained.

*Registering Geometry*

SceneGraph cannot know what geometry *should* be part of the shared
world. Other systems are responsible for introducing geometry into the
world. This process (defining geometry and informing SceneGraph) is
called *registering* the geometry. The source that registers the
geometry "owns" the geometry; the source's unique SourceId is required
to perform any operations on the geometry registered with that
SourceId. Geometry can be registered as *anchored* or *dynamic*.

Dynamic geometry can move; more specifically, its kinematics (e.g.,
pose) depends on a system's Context. Particularly, dynamic geometry is
*fixed* to a *frame* whose kinematics values depend on a context. As
the frame moves, the geometries fixed to it move with it. Therefore,
to register dynamic geometry a frame must be registered first. These
registered frames serve as the basis for repositioning geometry in the
shared world. The geometry source is responsible for providing
up-to-date kinematics values for those registered frames upon request
(via an appropriate output port on the source LeafSystem connecting to
the appropriate input port on SceneGraph). The work flow is as
follows: 1. A LeafSystem registers itself as a geometry source,
acquiring a SourceId (RegisterSource()). 2. The source registers a
frame (GeometrySource::RegisterFrame()). - A frame always has a
"parent" frame. It can implicitly be the world frame, *or* another
frame registered by the source. 3. Register one or more geometries to
a frame (GeometrySource::RegisterGeometry()). - The registered
geometry is posed relative to the frame to which it is fixed. - The
geometry can also be posed relative to another registered geometry. It
will be affixed to *that* geometry's frame.

Anchored geometry is *independent* of the context (i.e., it doesn't
move). Anchored geometries are always affixed to the immobile world
frame. As such, registering a frame is *not* required for registering
anchored geometry (see GeometrySource::RegisterAnchoredGeometry()).
However, the source still "owns" the anchored geometry.

*Updating Kinematics*

Registering *dynamic* geometry implies a contract between the geometry
source and SceneGraph. The geometry source must do the following: - It
must provide, populate, and connect two output ports: the "id" port
and the "pose" port. - The id port must contain *all* the frame ids
returned as a result of frame registration. - The pose port must
contain one pose per registered frame; the pose value is expressed
relative to the registered frame's *parent* frame. As mentioned above,
the iᵗʰ pose value should describe the frame indicated by the iᵗʰ id
in the id output port.

Failure to meet these requirements will lead to a run-time error.

Model versus Context
====================

Many (and eventually all) methods that configure the population of
SceneGraph have two variants that differ by whether they accept a
mutable Context or not. When no Context is provided, *this* SceneGraph
instance's underlying model is modified. When the SceneGraph instance
allocates a context, its model is copied into that context.

The second variant causes SceneGraph to modify the data stored in the
provided Context to be modified *instead of the internal model*.

The two interfaces *can* be used interchangeably. However,
modifications to ``this`` SceneGraph's underlying model will *not*
affect previously allocated Context instances. A new Context should be
allocated after modifying the model.

Note:
    In this initial version, the only methods with the
    Context-modifying variant are those methods that *do not* change
    the the semantics of the input or output ports. Modifications that
    make such changes must be coordinated across systems.

Detecting changes
=================

The geometry data associated with SceneGraph is coarsely versioned.
Consumers of the geometry can query for the version of the data and
recognize if the data has been modified since last examined.

The versioning is associated with geometry roles: proximity,
illustration, and perception; each role has its own, independent
version. Any operation that affects geometry with one of those roles
will modify the corresponding version. For example:


::

    // Does *not* modify any version; no roles have been assigned.
    const GeometryId geometry_id = scene_graph.RegisterGeometry(
    source_id, frame_id, make_unique<GeometryInstance>(...));
    // Modifies the proximity version.
    scene_graph.AssignRole(source_id, geometry_id, ProximityProperties());
    // Modifies the illustration version.
    scene_graph.AssignRole(source_id, geometry_id, IllustrationProperties());
    // Modifies the perception version if there exists a renderer that accepts the
    // geometry.
    scene_graph.AssignRole(source_id, geometry_id, PerceptionProperties());
    // Modifies the illustration version.
    scene_graph.RemoveRole(source_id, geometry_id, Role::kIllustration);
    // Modifies proximity version and perception version if the geometry is
    // registered with any renderer.
    scene_graph.RemoveGeometry(source_id, geometry_id);

Each copy of geometry data maintains its own set of versions.
SceneGraph's model has its own version, and that version is the same
as the version in the Context provided by
SceneGraph::CreateDefaultContext(). Modifications to the geometry data
contained in a Context modifies *that* data's version, but the
original model data's version is unmodified, reflecting the unchanged
model data.

The geometry data's version is accessed via a SceneGraphInspector
instance. model_inspector() will give access to SceneGraph's model
version. And QueryObject::inspector() will give access to the geometry
data stored in a Context.

Current versions can be compared against previously examined versions.
If the versions match, then the geometry data is guaranteed to be the
same. If they don't match, that indicates that the two sets of data
underwent different revision processes. That, however, doesn't
necessarily imply that the two sets of data are distinct. In other
words, the versioning will report a difference unless it can guarantee
equivalence.

It is possible that two different contexts have different versions and
a downstream system can be evaluated with each context alternatingly.
If the system behavior depends on the geometry version, this will
cause it to thrash whatever components depends on geometry version.
The system should *clearly* document this fact.)""";
        // Symbol: drake::geometry::SceneGraph::AddRenderer
        struct /* AddRenderer */ {
          // Source: drake/geometry/scene_graph.h:592
          const char* doc =
R"""(Adds a new render engine to this SceneGraph. The SceneGraph owns the
render engine. The render engine's name should be referenced in the
render::ColorRenderCamera "ColorRenderCamera" or
render::DepthRenderCamera "DepthRenderCamera" provided in the render
queries (see QueryObject::RenderColorImage() as an example).

There is no restriction on when a renderer is added relative to
geometry registration and role assignment. Given a representative
sequence of registration and perception role assignment, the addition
of the renderer can be introduced anywhere in the sequence and the end
result would be the same.


::

    GeometryId id1 = scene_graph.RegisterGeometry(source_id, ...);
    scene_graph.AssignRole(source_id, id1, PerceptionProperties());
    GeometryId id2 = scene_graph.RegisterGeometry(source_id, ...);
    scene_graph.AssignRole(source_id, id2, PerceptionProperties());
    GeometryId id3 = scene_graph.RegisterGeometry(source_id, ...);
    scene_graph.AssignRole(source_id, id3, PerceptionProperties());

Modifies the perception version if ``renderer`` accepts any previously
existing geometries (see scene_graph_versioning).

Parameter ``name``:
    The unique name of the renderer.

Parameter ``renderer``:
    The ``renderer`` to add.

Raises:
    RuntimeError if the name is not unique.)""";
        } AddRenderer;
        // Symbol: drake::geometry::SceneGraph::AssignRole
        struct /* AssignRole */ {
          // Source: drake/geometry/scene_graph.h:691
          const char* doc_proximity_direct =
R"""(Assigns the proximity role to the geometry indicated by
``geometry_id``. Modifies the proximity version (see
scene_graph_versioning).)""";
          // Source: drake/geometry/scene_graph.h:701
          const char* doc_proximity_context =
R"""(systems::Context-modifying variant of
AssignRole(SourceId,GeometryId,ProximityProperties) "AssignRole()" for
proximity properties. Rather than modifying SceneGraph's model, it
modifies the copy of the model stored in the provided context.)""";
          // Source: drake/geometry/scene_graph.h:718
          const char* doc_perception_direct =
R"""(Assigns the perception role to the geometry indicated by
``geometry_id``.

By default, a geometry with a perception role will be reified by all
render::RenderEngine instances. This behavior can be changed.
Renderers can be explicitly whitelisted via the ('renderer',
'accepting') perception property. Its type is std::set<std::string>
and it contains the names of all the renderers that *may* reify it. If
no property is defined (or an empty set is given), then the default
behavior of all renderers attempting to reify it will be restored.
Modifies the perception version if the geometry is added to any
renderer (see scene_graph_versioning).)""";
          // Source: drake/geometry/scene_graph.h:728
          const char* doc_perception_context =
R"""(systems::Context-modifying variant of
AssignRole(SourceId,GeometryId,PerceptionProperties) "AssignRole()"
for perception properties. Rather than modifying SceneGraph's model,
it modifies the copy of the model stored in the provided context.)""";
          // Source: drake/geometry/scene_graph.h:743
          const char* doc_illustration_direct =
R"""(Assigns the illustration role to the geometry indicated by
``geometry_id``. Modifies the illustration version (see
scene_graph_versioning).

Warning:
    When changing illustration properties (``assign =
    RoleAssign::kReplace``), there is no guarantee that these changes
    will affect the visualization. The visualizer needs to be able to
    "initialize" itself after changes to properties that will affect
    how a geometry appears. If changing a geometry's illustration
    properties doesn't seem to be affecting the visualization,
    retrigger its initialization action.)""";
          // Source: drake/geometry/scene_graph.h:766
          const char* doc_illustration_context =
R"""(systems::Context-modifying variant of
AssignRole(SourceId,GeometryId,IllustrationProperties) "AssignRole()"
for illustration properties. Rather than modifying SceneGraph's model,
it modifies the copy of the model stored in the provided context.

Warning:
    When changing illustration properties (``assign =
    RoleAssign::kReplace``), there is no guarantee that these changes
    will affect the visualization. The visualizer needs to be able to
    "initialize" itself after changes to properties that will affect
    how a geometry appears. If changing a geometry's illustration
    properties doesn't seem to be affecting the visualization,
    retrigger its initialization action.

Warning:
    Due to a bug (see issue `#13597
    <https://github.com/RobotLocomotion/drake/issues/13597>`_),
    changing the illustration roles or properties in a
    systems::Context will not have any apparent effect in, at least,
    drake_visualizer. Please change the illustration role in the model
    prior to allocating the context.)""";
        } AssignRole;
        // Symbol: drake::geometry::SceneGraph::ExcludeCollisionsBetween
        struct /* ExcludeCollisionsBetween */ {
          // Source: drake/geometry/scene_graph.h:898
          const char* doc_2args =
R"""(Excludes geometry pairs from collision evaluation by updating the
candidate pair set ``C = C - P``, where ``P = {(a, b)}, ∀ a ∈ A, b ∈
B`` and ``A = {a₀, a₁, ..., aₘ}`` and ``B = {b₀, b₁, ..., bₙ}`` are
the input sets of geometries ``setA`` and ``setB``, respectively. This
does *not* preclude collisions between members of the *same* set.
Modifies the proximity version (see scene_graph_versioning).

See also:
    scene_graph_collision_filtering for requirements and how collision
    filtering works.

Raises:
    RuntimeError if the groups include ids that don't exist in the
    scene graph.)""";
          // Source: drake/geometry/scene_graph.h:904
          const char* doc_3args =
R"""(systems::Context-modifying variant of ExcludeCollisionsBetween().
Rather than modifying SceneGraph's model, it modifies the copy of the
model stored in the provided context.)""";
        } ExcludeCollisionsBetween;
        // Symbol: drake::geometry::SceneGraph::ExcludeCollisionsWithin
        struct /* ExcludeCollisionsWithin */ {
          // Source: drake/geometry/scene_graph.h:878
          const char* doc_1args =
R"""(Excludes geometry pairs from collision evaluation by updating the
candidate pair set ``C = C - P``, where ``P = {(gᵢ, gⱼ)}, ∀ gᵢ, gⱼ ∈
G`` and ``G = {g₀, g₁, ..., gₘ}`` is the input ``set`` of geometries.

This method modifies the underlying model and requires a new Context
to be allocated. Modifies the proximity version (see
scene_graph_versioning).

See also:
    scene_graph_collision_filtering for requirements and how collision
    filtering works.

Raises:
    RuntimeError if the set includes ids that don't exist in the scene
    graph.)""";
          // Source: drake/geometry/scene_graph.h:883
          const char* doc_2args =
R"""(systems::Context-modifying variant of ExcludeCollisionsWithin().
Rather than modifying SceneGraph's model, it modifies the copy of the
model stored in the provided context.)""";
        } ExcludeCollisionsWithin;
        // Symbol: drake::geometry::SceneGraph::HasRenderer
        struct /* HasRenderer */ {
          // Source: drake/geometry/scene_graph.h:597
          const char* doc =
R"""(Reports if this SceneGraph has a renderer registered to the given
name.)""";
        } HasRenderer;
        // Symbol: drake::geometry::SceneGraph::RegisterAnchoredGeometry
        struct /* RegisterAnchoredGeometry */ {
          // Source: drake/geometry/scene_graph.h:531
          const char* doc =
R"""(Registers a new *anchored* geometry G for this source. This hangs
geometry G from the world frame (W). Its pose is defined in that frame
(i.e., ``X_WG``). Returns the corresponding unique geometry id.

Roles will be assigned to the registered geometry if the corresponding
GeometryInstance ``geometry`` has had properties assigned.

This method modifies the underlying model and requires a new Context
to be allocated. Potentially modifies proximity, perception, and
illustration versions based on the roles assigned to the geometry (see
scene_graph_versioning).

Parameter ``source_id``:
    The id for the source registering the frame.

Parameter ``geometry``:
    The anchored geometry G to add to the world.

Returns:
    A unique identifier for the added geometry.

Raises:
    RuntimeError if a) the ``source_id`` does *not* map to a
    registered source or b) the geometry's name doesn't satisfy the
    requirements outlined in GeometryInstance.)""";
        } RegisterAnchoredGeometry;
        // Symbol: drake::geometry::SceneGraph::RegisterFrame
        struct /* RegisterFrame */ {
          // Source: drake/geometry/scene_graph.h:422
          const char* doc_2args =
R"""(Registers a new frame F for this source. This hangs frame F on the
world frame (W). Its pose is defined relative to the world frame (i.e,
``X_WF``). Returns the corresponding unique frame id.

This method modifies the underlying model and requires a new Context
to be allocated.

Parameter ``source_id``:
    The id for the source registering the frame.

Parameter ``frame``:
    The frame to register.

Returns:
    A unique identifier for the added frame.

Raises:
    RuntimeError if a) the ``source_id`` does *not* map to a
    registered source, or b) ``frame`` has an id that has already been
    registered.)""";
          // Source: drake/geometry/scene_graph.h:442
          const char* doc_3args =
R"""(Registers a new frame F for this source. This hangs frame F on another
previously registered frame P (indicated by ``parent_id``). The pose
of the new frame is defined relative to the parent frame (i.e.,
``X_PF``). Returns the corresponding unique frame id.

This method modifies the underlying model and requires a new Context
to be allocated.

Parameter ``source_id``:
    The id for the source registering the frame.

Parameter ``parent_id``:
    The id of the parent frame P.

Parameter ``frame``:
    The frame to register.

Returns:
    A unique identifier for the added frame.

Raises:
    RuntimeError if a) the ``source_id`` does *not* map to a
    registered source, b) the ``parent_id`` does *not* map to a known
    frame or does not belong to the source, or c) ``frame`` has an id
    that has already been registered.)""";
        } RegisterFrame;
        // Symbol: drake::geometry::SceneGraph::RegisterGeometry
        struct /* RegisterGeometry */ {
          // Source: drake/geometry/scene_graph.h:468
          const char* doc_3args_source_id_frame_id_geometry =
R"""(Registers a new geometry G for this source. This hangs geometry G on a
previously registered frame F (indicated by ``frame_id``). The pose of
the geometry is defined in a fixed pose relative to F (i.e.,
``X_FG``). Returns the corresponding unique geometry id.

Roles will be assigned to the registered geometry if the corresponding
GeometryInstance ``geometry`` has had properties assigned.

This method modifies the underlying model and requires a new Context
to be allocated. Potentially modifies proximity, perception, and
illustration versions based on the roles assigned to the geometry (see
scene_graph_versioning).

Parameter ``source_id``:
    The id for the source registering the geometry.

Parameter ``frame_id``:
    The id for the frame F to hang the geometry on.

Parameter ``geometry``:
    The geometry G to affix to frame F.

Returns:
    A unique identifier for the added geometry.

Raises:
    RuntimeError if a) the ``source_id`` does *not* map to a
    registered source, b) the ``frame_id`` doesn't belong to the
    source, c) the ``geometry`` is equal to ``nullptr``, or d) the
    geometry's name doesn't satisfy the requirements outlined in
    GeometryInstance.)""";
          // Source: drake/geometry/scene_graph.h:474
          const char* doc_4args_context_source_id_frame_id_geometry =
R"""(systems::Context-modifying variant of RegisterGeometry(). Rather than
modifying SceneGraph's model, it modifies the copy of the model stored
in the provided context.)""";
          // Source: drake/geometry/scene_graph.h:502
          const char* doc_3args_source_id_geometry_id_geometry =
R"""(Registers a new geometry G for this source. This hangs geometry G on a
previously registered geometry P (indicated by ``geometry_id``). The
pose of the geometry is defined in a fixed pose relative to geometry P
(i.e., ``X_PG``). By induction, this geometry is effectively rigidly
affixed to the frame that P is affixed to. Returns the corresponding
unique geometry id.

Roles will be assigned to the registered geometry if the corresponding
GeometryInstance ``geometry`` has had properties assigned.

This method modifies the underlying model and requires a new Context
to be allocated. Potentially modifies proximity, perception, and
illustration versions based on the roles assigned to the geometry (see
scene_graph_versioning).

Parameter ``source_id``:
    The id for the source registering the geometry.

Parameter ``geometry_id``:
    The id for the parent geometry P.

Parameter ``geometry``:
    The geometry G to add.

Returns:
    A unique identifier for the added geometry.

Raises:
    RuntimeError if a) the ``source_id`` does *not* map to a
    registered source, b) the ``geometry_id`` doesn't belong to the
    source, c) the ``geometry`` is equal to ``nullptr``, or d) the
    geometry's name doesn't satisfy the requirements outlined in
    GeometryInstance.)""";
        } RegisterGeometry;
        // Symbol: drake::geometry::SceneGraph::RegisterSource
        struct /* RegisterSource */ {
          // Source: drake/geometry/scene_graph.h:343
          const char* doc =
R"""(Registers a new, named source to the geometry system. The caller must
save the returned SourceId; it is the token by which all other
operations on the geometry world are conducted.

This source id can be used to register arbitrary *anchored* geometry.
But if dynamic geometry is registered (via
RegisterGeometry/RegisterFrame), then the context-dependent pose
values must be provided on an input port. See get_source_pose_port().

This method modifies the underlying model and requires a new Context
to be allocated.

Parameter ``name``:
    The optional name of the source. If none is provided (or the empty
    string) a default name will be defined by SceneGraph's logic.

Raises:
    RuntimeError if the name is not unique.)""";
        } RegisterSource;
        // Symbol: drake::geometry::SceneGraph::RegisteredRendererNames
        struct /* RegisteredRendererNames */ {
          // Source: drake/geometry/scene_graph.h:603
          const char* doc =
R"""(Reports the names of all registered renderers.)""";
        } RegisteredRendererNames;
        // Symbol: drake::geometry::SceneGraph::RemoveGeometry
        struct /* RemoveGeometry */ {
          // Source: drake/geometry/scene_graph.h:552
          const char* doc_2args =
R"""(Removes the given geometry G (indicated by ``geometry_id``) from the
given source's registered geometries. All registered geometries
hanging from this geometry will also be removed.

This method modifies the underlying model and requires a new Context
to be allocated. Potentially modifies proximity, perception, and
illustration versions based on the roles assigned to the geometry (see
scene_graph_versioning).

Parameter ``source_id``:
    The identifier for the owner geometry source.

Parameter ``geometry_id``:
    The identifier of the geometry to remove (can be dynamic or
    anchored).

Raises:
    RuntimeError if a) the ``source_id`` does *not* map to a
    registered source, b) the ``geometry_id`` does not map to a valid
    geometry, or c) the ``geometry_id`` maps to a geometry that does
    not belong to the indicated source.)""";
          // Source: drake/geometry/scene_graph.h:557
          const char* doc_3args =
R"""(systems::Context-modifying variant of RemoveGeometry(). Rather than
modifying SceneGraph's model, it modifies the copy of the model stored
in the provided context.)""";
        } RemoveGeometry;
        // Symbol: drake::geometry::SceneGraph::RemoveRole
        struct /* RemoveRole */ {
          // Source: drake/geometry/scene_graph.h:782
          const char* doc_3args_source_id_frame_id_role =
R"""(Removes the indicated ``role`` from any geometry directly registered
to the frame indicated by ``frame_id`` (if the geometry has the role).
Potentially modifies the proximity, perception, or illustration
version based on the role being removed from the geometry (see
scene_graph_versioning).

Returns:
    The number of geometries affected by the removed role.

Raises:
    RuntimeError if a) ``source_id`` does not map to a registered
    source, b) ``frame_id`` does not map to a registered frame, c)
    ``frame_id`` does not belong to ``source_id`` (unless ``frame_id``
    is the world frame id), or d) the context has already been
    allocated.)""";
          // Source: drake/geometry/scene_graph.h:788
          const char* doc_4args_context_source_id_frame_id_role =
R"""(systems::Context-modifying variant of
RemoveRole(SourceId,FrameId,Role) "RemoveRole()" for frames. Rather
than modifying SceneGraph's model, it modifies the copy of the model
stored in the provided context.)""";
          // Source: drake/geometry/scene_graph.h:804
          const char* doc_geometry_direct =
R"""(Removes the indicated ``role`` from the geometry indicated by
``geometry_id``. Potentially modifies the proximity, perception, or
illustration version based on the role being removed from the geometry
(see scene_graph_versioning).

Returns:
    One if the geometry had the role removed and zero if the geometry
    did not have the role assigned in the first place.

Raises:
    RuntimeError if a) ``source_id`` does not map to a registered
    source, b) ``geometry_id`` does not map to a registered geometry,
    c) ``geometry_id`` does not belong to ``source_id``, or d) the
    context has already been allocated.)""";
          // Source: drake/geometry/scene_graph.h:810
          const char* doc_4args_context_source_id_geometry_id_role =
R"""(systems::Context-modifying variant of
RemoveRole(SourceId,GeometryId,Role) "RemoveRole()" for individual
geometries. Rather than modifying SceneGraph's model, it modifies the
copy of the model stored in the provided context.)""";
        } RemoveRole;
        // Symbol: drake::geometry::SceneGraph::RendererCount
        struct /* RendererCount */ {
          // Source: drake/geometry/scene_graph.h:600
          const char* doc =
R"""(Reports the number of renderers registered to this SceneGraph.)""";
        } RendererCount;
        // Symbol: drake::geometry::SceneGraph::SceneGraph<T>
        struct /* ctor */ {
          // Source: drake/geometry/scene_graph.h:284
          const char* doc =
R"""(Constructs a default (empty) scene graph.)""";
          // Source: drake/geometry/scene_graph.h:306
          const char* doc_deprecated =
R"""(Constructs a default (empty) scene graph.

Historically, geometry data (aka GeometryState) has been stored as
State in the Context. This is no longer the default; now it is stored
as a Parameter. This deprecated constructor allows you to exercise the
legacy behavior during the deprecation period (by passing ``True``).

The expectation is there are no current uses of SceneGraph that
*require* the data to be stored in State and, as such, this
constructor should largely go unused. If you *do* feel you require it,
please post an issue so we can resolve it prior to complete
deprecation of this behavior.

Parameter ``data_as_state``:
    ``True`` stores the data as State; ``False`` stores it as a
    Parameter. */ (Deprecated.)

Deprecated:
    The choice of storing geometry data as State has been deprecated.
    Please use the default constructor which sets the geometry data as
    a Parameter. If this doesn't work for you please submit an issue
    in Drake describing your problem. This will be removed from Drake
    on or after 2021-04-01.)""";
          // Source: drake/geometry/scene_graph.h:311
          const char* doc_copyconvert =
R"""(Constructor used for scalar conversions. It should only be used to
convert *from* double *to* other scalar types.)""";
        } ctor;
        // Symbol: drake::geometry::SceneGraph::SourceIsRegistered
        struct /* SourceIsRegistered */ {
          // Source: drake/geometry/scene_graph.h:347
          const char* doc =
R"""(Reports if the given source id is registered.

Parameter ``id``:
    The id of the source to query.)""";
        } SourceIsRegistered;
        // Symbol: drake::geometry::SceneGraph::get_pose_bundle_output_port
        struct /* get_pose_bundle_output_port */ {
          // Source: drake/geometry/scene_graph.h:357
          const char* doc =
R"""(Returns the output port which produces the PoseBundle for LCM
communication to drake visualizer.)""";
        } get_pose_bundle_output_port;
        // Symbol: drake::geometry::SceneGraph::get_query_output_port
        struct /* get_query_output_port */ {
          // Source: drake/geometry/scene_graph.h:363
          const char* doc =
R"""(Returns the output port which produces the QueryObject for performing
geometric queries.)""";
        } get_query_output_port;
        // Symbol: drake::geometry::SceneGraph::get_source_pose_port
        struct /* get_source_pose_port */ {
          // Source: drake/geometry/scene_graph.h:353
          const char* doc =
R"""(Given a valid source ``id``, returns a *pose* input port associated
with that ``id``. This port is used to communicate *pose* data for
registered frames.

Raises:
    RuntimeError if the source_id is *not* recognized.)""";
        } get_source_pose_port;
        // Symbol: drake::geometry::SceneGraph::model_inspector
        struct /* model_inspector */ {
          // Source: drake/geometry/scene_graph.h:821
          const char* doc =
R"""(Returns an inspector on the system's *model* scene graph data.)""";
        } model_inspector;
        // Symbol: drake::geometry::SceneGraph::world_frame_id
        struct /* world_frame_id */ {
          // Source: drake/geometry/scene_graph.h:816
          const char* doc =
R"""(Reports the identifier for the world frame.)""";
        } world_frame_id;
      } SceneGraph;
      // Symbol: drake::geometry::SceneGraphInspector
      struct /* SceneGraphInspector */ {
        // Source: drake/geometry/scene_graph_inspector.h:60
        const char* doc =
R"""(The SceneGraphInspector serves as a mechanism to query the topological
structure of a SceneGraph instance. The topological structure consists
of all of the SceneGraph data that does *not* depend on input pose
data. Including, but not limited to:

- names of frames and geometries
- hierarchies (parents of geometries, parents of frames, etc.)
- geometry parameters (e.g., contact, rendering, visualization)
- fixed poses of geometries relative to frames

In contrast, the following pieces of data *do* depend on input pose
data and *cannot* be performed with the SceneGraphInspector (see the
QueryObject instead):

- world pose of frames or geometry
- collision queries
- proximity queries

A SceneGraphInspector cannot be instantiated explicitly. Nor can it be
copied or moved. A *reference* to a SceneGraphInspector instance can
be acquired from

- a SceneGraph instance (to inspect the state of the system's *model*), or
- a QueryObject instance (to inspect the state of the scene graph data stored
in the context).

The reference should not be persisted (and, as previously indicated,
cannot be copied). SceneGraphInspector instances are cheap; they can
be created, queried, and thrown out. If there is any doubt about the
valid lifespan of a SceneGraphInspector, throw out the old instance
and request a new instance.

Template parameter ``T``:
    The scalar of the associated SceneGraph instance. The template
    parameter is provided for the sake of compatibility, although no
    queries (or their results) depend on the scalar.)""";
        // Symbol: drake::geometry::SceneGraphInspector::BelongsToSource
        struct /* BelongsToSource */ {
          // Source: drake/geometry/scene_graph_inspector.h:215
          const char* doc_2args_frame_id_source_id =
R"""(Reports if the frame with given ``frame_id`` was registered to the
source with the given ``source_id``.

Parameter ``frame_id``:
    The query frame id.

Parameter ``source_id``:
    The query source id.

Returns:
    True if ``frame_id`` was registered on ``source_id``.

Raises:
    RuntimeError If ``frame_id`` does not map to a registered frame or
    ``source_id`` does not map to a registered source.)""";
          // Source: drake/geometry/scene_graph_inspector.h:311
          const char* doc_2args_geometry_id_source_id =
R"""(Reports if the given geometry id was registered to the source with the
given source id.

Parameter ``geometry_id``:
    The query geometry id.

Parameter ``source_id``:
    The query source id.

Returns:
    True if ``geometry_id`` was registered on ``source_id``.

Raises:
    RuntimeError If ``geometry_id`` does not map to a registered
    geometry or ``source_id`` does not map to a registered source.)""";
        } BelongsToSource;
        // Symbol: drake::geometry::SceneGraphInspector::CloneGeometryInstance
        struct /* CloneGeometryInstance */ {
          // Source: drake/geometry/scene_graph_inspector.h:471
          const char* doc =
R"""(Obtains a new GeometryInstance that copies the geometry indicated by
the given ``geometry_id``.

Returns:
    A new GeometryInstance that is ready to be added as a new
    geometry. All roles/properties will be copied, the shape will be
    cloned based off of the original, but the returned id() will
    completely unique.

Raises:
    RuntimeError if the ``geometry_id`` does not refer to a valid
    geometry.)""";
        } CloneGeometryInstance;
        // Symbol: drake::geometry::SceneGraphInspector::CollisionFiltered
        struct /* CollisionFiltered */ {
          // Source: drake/geometry/scene_graph_inspector.h:446
          const char* doc =
R"""(Reports true if the two geometries with given ids ``geometry_id1`` and
``geometry_id2``, define a collision pair that has been filtered out.

Raises:
    RuntimeError if either id does not map to a registered geometry or
    if any of the geometries do not have a proximity role.)""";
        } CollisionFiltered;
        // Symbol: drake::geometry::SceneGraphInspector::FramesForSource
        struct /* FramesForSource */ {
          // Source: drake/geometry/scene_graph_inspector.h:197
          const char* doc =
R"""(Reports the ids of all of the frames registered to the source with the
given source ``source_id``.

Raises:
    RuntimeError if ``source_id`` does not map to a registered source.)""";
        } FramesForSource;
        // Symbol: drake::geometry::SceneGraphInspector::GetAllGeometryIds
        struct /* GetAllGeometryIds */ {
          // Source: drake/geometry/scene_graph_inspector.h:119
          const char* doc =
R"""(Returns the set of all ids for registered geometries. The order is
*not* guaranteed to have any particular meaning. But the order is
guaranteed to remain fixed until a topological change is made (e.g.,
removal or addition of geometry/frames).)""";
        } GetAllGeometryIds;
        // Symbol: drake::geometry::SceneGraphInspector::GetCollisionCandidates
        struct /* GetCollisionCandidates */ {
          // Source: drake/geometry/scene_graph_inspector.h:152
          const char* doc =
R"""(Returns all pairs of geometries that are candidates for collision (in
no particular order). See SceneGraph::ExcludeCollisionsBetween() or
SceneGraph::ExcludeCollisionsWithin() for information on why a
particular pair may *not* be a candidate. For candidate pair (A, B),
the candidate is always guaranteed to be reported in a fixed order
(i.e., always (A, B) and *never* (B, A)). This is the same ordering as
would be returned by, e.g.,
QueryObject::ComputePointPairPenetration().)""";
        } GetCollisionCandidates;
        // Symbol: drake::geometry::SceneGraphInspector::GetFrameGroup
        struct /* GetFrameGroup */ {
          // Source: drake/geometry/scene_graph_inspector.h:240
          const char* doc =
R"""(Reports the frame group for the frame with the given ``frame_id``.

Raises:
    RuntimeError if ``frame_id`` does not map to a registered frame.
    This value is equivalent to the old "model instance id".)""";
        } GetFrameGroup;
        // Symbol: drake::geometry::SceneGraphInspector::GetFrameId
        struct /* GetFrameId */ {
          // Source: drake/geometry/scene_graph_inspector.h:329
          const char* doc =
R"""(Reports the id of the frame to which the given geometry with the given
``geometry_id`` is registered.

Raises:
    RuntimeError if ``geometry_id`` does not map to a registered
    geometry.)""";
        } GetFrameId;
        // Symbol: drake::geometry::SceneGraphInspector::GetGeometries
        struct /* GetGeometries */ {
          // Source: drake/geometry/scene_graph_inspector.h:273
          const char* doc =
R"""(Returns geometry ids that have been registered directly to the frame
indicated by ``frame_id``. If a ``role`` is provided, only geometries
with that role assigned will be returned, otherwise all geometries
will be returned.

Parameter ``frame_id``:
    The id of the frame in question.

Parameter ``role``:
    The requested role; if omitted, all geometries registered to the
    frame are returned.

Returns:
    The requested unique geometry ids in a consistent order.

Raises:
    RuntimeError if ``id`` does not map to a registered frame.)""";
        } GetGeometries;
        // Symbol: drake::geometry::SceneGraphInspector::GetGeometryIdByName
        struct /* GetGeometryIdByName */ {
          // Source: drake/geometry/scene_graph_inspector.h:292
          const char* doc =
R"""(Reports the id of the geometry with the given ``name`` and ``role``,
attached to the frame with the given frame ``frame_id``.

Parameter ``frame_id``:
    The frame_id of the frame whose geometry is being queried.

Parameter ``role``:
    The assigned role of the desired geometry.

Parameter ``name``:
    The name of the geometry to query for. The name will be
    canonicalized prior to lookup (see canonicalized_geometry_names
    "GeometryInstance" for details).

Returns:
    The id of the queried geometry.

Raises:
    RuntimeError if no such geometry exists, multiple geometries have
    that name, or if the ``frame_id`` does not map to a registered
    frame.)""";
        } GetGeometryIdByName;
        // Symbol: drake::geometry::SceneGraphInspector::GetIllustrationProperties
        struct /* GetIllustrationProperties */ {
          // Source: drake/geometry/scene_graph_inspector.h:422
          const char* doc =
R"""(Returns a pointer to the const illustration properties of the geometry
with the given ``geometry_id``.

Parameter ``geometry_id``:
    The identifier for the queried geometry.

Returns:
    A pointer to the properties (or ``nullptr`` if there are no such
    properties).

Raises:
    RuntimeError if ``geometry_id`` does not map to a registered
    geometry.)""";
        } GetIllustrationProperties;
        // Symbol: drake::geometry::SceneGraphInspector::GetName
        struct /* GetName */ {
          // Source: drake/geometry/scene_graph_inspector.h:171
          const char* doc_1args_source_id =
R"""(Reports the name for the source with the given ``source_id``.

Raises:
    RuntimeError if ``source_id`` does not map to a registered source.)""";
          // Source: drake/geometry/scene_graph_inspector.h:232
          const char* doc_1args_frame_id =
R"""(Reports the name of the frame with the given ``frame_id``.

Raises:
    RuntimeError if ``frame_id`` does not map to a registered frame.)""";
          // Source: drake/geometry/scene_graph_inspector.h:339
          const char* doc_1args_geometry_id =
R"""(Reports the stored, canonical name of the geometry with the given
``geometry_id`` (see canonicalized_geometry_names "GeometryInstance"
for details).

Raises:
    RuntimeError if ``geometry_id`` does not map to a registered
    geometry.)""";
        } GetName;
        // Symbol: drake::geometry::SceneGraphInspector::GetOwningSourceName
        struct /* GetOwningSourceName */ {
          // Source: drake/geometry/scene_graph_inspector.h:224
          const char* doc_1args_frame_id =
R"""(Reports the *name* of the geometry source that registered the frame
with the given ``frame_id``.

Raises:
    RuntimeError If ``frame_id`` does not map to a registered frame.)""";
          // Source: drake/geometry/scene_graph_inspector.h:320
          const char* doc_1args_geometry_id =
R"""(Reports the *name* of the geometry source that registered the geometry
with the given ``geometry_id``.

Raises:
    RuntimeError If ``geometry_id`` does not map to a registered
    geometry.)""";
        } GetOwningSourceName;
        // Symbol: drake::geometry::SceneGraphInspector::GetPerceptionProperties
        struct /* GetPerceptionProperties */ {
          // Source: drake/geometry/scene_graph_inspector.h:435
          const char* doc =
R"""(Returns a pointer to the const perception properties of the geometry
with the given ``geometry_id``.

Parameter ``geometry_id``:
    The identifier for the queried geometry.

Returns:
    A pointer to the properties (or ``nullptr`` if there are no such
    properties).

Raises:
    RuntimeError if ``geometry_id`` does not map to a registered
    geometry.)""";
        } GetPerceptionProperties;
        // Symbol: drake::geometry::SceneGraphInspector::GetPoseInFrame
        struct /* GetPoseInFrame */ {
          // Source: drake/geometry/scene_graph_inspector.h:372
          const char* doc =
R"""(Reports the pose of the geometry G with the given ``geometry_id`` in
its registered frame F (regardless of whether its *topological parent*
is another geometry P or not). If the geometry was registered directly
to the frame F, then ``X_PG = X_FG``.

See also:
    GetPoseInParent()

Raises:
    RuntimeError if ``geometry_id`` does not map to a registered
    geometry.)""";
        } GetPoseInFrame;
        // Symbol: drake::geometry::SceneGraphInspector::GetPoseInParent
        struct /* GetPoseInParent */ {
          // Source: drake/geometry/scene_graph_inspector.h:359
          const char* doc =
R"""(Reports the pose of the geometry G with the given ``geometry_id`` in
its registered *topological parent* P, ``X_PG``. That topological
parent may be a frame F or another geometry. If the geometry was
registered directly to F, then ``X_PG = X_FG``.

See also:
    GetPoseInFrame()

Raises:
    RuntimeError if ``geometry_id`` does not map to a registered
    geometry.)""";
        } GetPoseInParent;
        // Symbol: drake::geometry::SceneGraphInspector::GetProperties
        struct /* GetProperties */ {
          // Source: drake/geometry/scene_graph_inspector.h:386
          const char* doc =
R"""(Return a pointer to the const properties indicated by ``role`` of the
geometry with the given ``geometry_id``.

Parameter ``geometry_id``:
    The identifier for the queried geometry.

Parameter ``role``:
    The role whose properties are acquired.

Returns:
    A pointer to the properties (or ``nullptr`` if there are no such
    properties).

Raises:
    RuntimeError if ``geometry_id`` does not map to a registered
    geometry.)""";
        } GetProperties;
        // Symbol: drake::geometry::SceneGraphInspector::GetProximityProperties
        struct /* GetProximityProperties */ {
          // Source: drake/geometry/scene_graph_inspector.h:409
          const char* doc =
R"""(Returns a pointer to the const proximity properties of the geometry
with the given ``geometry_id``.

Parameter ``geometry_id``:
    The identifier for the queried geometry.

Returns:
    A pointer to the properties (or ``nullptr`` if there are no such
    properties).

Raises:
    RuntimeError if ``geometry_id`` does not map to a registered
    geometry.)""";
        } GetProximityProperties;
        // Symbol: drake::geometry::SceneGraphInspector::GetShape
        struct /* GetShape */ {
          // Source: drake/geometry/scene_graph_inspector.h:347
          const char* doc =
R"""(Returns the shape specified for the geometry with the given
``geometry_id``. In order to extract the details of the shape, it
should be passed through an implementation of a ShapeReifier.)""";
        } GetShape;
        // Symbol: drake::geometry::SceneGraphInspector::GetSourceName
        struct /* GetSourceName */ {
          // Source: drake/geometry/scene_graph_inspector.h:179
          const char* doc_deprecated =
R"""(Reports the name for the source with the given ``id``.

Raises:
    RuntimeError if ``id`` does not map to a registered source. */
    (Deprecated.)

Deprecated:
    Please use GetName(SourceId) instead. This will be removed from
    Drake on or after 2021-04-01.)""";
        } GetSourceName;
        // Symbol: drake::geometry::SceneGraphInspector::NumAnchoredGeometries
        struct /* NumAnchoredGeometries */ {
          // Source: drake/geometry/scene_graph_inspector.h:140
          const char* doc =
R"""(Reports the total number of *anchored* geometries. This should provide
the same answer as calling NumGeometriesForFrame() with the world
frame id.)""";
        } NumAnchoredGeometries;
        // Symbol: drake::geometry::SceneGraphInspector::NumDynamicGeometries
        struct /* NumDynamicGeometries */ {
          // Source: drake/geometry/scene_graph_inspector.h:132
          const char* doc =
R"""(Reports the total number of *dynamic* geometries in the scene graph.)""";
        } NumDynamicGeometries;
        // Symbol: drake::geometry::SceneGraphInspector::NumFramesForSource
        struct /* NumFramesForSource */ {
          // Source: drake/geometry/scene_graph_inspector.h:188
          const char* doc =
R"""(Reports the number of frames registered to the source with the given
``source_id``.

Raises:
    RuntimeError if ``source_id`` does not map to a registered source.)""";
        } NumFramesForSource;
        // Symbol: drake::geometry::SceneGraphInspector::NumGeometriesForFrame
        struct /* NumGeometriesForFrame */ {
          // Source: drake/geometry/scene_graph_inspector.h:250
          const char* doc =
R"""(Reports the number of geometries affixed to the frame with the given
``frame_id``. This count does *not* include geometries attached to
frames that are descendants of this frame.

Raises:
    RuntimeError if ``frame_id`` does not map to a registered frame.)""";
        } NumGeometriesForFrame;
        // Symbol: drake::geometry::SceneGraphInspector::NumGeometriesForFrameWithRole
        struct /* NumGeometriesForFrameWithRole */ {
          // Source: drake/geometry/scene_graph_inspector.h:260
          const char* doc =
R"""(Reports the total number of geometries with the given ``role``
directly registered to the frame with the given ``frame_id``. This
count does *not* include geometries attached to frames that are
descendants of this frame.

Raises:
    RuntimeError if ``frame_id`` does not map to a registered frame.)""";
        } NumGeometriesForFrameWithRole;
        // Symbol: drake::geometry::SceneGraphInspector::NumGeometriesWithRole
        struct /* NumGeometriesWithRole */ {
          // Source: drake/geometry/scene_graph_inspector.h:126
          const char* doc =
R"""(Reports the *total* number of geometries in the scene graph with the
indicated role.)""";
        } NumGeometriesWithRole;
        // Symbol: drake::geometry::SceneGraphInspector::Reify
        struct /* Reify */ {
          // Source: drake/geometry/scene_graph_inspector.h:458
          const char* doc =
R"""(Introspects the geometry indicated by the given ``geometry_id``. The
geometry will be passed into the provided ``reifier``. This is the
mechanism by which external code can discover and respond to the
different types of geometries stored in SceneGraph. See ShapeToString
as an example.

Raises:
    RuntimeError if the ``geometry_id`` does not refer to a valid
    geometry.)""";
        } Reify;
        // Symbol: drake::geometry::SceneGraphInspector::SceneGraphInspector<T>
        struct /* ctor */ {
          // Source: drake/geometry/scene_graph_inspector.h:62
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::geometry::SceneGraphInspector::SourceIsRegistered
        struct /* SourceIsRegistered */ {
          // Source: drake/geometry/scene_graph_inspector.h:164
          const char* doc =
R"""(Reports ``True`` if the given ``source_id`` maps to a registered
source.)""";
        } SourceIsRegistered;
        // Symbol: drake::geometry::SceneGraphInspector::all_frame_ids
        struct /* all_frame_ids */ {
          // Source: drake/geometry/scene_graph_inspector.h:98
          const char* doc =
R"""(Provides a range object for all of the frame ids in the scene graph.
The order is not generally guaranteed; but it will be consistent as
long as there are no changes to the topology. This is intended to be
used as:


::

    for (FrameId id : inspector.all_frame_ids()) {
    ...
    }

This includes the id for the world frame.)""";
        } all_frame_ids;
        // Symbol: drake::geometry::SceneGraphInspector::geometry_version
        struct /* geometry_version */ {
          // Source: drake/geometry/scene_graph_inspector.h:476
          const char* doc =
R"""(Returns the geometry version that can be used to detect changes to the
geometry data associated with geometry roles. The reference returned
should not be persisted. If it needs to be persisted, it should be
copied.)""";
        } geometry_version;
        // Symbol: drake::geometry::SceneGraphInspector::num_frames
        struct /* num_frames */ {
          // Source: drake/geometry/scene_graph_inspector.h:83
          const char* doc =
R"""(Reports the *total* number of frames registered in the scene graph
(including the world frame).)""";
        } num_frames;
        // Symbol: drake::geometry::SceneGraphInspector::num_geometries
        struct /* num_geometries */ {
          // Source: drake/geometry/scene_graph_inspector.h:110
          const char* doc =
R"""(Reports the *total* number of geometries in the scene graph.)""";
        } num_geometries;
        // Symbol: drake::geometry::SceneGraphInspector::num_sources
        struct /* num_sources */ {
          // Source: drake/geometry/scene_graph_inspector.h:76
          const char* doc =
R"""(Reports the number of registered sources -- whether they have
registered frames/geometries or not. This will always be at least 1;
the SceneGraph itself counts as a source.)""";
        } num_sources;
        // Symbol: drake::geometry::SceneGraphInspector::world_frame_id
        struct /* world_frame_id */ {
          // Source: drake/geometry/scene_graph_inspector.h:104
          const char* doc = R"""(Reports the id for the world frame.)""";
        } world_frame_id;
      } SceneGraphInspector;
      // Symbol: drake::geometry::Shape
      struct /* Shape */ {
        // Source: drake/geometry/shape_specification.h:52
        const char* doc =
R"""(The base interface for all shape specifications. It has no public
constructor and cannot be instantiated directly. The Shape class has
two key properties:

- it is cloneable, and
- it can be "reified" (see ShapeReifier).

When you add a new subclass of Shape, you must:

1. add a virtual function ImplementGeometry() for the new shape in
ShapeReifier that invokes the ThrowUnsupportedGeometry method, and add to
the test for it in shape_specification_test.cc.
2. implement ImplementGeometry in derived ShapeReifiers to continue support
if desired, otherwise ensure unimplemented functions are not hidden in new
derivations of ShapeReifier with ``using``, for example, ``using
ShapeReifier::ImplementGeometry``. Existing subclasses should already have
this.

Otherwise, you might get a runtime error. We do not have an automatic
way to enforce them at compile time.)""";
        // Symbol: drake::geometry::Shape::Clone
        struct /* Clone */ {
          // Source: drake/geometry/shape_specification.h:62
          const char* doc =
R"""(Creates a unique copy of this shape. Invokes the protected DoClone().)""";
        } Clone;
        // Symbol: drake::geometry::Shape::Reify
        struct /* Reify */ {
          // Source: drake/geometry/shape_specification.h:59
          const char* doc =
R"""(Causes this description to be reified in the given ``reifier``. Each
concrete subclass must invoke the single, matching method on the
reifier. Provides optional user-data (cast as a void*) for the reifier
to consume.)""";
        } Reify;
        // Symbol: drake::geometry::Shape::Shape
        struct /* ctor */ {
          // Source: drake/geometry/shape_specification.h:95
          const char* doc =
R"""(Constructor available for derived class construction. A derived class
should invoke this in its initialization list, passing a ShapeTag
instantiated on its derived type, e.g.:


::

    class MyShape final : public Shape {
    public:
    MyShape() : Shape(ShapeTag<MyShape>()) {}
    ...
    };

The base class provides infrastructure for cloning and reification. To
work and to maintain sanity, we place the following requirements on
derived classes:

1. they must have a public copy constructor,
2. they must be marked as final, and
3. their constructors must invoke the parent constructor with a ShapeTag
instance (as noted above), and
4. The ShapeReifier class must be extended to include an invocation of
ShapeReifier::ImplementGeometry() on the derived Shape class.

Template parameter ``S``:
    The derived shape class. It must derive from Shape.)""";
        } ctor;
      } Shape;
      // Symbol: drake::geometry::ShapeName
      struct /* ShapeName */ {
        // Source: drake/geometry/shape_specification.h:401
        const char* doc =
R"""(Class that reports the name of the type of shape being reified (e.g.,
Sphere, Box, etc.))""";
        // Symbol: drake::geometry::ShapeName::ImplementGeometry
        struct /* ImplementGeometry */ {
          // Source: drake/geometry/shape_specification.h:416
          const char* doc = R"""()""";
        } ImplementGeometry;
        // Symbol: drake::geometry::ShapeName::ShapeName
        struct /* ctor */ {
          // Source: drake/geometry/shape_specification.h:403
          const char* doc_0args = R"""()""";
          // Source: drake/geometry/shape_specification.h:407
          const char* doc_1args =
R"""(Constructs a ShapeName from the given ``shape`` such that ``string()``
already contains the string representation of ``shape``.)""";
        } ctor;
        // Symbol: drake::geometry::ShapeName::name
        struct /* name */ {
          // Source: drake/geometry/shape_specification.h:445
          const char* doc =
R"""(Returns the name of the last shape reified. Empty if no shape has been
reified yet.)""";
        } name;
      } ShapeName;
      // Symbol: drake::geometry::ShapeReifier
      struct /* ShapeReifier */ {
        // Source: drake/geometry/shape_specification.h:357
        const char* doc =
R"""(The interface for converting shape descriptions to real shapes. Any
entity that consumes shape descriptions *must* implement this
interface.

This class explicitly enumerates all concrete shapes in its methods.
The addition of a new concrete shape class requires the addition of a
new corresponding method. There should *never* be a method that
accepts the Shape base class as an argument; it should *only* operate
on concrete derived classes.

The expected workflow is for a class that needs to turn shape
specifications into concrete geometry instances to implement the
ShapeReifier interface *and* invoke the Shape::Reify() method. For
example, a simple reifier that requires no user data would look like:


::

    class SimpleReifier : public ShapeReifier {
    void ProcessShape(const Shape& shape) {
    // Requires no user data.
    shape.Reify(this);
    }
    ...
    void ImplementGeometry(const Sphere& sphere, void*) override {
    // Do work to create a sphere.
    }
    };

Or a complex reifier that requires user data would look like:


::

    class ComplexReifier : public ShapeReifier {
    void ProcessShape(const Shape& shape) {
    ImportantData data{...};
    shape.Reify(this, &data);
    }
    ...
    void ImplementGeometry(const Sphere& sphere, void* data) override {
    DRAKE_ASSERT(data);
    ImportantData& data = *reinterpret_cast<ImportantData*>(data);
    // Do work to create a sphere using the provided user data.
    }
    };

Implementing a particular shape may require more data than is strictly
encapsulated in the Shape. The Implement* interface supports passing
user data through a type-erased ``void*``. Because a single class
invoked Shape::Reify() it is in a position to provide exactly the data
the shape implementations require.)""";
        // Symbol: drake::geometry::ShapeReifier::ImplementGeometry
        struct /* ImplementGeometry */ {
          // Source: drake/geometry/shape_specification.h:361
          const char* doc = R"""()""";
        } ImplementGeometry;
        // Symbol: drake::geometry::ShapeReifier::ShapeReifier
        struct /* ctor */ {
          // Source: drake/geometry/shape_specification.h:371
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::geometry::ShapeReifier::ThrowUnsupportedGeometry
        struct /* ThrowUnsupportedGeometry */ {
          // Source: drake/geometry/shape_specification.h:377
          const char* doc =
R"""(Derived ShapeReifiers can replace the default message for unsupported
geometries by overriding this method. The name of the unsupported
shape type is given as the single parameter.)""";
        } ThrowUnsupportedGeometry;
      } ShapeReifier;
      // Symbol: drake::geometry::ShapeTag
      struct /* ShapeTag */ {
        // Source: drake/geometry/shape_specification.h:29
        const char* doc =
R"""(Simple struct for instantiating the type-specific Shape functionality.
A class derived from the Shape class will invoke the parent's
constructor as Shape(ShapeTag<DerivedShape>()).)""";
      } ShapeTag;
      // Symbol: drake::geometry::ShapeToString
      struct /* ShapeToString */ {
        // Source: drake/geometry/shape_to_string.h:25
        const char* doc =
R"""(Class that turns a Shape into a std::string representation. This
reifier has a string() member that gets updated for each shape
reified. The expected workflow would be:


::

    c++
    ShapeToString reifier;
    SceneGraphInspector inspector = ...;  // Get the inspector from somewhere.
    for (GeometryId id : inspector.GetAllGeometryIds()) {
    inspector.Reify(id, reifier);
    std::cout << reifier.string() << "\n";
    }

This will write out a string representation of every geometry
registered to SceneGraph.)""";
        // Symbol: drake::geometry::ShapeToString::ImplementGeometry
        struct /* ImplementGeometry */ {
          // Source: drake/geometry/shape_to_string.h:30
          const char* doc = R"""()""";
        } ImplementGeometry;
        // Symbol: drake::geometry::ShapeToString::string
        struct /* string */ {
          // Source: drake/geometry/shape_to_string.h:40
          const char* doc = R"""()""";
        } string;
      } ShapeToString;
      // Symbol: drake::geometry::SignedDistancePair
      struct /* SignedDistancePair */ {
        // Source: drake/geometry/query_results/signed_distance_pair.h:32
        const char* doc =
R"""(The data for reporting the signed distance between two geometries, A
and B. It provides the id's of the two geometries, the witness points
Ca and Cb on the surfaces of A and B, the signed distance, and
nhat_BA_W a direction of fastest increasing distance (always unit
length and always point outward from B's surface).

- When A and B are separated, distance > 0.
- When A and B are touching or penetrating, distance <= 0.
- By definition, nhat_AB_W must be in the opposite direction of nhat_BA_W.
- (p_WCa - p_Wcb) = distance · nhat_BA_W.
- In some cases, nhat_BA_W is not unique, and is_nhat_BA_W_unique is false.

Warning:
    For two geometries that are just touching (i.e., distance = 0),
    the underlying code can guarantee a correct value for nhat_BA_W
    only when one geometry is a sphere, and the other geometry is a
    sphere, a box, or a cylinder. Otherwise, the underlying code is
    not in place yet to guarantee a correct value for nhat_BA_W when
    surfaces are just touching, and the vector will be populated by
    NaN values.

Template parameter ``T``:
    The underlying scalar type. Must be a valid Eigen scalar.)""";
        // Symbol: drake::geometry::SignedDistancePair::SignedDistancePair<T>
        struct /* ctor */ {
          // Source: drake/geometry/query_results/signed_distance_pair.h:46
          const char* doc_7args =
R"""(Constructor

Parameter ``a``:
    The id of the first geometry (A).

Parameter ``b``:
    The id of the second geometry (B).

Parameter ``p_ACa_in``:
    The witness point on geometry A's surface, in A's frame.

Parameter ``p_BCb_in``:
    The witness point on geometry B's surface, in B's frame.

Parameter ``dist``:
    The signed distance between p_A and p_B.

Parameter ``nhat_BA_W_in``:
    A direction of fastest increasing distance.

Parameter ``is_nhat_BA_W_unique_in``:
    True if nhat_BA_W is unique.

Precondition:
    nhat_BA_W_in is unit-length.)""";
          // Source: drake/geometry/query_results/signed_distance_pair.h:76
          const char* doc_5args =
R"""(Constructor. We keep this constructor temporarily for backward
compatibility.

Parameter ``a``:
    The id of the first geometry (A).

Parameter ``b``:
    The id of the second geometry (B).

Parameter ``p_ACa_in``:
    The witness point on geometry A's surface, in A's frame.

Parameter ``p_BCb_in``:
    The witness point on geometry B's surface, in B's frame.

Parameter ``dist``:
    The signed distance between p_A and p_B.)""";
        } ctor;
        // Symbol: drake::geometry::SignedDistancePair::SwapAAndB
        struct /* SwapAAndB */ {
          // Source: drake/geometry/query_results/signed_distance_pair.h:87
          const char* doc =
R"""(Swaps the interpretation of geometries A and B.)""";
        } SwapAAndB;
        // Symbol: drake::geometry::SignedDistancePair::distance
        struct /* distance */ {
          // Source: drake/geometry/query_results/signed_distance_pair.h:112
          const char* doc =
R"""(The signed distance between p_ACa and p_BCb.)""";
        } distance;
        // Symbol: drake::geometry::SignedDistancePair::id_A
        struct /* id_A */ {
          // Source: drake/geometry/query_results/signed_distance_pair.h:96
          const char* doc =
R"""(The id of the first geometry in the pair.)""";
        } id_A;
        // Symbol: drake::geometry::SignedDistancePair::id_B
        struct /* id_B */ {
          // Source: drake/geometry/query_results/signed_distance_pair.h:98
          const char* doc =
R"""(The id of the second geometry in the pair.)""";
        } id_B;
        // Symbol: drake::geometry::SignedDistancePair::is_nhat_BA_W_unique
        struct /* is_nhat_BA_W_unique */ {
          // Source: drake/geometry/query_results/signed_distance_pair.h:115
          const char* doc = R"""()""";
        } is_nhat_BA_W_unique;
        // Symbol: drake::geometry::SignedDistancePair::nhat_BA_W
        struct /* nhat_BA_W */ {
          // Source: drake/geometry/query_results/signed_distance_pair.h:114
          const char* doc =
R"""(A direction of fastest increasing distance.)""";
        } nhat_BA_W;
        // Symbol: drake::geometry::SignedDistancePair::p_ACa
        struct /* p_ACa */ {
          // Source: drake/geometry/query_results/signed_distance_pair.h:108
          const char* doc =
R"""(The witness point on geometry A's surface, expressed in A's frame.)""";
        } p_ACa;
        // Symbol: drake::geometry::SignedDistancePair::p_BCb
        struct /* p_BCb */ {
          // Source: drake/geometry/query_results/signed_distance_pair.h:110
          const char* doc =
R"""(The witness point on geometry B's surface, expressed in B's frame.)""";
        } p_BCb;
      } SignedDistancePair;
      // Symbol: drake::geometry::SignedDistanceToPoint
      struct /* SignedDistanceToPoint */ {
        // Source: drake/geometry/query_results/signed_distance_to_point.h:24
        const char* doc =
R"""(The data for reporting the signed distance from a query point to a
geometry. Reports the result of a signed distance query between a
query point Q and geometry G. This includes G's id, the signed
distance, the nearest point N on the surface of G, and the gradient of
the signed distance with respect to the position of Q. Generally, the
gradient of the signed distance function is not defined everywhere.
The value reported in this struct depends on the query function
returning it. Refer to the query function's documentation for what
value it will report for otherwise undefined gradient values.

Template parameter ``T``:
    The underlying scalar type. Must be a valid Eigen scalar.)""";
        // Symbol: drake::geometry::SignedDistanceToPoint::SignedDistanceToPoint<T>
        struct /* ctor */ {
          // Source: drake/geometry/query_results/signed_distance_to_point.h:52
          const char* doc =
R"""(Constructs SignedDistanceToPoint struct from calculated results.

Parameter ``id_G_in``:
    The id of the geometry G to which we measure distance from the
    query point Q.

Parameter ``p_GN_in``:
    The position of the nearest point N on G's surface from the query
    point Q, expressed in G's frame.

Parameter ``distance_in``:
    The signed distance from the query point Q to the nearest point N
    on the surface of geometry G. It is positive if Q is outside G. It
    is negative if Q is inside G. It is zero if Q is on the boundary
    of G.

Parameter ``grad_W_in``:
    The gradient vector of the distance function with respect to the
    query point Q, expressed in world frame W.

Parameter ``is_grad_W_unique_in``:
    True if grad_W is unique, false otherwise.

Note:
    grad_W is not well defined everywhere. For example, when computing
    the distance from a point to a sphere, and the point coincides
    with the center of the sphere, grad_W is not well defined (as it
    can be computed as p_GQ / |p_GQ|, but the denominator is 0). When
    grad_W is not well defined, and we instantiate
    SignedDistanceToPoint<T> with T being an AutoDiffScalar (like
    AutoDiffXd), the gradient of the query result is not well defined
    either, so the user should use the gradient in p_GN, distance and
    grad_W with caution.

Precondition:
    grad_W_in must not contain NaN.)""";
        } ctor;
        // Symbol: drake::geometry::SignedDistanceToPoint::distance
        struct /* distance */ {
          // Source: drake/geometry/query_results/signed_distance_to_point.h:73
          const char* doc =
R"""(The signed distance from the query point Q to the nearest point N on
the surface of geometry G. It is positive if Q is outside G. It is
negative if Q is inside G. It is zero if Q is on the boundary of G.)""";
        } distance;
        // Symbol: drake::geometry::SignedDistanceToPoint::grad_W
        struct /* grad_W */ {
          // Source: drake/geometry/query_results/signed_distance_to_point.h:76
          const char* doc =
R"""(The gradient vector of the distance function with respect to the query
point Q, expressed in world frame W.)""";
        } grad_W;
        // Symbol: drake::geometry::SignedDistanceToPoint::id_G
        struct /* id_G */ {
          // Source: drake/geometry/query_results/signed_distance_to_point.h:66
          const char* doc =
R"""(The id of the geometry G to which we measure distance from the query
point Q.)""";
        } id_G;
        // Symbol: drake::geometry::SignedDistanceToPoint::is_grad_W_unique
        struct /* is_grad_W_unique */ {
          // Source: drake/geometry/query_results/signed_distance_to_point.h:81
          const char* doc =
R"""(Whether grad_W is well defined. Ref to the constructor
SignedDistanceToPoint() for an explanation.)""";
        } is_grad_W_unique;
        // Symbol: drake::geometry::SignedDistanceToPoint::p_GN
        struct /* p_GN */ {
          // Source: drake/geometry/query_results/signed_distance_to_point.h:69
          const char* doc =
R"""(The position of the nearest point N on G's surface from the query
point Q, expressed in G's frame.)""";
        } p_GN;
      } SignedDistanceToPoint;
      // Symbol: drake::geometry::SignedDistanceToPointWithGradient
      struct /* SignedDistanceToPointWithGradient */ {
        // Source: drake/geometry/query_results/signed_distance_to_point_with_gradient.h:17
        const char* doc =
R"""(Same as SignedDistanceToPoint, except this class also contains the
gradient w.r.t p_GQ_G (the position of the query point Q measured and
expressed in object G's frame).)""";
        // Symbol: drake::geometry::SignedDistanceToPointWithGradient::SignedDistanceToPointWithGradient
        struct /* ctor */ {
          // Source: drake/geometry/query_results/signed_distance_to_point_with_gradient.h:18
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::geometry::SignedDistanceToPointWithGradient::ddistance_dp_GQ
        struct /* ddistance_dp_GQ */ {
          // Source: drake/geometry/query_results/signed_distance_to_point_with_gradient.h:56
          const char* doc =
R"""(The gradient of the distance w.r.t p_GQ.)""";
        } ddistance_dp_GQ;
        // Symbol: drake::geometry::SignedDistanceToPointWithGradient::dgrad_W_dp_GQ
        struct /* dgrad_W_dp_GQ */ {
          // Source: drake/geometry/query_results/signed_distance_to_point_with_gradient.h:64
          const char* doc = R"""(The derivative of grad_W w.r.t p_GQ.)""";
        } dgrad_W_dp_GQ;
        // Symbol: drake::geometry::SignedDistanceToPointWithGradient::distance
        struct /* distance */ {
          // Source: drake/geometry/query_results/signed_distance_to_point_with_gradient.h:54
          const char* doc =
R"""(Same as SignedDistanceToPoint::distance.The signed distance from the
query point Q to the nearest point N on the surface of geometry G.)""";
        } distance;
        // Symbol: drake::geometry::SignedDistanceToPointWithGradient::dp_GN_dp_GQ
        struct /* dp_GN_dp_GQ */ {
          // Source: drake/geometry/query_results/signed_distance_to_point_with_gradient.h:49
          const char* doc =
R"""(The gradient of p_GN w.r.t p_GQ (the position of query point Q
measured and expressed in object G's frame).)""";
        } dp_GN_dp_GQ;
        // Symbol: drake::geometry::SignedDistanceToPointWithGradient::grad_W
        struct /* grad_W */ {
          // Source: drake/geometry/query_results/signed_distance_to_point_with_gradient.h:62
          const char* doc =
R"""(Same as SignedDistanceToPoint::grad_W. The unit length gradient vector
of the distance function with respect to the query point Q, expressed
in world frame W.)""";
        } grad_W;
        // Symbol: drake::geometry::SignedDistanceToPointWithGradient::id_G
        struct /* id_G */ {
          // Source: drake/geometry/query_results/signed_distance_to_point_with_gradient.h:39
          const char* doc = R"""(Same as SignedDistanceToPoint::id_G.)""";
        } id_G;
        // Symbol: drake::geometry::SignedDistanceToPointWithGradient::is_grad_W_well_defined
        struct /* is_grad_W_well_defined */ {
          // Source: drake/geometry/query_results/signed_distance_to_point_with_gradient.h:67
          const char* doc =
R"""(Same as SignedDistanceToPoint::is_grad_W_well_defined.)""";
        } is_grad_W_well_defined;
        // Symbol: drake::geometry::SignedDistanceToPointWithGradient::p_GN
        struct /* p_GN */ {
          // Source: drake/geometry/query_results/signed_distance_to_point_with_gradient.h:44
          const char* doc =
R"""(Same as SignedDistanceToPoint::p_GN. The position of the nearest point
N on G's surface to the query point Q, expressed in G's frame.)""";
        } p_GN;
      } SignedDistanceToPointWithGradient;
      // Symbol: drake::geometry::SourceId
      struct /* SourceId */ {
        // Source: drake/geometry/geometry_ids.h:14
        const char* doc =
R"""(Type used to identify geometry sources in SceneGraph.)""";
      } SourceId;
      // Symbol: drake::geometry::Sphere
      struct /* Sphere */ {
        // Source: drake/geometry/shape_specification.h:104
        const char* doc =
R"""(Definition of sphere. It is centered in its canonical frame with the
given radius.)""";
        // Symbol: drake::geometry::Sphere::Sphere
        struct /* ctor */ {
          // Source: drake/geometry/shape_specification.h:111
          const char* doc =
R"""(Constructs a sphere with the given ``radius``.

Raises:
    RuntimeError if ``radius`` is negative. Note that a zero radius is
    is considered valid.)""";
        } ctor;
        // Symbol: drake::geometry::Sphere::radius
        struct /* radius */ {
          // Source: drake/geometry/shape_specification.h:113
          const char* doc = R"""()""";
        } radius;
      } Sphere;
      // Symbol: drake::geometry::SurfaceFace
      struct /* SurfaceFace */ {
        // Source: drake/geometry/proximity/surface_mesh.h:64
        const char* doc =
R"""(%SurfaceFace represents a triangular face in a SurfaceMesh.)""";
        // Symbol: drake::geometry::SurfaceFace::ReverseWinding
        struct /* ReverseWinding */ {
          // Source: drake/geometry/proximity/surface_mesh.h:98
          const char* doc =
R"""(Reverses the order of the vertex indices -- this essentially flips the
face normal based on the right-handed normal rule.)""";
        } ReverseWinding;
        // Symbol: drake::geometry::SurfaceFace::SurfaceFace
        struct /* ctor */ {
          // Source: drake/geometry/proximity/surface_mesh.h:73
          const char* doc_3args =
R"""(Constructs SurfaceFace.

Parameter ``v0``:
    Index of the first vertex in SurfaceMesh.

Parameter ``v1``:
    Index of the second vertex in SurfaceMesh.

Parameter ``v2``:
    Index of the last vertex in SurfaceMesh.)""";
          // Source: drake/geometry/proximity/surface_mesh.h:82
          const char* doc_1args =
R"""(Constructs SurfaceFace.

Parameter ``v``:
    array of three integer indices of the vertices of the face in
    SurfaceMesh.)""";
        } ctor;
        // Symbol: drake::geometry::SurfaceFace::vertex
        struct /* vertex */ {
          // Source: drake/geometry/proximity/surface_mesh.h:91
          const char* doc =
R"""(Returns the vertex index in SurfaceMesh of the i-th vertex of this
face.

Parameter ``i``:
    The local index of the vertex in this face.

Precondition:
    0 <= i < 3)""";
        } vertex;
      } SurfaceFace;
      // Symbol: drake::geometry::SurfaceFaceIndex
      struct /* SurfaceFaceIndex */ {
        // Source: drake/geometry/proximity/surface_mesh.h:27
        const char* doc =
R"""(Index for identifying a triangular face in a surface mesh.)""";
      } SurfaceFaceIndex;
      // Symbol: drake::geometry::SurfaceMesh
      struct /* SurfaceMesh */ {
        // Source: drake/geometry/proximity/surface_mesh.h:118
        const char* doc =
R"""(SurfaceMesh represents a triangulated surface.

Template parameter ``T``:
    The underlying scalar type for coordinates, e.g., double or
    AutoDiffXd. Must be a valid Eigen scalar.)""";
        // Symbol: drake::geometry::SurfaceMesh::Barycentric
        struct /* Barycentric */ {
          // Source: drake/geometry/proximity/surface_mesh.h:170
          const char* doc =
R"""(Type of barycentric coordinates on a triangular element. Barycentric
coordinates (b₀, b₁, b₂) satisfy b₀ + b₁ + b₂ = 1. It corresponds to a
position on the plane of the triangle. If all bᵢ >= 0, it corresponds
to a position inside the triangle or on the edges of the triangle. If
some bᵢ < 0, it corresponds to a position on the plane of the triangle
that is outside the triangle. Technically we could calculate one of
the bᵢ from the others; however, there is no standard way to omit one
of the coordinates.

The barycentric coordinates for a point Q are notated a b_Q.)""";
        } Barycentric;
        // Symbol: drake::geometry::SurfaceMesh::CalcBarycentric
        struct /* CalcBarycentric */ {
          // Source: drake/geometry/proximity/surface_mesh.h:323
          const char* doc =
R"""(Calculate barycentric coordinates with respect to the triangular face
``f`` of the point Q'. Q' is the projection of the provided point Q on
the plane of triangle ``f``. If Q lies on the plane, Q = Q'. This
operation is expensive compared with going from barycentric to
Cartesian.

Parameter ``p_MQ``:
    The position of point Q measured and expressed in the mesh's frame
    M.

Parameter ``f``:
    The index of a triangular face.

Returns ``b_Q``:
    ' The barycentric coordinates of Q' (projection of Q onto `f`'s
    plane) relative to triangle f.

Note:
    If Q' is outside the triangle, the barycentric coordinates (b₀,
    b₁, b₂) still satisfy b₀ + b₁ + b₂ = 1; however, some bᵢ will be
    negative.)""";
        } CalcBarycentric;
        // Symbol: drake::geometry::SurfaceMesh::CalcBoundingBox
        struct /* CalcBoundingBox */ {
          // Source: drake/geometry/proximity/surface_mesh.h:386
          const char* doc =
R"""(Calculates the axis-aligned bounding box of this surface mesh M.

Returns:
    the center and the size vector of the box expressed in M's frame.)""";
        } CalcBoundingBox;
        // Symbol: drake::geometry::SurfaceMesh::CalcCartesianFromBarycentric
        struct /* CalcCartesianFromBarycentric */ {
          // Source: drake/geometry/proximity/surface_mesh.h:294
          const char* doc =
R"""(Maps the barycentric coordinates ``Q_barycentric`` of a point Q in
``element_index`` to its position vector p_MQ.)""";
        } CalcCartesianFromBarycentric;
        // Symbol: drake::geometry::SurfaceMesh::CalcGradientVectorOfLinearField
        struct /* CalcGradientVectorOfLinearField */ {
          // Source: drake/geometry/proximity/surface_mesh.h:436
          const char* doc =
R"""(Calculates the gradient ∇u of a linear field u on the triangle ``f``.
Field u is defined by the three field values ``field_value[i]`` at the
i-th vertex of the triangle. The gradient ∇u is expressed in the
coordinates frame of this mesh M.)""";
        } CalcGradientVectorOfLinearField;
        // Symbol: drake::geometry::SurfaceMesh::Cartesian
        struct /* Cartesian */ {
          // Source: drake/geometry/proximity/surface_mesh.h:175
          const char* doc =
R"""(Type of Cartesian coordinates. Mesh consumers can use it in conversion
from Cartesian coordinates to barycentric coordinates.)""";
        } Cartesian;
        // Symbol: drake::geometry::SurfaceMesh::ElementIndex
        struct /* ElementIndex */ {
          // Source: drake/geometry/proximity/surface_mesh.h:156
          const char* doc =
R"""(Index for identifying a triangular element.)""";
        } ElementIndex;
        // Symbol: drake::geometry::SurfaceMesh::Equal
        struct /* Equal */ {
          // Source: drake/geometry/proximity/surface_mesh.h:407
          const char* doc =
R"""(Checks to see whether the given SurfaceMesh object is equal via deep
exact comparison. NaNs are treated as not equal as per the IEEE
standard.

Parameter ``mesh``:
    The mesh for comparison.

Returns:
    ``True`` if the given mesh is equal.)""";
        } Equal;
        // Symbol: drake::geometry::SurfaceMesh::ReverseFaceWinding
        struct /* ReverseFaceWinding */ {
          // Source: drake/geometry/proximity/surface_mesh.h:247
          const char* doc =
R"""(Reverses the ordering of all the faces' indices -- see
SurfaceFace::ReverseWinding().)""";
        } ReverseFaceWinding;
        // Symbol: drake::geometry::SurfaceMesh::ScalarType
        struct /* ScalarType */ {
          // Source: drake/geometry/proximity/surface_mesh.h:131
          const char* doc = R"""()""";
        } ScalarType;
        // Symbol: drake::geometry::SurfaceMesh::SurfaceMesh<T>
        struct /* ctor */ {
          // Source: drake/geometry/proximity/surface_mesh.h:219
          const char* doc =
R"""(Constructs a SurfaceMesh from faces and vertices.

Parameter ``faces``:
    The triangular faces.

Parameter ``vertices``:
    The vertices.)""";
        } ctor;
        // Symbol: drake::geometry::SurfaceMesh::TransformVertices
        struct /* TransformVertices */ {
          // Source: drake/geometry/proximity/surface_mesh.h:234
          const char* doc =
R"""(Transforms the vertices of this mesh from its initial frame M to the
new frame N.)""";
        } TransformVertices;
        // Symbol: drake::geometry::SurfaceMesh::VertexIndex
        struct /* VertexIndex */ {
          // Source: drake/geometry/proximity/surface_mesh.h:151
          const char* doc = R"""(Index for identifying a vertex.)""";
        } VertexIndex;
        // Symbol: drake::geometry::SurfaceMesh::area
        struct /* area */ {
          // Source: drake/geometry/proximity/surface_mesh.h:262
          const char* doc = R"""(Returns area of a triangular element.)""";
        } area;
        // Symbol: drake::geometry::SurfaceMesh::centroid
        struct /* centroid */ {
          // Source: drake/geometry/proximity/surface_mesh.h:288
          const char* doc =
R"""(Returns the area-weighted geometric centroid of this surface mesh. The
returned value is the position vector p_MSc from M's origin to the
centroid Sc, expressed in frame M. (M is the frame in which this
mesh's vertices are measured and expressed.) Note that the centroid is
not necessarily a point on the surface. If the total mesh area is
exactly zero, we define the centroid to be (0,0,0).

The centroid location is calculated *per face* not *per vertex* so is
insensitive to whether vertices are shared by faces.)""";
        } centroid;
        // Symbol: drake::geometry::SurfaceMesh::element
        struct /* element */ {
          // Source: drake/geometry/proximity/surface_mesh.h:181
          const char* doc =
R"""(Returns the triangular element identified by a given index.

Parameter ``e``:
    The index of the triangular element.

Precondition:
    e ∈ {0, 1, 2,..., num_faces()-1}.)""";
        } element;
        // Symbol: drake::geometry::SurfaceMesh::face_normal
        struct /* face_normal */ {
          // Source: drake/geometry/proximity/surface_mesh.h:273
          const char* doc =
R"""(Returns the unit face normal vector of a triangle. It respects the
right-handed normal rule. A near-zero-area triangle may get an
unreliable normal vector. A zero-area triangle will get a zero vector.

Precondition:
    f ∈ {0, 1, 2,..., num_faces()-1}.)""";
        } face_normal;
        // Symbol: drake::geometry::SurfaceMesh::faces
        struct /* faces */ {
          // Source: drake/geometry/proximity/surface_mesh.h:187
          const char* doc = R"""(Returns the faces.)""";
        } faces;
        // Symbol: drake::geometry::SurfaceMesh::num_elements
        struct /* num_elements */ {
          // Source: drake/geometry/proximity/surface_mesh.h:210
          const char* doc =
R"""(Returns the number of triangles in the mesh. For SurfaceMesh, an
element is a triangle. Returns the same number as num_faces() and
enables mesh consumers to be templated on mesh type.)""";
        } num_elements;
        // Symbol: drake::geometry::SurfaceMesh::num_faces
        struct /* num_faces */ {
          // Source: drake/geometry/proximity/surface_mesh.h:258
          const char* doc =
R"""(Returns the number of triangular elements in the mesh.)""";
        } num_faces;
        // Symbol: drake::geometry::SurfaceMesh::num_vertices
        struct /* num_vertices */ {
          // Source: drake/geometry/proximity/surface_mesh.h:204
          const char* doc =
R"""(Returns the number of vertices in the mesh.)""";
        } num_vertices;
        // Symbol: drake::geometry::SurfaceMesh::total_area
        struct /* total_area */ {
          // Source: drake/geometry/proximity/surface_mesh.h:266
          const char* doc =
R"""(Returns the total area of all the faces of this surface mesh.)""";
        } total_area;
        // Symbol: drake::geometry::SurfaceMesh::vertex
        struct /* vertex */ {
          // Source: drake/geometry/proximity/surface_mesh.h:197
          const char* doc =
R"""(Returns the vertex identified by a given index.

Parameter ``v``:
    The index of the vertex.

Precondition:
    v ∈ {0, 1, 2,...,num_vertices()-1}.)""";
        } vertex;
        // Symbol: drake::geometry::SurfaceMesh::vertices
        struct /* vertices */ {
          // Source: drake/geometry/proximity/surface_mesh.h:190
          const char* doc = R"""(Returns the vertices.)""";
        } vertices;
      } SurfaceMesh;
      // Symbol: drake::geometry::SurfaceVertex
      struct /* SurfaceVertex */ {
        // Source: drake/geometry/proximity/surface_mesh.h:34
        const char* doc =
R"""(SurfaceVertex represents a vertex in SurfaceMesh.

Template parameter ``T``:
    The underlying scalar type for coordinates, e.g., double or
    AutoDiffXd. Must be a valid Eigen scalar.)""";
        // Symbol: drake::geometry::SurfaceVertex::SurfaceVertex<T>
        struct /* ctor */ {
          // Source: drake/geometry/proximity/surface_mesh.h:42
          const char* doc =
R"""(Constructs SurfaceVertex.

Parameter ``r_MV``:
    displacement vector from the origin of M's frame to this vertex,
    expressed in M's frame.)""";
        } ctor;
        // Symbol: drake::geometry::SurfaceVertex::TransformInPlace
        struct /* TransformInPlace */ {
          // Source: drake/geometry/proximity/surface_mesh.h:52
          const char* doc =
R"""(Transforms this vertex position from its initial frame M to a new
frame N.)""";
        } TransformInPlace;
        // Symbol: drake::geometry::SurfaceVertex::r_MV
        struct /* r_MV */ {
          // Source: drake/geometry/proximity/surface_mesh.h:48
          const char* doc =
R"""(Returns the displacement vector from the origin of M's frame to this
vertex, expressed in M's frame.)""";
        } r_MV;
      } SurfaceVertex;
      // Symbol: drake::geometry::SurfaceVertexIndex
      struct /* SurfaceVertexIndex */ {
        // Source: drake/geometry/proximity/surface_mesh.h:22
        const char* doc =
R"""(Index used to identify a vertex in a surface mesh.)""";
      } SurfaceVertexIndex;
      // Symbol: drake::geometry::VolumeElement
      struct /* VolumeElement */ {
        // Source: drake/geometry/proximity/volume_mesh.h:67
        const char* doc =
R"""(VolumeElement represents a tetrahedral element in a VolumeMesh. It is
a topological entity in the sense that it only knows the indices of
its vertices but not their coordinates.)""";
        // Symbol: drake::geometry::VolumeElement::Equal
        struct /* Equal */ {
          // Source: drake/geometry/proximity/volume_mesh.h:109
          const char* doc =
R"""(Checks to see whether the given VolumeElement use the same four
VolumeVertexIndex's in the same order. We check for equality to the
last bit consistently with VolumeMesh::Equal(). Two permutations of
the four vertex indices of a tetrahedron are considered different
tetrahedra even though they span the same space.)""";
        } Equal;
        // Symbol: drake::geometry::VolumeElement::VolumeElement
        struct /* ctor */ {
          // Source: drake/geometry/proximity/volume_mesh.h:82
          const char* doc_4args =
R"""(Constructs VolumeElement. We follow the convention that the first
three vertices define a triangle with its right-handed normal pointing
inwards. The fourth vertex is then on the positive side of this first
triangle.

Warning:
    This class does not enforce our convention for the ordering of the
    vertices.

Parameter ``v0``:
    Index of the first vertex in VolumeMesh.

Parameter ``v1``:
    Index of the second vertex in VolumeMesh.

Parameter ``v2``:
    Index of the third vertex in VolumeMesh.

Parameter ``v3``:
    Index of the last vertex in VolumeMesh.)""";
          // Source: drake/geometry/proximity/volume_mesh.h:90
          const char* doc_1args =
R"""(Constructs VolumeElement.

Parameter ``v``:
    Array of four integer indices of the vertices of the element in
    VolumeMesh.)""";
        } ctor;
        // Symbol: drake::geometry::VolumeElement::vertex
        struct /* vertex */ {
          // Source: drake/geometry/proximity/volume_mesh.h:99
          const char* doc =
R"""(Returns the vertex index in VolumeMesh of the i-th vertex of this
element.

Parameter ``i``:
    The local index of the vertex in this element.

Precondition:
    0 <= i < 4)""";
        } vertex;
      } VolumeElement;
      // Symbol: drake::geometry::VolumeElementIndex
      struct /* VolumeElementIndex */ {
        // Source: drake/geometry/proximity/volume_mesh.h:28
        const char* doc =
R"""(Index for identifying a tetrahedral element in a volume mesh.)""";
      } VolumeElementIndex;
      // Symbol: drake::geometry::VolumeMesh
      struct /* VolumeMesh */ {
        // Source: drake/geometry/proximity/volume_mesh.h:136
        const char* doc =
R"""(VolumeMesh represents a tetrahedral volume mesh.

Template parameter ``T``:
    The underlying scalar type for coordinates, e.g., double or
    AutoDiffXd. Must be a valid Eigen scalar.)""";
        // Symbol: drake::geometry::VolumeMesh::Barycentric
        struct /* Barycentric */ {
          // Source: drake/geometry/proximity/volume_mesh.h:180
          const char* doc =
R"""(Type of barycentric coordinates on a tetrahedral element. Barycentric
coordinates (b₀, b₁, b₂, b₃) satisfy b₀ + b₁ + b₂ + b₃ = 1. It
corresponds to a position in the space. If all bᵢ >= 0, it corresponds
to a position inside the tetrahedron or on the faces of the
tetrahedron. If some bᵢ < 0, it corresponds to a position outside the
tetrahedron. Technically we could calculate one of the bᵢ from the
others; however, there is no standard way to omit one of the
coordinates.)""";
        } Barycentric;
        // Symbol: drake::geometry::VolumeMesh::CalcBarycentric
        struct /* CalcBarycentric */ {
          // Source: drake/geometry/proximity/volume_mesh.h:267
          const char* doc =
R"""(Calculate barycentric coordinates with respect to the tetrahedron
``e`` of the point Q'. This operation is expensive compared with going
from barycentric to Cartesian.

Parameter ``p_MQ``:
    A position expressed in the frame M of the mesh.

Parameter ``e``:
    The index of a tetrahedral element.

Note:
    If p_MQ is outside the tetrahedral element, the barycentric
    coordinates (b₀, b₁, b₂, b₃) still satisfy b₀ + b₁ + b₂ + b₃ = 1;
    however, some bᵢ will be negative.)""";
        } CalcBarycentric;
        // Symbol: drake::geometry::VolumeMesh::CalcGradientVectorOfLinearField
        struct /* CalcGradientVectorOfLinearField */ {
          // Source: drake/geometry/proximity/volume_mesh.h:324
          const char* doc =
R"""(Calculates the gradient ∇u of a linear field u on the tetrahedron
``e``. Field u is defined by the four field values ``field_value[i]``
at the i-th vertex of the tetrahedron. The gradient ∇u is expressed in
the coordinates frame of this mesh M.)""";
        } CalcGradientVectorOfLinearField;
        // Symbol: drake::geometry::VolumeMesh::CalcTetrahedronVolume
        struct /* CalcTetrahedronVolume */ {
          // Source: drake/geometry/proximity/volume_mesh.h:229
          const char* doc =
R"""(Calculates volume of a tetrahedral element.)""";
        } CalcTetrahedronVolume;
        // Symbol: drake::geometry::VolumeMesh::CalcVolume
        struct /* CalcVolume */ {
          // Source: drake/geometry/proximity/volume_mesh.h:250
          const char* doc =
R"""(Calculates the volume of ``this`` mesh by taking the sum of the volume
of each tetrahedral element.)""";
        } CalcVolume;
        // Symbol: drake::geometry::VolumeMesh::Cartesian
        struct /* Cartesian */ {
          // Source: drake/geometry/proximity/volume_mesh.h:185
          const char* doc =
R"""(Type of Cartesian coordinates. Mesh consumers can use it in conversion
from Cartesian coordinates to barycentric coordinates.)""";
        } Cartesian;
        // Symbol: drake::geometry::VolumeMesh::ElementIndex
        struct /* ElementIndex */ {
          // Source: drake/geometry/proximity/volume_mesh.h:170
          const char* doc =
R"""(Index for identifying a tetrahedral element.)""";
        } ElementIndex;
        // Symbol: drake::geometry::VolumeMesh::Equal
        struct /* Equal */ {
          // Source: drake/geometry/proximity/volume_mesh.h:299
          const char* doc =
R"""(Checks to see whether the given VolumeMesh object is equal via deep
exact comparison. NaNs are treated as not equal as per the IEEE
standard.

Parameter ``mesh``:
    The mesh for comparison.

Returns:
    ``True`` if the given mesh is equal.)""";
        } Equal;
        // Symbol: drake::geometry::VolumeMesh::ScalarType
        struct /* ScalarType */ {
          // Source: drake/geometry/proximity/volume_mesh.h:150
          const char* doc = R"""()""";
        } ScalarType;
        // Symbol: drake::geometry::VolumeMesh::VertexIndex
        struct /* VertexIndex */ {
          // Source: drake/geometry/proximity/volume_mesh.h:166
          const char* doc = R"""(Index for identifying a vertex.)""";
        } VertexIndex;
        // Symbol: drake::geometry::VolumeMesh::VolumeMesh<T>
        struct /* ctor */ {
          // Source: drake/geometry/proximity/volume_mesh.h:193
          const char* doc =
R"""(Constructor from a vector of vertices and from a vector of elements.
Each element must be a valid VolumeElement following the vertex
ordering convention documented in the VolumeElement class. This class
however does not enforce this convention and it is thus the
responsibility of the user.)""";
        } ctor;
        // Symbol: drake::geometry::VolumeMesh::element
        struct /* element */ {
          // Source: drake/geometry/proximity/volume_mesh.h:201
          const char* doc = R"""()""";
        } element;
        // Symbol: drake::geometry::VolumeMesh::num_elements
        struct /* num_elements */ {
          // Source: drake/geometry/proximity/volume_mesh.h:221
          const char* doc =
R"""(Returns the number of tetrahedral elements in the mesh.)""";
        } num_elements;
        // Symbol: drake::geometry::VolumeMesh::num_vertices
        struct /* num_vertices */ {
          // Source: drake/geometry/proximity/volume_mesh.h:225
          const char* doc =
R"""(Returns the number of vertices in the mesh.)""";
        } num_vertices;
        // Symbol: drake::geometry::VolumeMesh::tetrahedra
        struct /* tetrahedra */ {
          // Source: drake/geometry/proximity/volume_mesh.h:217
          const char* doc = R"""()""";
        } tetrahedra;
        // Symbol: drake::geometry::VolumeMesh::vertex
        struct /* vertex */ {
          // Source: drake/geometry/proximity/volume_mesh.h:210
          const char* doc =
R"""(Returns the vertex identified by a given index.

Parameter ``v``:
    The index of the vertex.

Precondition:
    v ∈ {0, 1, 2,...,num_vertices()-1}.)""";
        } vertex;
        // Symbol: drake::geometry::VolumeMesh::vertices
        struct /* vertices */ {
          // Source: drake/geometry/proximity/volume_mesh.h:215
          const char* doc = R"""()""";
        } vertices;
      } VolumeMesh;
      // Symbol: drake::geometry::VolumeVertex
      struct /* VolumeVertex */ {
        // Source: drake/geometry/proximity/volume_mesh.h:35
        const char* doc =
R"""(VolumeVertex represents a vertex in VolumeMesh.

Template parameter ``T``:
    The underlying scalar type for coordinates, e.g., double or
    AutoDiffXd. Must be a valid Eigen scalar.)""";
        // Symbol: drake::geometry::VolumeVertex::VolumeVertex<T>
        struct /* ctor */ {
          // Source: drake/geometry/proximity/volume_mesh.h:43
          const char* doc_1args =
R"""(Constructs VolumeVertex.

Parameter ``r_MV``:
    displacement vector from the origin of M's frame to this vertex,
    expressed in M's frame.)""";
          // Source: drake/geometry/proximity/volume_mesh.h:49
          const char* doc_3args =
R"""(Constructs VolumeVertex from the xyz components of a point V in a
frame M.)""";
        } ctor;
        // Symbol: drake::geometry::VolumeVertex::r_MV
        struct /* r_MV */ {
          // Source: drake/geometry/proximity/volume_mesh.h:55
          const char* doc =
R"""(Returns the displacement vector from the origin of M's frame to this
vertex, expressed in M's frame.)""";
        } r_MV;
      } VolumeVertex;
      // Symbol: drake::geometry::VolumeVertexIndex
      struct /* VolumeVertexIndex */ {
        // Source: drake/geometry/proximity/volume_mesh.h:23
        const char* doc =
R"""(Index used to identify a vertex in a volume mesh.)""";
      } VolumeVertexIndex;
      // Symbol: drake::geometry::operator!=
      struct /* operator_ne */ {
        // Source: drake/geometry/proximity/volume_mesh.h:122
        const char* doc = R"""()""";
      } operator_ne;
      // Symbol: drake::geometry::render
      struct /* render */ {
        // Symbol: drake::geometry::render::CameraProperties
        struct /* CameraProperties */ {
          // Source: drake/geometry/render/camera_properties.h:30
          const char* doc_deprecated =
R"""(The intrinsic properties for a render camera. The render system uses a
reduced set of intrinsic parameters by making some simplifying
assumptions:

- Zero skew coefficient between the x- and y-axes.
- The camera's principal point lies in the center of the image.

The focal length is inferred by the sensor format (width and height)
and the field of view along the y-axis. */ (Deprecated.)

Deprecated:
    CameraProperties are being deprecated. Please use
    ColorRenderCamera. This will be removed from Drake on or after
    2021-04-01.)""";
          // Symbol: drake::geometry::render::CameraProperties::CameraProperties
          struct /* ctor */ {
            // Source: drake/geometry/render/camera_properties.h:31
            const char* doc = R"""()""";
          } ctor;
          // Symbol: drake::geometry::render::CameraProperties::fov_y
          struct /* fov_y */ {
            // Source: drake/geometry/render/camera_properties.h:40
            const char* doc =
R"""(The camera's vertical field of view (in radians).)""";
          } fov_y;
          // Symbol: drake::geometry::render::CameraProperties::height
          struct /* height */ {
            // Source: drake/geometry/render/camera_properties.h:39
            const char* doc =
R"""(The height of the image (in pixels) to be rendered.)""";
          } height;
          // Symbol: drake::geometry::render::CameraProperties::renderer_name
          struct /* renderer_name */ {
            // Source: drake/geometry/render/camera_properties.h:41
            const char* doc = R"""(The name of the renderer to use.)""";
          } renderer_name;
          // Symbol: drake::geometry::render::CameraProperties::width
          struct /* width */ {
            // Source: drake/geometry/render/camera_properties.h:38
            const char* doc =
R"""(The width of the image (in pixels) to be rendered.)""";
          } width;
        } CameraProperties;
        // Symbol: drake::geometry::render::ClippingRange
        struct /* ClippingRange */ {
          // Source: drake/geometry/render/render_camera.h:17
          const char* doc =
R"""(Defines the near and far clipping planes for frustum-based (e.g.
OpenGL) RenderEngine cameras.)""";
          // Symbol: drake::geometry::render::ClippingRange::ClippingRange
          struct /* ctor */ {
            // Source: drake/geometry/render/render_camera.h:24
            const char* doc =
R"""(Constructs the ClippingRange.

Raises:
    RuntimeError if either value isn't positive, or if ``near >=
    far``.)""";
          } ctor;
          // Symbol: drake::geometry::render::ClippingRange::far
          struct /* far */ {
            // Source: drake/geometry/render/render_camera.h:27
            const char* doc = R"""()""";
          } far;
          // Symbol: drake::geometry::render::ClippingRange::near
          struct /* near */ {
            // Source: drake/geometry/render/render_camera.h:26
            const char* doc = R"""()""";
          } near;
        } ClippingRange;
        // Symbol: drake::geometry::render::ColorRenderCamera
        struct /* ColorRenderCamera */ {
          // Source: drake/geometry/render/render_camera.h:109
          const char* doc =
R"""(Collection of camera properties for cameras to be used with
color/label images.)""";
          // Symbol: drake::geometry::render::ColorRenderCamera::ColorRenderCamera
          struct /* ctor */ {
            // Source: drake/geometry/render/render_camera.h:118
            const char* doc_3args =
R"""(Constructs a ColorRenderCamera from the old, symmetric camera
representation. This constructor should only be used internally; it
serves as a stop gap measure until CameraProperties is fully
deprecated.)""";
            // Source: drake/geometry/render/render_camera.h:128
            const char* doc_2args =
R"""(Fully-specified constructor. See the documentation on the member
getter methods for documentation of parameters.)""";
          } ctor;
          // Symbol: drake::geometry::render::ColorRenderCamera::core
          struct /* core */ {
            // Source: drake/geometry/render/render_camera.h:132
            const char* doc = R"""(This camera's core render properties.)""";
          } core;
          // Symbol: drake::geometry::render::ColorRenderCamera::show_window
          struct /* show_window */ {
            // Source: drake/geometry/render/render_camera.h:135
            const char* doc =
R"""(If true, requests that the RenderEngine display the rendered image.)""";
          } show_window;
        } ColorRenderCamera;
        // Symbol: drake::geometry::render::DepthCameraProperties
        struct /* DepthCameraProperties */ {
          // Source: drake/geometry/render/camera_properties.h:51
          const char* doc_deprecated =
R"""(The intrinsic properties for a render *depth* camera. Consists of all
of the intrinsic properties of the render camera but extended with
additional depth-specific parameters.

See also:
    CameraProperties */ (Deprecated.)

Deprecated:
    DepthCameraProperties are being deprecated. Please use
    DepthRenderCamera. This will be removed from Drake on or after
    2021-04-01.)""";
          // Symbol: drake::geometry::render::DepthCameraProperties::DepthCameraProperties
          struct /* ctor */ {
            // Source: drake/geometry/render/camera_properties.h:52
            const char* doc = R"""()""";
          } ctor;
          // Symbol: drake::geometry::render::DepthCameraProperties::z_far
          struct /* z_far */ {
            // Source: drake/geometry/render/camera_properties.h:62
            const char* doc =
R"""(The maximum reportable depth value. All surfaces farther than this
distance, saturate to this value.)""";
          } z_far;
          // Symbol: drake::geometry::render::DepthCameraProperties::z_near
          struct /* z_near */ {
            // Source: drake/geometry/render/camera_properties.h:60
            const char* doc =
R"""(The minimum reportable depth value. All surfaces closer than this
distance, saturate to this value.)""";
          } z_near;
        } DepthCameraProperties;
        // Symbol: drake::geometry::render::DepthRange
        struct /* DepthRange */ {
          // Source: drake/geometry/render/render_camera.h:162
          const char* doc =
R"""(Defines a depth sensor's functional range. Only points that lie within
the range ``[min_depth, max_depth]`` will register meaningful values.

Note:
    It's important to carefully coordinate depth range and clipping
    planes. It might seem reasonable to use the depth range as
    clipping planes, but that would be a mistake. Objects closer than
    the depth range's minimum value have an occluding effect in
    reality. If the near clipping plane is set to the minimum depth
    range value, those objects will be clipped away and won't occlude
    as they should. In essence, the camera will see through them and
    return incorrect values from beyond the missing geometry. The near
    clipping plane should *always* be closer than the minimum depth
    range. How much closer depends on the scenario. Given the
    scenario, evaluate the closest possible distance to the camera
    that geometry in the scene could possibly achieve; the clipping
    plane should be slightly closer than that. When in doubt, some
    very small value (e.g., 1 mm) is typically safe.)""";
          // Symbol: drake::geometry::render::DepthRange::DepthRange
          struct /* ctor */ {
            // Source: drake/geometry/render/render_camera.h:169
            const char* doc =
R"""(Constructs the DepthRange.

Raises:
    RuntimeError if either value isn't positive, or if ``min_in >=
    max_in``.)""";
          } ctor;
          // Symbol: drake::geometry::render::DepthRange::max_depth
          struct /* max_depth */ {
            // Source: drake/geometry/render/render_camera.h:172
            const char* doc = R"""()""";
          } max_depth;
          // Symbol: drake::geometry::render::DepthRange::min_depth
          struct /* min_depth */ {
            // Source: drake/geometry/render/render_camera.h:171
            const char* doc = R"""()""";
          } min_depth;
        } DepthRange;
        // Symbol: drake::geometry::render::DepthRenderCamera
        struct /* DepthRenderCamera */ {
          // Source: drake/geometry/render/render_camera.h:181
          const char* doc =
R"""(Collection of camera properties for cameras to be used with depth
images.)""";
          // Symbol: drake::geometry::render::DepthRenderCamera::DepthRenderCamera
          struct /* ctor */ {
            // Source: drake/geometry/render/render_camera.h:190
            const char* doc_2args_camera_X_BD =
R"""(Constructs a DepthRenderCamera from the old, symmetric camera
representation. This constructor should only be used internally; it
serves as a stop gap measure until CameraProperties is fully
deprecated.)""";
            // Source: drake/geometry/render/render_camera.h:202
            const char* doc_2args_core_depth_range =
R"""(Fully-specified constructor. See the documentation on the member
getter methods for documentation of parameters.

Raises:
    RuntimeError if the depth_range is not fully contained within the
    clipping range.)""";
          } ctor;
          // Symbol: drake::geometry::render::DepthRenderCamera::core
          struct /* core */ {
            // Source: drake/geometry/render/render_camera.h:205
            const char* doc = R"""(This camera's core render properties.)""";
          } core;
          // Symbol: drake::geometry::render::DepthRenderCamera::depth_range
          struct /* depth_range */ {
            // Source: drake/geometry/render/render_camera.h:208
            const char* doc =
R"""(The range of valid values for the depth camera.)""";
          } depth_range;
        } DepthRenderCamera;
        // Symbol: drake::geometry::render::MakeRenderEngineGl
        struct /* MakeRenderEngineGl */ {
          // Source: drake/geometry/render/gl_renderer/render_engine_gl_factory.h:29
          const char* doc =
R"""(Constructs a RenderEngine implementation which uses a purely OpenGL
renderer. The engine only works under Ubuntu. If called on a Mac, it
will produce a "dummy" implementation.

Note:
    RenderEngineGl behaves a bit differently from other RenderEngine
    implementations (e.g., RenderEngineVtk) with respect to displayed
    images. First, RenderEngineGl can only display a *single* image
    type at a time. So, if a shown window has been requested for both
    label and color images, the images will alternate in the same
    window. Second, the window display draws all images *flipped
    vertically*. The image produced will be compatible with the Drake
    ecosystem, only the visualization will be upside down. This has
    been documented in
    https://github.com/RobotLocomotion/drake/issues/14254.

Warning:
    RenderEngineGl is not threadsafe. If a SceneGraph is instantiated
    with a RenderEngineGl and there are multiple Context instances for
    that SceneGraph, rendering in multiple threads may exhibit issues.)""";
        } MakeRenderEngineGl;
        // Symbol: drake::geometry::render::MakeRenderEngineVtk
        struct /* MakeRenderEngineVtk */ {
          // Source: drake/geometry/render/render_engine_vtk_factory.h:83
          const char* doc =
R"""(Constructs a RenderEngine implementation which uses a VTK-based OpenGL
renderer.

Geometry perception properties
------------------------------

This RenderEngine implementation looks for the following properties
when registering visual geometry, categorized by rendered image type.

**RGB images**

| Group name | Property Name | Required | Property Type | Property
Description | | :--------: | :-----------: | :------: |
:-------------: | :------------------- | | phong | diffuse | no¹ |
Eigen::Vector4d | The rgba value of the object surface. | | phong |
diffuse_map | no² | std::string | The path to a texture to apply to
the geometry.³ |

¹ If no diffuse value is given, a default rgba value will be applied.
The default color is a bright orange. This default value can be
changed to a different value at construction.

² If no path is specified, or the file cannot be read, the diffuse
rgba value is used (or its default). ³ RenderEngineVtk implements a
legacy feature for associating textures with *meshes*. If *no*
``(phong, diffuse_map)`` property is provided (or it refers to a file
that doesn't exist), for a mesh named ``/path/to/mesh.obj``,
RenderEngineVtk will search for a file ``/path/to/mesh.png``
(replacing "obj" with "png"). If that image exists, it will be used as
a texture on the mesh object.

**Depth images**

No specific properties required.

**Label images**

| Group name | Property Name | Required | Property Type | Property
Description | | :--------: | :-----------: | :-----------: |
:-------------: | :------------------- | | label | id | configurable⁵
| RenderLabel | The label to render into the image. |

⁵ RenderEngineVtk has a default render label value that is applied to
any geometry that doesn't have a (label, id) property at registration.
If a value is not explicitly specified, RenderEngineVtk uses
RenderLabel::kUnspecified as this default value. It can be explicitly
set upon construction. The possible values for this default label and
the ramifications of that choice are documented
render_engine_default_label "here".

**Geometries accepted by RenderEngineVtk**

As documented in RenderEngine::RegisterVisual(), a RenderEngine
implementation can use the properties found in the
PerceptionProperties to determine whether it *accepts* a shape
provided for registration. RenderEngineVtk makes use of defaults to
accept *all* geometries (assuming the properties pass validation,
e.g., render label validation).)""";
        } MakeRenderEngineVtk;
        // Symbol: drake::geometry::render::RenderCameraCore
        struct /* RenderCameraCore */ {
          // Source: drake/geometry/render/render_camera.h:43
          const char* doc =
R"""(Collection of core parameters for modeling a pinhole-model camera in a
RenderEngine. These parameters are applicable to both depth and
color/label renderings. Parameters specific to those output image
types can be found below.

While these parameters are generally applicable to all RenderEngine
implementations, this is not guaranteed to be true. For example, the
clipping range property only applies to frustum-based RenderEngine
implementations. I.e., it wouldn't apply to a ray-tracing based
implementation.)""";
          // Symbol: drake::geometry::render::RenderCameraCore::CalcProjectionMatrix
          struct /* CalcProjectionMatrix */ {
            // Source: drake/geometry/render/render_camera.h:89
            const char* doc =
R"""(Expresses ``this`` camera's pinhole camera properties as the
projective transform T_DC which transforms points in a camera's frame
C to a 2D, normalized device frame D. The transform is represented by
a 4x4 matrix (i.e., a <a
href="https://strawlab.org/2011/11/05/augmented-reality-with-OpenGL/">
classic OpenGl projection matrix</a>).)""";
          } CalcProjectionMatrix;
          // Symbol: drake::geometry::render::RenderCameraCore::RenderCameraCore
          struct /* ctor */ {
            // Source: drake/geometry/render/render_camera.h:52
            const char* doc_3args =
R"""((Advanced) Constructs a RenderCameraCore from the old, symmetric
camera representation. This constructor should only be used
internally; it serves as a stop gap measure until CameraProperties is
fully deprecated.)""";
            // Source: drake/geometry/render/render_camera.h:58
            const char* doc_4args =
R"""(Fully-specified constructor. See the documentation on the member
getter methods for documentation of parameters.)""";
          } ctor;
          // Symbol: drake::geometry::render::RenderCameraCore::clipping
          struct /* clipping */ {
            // Source: drake/geometry/render/render_camera.h:75
            const char* doc =
R"""(The near and far clipping planes for this camera. This property is
ignored by RenderEngine implementations that don't use a clipping
frustum.)""";
          } clipping;
          // Symbol: drake::geometry::render::RenderCameraCore::intrinsics
          struct /* intrinsics */ {
            // Source: drake/geometry/render/render_camera.h:71
            const char* doc =
R"""(The camera's intrinsic properties (e.g., focal length, sensor size,
etc.) See systems::sensors::CameraInfo for details.)""";
          } intrinsics;
          // Symbol: drake::geometry::render::RenderCameraCore::renderer_name
          struct /* renderer_name */ {
            // Source: drake/geometry/render/render_camera.h:67
            const char* doc =
R"""(The name of the render engine this camera should be used with.)""";
          } renderer_name;
          // Symbol: drake::geometry::render::RenderCameraCore::sensor_pose_in_camera_body
          struct /* sensor_pose_in_camera_body */ {
            // Source: drake/geometry/render/render_camera.h:79
            const char* doc =
R"""(The pose of the sensor frame (S) in the camera's body frame (B). This
is the "imager" referred to in systems::sensors::CameraInfo's
documentation.)""";
          } sensor_pose_in_camera_body;
        } RenderCameraCore;
        // Symbol: drake::geometry::render::RenderEngine
        struct /* RenderEngine */ {
          // Source: drake/geometry/render/render_engine.h:85
          const char* doc =
R"""(The engine for performing rasterization operations on geometry. This
includes rgb images and depth images. The coordinate system of
RenderEngine's viewpoint ``R`` is ``X-right``, `Y-down` and
``Z-forward`` with respect to the rendered images.

**Output image format**

- RGB (ImageRgba8U) : the RGB image has four channels in the following
order: red, green, blue, and alpha. Each channel is represented by
a uint8_t.

- Depth (ImageDepth32F) : the depth image has a depth channel represented
by a float. For a point in space ``P``, the value stored in the depth
channel holds *the Z-component of the position vector ``p_RP``.*
Note that this is different from the range data used by laser
range finders (like that provided by DepthSensor) in which the depth
value represents the distance from the sensor origin to the object's
surface.

- Label (ImageLabel16I) : the label image has single channel represented
by an int16_t. The value stored in the channel holds a RenderLabel value
which corresponds to an object class in the scene or an "empty" pixel (see
RenderLabel for more details).

**RenderLabels, registering geometry, and derived classes**

By convention, when registering a geometry, the provided properties
should contain no more than one RenderLabel instance, and that should
be the ``(label, id)`` property. RenderEngine provides the notion of a
*default render label* that will be applied where no ``(label, id)``
RenderLabel property is found. This default value can be one of two
values: RenderLabel::kDontCare or RenderLabel::kUnspecified. The
choice of default RenderLabel can be made at construction and it
affects registration behavior when the ``(label, id)`` property is
absent:

- RenderLabel::kUnspecified: throws an exception.
- RenderLabel::kDontCare: the geometry will be included in label images as
the generic, non-distinguishing label.

Choosing RenderLabel::kUnspecified is best in a system that wants
explicit feedback and strict enforcement on a policy of strict label
enforcement -- everything should receive a meaningful label. The
choice of RenderLabel::kDontCare is best for a less strict system in
which only some subset of geometry need be explicitly specified.

Derived classes configure their *de facto* default RenderLabel value,
or a user-configured default value, at construction, subject to the
requirements outlined above.

Derived classes should not access the ``(label, id)`` property
directly. RenderEngine provides a method to safely extract a
RenderLabel value from the PerceptionProperties, taking into account
the configured default value and the documented reserved_render_label
"RenderLabel semantics"; see GetRenderLabelOrThrow().)""";
          // Symbol: drake::geometry::render::RenderEngine::Clone
          struct /* Clone */ {
            // Source: drake/geometry/render/render_engine.h:110
            const char* doc =
R"""(Clones the render engine -- making the RenderEngine compatible with
copyable_unique_ptr.)""";
          } Clone;
          // Symbol: drake::geometry::render::RenderEngine::DoClone
          struct /* DoClone */ {
            // Source: drake/geometry/render/render_engine.h:391
            const char* doc =
R"""(The NVI-function for cloning this render engine.)""";
          } DoClone;
          // Symbol: drake::geometry::render::RenderEngine::DoRegisterVisual
          struct /* DoRegisterVisual */ {
            // Source: drake/geometry/render/render_engine.h:372
            const char* doc =
R"""(The NVI-function for sub-classes to implement actual geometry
registration. If the derived class chooses not to register this
particular shape, it should return false.

A derived render engine can choose not to register geometry because,
e.g., it doesn't have default properties. This is the primary
mechanism which enables different renderers to use different
geometries for the same frame. For example, a low-fidelity renderer
may use simple geometry whereas a high-fidelity renderer would require
a very detailed geometry. Both geometries would have
PerceptionProperties, but, based on the provided property groups and
values, one would be accepted and registered with one render engine
implementation and the other geometry with another render engine.

In accessing the RenderLabel property in ``properties`` derived class
should *exclusively* use GetRenderLabelOrThrow().)""";
          } DoRegisterVisual;
          // Symbol: drake::geometry::render::RenderEngine::DoRemoveGeometry
          struct /* DoRemoveGeometry */ {
            // Source: drake/geometry/render/render_engine.h:388
            const char* doc =
R"""(The NVI-function for removing the geometry with the given ``id``.

Parameter ``id``:
    The id of the geometry to remove.

Returns:
    True if the geometry was registered with this RenderEngine and
    removed, false if it wasn't registered in the first place.)""";
          } DoRemoveGeometry;
          // Symbol: drake::geometry::render::RenderEngine::DoRenderColorImage
          struct /* DoRenderColorImage */ {
            // Source: drake/geometry/render/render_engine.h:403
            const char* doc =
R"""(The NVI-function for rendering color with a fully-specified camera.
When RenderColorImage calls this, it has already confirmed that
``color_image_out`` is not ``nullptr`` and its size is consistent with
the camera intrinsics.

During the deprecation period, the default implementation strips out
intrinsics unsupported by the simple render API, prints a warning, and
attempts to delegate to the simple-camera RenderColorImage. After the
deprecation period, it will throw a "not implemented"-style exception.)""";
          } DoRenderColorImage;
          // Symbol: drake::geometry::render::RenderEngine::DoRenderDepthImage
          struct /* DoRenderDepthImage */ {
            // Source: drake/geometry/render/render_engine.h:417
            const char* doc =
R"""(The NVI-function for rendering depth with a fully-specified camera.
When RenderDepthImage calls this, it has already confirmed that
``depth_image_out`` is not ``nullptr`` and its size is consistent with
the camera intrinsics.

During the deprecation period, the default implementation strips out
intrinsics unsupported by the simple render API, prints a warning, and
attempts to delegate to the simple-camera RenderDepthImage. After the
deprecation period, it will throw a "not implemented"-style exception.)""";
          } DoRenderDepthImage;
          // Symbol: drake::geometry::render::RenderEngine::DoRenderLabelImage
          struct /* DoRenderLabelImage */ {
            // Source: drake/geometry/render/render_engine.h:431
            const char* doc =
R"""(The NVI-function for rendering label with a fully-specified camera.
When RenderLabelImage calls this, it has already confirmed that
``label_image_out`` is not ``nullptr`` and its size is consistent with
the camera intrinsics.

During the deprecation period, the default implementation strips out
intrinsics unsupported by the simple render API, prints a warning, and
attempts to delegate to the simple-camera RenderLabelImage. After the
deprecation period, it will throw a "not implemented"-style exception.)""";
          } DoRenderLabelImage;
          // Symbol: drake::geometry::render::RenderEngine::DoUpdateVisualPose
          struct /* DoUpdateVisualPose */ {
            // Source: drake/geometry/render/render_engine.h:381
            const char* doc =
R"""(The NVI-function for updating the pose of a render geometry
(identified by ``id``) to the given pose X_WG.

Parameter ``id``:
    The id of the render geometry whose pose is being set.

Parameter ``X_WG``:
    The pose of the render geometry in the world frame.)""";
          } DoUpdateVisualPose;
          // Symbol: drake::geometry::render::RenderEngine::GetColorDFromLabel
          struct /* GetColorDFromLabel */ {
            // Source: drake/geometry/render/render_engine.h:476
            const char* doc =
R"""(Transforms ``this`` render label into a double-valued RGB color.)""";
          } GetColorDFromLabel;
          // Symbol: drake::geometry::render::RenderEngine::GetColorIFromLabel
          struct /* GetColorIFromLabel */ {
            // Source: drake/geometry/render/render_engine.h:470
            const char* doc =
R"""(Transforms ``this`` render label into a byte-valued RGB color.)""";
          } GetColorIFromLabel;
          // Symbol: drake::geometry::render::RenderEngine::GetRenderLabelOrThrow
          struct /* GetRenderLabelOrThrow */ {
            // Source: drake/geometry/render/render_engine.h:440
            const char* doc =
R"""(Extracts the ``(label, id)`` RenderLabel property from the given
``properties`` and validates it (or the configured default if no such
property is defined).

Raises:
    RuntimeError If the tested render label value is deemed invalid.)""";
          } GetRenderLabelOrThrow;
          // Symbol: drake::geometry::render::RenderEngine::LabelFromColor
          struct /* LabelFromColor */ {
            // Source: drake/geometry/render/render_engine.h:465
            const char* doc =
R"""(Transforms the given byte-valued RGB color value into its
corresponding RenderLabel.)""";
          } LabelFromColor;
          // Symbol: drake::geometry::render::RenderEngine::RegisterVisual
          struct /* RegisterVisual */ {
            // Source: drake/geometry/render/render_engine.h:136
            const char* doc =
R"""(Requests registration of the given shape with this render engine. The
geometry is uniquely identified by the given ``id``. The renderer is
allowed to examine the given ``properties`` and choose to *not*
register the geometry.

Typically, derived classes will attempt to validate the RenderLabel
value stored in the ``(label, id)`` property (or its configured
default value if no such property exists). In that case, attempting to
assign RenderLabel::kEmpty or RenderLabel::kUnspecified will cause an
exception to be thrown (as reserved_render_label "documented").

Parameter ``id``:
    The geometry id of the shape to register.

Parameter ``shape``:
    The shape specification to add to the render engine.

Parameter ``properties``:
    The perception properties provided for this geometry.

Parameter ``X_WG``:
    The pose of the geometry relative to the world frame W.

Parameter ``needs_updates``:
    If true, the geometry's pose will be updated via UpdatePoses().

Returns:
    True if the RenderEngine implementation accepted the shape for
    registration.

Raises:
    RuntimeError if the shape is an unsupported type, the shape's
    RenderLabel value is RenderLabel::kUnspecified or
    RenderLabel::kEmpty, or a geometry has already been registered
    with the given ``id``.)""";
          } RegisterVisual;
          // Symbol: drake::geometry::render::RenderEngine::RemoveGeometry
          struct /* RemoveGeometry */ {
            // Source: drake/geometry/render/render_engine.h:145
            const char* doc =
R"""(Removes the geometry indicated by the given ``id`` from the engine.

Parameter ``id``:
    The id of the geometry to remove.

Returns:
    True if the geometry was removed (false implies that this id
    wasn't registered with this engine).)""";
          } RemoveGeometry;
          // Symbol: drake::geometry::render::RenderEngine::RenderColorImage
          struct /* RenderColorImage */ {
            // Source: drake/geometry/render/render_engine.h:240
            const char* doc_deprecated =
R"""((Deprecated.)

Deprecated:
    CameraProperties are being deprecated. Prefer the
    ColorRenderCamera variant; implement the protected
    DoRenderColorImage() method. This will be removed from Drake on or
    after 2021-04-01.)""";
            // Source: drake/geometry/render/render_engine.h:305
            const char* doc =
R"""(Renders the registered geometry into the given color (rgb) image based
on a *fully* specified camera.

Parameter ``camera``:
    The *render engine* camera properties.

Parameter ``color_image_out``:
    The rendered color image.

Raises:
    RuntimeError if ``color_image_out`` is ``nullptr`` or the size of
    the given input image doesn't match the size declared in
    ``camera``.)""";
          } RenderColorImage;
          // Symbol: drake::geometry::render::RenderEngine::RenderDepthImage
          struct /* RenderDepthImage */ {
            // Source: drake/geometry/render/render_engine.h:259
            const char* doc_deprecated =
R"""((Deprecated.)

Deprecated:
    DepthCameraProperties are being deprecated. Prefer the
    DepthRenderCamera variant; implement the protected
    DoRenderDepthImage() method. This will be removed from Drake on or
    after 2021-04-01.)""";
            // Source: drake/geometry/render/render_engine.h:321
            const char* doc =
R"""(Renders the registered geometry into the given depth image based on a
*fully* specified camera. In contrast to the other rendering
operations, depth images don't have an option to display the window;
generally, basic depth images are not readily communicative to humans.

Parameter ``camera``:
    The *render engine* camera properties.

Parameter ``depth_image_out``:
    The rendered depth image.

Raises:
    RuntimeError if ``depth_image_out`` is ``nullptr`` or the size of
    the given input image doesn't match the size declared in
    ``camera``.)""";
          } RenderDepthImage;
          // Symbol: drake::geometry::render::RenderEngine::RenderEngine
          struct /* ctor */ {
            // Source: drake/geometry/render/render_engine.h:95
            const char* doc =
R"""(Constructs a RenderEngine with the given default render label. The
default render label is applied to geometries that have not otherwise
specified a (label, id) property. The value *must* be either
RenderLabel::kUnspecified or RenderLabel::kDontCare. (See
render_engine_default_label "this section" for more details.)

Raises:
    RuntimeError if the default render label is not one of the two
    allowed labels.)""";
          } ctor;
          // Symbol: drake::geometry::render::RenderEngine::RenderLabelImage
          struct /* RenderLabelImage */ {
            // Source: drake/geometry/render/render_engine.h:278
            const char* doc_deprecated =
R"""((Deprecated.)

Deprecated:
    CameraProperties are being deprecated. Prefer the
    ColorRenderCamera variant; implement the protected
    DoRenderLabelImage() method. This will be removed from Drake on or
    after 2021-04-01.)""";
            // Source: drake/geometry/render/render_engine.h:339
            const char* doc =
R"""(Renders the registered geometry into the given label image based on a
*fully* specified camera.

Note:
    This uses the ColorRenderCamera as label images are typically
    rendered to be exactly registered with a corresponding color
    image.

Parameter ``camera``:
    The *render engine* camera properties.

Parameter ``label_image_out``:
    The rendered label image.

Raises:
    RuntimeError if ``label_image_out`` is ``nullptr`` or the size of
    the given input image doesn't match the size declared in
    ``camera``.)""";
          } RenderLabelImage;
          // Symbol: drake::geometry::render::RenderEngine::SetDefaultLightPosition
          struct /* SetDefaultLightPosition */ {
            // Source: drake/geometry/render/render_engine.h:491
            const char* doc =
R"""(Provides access to the light for manual configuration since it's
currently bound to the camera position. This is a temporary measure to
facilitate benchmarking and create visible shadows, and should not be
used publicly.

Parameter ``X_DL``:
    The pose of the light in a frame D that is attached to the camera
    position. In this frame D, the camera is located at (0, 0, 1),
    looking towards (0, 0, 0) at a distance of 1, with up being (0, 1,
    0).)""";
          } SetDefaultLightPosition;
          // Symbol: drake::geometry::render::RenderEngine::ThrowIfInvalid
          struct /* ThrowIfInvalid */ {
            // Source: drake/geometry/render/render_engine.h:494
            const char* doc = R"""()""";
          } ThrowIfInvalid;
          // Symbol: drake::geometry::render::RenderEngine::UpdatePoses
          struct /* UpdatePoses */ {
            // Source: drake/geometry/render/render_engine.h:158
            const char* doc =
R"""(Updates the poses of all geometries marked as "needing update" (see
RegisterVisual()).

Parameter ``X_WGs``:
    The poses of *all* geometries in SceneGraph (measured and
    expressed in the world frame). The pose for a geometry is accessed
    by that geometry's id.)""";
          } UpdatePoses;
          // Symbol: drake::geometry::render::RenderEngine::UpdateViewpoint
          struct /* UpdateViewpoint */ {
            // Source: drake/geometry/render/render_engine.h:171
            const char* doc =
R"""(Updates the renderer's viewpoint with given pose X_WR.

Parameter ``X_WR``:
    The pose of renderer's viewpoint in the world coordinate system.)""";
          } UpdateViewpoint;
          // Symbol: drake::geometry::render::RenderEngine::default_render_label
          struct /* default_render_label */ {
            // Source: drake/geometry/render/render_engine.h:350
            const char* doc =
R"""(Reports the render label value this render engine has been configured
to use.)""";
          } default_render_label;
          // Symbol: drake::geometry::render::RenderEngine::has_geometry
          struct /* has_geometry */ {
            // Source: drake/geometry/render/render_engine.h:149
            const char* doc =
R"""(Reports true if a geometry with the given ``id`` has been registered
with ``this`` engine.)""";
          } has_geometry;
        } RenderEngine;
        // Symbol: drake::geometry::render::RenderEngineGlParams
        struct /* RenderEngineGlParams */ {
          // Source: drake/geometry/render/gl_renderer/render_engine_gl_params.h:11
          const char* doc =
R"""(Construction parameters for RenderEngineGl.)""";
          // Symbol: drake::geometry::render::RenderEngineGlParams::default_clear_color
          struct /* default_clear_color */ {
            // Source: drake/geometry/render/gl_renderer/render_engine_gl_params.h:21
            const char* doc =
R"""(The default background color for color images.)""";
          } default_clear_color;
          // Symbol: drake::geometry::render::RenderEngineGlParams::default_diffuse
          struct /* default_diffuse */ {
            // Source: drake/geometry/render/gl_renderer/render_engine_gl_params.h:18
            const char* doc =
R"""(Default diffuse color to apply to a geometry when none is otherwise
specified in the (phong, diffuse) property.)""";
          } default_diffuse;
          // Symbol: drake::geometry::render::RenderEngineGlParams::default_label
          struct /* default_label */ {
            // Source: drake/geometry/render/gl_renderer/render_engine_gl_params.h:14
            const char* doc =
R"""(Default render label to apply to a geometry when none is otherwise
specified.)""";
          } default_label;
        } RenderEngineGlParams;
        // Symbol: drake::geometry::render::RenderEngineVtkParams
        struct /* RenderEngineVtkParams */ {
          // Source: drake/geometry/render/render_engine_vtk_factory.h:13
          const char* doc =
R"""(Construction parameters for the RenderEngineVtk.)""";
          // Symbol: drake::geometry::render::RenderEngineVtkParams::default_clear_color
          struct /* default_clear_color */ {
            // Source: drake/geometry/render/render_engine_vtk_factory.h:25
            const char* doc =
R"""(The rgb color to which the color buffer is cleared (each channel in
the range [0, 1]). The default value (in byte values) would be [204,
229, 255].)""";
          } default_clear_color;
          // Symbol: drake::geometry::render::RenderEngineVtkParams::default_diffuse
          struct /* default_diffuse */ {
            // Source: drake/geometry/render/render_engine_vtk_factory.h:20
            const char* doc =
R"""(The (optional) rgba color to apply to the (phong, diffuse) property
when none is otherwise specified. Note: currently the alpha channel is
unused by RenderEngineVtk.)""";
          } default_diffuse;
          // Symbol: drake::geometry::render::RenderEngineVtkParams::default_label
          struct /* default_label */ {
            // Source: drake/geometry/render/render_engine_vtk_factory.h:15
            const char* doc =
R"""(The (optional) label to apply when none is otherwise specified.)""";
          } default_label;
        } RenderEngineVtkParams;
        // Symbol: drake::geometry::render::RenderLabel
        struct /* RenderLabel */ {
          // Source: drake/geometry/render/render_label.h:69
          const char* doc =
R"""(Class representing object "labels" for rendering.

In a "label image" (see RenderEngine::RenderLabelImage() for details)
each pixel value indicates the classification of the object that
rendered into that pixel. The RenderLabel class provides that value
and one label is associated with each rendered geometry.

The labels could be unique for each geometry, or multiple geometries
could all share the same label (becoming indistinguishable in the
label image). Ultimately, it is the user's responsibility to assign
labels in a manner that is meaningful for their application.

**Reserved labels**

There are several RenderLabels that are reserved. They have specific
meaning in the context of the rendering ecosystem and are globally
available to all applications. They are:

- ``empty``: a pixel with the ``empty`` RenderLabel value indicates that *no*
geometry rendered to that pixel. Implemented as RenderLabel::kEmpty.
- ``do not render``: any geometry assigned the ``do not render`` tag will *not* be
rendered into a label image. This is a clear declaration that a geometry
should be omitted. Useful for marking, e.g., glass windows so that the
visible geometry behind the glass is what is included in the label image.
Implemented as RenderLabel::kDoNotRender.
- ``don't care``: the ``don't care`` label is intended as a convenient dumping
ground. This would be for geometry that *should* render into the label image,
but whose class is irrelevant (e.g., the walls of a room a robot is working
in or the background terrain in driving simulation). Implemented as
RenderLabel::kDontCare.
- ``unspecified``: a default-constructed RenderLabel has an ``unspecified`` value.
Implemented as RenderLabel::kUnspecified.

Generally, there is no good reason to assign ``empty`` or
``unspecified`` labels to a geometry. A RenderEngine implementation is
entitled to throw an exception if you attempt to do so.

Usage
-----

An application can simply instantiate RenderLabel with an arbitrary
value. This allows the application to define a particular mapping from
render label class to a preferred RenderLabel value. For a label image
to be *meaningful*, every pixel value should admit an unambiguous
interpretation. The application bears *full* responsibility in making
sure that a single value is not inadvertently associated with multiple
render classes. Finally, a RenderLabel cannot be explicitly
constructed with a reserved value -- those can only be accessed
through the static methods provided.

Note:
    The RenderLabel class is based on a 16-bit integer. This makes the
    label image more compact but means there are only, approximately,
    32,000 unique RenderLabel values.)""";
          // Symbol: drake::geometry::render::RenderLabel::RenderLabel
          struct /* ctor */ {
            // Source: drake/geometry/render/render_label.h:80
            const char* doc_0args =
R"""(Constructs a label with the reserved ``unspecified`` value.)""";
            // Source: drake/geometry/render/render_label.h:85
            const char* doc_1args =
R"""(Constructs a label with the given ``value``.

Raises:
    RuntimeError if a) is negative, or b) the ``value`` is one of the
    reserved values.)""";
          } ctor;
          // Symbol: drake::geometry::render::RenderLabel::ValueType
          struct /* ValueType */ {
            // Source: drake/geometry/render/render_label.h:76
            const char* doc = R"""()""";
          } ValueType;
          // Symbol: drake::geometry::render::RenderLabel::is_reserved
          struct /* is_reserved */ {
            // Source: drake/geometry/render/render_label.h:138
            const char* doc =
R"""(Reports if the label is a reserved label.)""";
          } is_reserved;
          // Symbol: drake::geometry::render::RenderLabel::operator short
          struct /* operator_short */ {
            // Source: drake/geometry/render/render_label.h:141
            const char* doc =
R"""(Implicit conversion to its underlying integer representation.)""";
          } operator_short;
          // Symbol: drake::geometry::render::RenderLabel::operator!=
          struct /* operator_ne */ {
            // Source: drake/geometry/render/render_label.h:95
            const char* doc =
R"""(Compares this label with the ``other`` label. Reports true if they
have different values.)""";
          } operator_ne;
          // Symbol: drake::geometry::render::RenderLabel::operator<
          struct /* operator_lt */ {
            // Source: drake/geometry/render/render_label.h:102
            const char* doc =
R"""(Allows the labels to be compared to imply a total ordering --
facilitates use in data structures which require ordering (e.g.,
std::set). The ordering has no particular meaning for applications.)""";
          } operator_lt;
        } RenderLabel;
        // Symbol: drake::geometry::render::shaders
        struct /* shaders */ {
        } shaders;
      } render;
      // Symbol: drake::geometry::to_string
      struct /* to_string */ {
        // Source: drake/geometry/geometry_roles.h:212
        const char* doc = R"""()""";
      } to_string;
    } geometry;
    // Symbol: drake::hash_append
    struct /* hash_append */ {
      // Source: drake/common/hash.h:79
      const char* doc_was_unable_to_choose_unambiguous_names =
R"""(Provides hash_append for integral constants.)""";
    } hash_append;
    // Symbol: drake::hash_append_range
    struct /* hash_append_range */ {
      // Source: drake/common/hash.h:147
      const char* doc =
R"""(Provides hash_append for a range, as given by two iterators.)""";
    } hash_append_range;
    // Symbol: drake::if_then_else
    struct /* if_then_else */ {
      // Source: drake/common/autodiff_overloads.h:182
      const char* doc_3args_bool_constEigenAutoDiffScalar_constEigenAutoDiffScalar =
R"""(Provides if-then-else expression for Eigen::AutoDiffScalar type. To
support Eigen's generic expressions, we use casting to the plain
object after applying Eigen::internal::remove_all. It is based on the
Eigen's implementation of min/max function for AutoDiffScalar type
(https://bitbucket.org/eigen/eigen/src/10a1de58614569c9250df88bdfc6402024687bc6/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h?at=default&fileviewer=file-view-default#AutoDiffScalar.h-546).)""";
      // Source: drake/common/double_overloads.h:17
      const char* doc_3args_f_cond_v_then_v_else =
R"""(The semantics is similar but not exactly the same as C++'s conditional
expression constructed by its ternary operator, @c ?:. In
``if_then_else(f_cond, v_then, v_else)``, both of ``v_then`` and
``v_else`` are evaluated regardless of the evaluation of ``f_cond``.
In contrast, only one of ``v_then`` or ``v_else`` is evaluated in
C++'s conditional expression ``f_cond ? v_then : v_else``.)""";
    } if_then_else;
    // Symbol: drake::is_approx_equal_abstol
    struct /* is_approx_equal_abstol */ {
      // Source: drake/common/is_approx_equal_abstol.h:13
      const char* doc =
R"""(Returns true if and only if the two matrices are equal to within a
certain absolute elementwise ``tolerance``. Special values
(infinities, NaN, etc.) do not compare as equal elements.)""";
    } is_approx_equal_abstol;
    // Symbol: drake::is_cloneable_internal
    struct /* is_cloneable_internal */ {
      // Symbol: drake::is_cloneable_internal::is_cloneable_helper
      struct /* is_cloneable_helper */ {
        // Source: drake/common/is_cloneable.h:14
        const char* doc = R"""()""";
      } is_cloneable_helper;
    } is_cloneable_internal;
    // Symbol: drake::is_eigen_nonvector_expression_double_pair
    struct /* is_eigen_nonvector_expression_double_pair */ {
      // Source: drake/common/symbolic_expression.h:1489
      const char* doc = R"""()""";
    } is_eigen_nonvector_expression_double_pair;
    // Symbol: drake::is_eigen_nonvector_of
    struct /* is_eigen_nonvector_of */ {
      // Source: drake/common/eigen_types.h:258
      const char* doc = R"""()""";
    } is_eigen_nonvector_of;
    // Symbol: drake::is_eigen_scalar_same
    struct /* is_eigen_scalar_same */ {
      // Source: drake/common/eigen_types.h:223
      const char* doc = R"""()""";
    } is_eigen_scalar_same;
    // Symbol: drake::is_eigen_type
    struct /* is_eigen_type */ {
      // Source: drake/common/eigen_types.h:217
      const char* doc = R"""()""";
    } is_eigen_type;
    // Symbol: drake::is_eigen_vector
    struct /* is_eigen_vector */ {
      // Source: drake/common/eigen_types.h:233
      const char* doc = R"""()""";
    } is_eigen_vector;
    // Symbol: drake::is_eigen_vector_expression_double_pair
    struct /* is_eigen_vector_expression_double_pair */ {
      // Source: drake/common/symbolic_expression.h:1499
      const char* doc = R"""()""";
    } is_eigen_vector_expression_double_pair;
    // Symbol: drake::is_eigen_vector_of
    struct /* is_eigen_vector_of */ {
      // Source: drake/common/eigen_types.h:242
      const char* doc = R"""()""";
    } is_eigen_vector_of;
    // Symbol: drake::is_less_than_comparable_internal
    struct /* is_less_than_comparable_internal */ {
      // Symbol: drake::is_less_than_comparable_internal::is_less_than_comparable_helper
      struct /* is_less_than_comparable_helper */ {
        // Source: drake/common/is_less_than_comparable.h:15
        const char* doc = R"""()""";
      } is_less_than_comparable_helper;
    } is_less_than_comparable_internal;
    // Symbol: drake::lcm
    struct /* lcm */ {
      // Symbol: drake::lcm::AreLcmMessagesEqual
      struct /* AreLcmMessagesEqual */ {
        // Source: drake/lcm/lcm_messages.h:45
        const char* doc =
R"""(Compares two LCM messages of the same type to see if they are equal.)""";
      } AreLcmMessagesEqual;
      // Symbol: drake::lcm::DecodeLcmMessage
      struct /* DecodeLcmMessage */ {
        // Source: drake/lcm/lcm_messages.h:30
        const char* doc =
R"""(Decodes an LCM message from a series of bytes.

Raises:
    RuntimeError if decoding fails.)""";
      } DecodeLcmMessage;
      // Symbol: drake::lcm::DrakeLcm
      struct /* DrakeLcm */ {
        // Source: drake/lcm/drake_lcm.h:18
        const char* doc = R"""(A wrapper around a *real* LCM instance.)""";
        // Symbol: drake::lcm::DrakeLcm::DrakeLcm
        struct /* ctor */ {
          // Source: drake/lcm/drake_lcm.h:26
          const char* doc_0args =
R"""(Constructs using LCM's default URL (either the default hard-coded URL,
or else LCM_DEFAULT_URL environment variable if it is set).)""";
          // Source: drake/lcm/drake_lcm.h:32
          const char* doc_1args =
R"""(Constructs using the given URL. If empty, it will use the default URL
as per the no-argument constructor.)""";
        } ctor;
        // Symbol: drake::lcm::DrakeLcm::HandleSubscriptions
        struct /* HandleSubscriptions */ {
          // Source: drake/lcm/drake_lcm.h:55
          const char* doc = R"""()""";
        } HandleSubscriptions;
        // Symbol: drake::lcm::DrakeLcm::Publish
        struct /* Publish */ {
          // Source: drake/lcm/drake_lcm.h:51
          const char* doc = R"""()""";
        } Publish;
        // Symbol: drake::lcm::DrakeLcm::Subscribe
        struct /* Subscribe */ {
          // Source: drake/lcm/drake_lcm.h:53
          const char* doc = R"""()""";
        } Subscribe;
        // Symbol: drake::lcm::DrakeLcm::get_lcm_instance
        struct /* get_lcm_instance */ {
          // Source: drake/lcm/drake_lcm.h:44
          const char* doc =
R"""((Advanced.) An accessor to the underlying LCM instance. The returned
pointer is guaranteed to be valid for the duration of this object's
lifetime.)""";
        } get_lcm_instance;
        // Symbol: drake::lcm::DrakeLcm::get_lcm_url
        struct /* get_lcm_url */ {
          // Source: drake/lcm/drake_lcm.h:49
          const char* doc = R"""(Returns the LCM URL.)""";
        } get_lcm_url;
      } DrakeLcm;
      // Symbol: drake::lcm::DrakeLcmInterface
      struct /* DrakeLcmInterface */ {
        // Source: drake/lcm/drake_lcm_interface.h:41
        const char* doc =
R"""(A pure virtual interface that enables LCM to be mocked.

Because it must be pure, in general it will receive breaking API
changes without notice. Users should not subclass this interface
directly, but rather use one of the existing subclasses instead.

Similarly, method arguments will receive breaking API changes without
notice. Users should not call this interface directly, but rather use
drake::lcm::Publish() or drake::lcm::Subscribe() instead.)""";
        // Symbol: drake::lcm::DrakeLcmInterface::DrakeLcmInterface
        struct /* ctor */ {
          // Source: drake/lcm/drake_lcm_interface.h:43
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::lcm::DrakeLcmInterface::HandleSubscriptions
        struct /* HandleSubscriptions */ {
          // Source: drake/lcm/drake_lcm_interface.h:108
          const char* doc =
R"""(Invokes the HandlerFunction callbacks for all subscriptions' pending
messages. If ``timeout_millis`` is >0, blocks for up to that long
until at least one message is handled.

Returns:
    the number of messages handled, or 0 on timeout.

Raises:
    RuntimeError when a subscribed handler throws.)""";
        } HandleSubscriptions;
        // Symbol: drake::lcm::DrakeLcmInterface::HandlerFunction
        struct /* HandlerFunction */ {
          // Source: drake/lcm/drake_lcm_interface.h:55
          const char* doc =
R"""(A callback used by DrakeLcmInterface::Subscribe(), with arguments: -
``message_buffer`` A pointer to the byte vector that is the serial
representation of the LCM message. - ``message_size`` The size of
``message_buffer``.

A callback should never throw an exception, because it is indirectly
called from C functions.)""";
        } HandlerFunction;
        // Symbol: drake::lcm::DrakeLcmInterface::Publish
        struct /* Publish */ {
          // Source: drake/lcm/drake_lcm_interface.h:74
          const char* doc =
R"""(Most users should use the drake::lcm::Publish() free function, instead
of this interface method.

Publishes an LCM message on channel ``channel``.

Parameter ``channel``:
    The channel on which to publish the message. Must not be the empty
    string.

Parameter ``data``:
    A buffer containing the serialized bytes of the message to
    publish.

Parameter ``data_size``:
    The length of @data in bytes.

Parameter ``time_sec``:
    Time in seconds when the publish event occurred. If unknown, use
    nullopt or a default-constructed optional.)""";
        } Publish;
        // Symbol: drake::lcm::DrakeLcmInterface::Subscribe
        struct /* Subscribe */ {
          // Source: drake/lcm/drake_lcm_interface.h:98
          const char* doc =
R"""(Most users should use the drake::lcm::Subscribe() free function or the
drake::lcm::Subscriber wrapper class, instead of this interface
method.

Subscribes to an LCM channel without automatic message decoding. The
handler will be invoked when a message arrives on channel ``channel``.

The handler should never throw an exception, because it is indirectly
called from C functions.

NOTE: Unlike upstream LCM, DrakeLcm does not support regexes for the
``channel`` argument.

Parameter ``channel``:
    The channel to subscribe to. Must not be the empty string.

Returns:
    the object used to manage the subscription if that is supported,
    or else nullptr if not supported. The unsubscribe-on-delete
    default is ``False``. Refer to the DrakeSubscriptionInterface
    class overview for details.)""";
        } Subscribe;
      } DrakeLcmInterface;
      // Symbol: drake::lcm::DrakeLcmLog
      struct /* DrakeLcmLog */ {
        // Source: drake/lcm/drake_lcm_log.h:27
        const char* doc =
R"""(A LCM interface for logging LCM messages to a file or playing back
from a existing log. Note the user is responsible for offsetting the
clock used to generate the log and the clock used for playback. For
example, if the log is generated by some external logger (the
lcm-logger binary), which uses the unix epoch time clock to record
message arrival time, the user needs to offset those timestamps
properly to match and the clock used for playback.)""";
        // Symbol: drake::lcm::DrakeLcmLog::DispatchMessageAndAdvanceLog
        struct /* DispatchMessageAndAdvanceLog */ {
          // Source: drake/lcm/drake_lcm_log.h:104
          const char* doc =
R"""(Let ``MSG`` be the next message event in the log, if ``current_time``
matches ``MSG`'s timestamp, for every DrakeLcmMessageHandlerInterface
`sub`` that's subscribed to ``MSG`'s channel, invoke `sub`'s
HandleMessage method. Then, this function advances the log by exactly
one message. This function does nothing if `MSG`` is null (end of log)
or ``current_time`` does not match `MSG`'s timestamp.

Raises:
    RuntimeError if this instance is not constructed in read-only
    mode.)""";
        } DispatchMessageAndAdvanceLog;
        // Symbol: drake::lcm::DrakeLcmLog::DrakeLcmLog
        struct /* ctor */ {
          // Source: drake/lcm/drake_lcm_log.h:46
          const char* doc =
R"""(Constructs a DrakeLcmLog.

Parameter ``file_name``:
    Log's file name for reading or writing.

Parameter ``is_write``:
    If false, this instance reads from the Lcm log identified by
    ``file_name``. If true, this instance writes to the Lcm log whose
    name is given by ``file_name``.

Parameter ``overwrite_publish_time_with_system_clock``:
    This parameter only affects the Publish method in write-only mode.
    If true, override the ``second`` parameter passed to Publish
    method, and use host system's clock to generate the timestamp for
    the logged message. This is used to mimic lcm-logger's behavior.
    It also implicitly records how fast the messages are generated in
    real time.

Raises:
    RuntimeError if unable to open file.)""";
        } ctor;
        // Symbol: drake::lcm::DrakeLcmLog::GetNextMessageTime
        struct /* GetNextMessageTime */ {
          // Source: drake/lcm/drake_lcm_log.h:91
          const char* doc =
R"""(Returns the time in seconds for the next logged message's occurrence
time or infinity if there are no more messages in the current log.

Raises:
    RuntimeError if this instance is not constructed in read-only
    mode.)""";
        } GetNextMessageTime;
        // Symbol: drake::lcm::DrakeLcmLog::HandleSubscriptions
        struct /* HandleSubscriptions */ {
          // Source: drake/lcm/drake_lcm_log.h:82
          const char* doc =
R"""(This is a no-op for Read mode, and an exception in Write mode.)""";
        } HandleSubscriptions;
        // Symbol: drake::lcm::DrakeLcmLog::Publish
        struct /* Publish */ {
          // Source: drake/lcm/drake_lcm_log.h:64
          const char* doc =
R"""(Writes an entry occurred at ``timestamp`` with content ``data`` to the
log file. The current implementation blocks until writing is done.

Parameter ``channel``:
    Channel name.

Parameter ``data``:
    Pointer to raw bytes.

Parameter ``data_size``:
    Number of bytes in ``data``.

Parameter ``time_sec``:
    Time in seconds when the message is published. Since messages are
    save to the log file in the order of Publish calls, this function
    should only be called with non-decreasing ``second``. Note that
    this parameter can be overwritten by the host system's clock if
    ``overwrite_publish_time_with_system_clock`` is true at
    construction time.

Raises:
    RuntimeError if this instance is not constructed in write-only
    mode.)""";
        } Publish;
        // Symbol: drake::lcm::DrakeLcmLog::Subscribe
        struct /* Subscribe */ {
          // Source: drake/lcm/drake_lcm_log.h:76
          const char* doc =
R"""(Subscribes ``handler`` to ``channel``. Multiple handlers can subscribe
to the same channel.

Raises:
    RuntimeError if this instance is not constructed in read-only
    mode.

Returns:
    nullptr because this implementation does not support unsubscribe.)""";
        } Subscribe;
        // Symbol: drake::lcm::DrakeLcmLog::is_write
        struct /* is_write */ {
          // Source: drake/lcm/drake_lcm_log.h:109
          const char* doc =
R"""(Returns true if this instance is constructed in write-only mode.)""";
        } is_write;
        // Symbol: drake::lcm::DrakeLcmLog::second_to_timestamp
        struct /* second_to_timestamp */ {
          // Source: drake/lcm/drake_lcm_log.h:123
          const char* doc =
R"""(Converts time (in seconds) relative to the starting time passed to the
constructor to a timestamp in microseconds.)""";
        } second_to_timestamp;
        // Symbol: drake::lcm::DrakeLcmLog::timestamp_to_second
        struct /* timestamp_to_second */ {
          // Source: drake/lcm/drake_lcm_log.h:115
          const char* doc =
R"""(Converts ``timestamp`` (in microseconds) to time (in seconds) relative
to the starting time passed to the constructor.)""";
        } timestamp_to_second;
      } DrakeLcmLog;
      // Symbol: drake::lcm::DrakeMockLcm
      struct /* DrakeMockLcm */ {
        // Source: drake/lcm/drake_mock_lcm.h:15
        const char* doc =
R"""(An implementation of DrakeLcmInterface that manipulates LCM messages
in memory, not on the wire. Other than the class name, it is identical
to a ``DrakeLcm("memq://")``, i.e., an object constructed with the <a
href="https://lcm-proj.github.io/group__LcmC__lcm__t.html#gaf29963ef43edadf45296d5ad82c18d4b">memq
provider</a>.)""";
        // Symbol: drake::lcm::DrakeMockLcm::DrakeMockLcm
        struct /* ctor */ {
          // Source: drake/lcm/drake_mock_lcm.h:17
          const char* doc = R"""()""";
        } ctor;
      } DrakeMockLcm;
      // Symbol: drake::lcm::DrakeSubscriptionInterface
      struct /* DrakeSubscriptionInterface */ {
        // Source: drake/lcm/drake_lcm_interface.h:141
        const char* doc =
R"""(A helper class returned by DrakeLcmInterface::Subscribe() that allows
for (possibly automatic) unsubscription and/or queue capacity control.
Refer to that method for additional details.

Instance of this object are always stored in ``std::shared_ptr`` to
manage them as resources. When a particular DrakeLcmInterface
implementation does not support subscription controls, the managed
pointer will be ``nullptr`` instead of an instance of this object.

To unsubscribe, induce a call to the DrakeSubscriptionInterface
destructor by bringing the ``std::shared_ptr`` use count to zero. That
usually means either a call to ``subscription.reset()`` or by allowing
it to go out of scope.

To *disable* unsubscription so that the pointer loss *never* causes
unsubscription, call
``subscription->set_unsubscribe_on_delete(false)``. To *enable*
unsubscription, set it to ``True``. Which choice is active by default
is specified by whatever method returns this object.)""";
        // Symbol: drake::lcm::DrakeSubscriptionInterface::DrakeSubscriptionInterface
        struct /* ctor */ {
          // Source: drake/lcm/drake_lcm_interface.h:143
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::lcm::DrakeSubscriptionInterface::set_queue_capacity
        struct /* set_queue_capacity */ {
          // Source: drake/lcm/drake_lcm_interface.h:161
          const char* doc =
R"""(Sets this subscription's queue depth to store messages inbetween calls
to DrakeLcmInterface::HandleSubscriptions. When the queue becomes
full, new received messages will be discarded. The default depth is 1.

Warning:
    The memq:// LCM URL does not support per-channel queues, so this
    method has no effect when memq is being used, e.g., in Drake unit
    tests.)""";
        } set_queue_capacity;
        // Symbol: drake::lcm::DrakeSubscriptionInterface::set_unsubscribe_on_delete
        struct /* set_unsubscribe_on_delete */ {
          // Source: drake/lcm/drake_lcm_interface.h:151
          const char* doc =
R"""(Sets whether or not the subscription on DrakeLcmInterface will be
terminated when this object is deleted. It is permitted to call this
method many times, with a new ``enabled`` value each time.)""";
        } set_unsubscribe_on_delete;
      } DrakeSubscriptionInterface;
      // Symbol: drake::lcm::EncodeLcmMessage
      struct /* EncodeLcmMessage */ {
        // Source: drake/lcm/lcm_messages.h:16
        const char* doc =
R"""(Encodes an LCM message to a series of bytes.)""";
      } EncodeLcmMessage;
      // Symbol: drake::lcm::LcmHandleSubscriptionsUntil
      struct /* LcmHandleSubscriptionsUntil */ {
        // Source: drake/lcm/drake_lcm_interface.h:304
        const char* doc =
R"""(Convenience function that repeatedly calls
``lcm->HandleSubscriptions()`` with a timeout value of
``timeout_millis``, until ``finished()`` returns true. Returns the
total number of messages handled.)""";
      } LcmHandleSubscriptionsUntil;
      // Symbol: drake::lcm::Publish
      struct /* Publish */ {
        // Source: drake/lcm/drake_lcm_interface.h:182
        const char* doc =
R"""(Publishes an LCM message on channel ``channel``.

Parameter ``lcm``:
    The LCM service on which to publish the message. Must not be null.

Parameter ``channel``:
    The channel on which to publish the message. Must not be the empty
    string.

Parameter ``message``:
    The message to publish.

Parameter ``time_sec``:
    Time in seconds when the publish event occurred. If unknown, use
    the default value of nullopt.)""";
      } Publish;
      // Symbol: drake::lcm::Subscribe
      struct /* Subscribe */ {
        // Source: drake/lcm/drake_lcm_interface.h:215
        const char* doc =
R"""(Subscribes to an LCM channel named ``channel`` and decodes messages of
type ``Message``. See also drake::lcm::Subscriber for a simple way to
passively observe received messages, without the need to write a
handler function.

Parameter ``lcm``:
    The LCM service on which to subscribe. Must not be null.

Parameter ``channel``:
    The channel on which to subscribe. Must not be the empty string.

Parameter ``handler``:
    The callback when a message is received and decoded without error.

Parameter ``on_error``:
    The callback when a message is received and cannot be decoded; if
    no error handler is given, an exception is thrown instead.

Returns:
    the object used to unsubscribe if that is supported, or else
    nullptr if unsubscribe is not supported. The unsubscribe-on-delete
    default is ``False``, so that ignoring this result leaves the
    subscription intact. Refer to the DrakeSubscriptionInterface class
    overview for details.

Note:
    Depending on the specific DrakeLcmInterface implementation, the
    handler might be invoked on a different thread than this function.)""";
      } Subscribe;
      // Symbol: drake::lcm::Subscriber
      struct /* Subscriber */ {
        // Source: drake/lcm/drake_lcm_interface.h:246
        const char* doc =
R"""(Subscribes to and stores a copy of the most recent message on a given
channel, for some ``Message`` type. All copies of a given Subscriber
share the same underlying data. This class does NOT provide any mutex
behavior for multi-threaded locking; it should only be used in cases
where the governing DrakeLcmInterface::HandleSubscriptions is called
from the same thread that owns all copies of this object.)""";
        // Symbol: drake::lcm::Subscriber::Subscriber<Message>
        struct /* ctor */ {
          // Source: drake/lcm/drake_lcm_interface.h:258
          const char* doc =
R"""(Subscribes to the (non-empty) ``channel`` on the given (non-null)
``lcm`` instance. The ``lcm`` pointer is only used during
construction; it is not retained by this object. When a undecodable
message is received, ``on_error`` handler is invoked; when
``on_error`` is not provided, an exception will be thrown instead.)""";
        } ctor;
        // Symbol: drake::lcm::Subscriber::clear
        struct /* clear */ {
          // Source: drake/lcm/drake_lcm_interface.h:282
          const char* doc =
R"""(Clears all data (sets the message and count to all zeros).)""";
        } clear;
        // Symbol: drake::lcm::Subscriber::count
        struct /* count */ {
          // Source: drake/lcm/drake_lcm_interface.h:278
          const char* doc =
R"""(Returns the total number of received messages.)""";
        } count;
        // Symbol: drake::lcm::Subscriber::message
        struct /* message */ {
          // Source: drake/lcm/drake_lcm_interface.h:274
          const char* doc =
R"""(Returns the most recently received message, or a value-initialized
(zeros) message otherwise.)""";
        } message;
      } Subscriber;
    } lcm;
    // Symbol: drake::log
    struct /* log */ {
      // Source: drake/common/text_logging.h:168
      const char* doc =
R"""(Retrieve an instance of a logger to use for logging; for example:


::

    drake::log()->info("potato!")

See the text_logging.h documentation for a short tutorial.)""";
    } log;
    // Symbol: drake::logging
    struct /* logging */ {
      // Symbol: drake::logging::Warn
      struct /* Warn */ {
        // Source: drake/common/text_logging.h:195
        const char* doc =
R"""(When constructed, logs a message (at "warn" severity); the destructor
is guaranteed to be trivial. This is useful for declaring an instance
of this class as a function-static global, so that a warning is logged
the first time the program encounters some code, but does not repeat
the warning on subsequent encounters within the same process.

For example:


::

    double* SanityCheck(double* data) {
      if (!data) {
        static const logging::Warn log_once("Bad data!");
        return alternative_data();
      }
      return data;
    })""";
        // Symbol: drake::logging::Warn::Warn
        struct /* Warn */ {
          // Source: drake/common/text_logging.h:197
          const char* doc = R"""()""";
        } Warn;
      } Warn;
      // Symbol: drake::logging::get_dist_sink
      struct /* get_dist_sink */ {
        // Source: drake/common/text_logging.h:177
        const char* doc =
R"""((Advanced) Retrieves the default sink for all Drake logs. When spdlog
is enabled, the return value can be cast to
spdlog::sinks::dist_sink_mt and thus allows consumers of Drake to
redirect Drake's text logs to locations other than the default of
stderr. When spdlog is disabled, the return value is an empty class.)""";
      } get_dist_sink;
      // Symbol: drake::logging::logger
      struct /* logger */ {
        // Source: drake/common/text_logging.h:101
        const char* doc =
R"""(The drake::logging::logger class provides text logging methods. See
the text_logging.h documentation for a short tutorial.)""";
      } logger;
      // Symbol: drake::logging::set_log_level
      struct /* set_log_level */ {
        // Source: drake/common/text_logging.h:208
        const char* doc =
R"""(Invokes ``drake::log()->set_level(level)``.

Parameter ``level``:
    Must be a string from spdlog enumerations: ``trace``, `debug`,
    ``info``, `warn`, ``err``, `critical`, ``off``, or ``unchanged``
    (not an enum, but useful for command-line).

Returns:
    The string value of the previous log level. If SPDLOG is disabled,
    then this returns an empty string.)""";
      } set_log_level;
    } logging;
    // Symbol: drake::manipulation
    struct /* manipulation */ {
      // Symbol: drake::manipulation::PiecewiseCartesianTrajectory
      struct /* PiecewiseCartesianTrajectory */ {
        // Source: drake/manipulation/util/trajectory_utils.h:123
        const char* doc_deprecated =
R"""(A wrapper class that represents a Cartesian trajectory, whose position
part is a PiecewiseCubicTrajectory, and the rotation part is a
PiecewiseQuaternionSlerp. / (Deprecated.)

Deprecated:
    Use PiecewisePoseTrajectory instead. This will be removed from
    Drake on or after 2021-05-01.)""";
        // Symbol: drake::manipulation::PiecewiseCartesianTrajectory::MakeCubicLinearWithEndLinearVelocity
        struct /* MakeCubicLinearWithEndLinearVelocity */ {
          // Source: drake/manipulation/util/trajectory_utils.h:139
          const char* doc =
R"""(Constructs a PiecewiseCartesianTrajectory from given ``time`` and
``poses``. A cubic polynomial with zero end velocities is used to
construct the position part. There must be at least two elements in
``times`` and ``poses``.

Parameter ``times``:
    Breaks used to build the splines.

Parameter ``poses``:
    Knots used to build the splines.

Parameter ``vel0``:
    Start linear velocity.

Parameter ``vel1``:
    End linear velocity.)""";
        } MakeCubicLinearWithEndLinearVelocity;
        // Symbol: drake::manipulation::PiecewiseCartesianTrajectory::PiecewiseCartesianTrajectory<T>
        struct /* ctor */ {
          // Source: drake/manipulation/util/trajectory_utils.h:161
          const char* doc =
R"""(Constructor.

Parameter ``pos_traj``:
    Position trajectory.

Parameter ``rot_traj``:
    Orientation trajectory.)""";
        } ctor;
        // Symbol: drake::manipulation::PiecewiseCartesianTrajectory::get_acceleration
        struct /* get_acceleration */ {
          // Source: drake/manipulation/util/trajectory_utils.h:212
          const char* doc =
R"""(Returns the interpolated acceleration at ``time`` or zero if ``time``
is before this trajectory's start time or after its end time.)""";
        } get_acceleration;
        // Symbol: drake::manipulation::PiecewiseCartesianTrajectory::get_orientation_trajectory
        struct /* get_orientation_trajectory */ {
          // Source: drake/manipulation/util/trajectory_utils.h:244
          const char* doc = R"""(Returns the orientation trajectory.)""";
        } get_orientation_trajectory;
        // Symbol: drake::manipulation::PiecewiseCartesianTrajectory::get_pose
        struct /* get_pose */ {
          // Source: drake/manipulation/util/trajectory_utils.h:184
          const char* doc =
R"""(Returns the interpolated pose at ``time``.)""";
        } get_pose;
        // Symbol: drake::manipulation::PiecewiseCartesianTrajectory::get_position_trajectory
        struct /* get_position_trajectory */ {
          // Source: drake/manipulation/util/trajectory_utils.h:237
          const char* doc = R"""(Returns the position trajectory.)""";
        } get_position_trajectory;
        // Symbol: drake::manipulation::PiecewiseCartesianTrajectory::get_velocity
        struct /* get_velocity */ {
          // Source: drake/manipulation/util/trajectory_utils.h:197
          const char* doc =
R"""(Returns the interpolated velocity at ``time`` or zero if ``time`` is
before this trajectory's start time or after its end time.)""";
        } get_velocity;
        // Symbol: drake::manipulation::PiecewiseCartesianTrajectory::is_approx
        struct /* is_approx */ {
          // Source: drake/manipulation/util/trajectory_utils.h:227
          const char* doc =
R"""(Returns true if the position and orientation trajectories are both
within ``tol`` from the other's.)""";
        } is_approx;
      } PiecewiseCartesianTrajectory;
      // Symbol: drake::manipulation::PiecewiseCubicTrajectory
      struct /* PiecewiseCubicTrajectory */ {
        // Source: drake/manipulation/util/trajectory_utils.h:24
        const char* doc_deprecated =
R"""(A wrapper class that stores a PiecewisePolynomial and its first and
second derivatives. This class is supposed to represent position,
velocity and acceleration. Thus, when the interpolating time is beyond
the time bounds, the interpolated velocity and acceleration will be
set to zero, and the interpolated position will peg at the terminal
values. All dimensions are assumed to be independent of each other. /
(Deprecated.)

Deprecated:
    Use PiecewisePolynomial instead. This will be removed from Drake
    on or after 2021-05-01.)""";
        // Symbol: drake::manipulation::PiecewiseCubicTrajectory::PiecewiseCubicTrajectory<T>
        struct /* ctor */ {
          // Source: drake/manipulation/util/trajectory_utils.h:35
          const char* doc =
R"""(Constructor.

Parameter ``position_traj``:
    PiecewisePolynomial that represents the position trajectory. Its
    first and second derivatives are computed and stored.)""";
        } ctor;
        // Symbol: drake::manipulation::PiecewiseCubicTrajectory::get_acceleration
        struct /* get_acceleration */ {
          // Source: drake/manipulation/util/trajectory_utils.h:61
          const char* doc =
R"""(Returns the interpolated acceleration at ``time`` or zero if ``time``
is out of the time bounds.)""";
        } get_acceleration;
        // Symbol: drake::manipulation::PiecewiseCubicTrajectory::get_acceleration_trajectory
        struct /* get_acceleration_trajectory */ {
          // Source: drake/manipulation/util/trajectory_utils.h:105
          const char* doc =
R"""(Returns the acceleration trajectory (second derivative).)""";
        } get_acceleration_trajectory;
        // Symbol: drake::manipulation::PiecewiseCubicTrajectory::get_end_time
        struct /* get_end_time */ {
          // Source: drake/manipulation/util/trajectory_utils.h:75
          const char* doc =
R"""(Returns the end time of this trajectory.)""";
        } get_end_time;
        // Symbol: drake::manipulation::PiecewiseCubicTrajectory::get_position
        struct /* get_position */ {
          // Source: drake/manipulation/util/trajectory_utils.h:45
          const char* doc =
R"""(Returns the interpolated position at ``time``.)""";
        } get_position;
        // Symbol: drake::manipulation::PiecewiseCubicTrajectory::get_position_trajectory
        struct /* get_position_trajectory */ {
          // Source: drake/manipulation/util/trajectory_utils.h:91
          const char* doc = R"""(Returns the position trajectory.)""";
        } get_position_trajectory;
        // Symbol: drake::manipulation::PiecewiseCubicTrajectory::get_start_time
        struct /* get_start_time */ {
          // Source: drake/manipulation/util/trajectory_utils.h:70
          const char* doc =
R"""(Returns the start time of this trajectory.)""";
        } get_start_time;
        // Symbol: drake::manipulation::PiecewiseCubicTrajectory::get_velocity
        struct /* get_velocity */ {
          // Source: drake/manipulation/util/trajectory_utils.h:51
          const char* doc =
R"""(Returns the interpolated velocity at ``time`` or zero if ``time`` is
out of the time bounds.)""";
        } get_velocity;
        // Symbol: drake::manipulation::PiecewiseCubicTrajectory::get_velocity_trajectory
        struct /* get_velocity_trajectory */ {
          // Source: drake/manipulation/util/trajectory_utils.h:98
          const char* doc =
R"""(Returns the velocity trajectory (first derivative).)""";
        } get_velocity_trajectory;
        // Symbol: drake::manipulation::PiecewiseCubicTrajectory::is_approx
        struct /* is_approx */ {
          // Source: drake/manipulation/util/trajectory_utils.h:81
          const char* doc =
R"""(Returns true if the position trajectory and its first and second
derivatives are all within ``tol`` to ``other``.)""";
        } is_approx;
      } PiecewiseCubicTrajectory;
      // Symbol: drake::manipulation::kinova_jaco
      struct /* kinova_jaco */ {
        // Symbol: drake::manipulation::kinova_jaco::JacoCommandReceiver
        struct /* JacoCommandReceiver */ {
          // Source: drake/manipulation/kinova_jaco/jaco_command_receiver.h:37
          const char* doc =
R"""(Handles lcmt_jaco_command message from a LcmSubscriberSystem.

Note that this system does not actually subscribe to an LCM channel.
To receive the message, the input of this system should be connected
to a LcmSubscriberSystem::Make<drake::lcmt_jaco_command>().

It has one input port, "lcmt_jaco_command".

This system has a single output port which contains the commanded
position and velocity for each joint. Finger velocities will be
translated from the values used by the Kinova SDK to values
appropriate for the finger joints in the Jaco description (see
jaco_constants.h).

.. pydrake_system::

    name: JacoCommandReceiver
    input_ports:
    - lcmt_jaco_command
    output_ports:
    - state)""";
          // Symbol: drake::manipulation::kinova_jaco::JacoCommandReceiver::JacoCommandReceiver
          struct /* ctor */ {
            // Source: drake/manipulation/kinova_jaco/jaco_command_receiver.h:39
            const char* doc = R"""()""";
          } ctor;
          // Symbol: drake::manipulation::kinova_jaco::JacoCommandReceiver::set_initial_position
          struct /* set_initial_position */ {
            // Source: drake/manipulation/kinova_jaco/jaco_command_receiver.h:49
            const char* doc =
R"""(Sets the initial commanded position of the controlled jaco prior to
any command messages being received. If this function is not called,
the starting position will be the zero configuration. Finger positions
should be specified as values appropriate for the Jaco description
(see jaco_constants.h), not in Kinova SDK values.)""";
          } set_initial_position;
        } JacoCommandReceiver;
        // Symbol: drake::manipulation::kinova_jaco::JacoCommandSender
        struct /* JacoCommandSender */ {
          // Source: drake/manipulation/kinova_jaco/jaco_command_sender.h:37
          const char* doc =
R"""(Creates and outputs lcmt_jaco_command messages.

Note that this system does not actually send the message to an LCM
channel. To send the message, the output of this system should be
connected to a
systems::lcm::LcmPublisherSystem::Make<lcmt_jaco_command>().

This system has one vector-valued input port containing the desired
position and velocity. Finger velocities will be translated to the
values used by the Kinova SDK from values appropriate for the finger
joints in the Jaco description (see jaco_constants.h).

This system has one abstract-valued output port of type
lcmt_jaco_command.

.. pydrake_system::

    name: JacoCommandSender
    input_ports:
    - state
    output_ports:
    - lcmt_jaco_command

See also:
    ``lcmt_jaco_command.lcm`` for additional documentation.)""";
          // Symbol: drake::manipulation::kinova_jaco::JacoCommandSender::JacoCommandSender
          struct /* ctor */ {
            // Source: drake/manipulation/kinova_jaco/jaco_command_sender.h:39
            const char* doc = R"""()""";
          } ctor;
        } JacoCommandSender;
        // Symbol: drake::manipulation::kinova_jaco::JacoStatusReceiver
        struct /* JacoStatusReceiver */ {
          // Source: drake/manipulation/kinova_jaco/jaco_status_receiver.h:42
          const char* doc =
R"""(@system name: JacoStatusReceiver input_ports: - lcmt_jaco_status
output_ports: - state - torque - torque_external - current @endsystem

See also:
    ``lcmt_jaco_status.lcm`` for additional documentation.)""";
          // Symbol: drake::manipulation::kinova_jaco::JacoStatusReceiver::JacoStatusReceiver
          struct /* ctor */ {
            // Source: drake/manipulation/kinova_jaco/jaco_status_receiver.h:44
            const char* doc = R"""()""";
          } ctor;
          // Symbol: drake::manipulation::kinova_jaco::JacoStatusReceiver::get_current_output_port
          struct /* get_current_output_port */ {
            // Source: drake/manipulation/kinova_jaco/jaco_status_receiver.h:54
            const char* doc = R"""()""";
          } get_current_output_port;
          // Symbol: drake::manipulation::kinova_jaco::JacoStatusReceiver::get_state_output_port
          struct /* get_state_output_port */ {
            // Source: drake/manipulation/kinova_jaco/jaco_status_receiver.h:51
            const char* doc = R"""()""";
          } get_state_output_port;
          // Symbol: drake::manipulation::kinova_jaco::JacoStatusReceiver::get_torque_external_output_port
          struct /* get_torque_external_output_port */ {
            // Source: drake/manipulation/kinova_jaco/jaco_status_receiver.h:53
            const char* doc = R"""()""";
          } get_torque_external_output_port;
          // Symbol: drake::manipulation::kinova_jaco::JacoStatusReceiver::get_torque_output_port
          struct /* get_torque_output_port */ {
            // Source: drake/manipulation/kinova_jaco/jaco_status_receiver.h:52
            const char* doc = R"""()""";
          } get_torque_output_port;
        } JacoStatusReceiver;
        // Symbol: drake::manipulation::kinova_jaco::JacoStatusSender
        struct /* JacoStatusSender */ {
          // Source: drake/manipulation/kinova_jaco/jaco_status_sender.h:43
          const char* doc =
R"""(Creates and outputs lcmt_jaco_status messages.

Note that this system does not actually send the message to an LCM
channel. To send the message, the output of this system should be
connected to a
systems::lcm::LcmPublisherSystem::Make<lcmt_jaco_status>().

This system has many vector-valued input ports. State input ports (q,
v) will have (num_joints + num_fingers) * 2 elements. Torque, torque
external and current input ports will have num_joints + num_fingers
elements. If the torque, torque_external, or current input ports are
not connected, the output message will use zeros. Finger velocities
will be translated to the values used by the Kinova SDK from values
appropriate for the finger joints in the Jaco description (see
jaco_constants.h).

This system has one abstract-valued output port of type
lcmt_jaco_status.

This system is presently only used in simulation. The robot hardware
drivers publish directly to LCM and do not make use of this system.

.. pydrake_system::

    name: JacoStatusSender
    input_ports:
    - state
    - torque (optional)
    - torque_external (optional)
    - current (optional)
    output_ports:
    - lcmt_jaco_status

See also:
    ``lcmt_jaco_status.lcm`` for additional documentation.)""";
          // Symbol: drake::manipulation::kinova_jaco::JacoStatusSender::JacoStatusSender
          struct /* ctor */ {
            // Source: drake/manipulation/kinova_jaco/jaco_status_sender.h:45
            const char* doc = R"""()""";
          } ctor;
          // Symbol: drake::manipulation::kinova_jaco::JacoStatusSender::get_current_input_port
          struct /* get_current_input_port */ {
            // Source: drake/manipulation/kinova_jaco/jaco_status_sender.h:55
            const char* doc = R"""()""";
          } get_current_input_port;
          // Symbol: drake::manipulation::kinova_jaco::JacoStatusSender::get_state_input_port
          struct /* get_state_input_port */ {
            // Source: drake/manipulation/kinova_jaco/jaco_status_sender.h:52
            const char* doc = R"""()""";
          } get_state_input_port;
          // Symbol: drake::manipulation::kinova_jaco::JacoStatusSender::get_torque_external_input_port
          struct /* get_torque_external_input_port */ {
            // Source: drake/manipulation/kinova_jaco/jaco_status_sender.h:54
            const char* doc = R"""()""";
          } get_torque_external_input_port;
          // Symbol: drake::manipulation::kinova_jaco::JacoStatusSender::get_torque_input_port
          struct /* get_torque_input_port */ {
            // Source: drake/manipulation/kinova_jaco/jaco_status_sender.h:53
            const char* doc = R"""()""";
          } get_torque_input_port;
        } JacoStatusSender;
      } kinova_jaco;
      // Symbol: drake::manipulation::kuka_iiwa
      struct /* kuka_iiwa */ {
        // Symbol: drake::manipulation::kuka_iiwa::IiwaCommandReceiver
        struct /* IiwaCommandReceiver */ {
          // Source: drake/manipulation/kuka_iiwa/iiwa_command_receiver.h:49
          const char* doc =
R"""(Handles lcmt_iiwa_command message from a LcmSubscriberSystem.

Note that this system does not actually subscribe to an LCM channel.
To receive the message, the input of this system should be connected
to a LcmSubscriberSystem::Make<drake::lcmt_iiwa_command>().

It has one required input port, "lcmt_iiwa_command".

It has two output ports: one for the commanded position for each
joint, and one for commanded additional feedforward joint torque.

.. pydrake_system::

    name: IiwaCommandReceiver
    input_ports:
    - lcmt_iiwa_command
    - position_measured (optional)
    output_ports:
    - position
    - torque

@par Output prior to receiving a valid lcmt_iiwa_command message: The
"position" output initially feeds through from the "position_measured"
input port -- or if not connected, outputs zero. When discrete update
events are enabled (e.g., during a simulation), the system latches the
"position_measured" input into state during the first event, and the
"position" output comes from the latched state, no longer fed through
from the "position" input. Alternatively, the LatchInitialPosition()
method is available to achieve the same effect without using events.
@par The "torque" output will always be a vector of zeros.)""";
          // Symbol: drake::manipulation::kuka_iiwa::IiwaCommandReceiver::IiwaCommandReceiver
          struct /* ctor */ {
            // Source: drake/manipulation/kuka_iiwa/iiwa_command_receiver.h:51
            const char* doc = R"""()""";
          } ctor;
          // Symbol: drake::manipulation::kuka_iiwa::IiwaCommandReceiver::LatchInitialPosition
          struct /* LatchInitialPosition */ {
            // Source: drake/manipulation/kuka_iiwa/iiwa_command_receiver.h:61
            const char* doc =
R"""((Advanced.) Copies the current "position_measured" input (or zero if
not connected) into Context state, and changes the behavior of the
"position" output to produce the latched state if no message has been
received yet. The latching already happens automatically during the
first discrete update event (e.g., when using a Simulator); this
method exists for use when not already using a Simulator or other
special cases.)""";
          } LatchInitialPosition;
          // Symbol: drake::manipulation::kuka_iiwa::IiwaCommandReceiver::get_commanded_position_output_port
          struct /* get_commanded_position_output_port */ {
            // Source: drake/manipulation/kuka_iiwa/iiwa_command_receiver.h:71
            const char* doc = R"""()""";
          } get_commanded_position_output_port;
          // Symbol: drake::manipulation::kuka_iiwa::IiwaCommandReceiver::get_commanded_torque_output_port
          struct /* get_commanded_torque_output_port */ {
            // Source: drake/manipulation/kuka_iiwa/iiwa_command_receiver.h:75
            const char* doc = R"""()""";
          } get_commanded_torque_output_port;
          // Symbol: drake::manipulation::kuka_iiwa::IiwaCommandReceiver::get_message_input_port
          struct /* get_message_input_port */ {
            // Source: drake/manipulation/kuka_iiwa/iiwa_command_receiver.h:65
            const char* doc = R"""()""";
          } get_message_input_port;
          // Symbol: drake::manipulation::kuka_iiwa::IiwaCommandReceiver::get_position_measured_input_port
          struct /* get_position_measured_input_port */ {
            // Source: drake/manipulation/kuka_iiwa/iiwa_command_receiver.h:68
            const char* doc = R"""()""";
          } get_position_measured_input_port;
        } IiwaCommandReceiver;
        // Symbol: drake::manipulation::kuka_iiwa::IiwaCommandSender
        struct /* IiwaCommandSender */ {
          // Source: drake/manipulation/kuka_iiwa/iiwa_command_sender.h:36
          const char* doc =
R"""(Creates and outputs lcmt_iiwa_command messages.

Note that this system does not actually send the message an LCM
channel. To send the message, the output of this system should be
connected to a
systems::lcm::LcmPublisherSystem::Make<lcmt_iiwa_command>().

This system has two vector-valued input ports, one for the commanded
position (which must be connected) and one for commanded torque (which
is optional). If the torque input port is not connected, then no
torque values will be emitted in the resulting message.

This system has one abstract-valued output port of type
lcmt_iiwa_command.

.. pydrake_system::

    name: IiwaCommandSender
    input_ports:
    - position
    - torque (optional)
    output_ports:
    - lcmt_iiwa_command

See also:
    ``lcmt_iiwa_command.lcm`` for additional documentation.)""";
          // Symbol: drake::manipulation::kuka_iiwa::IiwaCommandSender::IiwaCommandSender
          struct /* ctor */ {
            // Source: drake/manipulation/kuka_iiwa/iiwa_command_sender.h:38
            const char* doc = R"""()""";
          } ctor;
          // Symbol: drake::manipulation::kuka_iiwa::IiwaCommandSender::get_position_input_port
          struct /* get_position_input_port */ {
            // Source: drake/manipulation/kuka_iiwa/iiwa_command_sender.h:44
            const char* doc = R"""()""";
          } get_position_input_port;
          // Symbol: drake::manipulation::kuka_iiwa::IiwaCommandSender::get_torque_input_port
          struct /* get_torque_input_port */ {
            // Source: drake/manipulation/kuka_iiwa/iiwa_command_sender.h:45
            const char* doc = R"""()""";
          } get_torque_input_port;
        } IiwaCommandSender;
        // Symbol: drake::manipulation::kuka_iiwa::IiwaStatusReceiver
        struct /* IiwaStatusReceiver */ {
          // Source: drake/manipulation/kuka_iiwa/iiwa_status_receiver.h:41
          const char* doc =
R"""(@system name: IiwaStatusReceiver input_ports: - lcmt_iiwa_status
output_ports: - position_commanded - position_measured -
velocity_estimated - torque_commanded - torque_measured -
torque_external @endsystem

See also:
    ``lcmt_iiwa_status.lcm`` for additional documentation.)""";
          // Symbol: drake::manipulation::kuka_iiwa::IiwaStatusReceiver::IiwaStatusReceiver
          struct /* ctor */ {
            // Source: drake/manipulation/kuka_iiwa/iiwa_status_receiver.h:43
            const char* doc = R"""()""";
          } ctor;
          // Symbol: drake::manipulation::kuka_iiwa::IiwaStatusReceiver::get_position_commanded_output_port
          struct /* get_position_commanded_output_port */ {
            // Source: drake/manipulation/kuka_iiwa/iiwa_status_receiver.h:49
            const char* doc = R"""()""";
          } get_position_commanded_output_port;
          // Symbol: drake::manipulation::kuka_iiwa::IiwaStatusReceiver::get_position_measured_output_port
          struct /* get_position_measured_output_port */ {
            // Source: drake/manipulation/kuka_iiwa/iiwa_status_receiver.h:50
            const char* doc = R"""()""";
          } get_position_measured_output_port;
          // Symbol: drake::manipulation::kuka_iiwa::IiwaStatusReceiver::get_torque_commanded_output_port
          struct /* get_torque_commanded_output_port */ {
            // Source: drake/manipulation/kuka_iiwa/iiwa_status_receiver.h:52
            const char* doc = R"""()""";
          } get_torque_commanded_output_port;
          // Symbol: drake::manipulation::kuka_iiwa::IiwaStatusReceiver::get_torque_external_output_port
          struct /* get_torque_external_output_port */ {
            // Source: drake/manipulation/kuka_iiwa/iiwa_status_receiver.h:54
            const char* doc = R"""()""";
          } get_torque_external_output_port;
          // Symbol: drake::manipulation::kuka_iiwa::IiwaStatusReceiver::get_torque_measured_output_port
          struct /* get_torque_measured_output_port */ {
            // Source: drake/manipulation/kuka_iiwa/iiwa_status_receiver.h:53
            const char* doc = R"""()""";
          } get_torque_measured_output_port;
          // Symbol: drake::manipulation::kuka_iiwa::IiwaStatusReceiver::get_velocity_estimated_output_port
          struct /* get_velocity_estimated_output_port */ {
            // Source: drake/manipulation/kuka_iiwa/iiwa_status_receiver.h:51
            const char* doc = R"""()""";
          } get_velocity_estimated_output_port;
        } IiwaStatusReceiver;
        // Symbol: drake::manipulation::kuka_iiwa::IiwaStatusSender
        struct /* IiwaStatusSender */ {
          // Source: drake/manipulation/kuka_iiwa/iiwa_status_sender.h:53
          const char* doc =
R"""(Creates and outputs lcmt_iiwa_status messages.

Note that this system does not actually send the message an LCM
channel. To send the message, the output of this system should be
connected to a
systems::lcm::LcmPublisherSystem::Make<lcmt_iiwa_status>().

This system has many vector-valued input ports, each of which has
exactly num_joints elements.

- ``position_commanded``: the most recently received position command.
- ``position_measured``: the plant's current position.
- ``velocity_estimated`` (optional): the plant's current velocity (this
    should be a low-pass filter of the position's derivative; see detailed
    comments in ``lcmt_iiwa_status.lcm``); when absent, the output message
    will use zeros.
- ``torque_commanded``: the most recently received joint torque command.
- ``torque_measured`` (optional): the plant's measured joint torque; when
    absent, the output message will duplicate torque_commanded.
- ``torque_external`` (optional): the plant's external joint torque; when
    absent, the output message will use zeros.

This system has one abstract-valued output port of type
lcmt_iiwa_status.

This system is presently only used in simulation. The robot hardware
drivers publish directly to LCM and do not make use of this system.

.. pydrake_system::

    name: IiwaStatusSender
    input_ports:
    - position_commanded
    - position_measured
    - velocity_estimated (optional)
    - torque_commanded
    - torque_measured (optional)
    - torque_external (optional)
    output_ports:
    - lcmt_iiwa_status

See also:
    ``lcmt_iiwa_status.lcm`` for additional documentation.)""";
          // Symbol: drake::manipulation::kuka_iiwa::IiwaStatusSender::IiwaStatusSender
          struct /* ctor */ {
            // Source: drake/manipulation/kuka_iiwa/iiwa_status_sender.h:55
            const char* doc = R"""()""";
          } ctor;
          // Symbol: drake::manipulation::kuka_iiwa::IiwaStatusSender::get_position_commanded_input_port
          struct /* get_position_commanded_input_port */ {
            // Source: drake/manipulation/kuka_iiwa/iiwa_status_sender.h:61
            const char* doc = R"""()""";
          } get_position_commanded_input_port;
          // Symbol: drake::manipulation::kuka_iiwa::IiwaStatusSender::get_position_measured_input_port
          struct /* get_position_measured_input_port */ {
            // Source: drake/manipulation/kuka_iiwa/iiwa_status_sender.h:62
            const char* doc = R"""()""";
          } get_position_measured_input_port;
          // Symbol: drake::manipulation::kuka_iiwa::IiwaStatusSender::get_torque_commanded_input_port
          struct /* get_torque_commanded_input_port */ {
            // Source: drake/manipulation/kuka_iiwa/iiwa_status_sender.h:64
            const char* doc = R"""()""";
          } get_torque_commanded_input_port;
          // Symbol: drake::manipulation::kuka_iiwa::IiwaStatusSender::get_torque_external_input_port
          struct /* get_torque_external_input_port */ {
            // Source: drake/manipulation/kuka_iiwa/iiwa_status_sender.h:66
            const char* doc = R"""()""";
          } get_torque_external_input_port;
          // Symbol: drake::manipulation::kuka_iiwa::IiwaStatusSender::get_torque_measured_input_port
          struct /* get_torque_measured_input_port */ {
            // Source: drake/manipulation/kuka_iiwa/iiwa_status_sender.h:65
            const char* doc = R"""()""";
          } get_torque_measured_input_port;
          // Symbol: drake::manipulation::kuka_iiwa::IiwaStatusSender::get_velocity_estimated_input_port
          struct /* get_velocity_estimated_input_port */ {
            // Source: drake/manipulation/kuka_iiwa/iiwa_status_sender.h:63
            const char* doc = R"""()""";
          } get_velocity_estimated_input_port;
        } IiwaStatusSender;
        // Symbol: drake::manipulation::kuka_iiwa::get_iiwa_max_joint_velocities
        struct /* get_iiwa_max_joint_velocities */ {
          // Source: drake/manipulation/kuka_iiwa/iiwa_constants.h:13
          const char* doc =
R"""(Returns the maximum joint velocities provided by Kuka.

Returns:
    Maximum joint velocities (rad/s).)""";
        } get_iiwa_max_joint_velocities;
      } kuka_iiwa;
      // Symbol: drake::manipulation::perception
      struct /* perception */ {
        // Symbol: drake::manipulation::perception::ExtractOptitrackPose
        struct /* ExtractOptitrackPose */ {
          // Source: drake/manipulation/perception/optitrack_pose_extractor.h:23
          const char* doc =
R"""(Gets the pose of an Optitrack rigid body.

Returns:
    X_OB, the pose of the body ``B`` in the optitrack frame ``O``.)""";
        } ExtractOptitrackPose;
        // Symbol: drake::manipulation::perception::ExtractOptitrackPoses
        struct /* ExtractOptitrackPoses */ {
          // Source: drake/manipulation/perception/optitrack_pose_extractor.h:30
          const char* doc =
R"""(Extracts poses of all objects from an Optitrack message.

Returns:
    Mapping from object ID to pose.)""";
        } ExtractOptitrackPoses;
        // Symbol: drake::manipulation::perception::FindOptitrackBody
        struct /* FindOptitrackBody */ {
          // Source: drake/manipulation/perception/optitrack_pose_extractor.h:39
          const char* doc =
R"""(Gets a rigid body from an optitrack frame message given an object ID.

Parameter ``message``:
    Optitrack message.

Parameter ``object_id``:
    ID to be searched for in the frame message.

Returns:
    Rigid body object, or ``nullopt`` if not found.)""";
        } FindOptitrackBody;
        // Symbol: drake::manipulation::perception::FindOptitrackObjectId
        struct /* FindOptitrackObjectId */ {
          // Source: drake/manipulation/perception/optitrack_pose_extractor.h:47
          const char* doc =
R"""(Gets the object ID from an Optitrack description message.

Parameter ``message``:
    Description message.

Returns:
    Object ID if found, or ``nullopt`` if not found.)""";
        } FindOptitrackObjectId;
        // Symbol: drake::manipulation::perception::OptitrackPoseExtractor
        struct /* OptitrackPoseExtractor */ {
          // Source: drake/manipulation/perception/optitrack_pose_extractor.h:58
          const char* doc =
R"""(Extracts and provides an output of the pose of a desired object as an
Eigen::Isometry3d from an Optitrack LCM OPTITRACK_FRAME_T message, the
pose transformed to a desired coordinate frame.)""";
          // Symbol: drake::manipulation::perception::OptitrackPoseExtractor::OptitrackPoseExtractor
          struct /* ctor */ {
            // Source: drake/manipulation/perception/optitrack_pose_extractor.h:71
            const char* doc =
R"""(Constructs the OptitrackPoseExtractor.

Parameter ``object_id``:
    An ID of the object being tracked. This ID must correspond to the
    those present within the OPTITRACK_FRAME_T message or else a
    runtime exception is thrown.

Parameter ``X_WO``:
    The pose of the optitrack frame O in the World frame W.

Parameter ``optitrack_lcm_status_period``:
    The discrete update period of the OptitrackPoseExtractor. It
    should be set based on the period of incoming optitrack messages.)""";
          } ctor;
          // Symbol: drake::manipulation::perception::OptitrackPoseExtractor::get_measured_pose_output_port
          struct /* get_measured_pose_output_port */ {
            // Source: drake/manipulation/perception/optitrack_pose_extractor.h:74
            const char* doc = R"""()""";
          } get_measured_pose_output_port;
        } OptitrackPoseExtractor;
        // Symbol: drake::manipulation::perception::PoseSmoother
        struct /* PoseSmoother */ {
          // Source: drake/manipulation/perception/pose_smoother.h:35
          const char* doc =
R"""(This class accepts the pose of a rigid body (composed by a
Eigen::Isometry3d) and returns a smoothed pose by performing either
the first or both of these processes : i. Rejecting outliers on the
basis of user-defined linear/angular velocity thresholds on
consecutive pose data values. ii. Moving average smoothing of the
resulting data within a specified window size. Note on quaternion
averaging : While a "correct" quaternion averaging algorithm requires
averaging the corresponding attitudes, this class implements a
simplification based on the version described in
http://wiki.unity3d.com/index.php/Averaging_Quaternions_and_Vectors
and in the introduction of Markley et al. References: L. Markley, Y.
Cheng, J. L. Crassidis, and Y. Oshman, "Quaternion Averaging", NASA
Technical note, available to download at
https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/20070017872.pdf)""";
          // Symbol: drake::manipulation::perception::PoseSmoother::PoseSmoother
          struct /* ctor */ {
            // Source: drake/manipulation/perception/pose_smoother.h:52
            const char* doc =
R"""(Constructs the pose smoother with or without averaging - i.e. performs
outlier rejection and smoothing of the input pose. Smoothing is
disabled for a window size lesser than 1.

Parameter ``desired_max_linear_velocity``:
    Upper threshold on linear velocity (m/sec).

Parameter ``desired_max_angular_velocity``:
    Upper threshold on angular velocity (rad/sec).

Parameter ``period_sec``:
    The period for the internal update (sec). This must be set to a
    value greater than 0.

Parameter ``filter_window_size``:
    Window size for the moving average smoothing. Must be set to a
    value greater than 1 to enable averaging (smoothing).)""";
          } ctor;
          // Symbol: drake::manipulation::perception::PoseSmoother::get_smoothed_pose_output_port
          struct /* get_smoothed_pose_output_port */ {
            // Source: drake/manipulation/perception/pose_smoother.h:56
            const char* doc = R"""()""";
          } get_smoothed_pose_output_port;
          // Symbol: drake::manipulation::perception::PoseSmoother::get_smoothed_velocity_output_port
          struct /* get_smoothed_velocity_output_port */ {
            // Source: drake/manipulation/perception/pose_smoother.h:60
            const char* doc = R"""()""";
          } get_smoothed_velocity_output_port;
        } PoseSmoother;
      } perception;
      // Symbol: drake::manipulation::planner
      struct /* planner */ {
        // Symbol: drake::manipulation::planner::ComputePoseDiffInCommonFrame
        struct /* ComputePoseDiffInCommonFrame */ {
          // Source: drake/manipulation/planner/differential_inverse_kinematics.h:46
          const char* doc =
R"""(Computes the pose "difference" between ``pose1`` and ``pose0`` s.t.
the linear part equals p_C1 - p_C0, and the angular part equals R_C1 *
R_C0.inv(), where p and R stand for the position and rotation parts,
and C is the common frame.)""";
        } ComputePoseDiffInCommonFrame;
        // Symbol: drake::manipulation::planner::ConstraintRelaxingIk
        struct /* ConstraintRelaxingIk */ {
          // Source: drake/manipulation/planner/constraint_relaxing_ik.h:20
          const char* doc =
R"""(A wrapper class around the IK planner. This class improves IK's
usability by handling constraint relaxing and multiple initial guesses
internally.)""";
          // Symbol: drake::manipulation::planner::ConstraintRelaxingIk::ConstraintRelaxingIk
          struct /* ctor */ {
            // Source: drake/manipulation/planner/constraint_relaxing_ik.h:46
            const char* doc =
R"""(Constructor. Instantiates an internal MultibodyPlant from
``model_path``.

Parameter ``model_path``:
    Path to the model file.

Parameter ``end_effector_link_name``:
    Link name of the end effector.)""";
          } ctor;
          // Symbol: drake::manipulation::planner::ConstraintRelaxingIk::IkCartesianWaypoint
          struct /* IkCartesianWaypoint */ {
            // Source: drake/manipulation/planner/constraint_relaxing_ik.h:27
            const char* doc =
R"""(Cartesian waypoint. Input to the IK solver.)""";
            // Symbol: drake::manipulation::planner::ConstraintRelaxingIk::IkCartesianWaypoint::constrain_orientation
            struct /* constrain_orientation */ {
              // Source: drake/manipulation/planner/constraint_relaxing_ik.h:36
              const char* doc =
R"""(Signals if orientation constraint is enabled.)""";
            } constrain_orientation;
            // Symbol: drake::manipulation::planner::ConstraintRelaxingIk::IkCartesianWaypoint::eigen_aligned_operator_new_marker_type
            struct /* eigen_aligned_operator_new_marker_type */ {
              // Source: drake/manipulation/planner/constraint_relaxing_ik.h:38
              const char* doc = R"""()""";
            } eigen_aligned_operator_new_marker_type;
            // Symbol: drake::manipulation::planner::ConstraintRelaxingIk::IkCartesianWaypoint::pos_tol
            struct /* pos_tol */ {
              // Source: drake/manipulation/planner/constraint_relaxing_ik.h:31
              const char* doc =
R"""(Bounding box for the end effector in the world frame.)""";
            } pos_tol;
            // Symbol: drake::manipulation::planner::ConstraintRelaxingIk::IkCartesianWaypoint::pose
            struct /* pose */ {
              // Source: drake/manipulation/planner/constraint_relaxing_ik.h:29
              const char* doc =
R"""(Desired end effector pose in the world frame.)""";
            } pose;
            // Symbol: drake::manipulation::planner::ConstraintRelaxingIk::IkCartesianWaypoint::rot_tol
            struct /* rot_tol */ {
              // Source: drake/manipulation/planner/constraint_relaxing_ik.h:34
              const char* doc =
R"""(Max angle difference (in radians) between solved end effector's
orientation and the desired.)""";
            } rot_tol;
          } IkCartesianWaypoint;
          // Symbol: drake::manipulation::planner::ConstraintRelaxingIk::PlanSequentialTrajectory
          struct /* PlanSequentialTrajectory */ {
            // Source: drake/manipulation/planner/constraint_relaxing_ik.h:71
            const char* doc =
R"""(Generates IK solutions for each waypoint sequentially. For waypoint
wp_i, the IK tries to solve q_i that satisfies the end effector
constraints in wp_i and minimizes the squared difference to q_{i-1},
where q_{i-1} is the solution to the previous wp_{i-1}. q_{i-1} =
``q_current`` when i = 0. This function internally does constraint
relaxing and initial condition guessing if necessary.

Note that ``q_current`` is inserted at the beginning of ``q_sol``.

Parameter ``waypoints``:
    A sequence of desired waypoints.

Parameter ``q_current``:
    The initial generalized position.

Parameter ``q_sol``:
    Results.

Returns:
    True if solved successfully.)""";
          } PlanSequentialTrajectory;
          // Symbol: drake::manipulation::planner::ConstraintRelaxingIk::SetEndEffector
          struct /* SetEndEffector */ {
            // Source: drake/manipulation/planner/constraint_relaxing_ik.h:52
            const char* doc = R"""(Sets end effector to ``link_name``.)""";
          } SetEndEffector;
        } ConstraintRelaxingIk;
        // Symbol: drake::manipulation::planner::DifferentialInverseKinematicsIntegrator
        struct /* DifferentialInverseKinematicsIntegrator */ {
          // Source: drake/manipulation/planner/differential_inverse_kinematics_integrator.h:35
          const char* doc =
R"""(A LeafSystem which uses DoDifferentialInverseKinematics to produce
joint position commands.

Rather than calling DoDifferentialInverseKinematics on the current
measured positions of the robot, this System maintains its own
internal state and integrates successive velocity commands open loop.
Using measured joint positions in a feedback loop can lead to undamped
oscillations in the redundant joints; we hope to resolve this and are
tracking it in #9773.

Note: It is highly recommended that the user calls ``SetPosition()``
once to initialize the position commands to match the initial
positions of the robot.

.. pydrake_system::

    name: DifferentialInverseKinematicsIntegrator
    input_ports:
    - X_WE_desired
    output_ports:
    - joint_positions)""";
          // Symbol: drake::manipulation::planner::DifferentialInverseKinematicsIntegrator::DifferentialInverseKinematicsIntegrator
          struct /* ctor */ {
            // Source: drake/manipulation/planner/differential_inverse_kinematics_integrator.h:60
            const char* doc =
R"""(Constructs the system.

Parameter ``robot``:
    A MultibodyPlant describing the robot.

Parameter ``frame_E``:
    End-effector frame.

Parameter ``time_step``:
    the discrete time step of the (Euler) integration.

Parameter ``parameters``:
    Collection of various problem specific constraints and constants.
    The ``timestep`` parameter will be set to ``time_step``.

Parameter ``robot_context``:
    Optional Context of the MultibodyPlant. The position values of
    this context will be overwritten during integration; you only need
    to pass this in if the robot has any non-default parameters.
    $*Default:* ``robot.CreateDefaultContext()``.

Parameter ``log_only_when_result_state_changes``:
    is a boolean that determines whether the system will log on every
    differential IK failure, or only when the failure state changes.
    When the value is ``True``, it will cause the system to have an
    additional discrete state variable to store the most recent
    DifferentialInverseKinematicsStatus. Set this to ``False`` if you
    want IsDifferenceEquationSystem() to return ``True``.

Note: All references must remain valid for the lifetime of this
system.)""";
          } ctor;
          // Symbol: drake::manipulation::planner::DifferentialInverseKinematicsIntegrator::ForwardKinematics
          struct /* ForwardKinematics */ {
            // Source: drake/manipulation/planner/differential_inverse_kinematics_integrator.h:75
            const char* doc =
R"""(Provides X_WE as a function of the joint position set in ``context``.)""";
          } ForwardKinematics;
          // Symbol: drake::manipulation::planner::DifferentialInverseKinematicsIntegrator::SetPositions
          struct /* SetPositions */ {
            // Source: drake/manipulation/planner/differential_inverse_kinematics_integrator.h:71
            const char* doc =
R"""(Sets the joint positions, which are stored as state in the context. It
is recommended that the user calls this method to initialize the
position commands to match the initial positions of the robot.)""";
          } SetPositions;
          // Symbol: drake::manipulation::planner::DifferentialInverseKinematicsIntegrator::get_mutable_parameters
          struct /* get_mutable_parameters */ {
            // Source: drake/manipulation/planner/differential_inverse_kinematics_integrator.h:84
            const char* doc =
R"""(Returns a mutable reference to the differential IK parameters owned by
this system.)""";
          } get_mutable_parameters;
          // Symbol: drake::manipulation::planner::DifferentialInverseKinematicsIntegrator::get_parameters
          struct /* get_parameters */ {
            // Source: drake/manipulation/planner/differential_inverse_kinematics_integrator.h:80
            const char* doc =
R"""(Returns a const reference to the differential IK parameters owned by
this system.)""";
          } get_parameters;
        } DifferentialInverseKinematicsIntegrator;
        // Symbol: drake::manipulation::planner::DifferentialInverseKinematicsParameters
        struct /* DifferentialInverseKinematicsParameters */ {
          // Source: drake/manipulation/planner/differential_inverse_kinematics.h:52
          const char* doc =
R"""(Contains parameters for differential inverse kinematics.)""";
          // Symbol: drake::manipulation::planner::DifferentialInverseKinematicsParameters::AddLinearVelocityConstraint
          struct /* AddLinearVelocityConstraint */ {
            // Source: drake/manipulation/planner/differential_inverse_kinematics.h:207
            const char* doc =
R"""(Adds a linear velocity constraint.

Parameter ``linear_velocity_constraint``:
    A linear constraint on joint velocities.

Raises:
    ValueError if ``constraint->num_vars !=
    this->get_num_velocities()``.)""";
          } AddLinearVelocityConstraint;
          // Symbol: drake::manipulation::planner::DifferentialInverseKinematicsParameters::ClearLinearVelocityConstraints
          struct /* ClearLinearVelocityConstraints */ {
            // Source: drake/manipulation/planner/differential_inverse_kinematics.h:213
            const char* doc = R"""(Clears all linear velocity constraints.)""";
          } ClearLinearVelocityConstraints;
          // Symbol: drake::manipulation::planner::DifferentialInverseKinematicsParameters::DifferentialInverseKinematicsParameters
          struct /* ctor */ {
            // Source: drake/manipulation/planner/differential_inverse_kinematics.h:64
            const char* doc =
R"""(Constructor. Initializes the nominal joint position to zeros of size
``num_positions``. Timestep is initialized to 1. The end effector
gains are initialized to ones. All constraints are initialized to
nullopt.

Parameter ``num_positions``:
    Number of generalized positions.

Parameter ``num_velocities``:
    Number of generalized velocities.)""";
          } ctor;
          // Symbol: drake::manipulation::planner::DifferentialInverseKinematicsParameters::get_end_effector_velocity_gain
          struct /* get_end_effector_velocity_gain */ {
            // Source: drake/manipulation/planner/differential_inverse_kinematics.h:78
            const char* doc = R"""()""";
          } get_end_effector_velocity_gain;
          // Symbol: drake::manipulation::planner::DifferentialInverseKinematicsParameters::get_joint_acceleration_limits
          struct /* get_joint_acceleration_limits */ {
            // Source: drake/manipulation/planner/differential_inverse_kinematics.h:98
            const char* doc = R"""()""";
          } get_joint_acceleration_limits;
          // Symbol: drake::manipulation::planner::DifferentialInverseKinematicsParameters::get_joint_position_limits
          struct /* get_joint_position_limits */ {
            // Source: drake/manipulation/planner/differential_inverse_kinematics.h:88
            const char* doc = R"""()""";
          } get_joint_position_limits;
          // Symbol: drake::manipulation::planner::DifferentialInverseKinematicsParameters::get_joint_velocity_limits
          struct /* get_joint_velocity_limits */ {
            // Source: drake/manipulation/planner/differential_inverse_kinematics.h:93
            const char* doc = R"""()""";
          } get_joint_velocity_limits;
          // Symbol: drake::manipulation::planner::DifferentialInverseKinematicsParameters::get_linear_velocity_constraints
          struct /* get_linear_velocity_constraints */ {
            // Source: drake/manipulation/planner/differential_inverse_kinematics.h:103
            const char* doc = R"""()""";
          } get_linear_velocity_constraints;
          // Symbol: drake::manipulation::planner::DifferentialInverseKinematicsParameters::get_nominal_joint_position
          struct /* get_nominal_joint_position */ {
            // Source: drake/manipulation/planner/differential_inverse_kinematics.h:74
            const char* doc = R"""()""";
          } get_nominal_joint_position;
          // Symbol: drake::manipulation::planner::DifferentialInverseKinematicsParameters::get_num_positions
          struct /* get_num_positions */ {
            // Source: drake/manipulation/planner/differential_inverse_kinematics.h:70
            const char* doc = R"""()""";
          } get_num_positions;
          // Symbol: drake::manipulation::planner::DifferentialInverseKinematicsParameters::get_num_velocities
          struct /* get_num_velocities */ {
            // Source: drake/manipulation/planner/differential_inverse_kinematics.h:72
            const char* doc = R"""()""";
          } get_num_velocities;
          // Symbol: drake::manipulation::planner::DifferentialInverseKinematicsParameters::get_timestep
          struct /* get_timestep */ {
            // Source: drake/manipulation/planner/differential_inverse_kinematics.h:68
            const char* doc = R"""(@name Getters.)""";
          } get_timestep;
          // Symbol: drake::manipulation::planner::DifferentialInverseKinematicsParameters::get_unconstrained_degrees_of_freedom_velocity_limit
          struct /* get_unconstrained_degrees_of_freedom_velocity_limit */ {
            // Source: drake/manipulation/planner/differential_inverse_kinematics.h:83
            const char* doc = R"""()""";
          } get_unconstrained_degrees_of_freedom_velocity_limit;
          // Symbol: drake::manipulation::planner::DifferentialInverseKinematicsParameters::set_end_effector_velocity_gain
          struct /* set_end_effector_velocity_gain */ {
            // Source: drake/manipulation/planner/differential_inverse_kinematics.h:143
            const char* doc =
R"""(Sets the end effector gains in the body frame. Gains can be used to
specify relative importance among different dimensions.

Raises:
    RuntimeError if any element of ``gain_E`` is larger than 1 or
    smaller than 0.)""";
          } set_end_effector_velocity_gain;
          // Symbol: drake::manipulation::planner::DifferentialInverseKinematicsParameters::set_joint_acceleration_limits
          struct /* set_joint_acceleration_limits */ {
            // Source: drake/manipulation/planner/differential_inverse_kinematics.h:191
            const char* doc =
R"""(Sets the joint acceleration limits.

Parameter ``q_bounds``:
    The first element is the lower bound, and the second is the upper
    bound.

Raises:
    RuntimeError if the first or second element of ``q_bounds`` has
    the wrong dimension or any element of the second element is
    smaller than its corresponding part in the first element.)""";
          } set_joint_acceleration_limits;
          // Symbol: drake::manipulation::planner::DifferentialInverseKinematicsParameters::set_joint_position_limits
          struct /* set_joint_position_limits */ {
            // Source: drake/manipulation/planner/differential_inverse_kinematics.h:157
            const char* doc =
R"""(Sets the joint position limits.

Parameter ``q_bounds``:
    The first element is the lower bound, and the second is the upper
    bound.

Raises:
    RuntimeError if the first or second element of ``q_bounds`` has
    the wrong dimension or any element of the second element is
    smaller than its corresponding part in the first element.)""";
          } set_joint_position_limits;
          // Symbol: drake::manipulation::planner::DifferentialInverseKinematicsParameters::set_joint_velocity_limits
          struct /* set_joint_velocity_limits */ {
            // Source: drake/manipulation/planner/differential_inverse_kinematics.h:174
            const char* doc =
R"""(Sets the joint velocity limits.

Parameter ``q_bounds``:
    The first element is the lower bound, and the second is the upper
    bound.

Raises:
    RuntimeError if the first or second element of ``q_bounds`` has
    the wrong dimension or any element of the second element is
    smaller than its corresponding part in the first element.)""";
          } set_joint_velocity_limits;
          // Symbol: drake::manipulation::planner::DifferentialInverseKinematicsParameters::set_nominal_joint_position
          struct /* set_nominal_joint_position */ {
            // Source: drake/manipulation/planner/differential_inverse_kinematics.h:131
            const char* doc =
R"""(Sets the nominal joint position.

Raises:
    RuntimeError if ``nominal_joint_position``'s dimension differs.)""";
          } set_nominal_joint_position;
          // Symbol: drake::manipulation::planner::DifferentialInverseKinematicsParameters::set_timestep
          struct /* set_timestep */ {
            // Source: drake/manipulation/planner/differential_inverse_kinematics.h:112
            const char* doc =
R"""(@name Setters. Sets timestep to ``dt``.

Raises:
    RuntimeError if dt <= 0.)""";
          } set_timestep;
          // Symbol: drake::manipulation::planner::DifferentialInverseKinematicsParameters::set_unconstrained_degrees_of_freedom_velocity_limit
          struct /* set_unconstrained_degrees_of_freedom_velocity_limit */ {
            // Source: drake/manipulation/planner/differential_inverse_kinematics.h:122
            const char* doc =
R"""(Sets the max magnitude of the velocity in the unconstrained degree of
freedom to ``limit``.

Raises:
    RuntimeError if limit < 0.)""";
          } set_unconstrained_degrees_of_freedom_velocity_limit;
        } DifferentialInverseKinematicsParameters;
        // Symbol: drake::manipulation::planner::DifferentialInverseKinematicsResult
        struct /* DifferentialInverseKinematicsResult */ {
          // Source: drake/manipulation/planner/differential_inverse_kinematics.h:34
          const char* doc = R"""()""";
          // Symbol: drake::manipulation::planner::DifferentialInverseKinematicsResult::joint_velocities
          struct /* joint_velocities */ {
            // Source: drake/manipulation/planner/differential_inverse_kinematics.h:35
            const char* doc = R"""()""";
          } joint_velocities;
          // Symbol: drake::manipulation::planner::DifferentialInverseKinematicsResult::status
          struct /* status */ {
            // Source: drake/manipulation/planner/differential_inverse_kinematics.h:36
            const char* doc = R"""()""";
          } status;
        } DifferentialInverseKinematicsResult;
        // Symbol: drake::manipulation::planner::DifferentialInverseKinematicsStatus
        struct /* DifferentialInverseKinematicsStatus */ {
          // Source: drake/manipulation/planner/differential_inverse_kinematics.h:24
          const char* doc = R"""()""";
          // Symbol: drake::manipulation::planner::DifferentialInverseKinematicsStatus::kNoSolutionFound
          struct /* kNoSolutionFound */ {
            // Source: drake/manipulation/planner/differential_inverse_kinematics.h:26
            const char* doc = R"""(Solver unable to find a solution.)""";
          } kNoSolutionFound;
          // Symbol: drake::manipulation::planner::DifferentialInverseKinematicsStatus::kSolutionFound
          struct /* kSolutionFound */ {
            // Source: drake/manipulation/planner/differential_inverse_kinematics.h:25
            const char* doc = R"""(Found the optimal solution.)""";
          } kSolutionFound;
          // Symbol: drake::manipulation::planner::DifferentialInverseKinematicsStatus::kStuck
          struct /* kStuck */ {
            // Source: drake/manipulation/planner/differential_inverse_kinematics.h:27
            const char* doc =
R"""(Unable to follow the desired velocity direction)""";
          } kStuck;
        } DifferentialInverseKinematicsStatus;
        // Symbol: drake::manipulation::planner::DoDifferentialInverseKinematics
        struct /* DoDifferentialInverseKinematics */ {
          // Source: drake/manipulation/planner/differential_inverse_kinematics.h:282
          const char* doc_5args_q_current_v_current_V_J_parameters =
R"""(Computes a generalized velocity v_next, via the following
MathematicalProgram:


::

    min_{v_next,alpha}   100 * | alpha - |V| |^2
                           // iff J.rows() < J.cols(), then
                             + | q_current + v_next*dt - q_nominal |^2
    
      s.t. J*v_next = alpha * V / |V|  // J*v_next has the same direction as V
           joint_lim_min <= q_current + v_next*dt <= joint_lim_max
           joint_vel_lim_min <= v_next <= joint_vel_lim_max
           joint_accel_lim_min <= (v_next - v_current)/dt <=
             joint_accel_lim_max
           for all i > J.rows(),
             -unconstrained_vel_lim <= S.col(i)' v_next <= unconstrained_vel_lim
             where J = UΣS' is the SVD, with the singular values in decreasing
             order.  Note that the constraint is imposed on each column
             independently.
    
           and any additional linear constraints added via
             AddLinearVelocityConstraint() in the
             DifferentialInverseKinematicsParameters.
      where J.rows() == V.size() and
      J.cols() == v_current.size() == q_current.size() == v_next.size().  V
      can have any size, with each element representing a constraint on the
      solution (6 constraints specifying an end-effector pose is typical, but
      not required).

Intuitively, this finds a v_next such that J*v_next is in the same
direction as V, and the difference between |V| and |J * v_next| is
minimized while all constraints in ``parameters`` are satisfied as
well. If the problem is redundant, a secondary objective to minimize
|q_current + v_next * dt - q_nominal| is added to the problem.

It is possible that the solver is unable to find such a generalized
velocity while not violating the constraints, in which case, status
will be set to kStuck in the returned
DifferentialInverseKinematicsResult.

Parameter ``q_current``:
    The current generalized position.

Parameter ``v_current``:
    The current generalized position.

Parameter ``V``:
    Desired spatial velocity. It must have the same number of rows as
    ``J``.

Parameter ``J``:
    Jacobian with respect to generalized velocities v. It must have
    the same number of rows as ``V``. J * v need to represent the same
    spatial velocity as ``V``.

Parameter ``parameters``:
    Collection of various problem specific constraints and constants.

Returns:
    If the solver successfully finds a solution, joint_velocities will
    be set to v, otherwise it will be nullopt.)""";
          // Source: drake/manipulation/planner/differential_inverse_kinematics.h:307
          const char* doc_5args_robot_context_V_WE_desired_frame_E_parameters =
R"""(A wrapper over DoDifferentialInverseKinematics(q_current, v_current,
V, J, params) that tracks frame E's spatial velocity. q_current and
v_current are taken from ``context``. V is computed by first
transforming ``V_WE`` to V_WE_E, then taking the element-wise product
between V_WE_E and the gains (specified in frame E) in ``parameters``,
and only selecting the non zero elements. J is computed similarly.

Parameter ``robot``:
    A MultibodyPlant model.

Parameter ``context``:
    Must be the Context of the MultibodyPlant. Contains the current
    generalized position and velocity.

Parameter ``V_WE_desired``:
    Desired world frame spatial velocity of ``frame_E``.

Parameter ``frame_E``:
    End effector frame.

Parameter ``parameters``:
    Collection of various problem specific constraints and constants.

Returns:
    If the solver successfully finds a solution, joint_velocities will
    be set to v, otherwise it will be nullopt.)""";
          // Source: drake/manipulation/planner/differential_inverse_kinematics.h:331
          const char* doc_5args_robot_context_X_WE_desired_frame_E_parameters =
R"""(A wrapper over DoDifferentialInverseKinematics(robot, context,
V_WE_desired, frame_E, params) that tracks frame E's pose in the world
frame. q_current and v_current are taken from ``cache``. V_WE is
computed by ComputePoseDiffInCommonFrame(X_WE, X_WE_desired) / dt,
where X_WE is computed from ``context``, and dt is taken from
``parameters``.

Parameter ``robot``:
    A MultibodyPlant model.

Parameter ``context``:
    Must be the Context of the MultibodyPlant. Contains the current
    generalized position and velocity.

Parameter ``X_WE_desired``:
    Desired pose of ``frame_E`` in the world frame.

Parameter ``frame_E``:
    End effector frame.

Parameter ``parameters``:
    Collection of various problem specific constraints and constants.

Returns:
    If the solver successfully finds a solution, joint_velocities will
    be set to v, otherwise it will be nullopt.)""";
        } DoDifferentialInverseKinematics;
        // Symbol: drake::manipulation::planner::InterpolatorType
        struct /* InterpolatorType */ {
          // Source: drake/manipulation/planner/robot_plan_interpolator.h:17
          const char* doc =
R"""(This enum specifies the type of interpolator to use in constructing
the piece-wise polynomial.)""";
          // Symbol: drake::manipulation::planner::InterpolatorType::Cubic
          struct /* Cubic */ {
            // Source: drake/manipulation/planner/robot_plan_interpolator.h:21
            const char* doc = R"""()""";
          } Cubic;
          // Symbol: drake::manipulation::planner::InterpolatorType::FirstOrderHold
          struct /* FirstOrderHold */ {
            // Source: drake/manipulation/planner/robot_plan_interpolator.h:19
            const char* doc = R"""()""";
          } FirstOrderHold;
          // Symbol: drake::manipulation::planner::InterpolatorType::Pchip
          struct /* Pchip */ {
            // Source: drake/manipulation/planner/robot_plan_interpolator.h:20
            const char* doc = R"""()""";
          } Pchip;
          // Symbol: drake::manipulation::planner::InterpolatorType::ZeroOrderHold
          struct /* ZeroOrderHold */ {
            // Source: drake/manipulation/planner/robot_plan_interpolator.h:18
            const char* doc = R"""()""";
          } ZeroOrderHold;
        } InterpolatorType;
        // Symbol: drake::manipulation::planner::RobotPlanInterpolator
        struct /* RobotPlanInterpolator */ {
          // Source: drake/manipulation/planner/robot_plan_interpolator.h:44
          const char* doc =
R"""(This class implements a source of joint positions for a robot. It has
one input port for lcmt_robot_plan messages containing a plan to
follow.

The system has two output ports, one with the current desired state
(q,v) of the robot and another for the accelerations.

.. pydrake_system::

    name: RobotPlanInterpolator
    input_ports:
    - plan
    output_ports:
    - state
    - acceleration

If a plan is received with no knot points, the system will create a
plan which commands the robot to hold at the measured position.)""";
          // Symbol: drake::manipulation::planner::RobotPlanInterpolator::DoCalcUnrestrictedUpdate
          struct /* DoCalcUnrestrictedUpdate */ {
            // Source: drake/manipulation/planner/robot_plan_interpolator.h:82
            const char* doc = R"""()""";
          } DoCalcUnrestrictedUpdate;
          // Symbol: drake::manipulation::planner::RobotPlanInterpolator::Initialize
          struct /* Initialize */ {
            // Source: drake/manipulation/planner/robot_plan_interpolator.h:73
            const char* doc =
R"""(Makes a plan to hold at the measured joint configuration ``q0``
starting at ``plan_start_time``. This function needs to be explicitly
called before any simulation. Otherwise this aborts in CalcOutput().)""";
          } Initialize;
          // Symbol: drake::manipulation::planner::RobotPlanInterpolator::RobotPlanInterpolator
          struct /* ctor */ {
            // Source: drake/manipulation/planner/robot_plan_interpolator.h:46
            const char* doc = R"""()""";
          } ctor;
          // Symbol: drake::manipulation::planner::RobotPlanInterpolator::SetDefaultState
          struct /* SetDefaultState */ {
            // Source: drake/manipulation/planner/robot_plan_interpolator.h:79
            const char* doc = R"""()""";
          } SetDefaultState;
          // Symbol: drake::manipulation::planner::RobotPlanInterpolator::get_acceleration_output_port
          struct /* get_acceleration_output_port */ {
            // Source: drake/manipulation/planner/robot_plan_interpolator.h:64
            const char* doc = R"""()""";
          } get_acceleration_output_port;
          // Symbol: drake::manipulation::planner::RobotPlanInterpolator::get_plan_input_port
          struct /* get_plan_input_port */ {
            // Source: drake/manipulation/planner/robot_plan_interpolator.h:54
            const char* doc =
R"""(N.B. This input port is useless and may be left disconnected.)""";
          } get_plan_input_port;
          // Symbol: drake::manipulation::planner::RobotPlanInterpolator::get_state_output_port
          struct /* get_state_output_port */ {
            // Source: drake/manipulation/planner/robot_plan_interpolator.h:59
            const char* doc = R"""()""";
          } get_state_output_port;
          // Symbol: drake::manipulation::planner::RobotPlanInterpolator::plant
          struct /* plant */ {
            // Source: drake/manipulation/planner/robot_plan_interpolator.h:76
            const char* doc = R"""()""";
          } plant;
        } RobotPlanInterpolator;
      } planner;
      // Symbol: drake::manipulation::schunk_wsg
      struct /* schunk_wsg */ {
        // Symbol: drake::manipulation::schunk_wsg::ControlMode
        struct /* ControlMode */ {
          // Source: drake/manipulation/schunk_wsg/schunk_wsg_plain_controller.h:11
          const char* doc = R"""()""";
          // Symbol: drake::manipulation::schunk_wsg::ControlMode::kForce
          struct /* kForce */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_plain_controller.h:11
            const char* doc = R"""()""";
          } kForce;
          // Symbol: drake::manipulation::schunk_wsg::ControlMode::kPosition
          struct /* kPosition */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_plain_controller.h:11
            const char* doc = R"""()""";
          } kPosition;
        } ControlMode;
        // Symbol: drake::manipulation::schunk_wsg::GetSchunkWsgOpenPosition
        struct /* GetSchunkWsgOpenPosition */ {
          // Source: drake/manipulation/schunk_wsg/schunk_wsg_constants.h:41
          const char* doc =
R"""(Returns the position vector corresponding to the open position of the
gripper.)""";
        } GetSchunkWsgOpenPosition;
        // Symbol: drake::manipulation::schunk_wsg::MakeMultibodyForceToWsgForceSystem
        struct /* MakeMultibodyForceToWsgForceSystem */ {
          // Source: drake/manipulation/schunk_wsg/schunk_wsg_constants.h:95
          const char* doc =
R"""(Helper method to create a MultibodyForceToWsgForceSystem.)""";
        } MakeMultibodyForceToWsgForceSystem;
        // Symbol: drake::manipulation::schunk_wsg::MakeMultibodyStateToWsgStateSystem
        struct /* MakeMultibodyStateToWsgStateSystem */ {
          // Source: drake/manipulation/schunk_wsg/schunk_wsg_constants.h:54
          const char* doc =
R"""(Extract the distance between the fingers (and its time derivative) out
of the plant model which pretends the two fingers are independent.)""";
        } MakeMultibodyStateToWsgStateSystem;
        // Symbol: drake::manipulation::schunk_wsg::MultibodyForceToWsgForceSystem
        struct /* MultibodyForceToWsgForceSystem */ {
          // Source: drake/manipulation/schunk_wsg/schunk_wsg_constants.h:67
          const char* doc =
R"""(Extract the gripper measured force from the generalized forces on the
two fingers.)""";
          // Symbol: drake::manipulation::schunk_wsg::MultibodyForceToWsgForceSystem::DoCalcVectorOutput
          struct /* DoCalcVectorOutput */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_constants.h:79
            const char* doc = R"""()""";
          } DoCalcVectorOutput;
          // Symbol: drake::manipulation::schunk_wsg::MultibodyForceToWsgForceSystem::MultibodyForceToWsgForceSystem<T>
          struct /* ctor */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_constants.h:69
            const char* doc = R"""()""";
          } ctor;
        } MultibodyForceToWsgForceSystem;
        // Symbol: drake::manipulation::schunk_wsg::SchunkWsgCommandReceiver
        struct /* SchunkWsgCommandReceiver */ {
          // Source: drake/manipulation/schunk_wsg/schunk_wsg_lcm.h:37
          const char* doc =
R"""(Handles the command for the Schunk WSG gripper from a
LcmSubscriberSystem.

It has one input port: "command_message" for lcmt_schunk_wsg_command
abstract values.

It has two output ports: one for the commanded finger position
represented as the desired distance between the fingers in meters, and
one for the commanded force limit. The commanded position and force
limit are scalars (BasicVector<double> of size 1).

.. pydrake_system::

    name: SchunkWsgCommandReceiver
    input_ports:
    - command_message
    output_ports:
    - position
    - force_limit)""";
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgCommandReceiver::SchunkWsgCommandReceiver
          struct /* ctor */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_lcm.h:46
            const char* doc =
R"""(Parameter ``initial_position``:
    the commanded position to output if no LCM message has been
    received yet.

Parameter ``initial_force``:
    the commanded force limit to output if no LCM message has been
    received yet.)""";
          } ctor;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgCommandReceiver::get_force_limit_output_port
          struct /* get_force_limit_output_port */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_lcm.h:53
            const char* doc = R"""()""";
          } get_force_limit_output_port;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgCommandReceiver::get_position_output_port
          struct /* get_position_output_port */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_lcm.h:49
            const char* doc = R"""()""";
          } get_position_output_port;
        } SchunkWsgCommandReceiver;
        // Symbol: drake::manipulation::schunk_wsg::SchunkWsgCommandSender
        struct /* SchunkWsgCommandSender */ {
          // Source: drake/manipulation/schunk_wsg/schunk_wsg_lcm.h:85
          const char* doc =
R"""(Send lcmt_schunk_wsg_command messages for a Schunk WSG gripper. Has
two input ports: one for the commanded finger position represented as
the desired signed distance between the fingers in meters, and one for
the commanded force limit. The commanded position and force limit are
scalars (BasicVector<double> of size 1).

.. pydrake_system::

    name: SchunkWsgCommandSender
    input_ports:
    - position
    - force_limit (optional)
    output_ports:
    - lcmt_schunk_wsg_command)""";
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgCommandSender::SchunkWsgCommandSender
          struct /* ctor */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_lcm.h:87
            const char* doc = R"""()""";
          } ctor;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgCommandSender::get_command_output_port
          struct /* get_command_output_port */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_lcm.h:101
            const char* doc = R"""()""";
          } get_command_output_port;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgCommandSender::get_force_limit_input_port
          struct /* get_force_limit_input_port */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_lcm.h:96
            const char* doc = R"""()""";
          } get_force_limit_input_port;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgCommandSender::get_position_input_port
          struct /* get_position_input_port */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_lcm.h:91
            const char* doc = R"""()""";
          } get_position_input_port;
        } SchunkWsgCommandSender;
        // Symbol: drake::manipulation::schunk_wsg::SchunkWsgController
        struct /* SchunkWsgController */ {
          // Source: drake/manipulation/schunk_wsg/schunk_wsg_controller.h:29
          const char* doc =
R"""(This class implements a controller for a Schunk WSG gripper. It has
two input ports: lcmt_schunk_wsg_command message and the current
state, and an output port which emits the target force for the
actuated finger. Note, only one of the command input ports should be
connected, However, if both are connected, the message input will be
ignored. The internal implementation consists of a PID controller
(which controls the target position from the command message) combined
with a saturation block (which applies the force control from the
command message).

.. pydrake_system::

    name: SchunkWsgController
    input_ports:
    - state
    - command_message
    output_ports:
    - force)""";
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgController::SchunkWsgController
          struct /* ctor */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_controller.h:31
            const char* doc = R"""()""";
          } ctor;
        } SchunkWsgController;
        // Symbol: drake::manipulation::schunk_wsg::SchunkWsgPdController
        struct /* SchunkWsgPdController */ {
          // Source: drake/manipulation/schunk_wsg/schunk_wsg_position_controller.h:59
          const char* doc =
R"""(This class implements a controller for a Schunk WSG gripper in
position control mode. It assumes that the gripper is modeled in the
plant as two independent prismatic joints for the fingers.

Note: This is intended as a simpler single-system implementation that
can replace the SchunkWsgController when using position control mode.
We anticipate a single-system SchunkWsgForceController implementation
to (soon) replace the other mode, and then will deprecate
SchunkWsgController.

Call the positions of the prismatic joints q₀ and q₁. q₀ = q₁ = 0 is
the configuration where the fingers are touching in the center. When
the gripper is open, q₀ < 0 and q₁ > 0.

The physical gripper mechanically imposes that -q₀ = q₁, and
implements a controller to track -q₀ = q₁ = q_d/2 (q_d is the desired
position, which is the signed distance between the two fingers). We
model that here with two PD controllers -- one that implements the
physical constraint (keeping the fingers centered): f₀+f₁ =
-kp_constraint*(q₀+q₁) - kd_constraint*(v₀+v₁), and another to
implement the controller (opening/closing the fingers): -f₀+f₁ =
sat(kp_command*(q_d + q₀ - q₁) + kd_command*(v_d + v₀ - v₁)), where
sat() saturates the command to be in the range [-force_limit,
force_limit]. The expectation is that kp_constraint ≫ kp_command.

.. pydrake_system::

    name: SchunkWSGPdController
    input_ports:
    - desired_state
    - force_limit (optional)
    - state
    output_ports:
    - generalized_force
    - grip_force

The desired_state is a BasicVector<double> of size 2 (position and
velocity of the distance between the fingers). The force_limit is a
scalar (BasicVector<double> of size 1) and is optional; if the input
port is not connected then the constant value passed into the
constructor is used. The state is a BasicVector<double> of size 4
(positions and velocities of the two fingers). The output
generalized_force is a BasicVector<double> of size 2 (generalized
force inputs to the two fingers). The output grip_force is a scalar
surrogate for the force measurement from the driver, f = abs(f₀-f₁)
which, like the gripper itself, only reports a positive force.)""";
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgPdController::SchunkWsgPdController
          struct /* ctor */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_position_controller.h:69
            const char* doc =
R"""(Initialize the controller. The gain parameters are set based limited
tuning in simulation with a kuka picking up small objects.)""";
          } ctor;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgPdController::get_desired_state_input_port
          struct /* get_desired_state_input_port */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_position_controller.h:74
            const char* doc = R"""()""";
          } get_desired_state_input_port;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgPdController::get_force_limit_input_port
          struct /* get_force_limit_input_port */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_position_controller.h:78
            const char* doc = R"""()""";
          } get_force_limit_input_port;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgPdController::get_generalized_force_output_port
          struct /* get_generalized_force_output_port */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_position_controller.h:86
            const char* doc = R"""()""";
          } get_generalized_force_output_port;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgPdController::get_grip_force_output_port
          struct /* get_grip_force_output_port */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_position_controller.h:90
            const char* doc = R"""()""";
          } get_grip_force_output_port;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgPdController::get_state_input_port
          struct /* get_state_input_port */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_position_controller.h:82
            const char* doc = R"""()""";
          } get_state_input_port;
        } SchunkWsgPdController;
        // Symbol: drake::manipulation::schunk_wsg::SchunkWsgPlainController
        struct /* SchunkWsgPlainController */ {
          // Source: drake/manipulation/schunk_wsg/schunk_wsg_plain_controller.h:109
          const char* doc =
R"""(This class implements a controller for a Schunk WSG gripper as a
``systems::Diagram``. The composition of this diagram is determined by
the control mode specified for the controller, which can be either
ControlMode::kPosition or ControlMode::kForce. In both cases, the
overall layout of the diagram is:


::

    ┌─────────────┐
    joint       │Joint State  │   ┌──────────┐
    state ─────▶│To Control   ├──▶│          │
                │State        │   │          │
                └─────────────┘   │PID       │   ╔════════════╗
                ╔═════════════╗   │Controller├──▶║            ╟─────┐
    desired     ║Generate     ║   │          │   ║            ║     │
    grip ──────▶║Desired      ╟──▶│          │   ║Handle      ║     │
    state       ║Control State║   └──────────┘   ║Feed-Forward║     │
                ╚═════════════╝                  ║Force       ║     │
    feed                                         ║            ║     │
    forward ────────────────────────────────────▶║            ╟──┐  │
    force                                        ╚════════════╝  │  │
                                                                 │  │
                              ┌──────────────────────────────────┘  │
                              │              ┌──────────────────────┘
                              │              │
                              │              │   ┌───────────┐
                              │              │   │Mean Finger│   ┌───┐
                              │              └──▶│Force To   ├──▶│   │
                              │                  │Joint Force│   │   │
                              │                  └───────────┘   │   │
                              │                                  │ + ├──▶ control
                              │   ┌──────────┐   ┌───────────┐   │   │
                    ┌─────────│──▶│          │   │Grip Force │   │   │
                    │   ┌──┐  └──▶│Saturation├──▶│To Joint   ├──▶│   │
    max force / 2 ──┴──▶│-1├─────▶│          │   │Force      │   └───┘
                        └──┘      └──────────┘   └───────────┘

The blocks with double outlines (══) differ between the two control
modes:

- Generate Desired Control State
  - ControlMode::kPosition



::

    ┌───────────┐
           │Desired    │
           │Mean Finger├──▶█
           │State      │   █   ┌─────────────┐
           └───────────┘   █   │Muxed States │    desired
                           █──▶│To Control   ├──▶ control
                           █   │State        │    state
            desired        █   └─────────────┘
            grip   ───────▶█
            state

- ControlMode::kForce


::

    ┌───────────┐
           │Desired    │                          desired
           │Mean Finger├────────────────────────▶ control
           │State      │                          state
           └───────────┘
    
            desired        ┌────────┐
            grip   ───────▶│IGNORED │
            state          └────────┘

- Handle Feed-Forward Force - ControlMode::kPosition


::

    █────▶ mean finger force
            pid                         █
            controller ────────────────▶█
            output                      █
                                        █────▶ grip force
            feed           ┌────────┐
            forward ──────▶│IGNORED │
            force          └────────┘

- ControlMode::kForce


::

    pid
            controller ──────────────────────▶ mean finger force
            output
    
            feed
            forward ─────────────────────────▶ grip force
            force

The remaining blocks differ only in their numerical parameters.

Note that the "feed forward force" input is ignored for
ControlMode::kPosition and the "desired grip state" input is ignored
for ControlMode::kPosition.)""";
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgPlainController::SchunkWsgPlainController
          struct /* ctor */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_plain_controller.h:115
            const char* doc =
R"""(Specify control gains and mode. Mode defaults to position control.)""";
          } ctor;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgPlainController::get_input_port_desired_state
          struct /* get_input_port_desired_state */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_plain_controller.h:141
            const char* doc =
R"""(Returns the desired grip state input port.

Precondition:
    ``this`` was constructed with ``control_mode`` set to
    ``ControlMode::kPosition``.)""";
          } get_input_port_desired_state;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgPlainController::get_input_port_estimated_state
          struct /* get_input_port_estimated_state */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_plain_controller.h:133
            const char* doc = R"""()""";
          } get_input_port_estimated_state;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgPlainController::get_input_port_feed_forward_force
          struct /* get_input_port_feed_forward_force */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_plain_controller.h:123
            const char* doc =
R"""(Returns the feed-forward force input port.

Precondition:
    ``this`` was constructed with ``control_mode`` set to
    ``ControlMode::kForce``.)""";
          } get_input_port_feed_forward_force;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgPlainController::get_input_port_max_force
          struct /* get_input_port_max_force */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_plain_controller.h:128
            const char* doc = R"""()""";
          } get_input_port_max_force;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgPlainController::get_output_port_control
          struct /* get_output_port_control */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_plain_controller.h:147
            const char* doc = R"""()""";
          } get_output_port_control;
        } SchunkWsgPlainController;
        // Symbol: drake::manipulation::schunk_wsg::SchunkWsgPositionController
        struct /* SchunkWsgPositionController */ {
          // Source: drake/manipulation/schunk_wsg/schunk_wsg_position_controller.h:136
          const char* doc =
R"""(This class implements a controller for a Schunk WSG gripper in
position control mode adding a discrete-derivative to estimate the
desired velocity from the desired position commands. It is a thin
wrapper around SchunkWsgPdController.

.. pydrake_system::

    name: SchunkWSGPositionController
    input_ports:
    - desired_position
    - force_limit (optional)
    - state
    output_ports:
    - generalized_force
    - grip_force

See also:
    SchunkWsgPdController)""";
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgPositionController::SchunkWsgPositionController
          struct /* ctor */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_position_controller.h:144
            const char* doc =
R"""(Initialize the controller. The default ``time_step`` is set to match
the update rate of the wsg firmware. The gain parameters are set based
limited tuning in simulation with a kuka picking up small objects.

See also:
    SchunkWsgPdController::SchunkWsgPdController())""";
          } ctor;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgPositionController::get_desired_position_input_port
          struct /* get_desired_position_input_port */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_position_controller.h:151
            const char* doc = R"""()""";
          } get_desired_position_input_port;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgPositionController::get_force_limit_input_port
          struct /* get_force_limit_input_port */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_position_controller.h:155
            const char* doc = R"""()""";
          } get_force_limit_input_port;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgPositionController::get_generalized_force_output_port
          struct /* get_generalized_force_output_port */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_position_controller.h:163
            const char* doc = R"""()""";
          } get_generalized_force_output_port;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgPositionController::get_grip_force_output_port
          struct /* get_grip_force_output_port */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_position_controller.h:167
            const char* doc = R"""()""";
          } get_grip_force_output_port;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgPositionController::get_state_input_port
          struct /* get_state_input_port */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_position_controller.h:159
            const char* doc = R"""()""";
          } get_state_input_port;
        } SchunkWsgPositionController;
        // Symbol: drake::manipulation::schunk_wsg::SchunkWsgStatusReceiver
        struct /* SchunkWsgStatusReceiver */ {
          // Source: drake/manipulation/schunk_wsg/schunk_wsg_lcm.h:132
          const char* doc =
R"""(Handles lcmt_schunk_wsg_status messages from a LcmSubscriberSystem.
Has two output ports: one for the measured state of the gripper,
represented as the signed distance between the fingers in meters and
its corresponding velocity, and one for the measured force.

.. pydrake_system::

    name: SchunkWsgStatusReceiver
    input_ports:
    - lcmt_schunk_wsg_status
    output_ports:
    - state
    - force)""";
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgStatusReceiver::SchunkWsgStatusReceiver
          struct /* ctor */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_lcm.h:134
            const char* doc = R"""()""";
          } ctor;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgStatusReceiver::get_force_output_port
          struct /* get_force_output_port */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_lcm.h:147
            const char* doc = R"""()""";
          } get_force_output_port;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgStatusReceiver::get_state_output_port
          struct /* get_state_output_port */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_lcm.h:142
            const char* doc = R"""()""";
          } get_state_output_port;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgStatusReceiver::get_status_input_port
          struct /* get_status_input_port */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_lcm.h:138
            const char* doc = R"""()""";
          } get_status_input_port;
        } SchunkWsgStatusReceiver;
        // Symbol: drake::manipulation::schunk_wsg::SchunkWsgStatusSender
        struct /* SchunkWsgStatusSender */ {
          // Source: drake/manipulation/schunk_wsg/schunk_wsg_lcm.h:185
          const char* doc =
R"""(Sends lcmt_schunk_wsg_status messages for a Schunk WSG. This system
has one input port for the current state of the WSG, and one optional
input port for the measured gripping force.

.. pydrake_system::

    name: SchunkStatusSender
    input_ports:
    - state
    - force
    output_ports:
    - lcmt_schunk_wsg_status

The state input is a BasicVector<double> of size 2 -- with one
position and one velocity -- representing the distance between the
fingers (positive implies non-penetration).)""";
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgStatusSender::SchunkWsgStatusSender
          struct /* ctor */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_lcm.h:187
            const char* doc = R"""()""";
          } ctor;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgStatusSender::get_force_input_port
          struct /* get_force_input_port */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_lcm.h:194
            const char* doc = R"""()""";
          } get_force_input_port;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgStatusSender::get_state_input_port
          struct /* get_state_input_port */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_lcm.h:189
            const char* doc = R"""()""";
          } get_state_input_port;
        } SchunkWsgStatusSender;
        // Symbol: drake::manipulation::schunk_wsg::SchunkWsgTrajectoryGenerator
        struct /* SchunkWsgTrajectoryGenerator */ {
          // Source: drake/manipulation/schunk_wsg/schunk_wsg_trajectory_generator.h:29
          const char* doc =
R"""(This system defines input ports for the desired finger position
represented as the desired distance between the fingers in meters and
the desired force limit in newtons, and emits target position/velocity
for the actuated finger to reach the commanded target, expressed as
the negative of the distance between the two fingers in meters. The
force portion of the command message is passed through this system,
but does not affect the generated trajectory. The desired_position and
force_limit are scalars (BasicVector<double> of size 1).)""";
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgTrajectoryGenerator::SchunkWsgTrajectoryGenerator
          struct /* ctor */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_trajectory_generator.h:37
            const char* doc =
R"""(Parameter ``input_size``:
    The size of the state input port to create (one reason this may
    vary is passing in the entire state of a rigid body tree vs.
    having already demultiplexed the actuated finger).

Parameter ``position_index``:
    The index in the state input vector which contains the position of
    the actuated finger.)""";
          } ctor;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgTrajectoryGenerator::get_desired_position_input_port
          struct /* get_desired_position_input_port */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_trajectory_generator.h:39
            const char* doc = R"""()""";
          } get_desired_position_input_port;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgTrajectoryGenerator::get_force_limit_input_port
          struct /* get_force_limit_input_port */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_trajectory_generator.h:43
            const char* doc = R"""()""";
          } get_force_limit_input_port;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgTrajectoryGenerator::get_max_force_output_port
          struct /* get_max_force_output_port */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_trajectory_generator.h:55
            const char* doc = R"""()""";
          } get_max_force_output_port;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgTrajectoryGenerator::get_state_input_port
          struct /* get_state_input_port */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_trajectory_generator.h:47
            const char* doc = R"""()""";
          } get_state_input_port;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgTrajectoryGenerator::get_target_output_port
          struct /* get_target_output_port */ {
            // Source: drake/manipulation/schunk_wsg/schunk_wsg_trajectory_generator.h:51
            const char* doc = R"""()""";
          } get_target_output_port;
        } SchunkWsgTrajectoryGenerator;
        // Symbol: drake::manipulation::schunk_wsg::SchunkWsgTrajectoryGeneratorStateVector
        struct /* SchunkWsgTrajectoryGeneratorStateVector */ {
          // Source: drake/manipulation/schunk_wsg/gen/schunk_wsg_trajectory_generator_state_vector.h:47
          const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgTrajectoryGeneratorStateVector::DoClone
          struct /* DoClone */ {
            // Source: drake/manipulation/schunk_wsg/gen/schunk_wsg_trajectory_generator_state_vector.h:102
            const char* doc = R"""()""";
          } DoClone;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgTrajectoryGeneratorStateVector::GetCoordinateNames
          struct /* GetCoordinateNames */ {
            // Source: drake/manipulation/schunk_wsg/gen/schunk_wsg_trajectory_generator_state_vector.h:201
            const char* doc =
R"""(See
SchunkWsgTrajectoryGeneratorStateVectorIndices::GetCoordinateNames().)""";
          } GetCoordinateNames;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgTrajectoryGeneratorStateVector::IsValid
          struct /* IsValid */ {
            // Source: drake/manipulation/schunk_wsg/gen/schunk_wsg_trajectory_generator_state_vector.h:206
            const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";
          } IsValid;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgTrajectoryGeneratorStateVector::K
          struct /* K */ {
            // Source: drake/manipulation/schunk_wsg/gen/schunk_wsg_trajectory_generator_state_vector.h:51
            const char* doc =
R"""(An abbreviation for our row index constants.)""";
          } K;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgTrajectoryGeneratorStateVector::SchunkWsgTrajectoryGeneratorStateVector<T>
          struct /* ctor */ {
            // Source: drake/manipulation/schunk_wsg/gen/schunk_wsg_trajectory_generator_state_vector.h:58
            const char* doc =
R"""(Default constructor. Sets all rows to their default value:

* ``last_target_position`` defaults to 0.0 with unknown units.

* ``trajectory_start_time`` defaults to 0.0 with unknown units.

* ``last_position`` defaults to 0.0 with unknown units.

* ``max_force`` defaults to 0.0 with unknown units.)""";
          } ctor;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgTrajectoryGeneratorStateVector::Serialize
          struct /* Serialize */ {
            // Source: drake/manipulation/schunk_wsg/gen/schunk_wsg_trajectory_generator_state_vector.h:187
            const char* doc =
R"""(Visit each field of this named vector, passing them (in order) to the
given Archive. The archive can read and/or write to the vector values.
One common use of Serialize is the //common/yaml tools.)""";
          } Serialize;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgTrajectoryGeneratorStateVector::SetToNamedVariables
          struct /* SetToNamedVariables */ {
            // Source: drake/manipulation/schunk_wsg/gen/schunk_wsg_trajectory_generator_state_vector.h:94
            const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";
          } SetToNamedVariables;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgTrajectoryGeneratorStateVector::last_position
          struct /* last_position */ {
            // Source: drake/manipulation/schunk_wsg/gen/schunk_wsg_trajectory_generator_state_vector.h:146
            const char* doc = R"""(last_position)""";
          } last_position;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgTrajectoryGeneratorStateVector::last_target_position
          struct /* last_target_position */ {
            // Source: drake/manipulation/schunk_wsg/gen/schunk_wsg_trajectory_generator_state_vector.h:110
            const char* doc = R"""(last_target_position)""";
          } last_target_position;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgTrajectoryGeneratorStateVector::max_force
          struct /* max_force */ {
            // Source: drake/manipulation/schunk_wsg/gen/schunk_wsg_trajectory_generator_state_vector.h:164
            const char* doc = R"""(max_force)""";
          } max_force;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgTrajectoryGeneratorStateVector::set_last_position
          struct /* set_last_position */ {
            // Source: drake/manipulation/schunk_wsg/gen/schunk_wsg_trajectory_generator_state_vector.h:151
            const char* doc = R"""(Setter that matches last_position().)""";
          } set_last_position;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgTrajectoryGeneratorStateVector::set_last_target_position
          struct /* set_last_target_position */ {
            // Source: drake/manipulation/schunk_wsg/gen/schunk_wsg_trajectory_generator_state_vector.h:115
            const char* doc =
R"""(Setter that matches last_target_position().)""";
          } set_last_target_position;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgTrajectoryGeneratorStateVector::set_max_force
          struct /* set_max_force */ {
            // Source: drake/manipulation/schunk_wsg/gen/schunk_wsg_trajectory_generator_state_vector.h:169
            const char* doc = R"""(Setter that matches max_force().)""";
          } set_max_force;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgTrajectoryGeneratorStateVector::set_trajectory_start_time
          struct /* set_trajectory_start_time */ {
            // Source: drake/manipulation/schunk_wsg/gen/schunk_wsg_trajectory_generator_state_vector.h:133
            const char* doc =
R"""(Setter that matches trajectory_start_time().)""";
          } set_trajectory_start_time;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgTrajectoryGeneratorStateVector::trajectory_start_time
          struct /* trajectory_start_time */ {
            // Source: drake/manipulation/schunk_wsg/gen/schunk_wsg_trajectory_generator_state_vector.h:128
            const char* doc = R"""(trajectory_start_time)""";
          } trajectory_start_time;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgTrajectoryGeneratorStateVector::with_last_position
          struct /* with_last_position */ {
            // Source: drake/manipulation/schunk_wsg/gen/schunk_wsg_trajectory_generator_state_vector.h:157
            const char* doc =
R"""(Fluent setter that matches last_position(). Returns a copy of ``this``
with last_position set to a new value.)""";
          } with_last_position;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgTrajectoryGeneratorStateVector::with_last_target_position
          struct /* with_last_target_position */ {
            // Source: drake/manipulation/schunk_wsg/gen/schunk_wsg_trajectory_generator_state_vector.h:122
            const char* doc =
R"""(Fluent setter that matches last_target_position(). Returns a copy of
``this`` with last_target_position set to a new value.)""";
          } with_last_target_position;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgTrajectoryGeneratorStateVector::with_max_force
          struct /* with_max_force */ {
            // Source: drake/manipulation/schunk_wsg/gen/schunk_wsg_trajectory_generator_state_vector.h:175
            const char* doc =
R"""(Fluent setter that matches max_force(). Returns a copy of ``this``
with max_force set to a new value.)""";
          } with_max_force;
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgTrajectoryGeneratorStateVector::with_trajectory_start_time
          struct /* with_trajectory_start_time */ {
            // Source: drake/manipulation/schunk_wsg/gen/schunk_wsg_trajectory_generator_state_vector.h:140
            const char* doc =
R"""(Fluent setter that matches trajectory_start_time(). Returns a copy of
``this`` with trajectory_start_time set to a new value.)""";
          } with_trajectory_start_time;
        } SchunkWsgTrajectoryGeneratorStateVector;
        // Symbol: drake::manipulation::schunk_wsg::SchunkWsgTrajectoryGeneratorStateVectorIndices
        struct /* SchunkWsgTrajectoryGeneratorStateVectorIndices */ {
          // Source: drake/manipulation/schunk_wsg/gen/schunk_wsg_trajectory_generator_state_vector.h:27
          const char* doc =
R"""(Describes the row indices of a
SchunkWsgTrajectoryGeneratorStateVector.)""";
          // Symbol: drake::manipulation::schunk_wsg::SchunkWsgTrajectoryGeneratorStateVectorIndices::GetCoordinateNames
          struct /* GetCoordinateNames */ {
            // Source: drake/manipulation/schunk_wsg/gen/schunk_wsg_trajectory_generator_state_vector.h:42
            const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words,
``SchunkWsgTrajectoryGeneratorStateVectorIndices::GetCoordinateNames()[i]``
is the name for ``BasicVector::GetAtIndex(i)``.)""";
          } GetCoordinateNames;
        } SchunkWsgTrajectoryGeneratorStateVectorIndices;
      } schunk_wsg;
      // Symbol: drake::manipulation::util
      struct /* util */ {
        // Symbol: drake::manipulation::util::ApplyJointVelocityLimits
        struct /* ApplyJointVelocityLimits */ {
          // Source: drake/manipulation/util/robot_plan_utils.h:31
          const char* doc =
R"""(Scales a plan so that no step exceeds the robot's maximum joint
velocities. The size of ``keyframes`` must match the size of
``times``. Times must be in strictly increasing order and start with
zero. Per-joint velocity limits are specified by ``limits``, which
much be the same size ad the number of joints in each element of
``keyframes``. Assumes that velocity limits are equal regardless of
direction. If any step does exceed the maximum velocities in
``limits``, ``times`` will be modified to reduce the velocity.)""";
        } ApplyJointVelocityLimits;
        // Symbol: drake::manipulation::util::EncodeKeyFrames
        struct /* EncodeKeyFrames */ {
          // Source: drake/manipulation/util/robot_plan_utils.h:42
          const char* doc =
R"""(Makes an lcmt_robot_plan message. The entries in ``joint_names``
should be unique, though the behavior if names are duplicated depends
on how the returned plan is evaluated. The size of each vector in
``keyframes`` must match the size of ``joint_names``. The size of
``keyframes`` must match the size of ``times``. Times must be in
strictly increasing order.)""";
        } EncodeKeyFrames;
        // Symbol: drake::manipulation::util::GetJointNames
        struct /* GetJointNames */ {
          // Source: drake/manipulation/util/robot_plan_utils.h:20
          const char* doc =
R"""(Returns:
    A vector of joint names corresponding to the positions in
    ``plant`` in the order of the joint indices. If joints with
    duplicate names exist in different model instance in the plant,
    the names will be duplicated in the output.)""";
        } GetJointNames;
        // Symbol: drake::manipulation::util::MoveIkDemoBase
        struct /* MoveIkDemoBase */ {
          // Source: drake/manipulation/util/move_ik_demo_base.h:30
          const char* doc =
R"""(This class provides some common functionality for generating IK plans
for robot arms, including things like creating a MultibodyPlant,
setting joint velocity limits, implementing a robot status update
handler suitable for invoking from an LCM callback, and generating
plans to move a specified link to a goal configuration.

This can be useful when building simple demonstration programs to move
a robot arm, for example when testing new arms which haven't been
previously used with Drake, or testing modifications to existing robot
configurations. See the kuka_iiwa_arm and kinova_jaco_arm examples for
existing uses.)""";
          // Symbol: drake::manipulation::util::MoveIkDemoBase::HandleStatus
          struct /* HandleStatus */ {
            // Source: drake/manipulation/util/move_ik_demo_base.h:66
            const char* doc =
R"""(Update the current robot status.

Parameter ``q``:
    must be equal to the number of positions in the MultibodyPlant
    (see plant()).)""";
          } HandleStatus;
          // Symbol: drake::manipulation::util::MoveIkDemoBase::MoveIkDemoBase
          struct /* ctor */ {
            // Source: drake/manipulation/util/move_ik_demo_base.h:44
            const char* doc =
R"""(Parameter ``robot_description``:
    A description file to load of the robot to plan.

Parameter ``base_link``:
    Name of the base link of the robot, will be welded to the world in
    the planning model.

Parameter ``ik_link``:
    Name of the link to plan a pose for.

Parameter ``print_interval``:
    Print an updated end effector position every N calls to
    HandleStatus.)""";
          } ctor;
          // Symbol: drake::manipulation::util::MoveIkDemoBase::Plan
          struct /* Plan */ {
            // Source: drake/manipulation/util/move_ik_demo_base.h:74
            const char* doc =
R"""(Attempt to generate a plan moving ik_link (specified at construction
time) from the joint configuration specified in the last call to
``HandleStatus`` to a configuration with ik_link at ``goal_pose``.
Returns nullopt if planning failed.

Raises:
    If HandleStatus has not been invoked.)""";
          } Plan;
          // Symbol: drake::manipulation::util::MoveIkDemoBase::plant
          struct /* plant */ {
            // Source: drake/manipulation/util/move_ik_demo_base.h:52
            const char* doc =
R"""(Returns:
    a reference to the internal plant.)""";
          } plant;
          // Symbol: drake::manipulation::util::MoveIkDemoBase::set_joint_velocity_limits
          struct /* set_joint_velocity_limits */ {
            // Source: drake/manipulation/util/move_ik_demo_base.h:60
            const char* doc =
R"""(Set the joint velocity limts when building the plan. The default
velocity limits from the robot description will be used if this isn't
set.

Precondition:
    The size of the input vector must be equal to the number of
    velocities in the MultibodyPlant (see plant()).)""";
          } set_joint_velocity_limits;
          // Symbol: drake::manipulation::util::MoveIkDemoBase::status_count
          struct /* status_count */ {
            // Source: drake/manipulation/util/move_ik_demo_base.h:78
            const char* doc =
R"""(Returns a count of how many times ``HandleStatus`` has been called.)""";
          } status_count;
        } MoveIkDemoBase;
        // Symbol: drake::manipulation::util::MovingAverageFilter
        struct /* MovingAverageFilter */ {
          // Source: drake/manipulation/util/moving_average_filter.h:33
          const char* doc =
R"""(The implementation of a Moving Average Filter. This discrete time
filter outputs the average of the last n samples i.e. y[k] = 1/n ∑ⱼ
x[k-j] ∀ j = 0..n-1, when n<k and, = 1/k ∑ⱼ x[j] ∀ j = 0..k otherwise;
where n is the window size and x being the discrete-time signal that
is to be filtered, y is the filtered signal and k is the index of
latest element in the signal time-series.

Note that this class is meant to serve as a standalone simple utility
and a filter of this form in a more ``drake::systems`` flavour can be
generated from a ``systems::AffineSystem`` since this is a LTI filter.

Template parameter ``T``:
    The element type. Instantiated templates for the following kinds
    of T's are provided:

- double
- VectorX<double>)""";
          // Symbol: drake::manipulation::util::MovingAverageFilter::MovingAverageFilter<T>
          struct /* ctor */ {
            // Source: drake/manipulation/util/moving_average_filter.h:41
            const char* doc =
R"""(Constructs the filter with the specified ``window_size``.

Parameter ``window_size``:
    The size of the window.

Raises:
    RuntimeError when window_size <= 0.)""";
          } ctor;
          // Symbol: drake::manipulation::util::MovingAverageFilter::Update
          struct /* Update */ {
            // Source: drake/manipulation/util/moving_average_filter.h:51
            const char* doc =
R"""(Updates the average filter result. Every call to this method modifies
the internal state of this filter thus resulting in a computation of
the moving average of the data present within the filter window.

Parameter ``new_data``:
    $Returns:)""";
          } Update;
          // Symbol: drake::manipulation::util::MovingAverageFilter::moving_average
          struct /* moving_average */ {
            // Source: drake/manipulation/util/moving_average_filter.h:58
            const char* doc =
R"""(Returns the most recent result of the averaging filter.)""";
          } moving_average;
          // Symbol: drake::manipulation::util::MovingAverageFilter::window
          struct /* window */ {
            // Source: drake/manipulation/util/moving_average_filter.h:53
            const char* doc = R"""()""";
          } window;
        } MovingAverageFilter;
      } util;
    } manipulation;
    // Symbol: drake::math
    struct /* math */ {
      // Symbol: drake::math::AreQuaternionsEqualForOrientation
      struct /* AreQuaternionsEqualForOrientation */ {
        // Source: drake/math/quaternion.h:164
        const char* doc =
R"""(This function tests whether two quaternions represent the same
orientation. This function converts each quaternion to its canonical
form and tests whether the absolute value of the difference in
corresponding elements of these canonical quaternions is within
tolerance.

Parameter ``quat1``:
    Quaternion [w, x, y, z] that relates two right-handed orthogonal
    unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: quat
    is analogous to the rotation matrix R_AB.

Parameter ``quat2``:
    Quaternion with a description analogous to quat1.

Parameter ``tolerance``:
    Nonnegative real scalar defining the allowable difference in the
    orientation described by quat1 and quat2.

Returns:
    ``True`` if quat1 and quat2 represent the same orientation (to
    within tolerance), otherwise ``False``.)""";
      } AreQuaternionsEqualForOrientation;
      // Symbol: drake::math::AutoDiffToGradientMatrix
      struct /* AutoDiffToGradientMatrix */ {
        // Source: drake/math/autodiff_gradient.h:20
        const char* doc = R"""()""";
        // Symbol: drake::math::AutoDiffToGradientMatrix::type
        struct /* type */ {
          // Source: drake/math/autodiff_gradient.h:24
          const char* doc = R"""()""";
        } type;
      } AutoDiffToGradientMatrix;
      // Symbol: drake::math::AutoDiffToValueMatrix
      struct /* AutoDiffToValueMatrix */ {
        // Source: drake/math/autodiff.h:20
        const char* doc = R"""()""";
        // Symbol: drake::math::AutoDiffToValueMatrix::type
        struct /* type */ {
          // Source: drake/math/autodiff.h:23
          const char* doc = R"""()""";
        } type;
      } AutoDiffToValueMatrix;
      // Symbol: drake::math::BalanceQuadraticForms
      struct /* BalanceQuadraticForms */ {
        // Source: drake/math/quadratic_form.h:108
        const char* doc =
R"""(Given two quadratic forms, x'Sx > 0 and x'Px, (with P symmetric and
full rank), finds a change of variables x = Ty, which simultaneously
diagonalizes both forms (as inspired by "balanced truncation" in
model-order reduction [1]). In this note, we use abs(M) to indicate
the elementwise absolute value.

Adapting from [1], we observe that there is a family of coordinate
systems that can simultaneously diagonalize T'ST and T'PT. Using D to
denote a diagonal matrix, we call the result S-normal if T'ST = I and
abs(T'PT) = D⁻², call it P-normal if T'ST = D² and abs(T'PT) = I, and
call it "balanced" if T'ST = D and abs(T'PT) = D⁻¹. Note that if P >
0, then T'PT = D⁻¹.

We find x=Ty such that T'ST = D and abs(T'PT) = D⁻¹, where D is
diagonal. The recipe is: - Factorize S = LL', and choose R=L⁻¹. - Take
svd(RPR') = UΣV', and note that U=V for positive definite matrices,
and V is U up to a sign flip of the singular vectors for all symmetric
matrices. - Choose T = R'U Σ^{-1/4}, where the matrix exponent can be
taken elementwise because Σ is diagonal. This gives T'ST = Σ^{-1/2}
(by using U'U=I), and abs(T'PT) = Σ^{1/2}. If P > 0, then T'PT =
Σ^{1/2}.

Note that the numerical "balancing" can address the absolute scaling
of the quadratic forms, but not the relative scaling. To understand
this, consider the scalar case: we have two quadratic functions, sx²
and px², with s>0, p>0. We'd like to choose x=Ty so that sT²y² and
pT²y² are "balanced" (we'd like them both to be close to y²). We'll
choose T=p^{-1/4}s^{-1/4}, which gives sx² = sqrt(s/p)y², and px² =
sqrt(p/s)y². For instance if s=1e8 and p=1e8, then t=1e-4 and st^2 =
pt^2 = 1. But if s=10, p=1e7, then t=0.01, and st^2 = 1e-3, pt^2 =
1e3.

In the matrix case, the absolute scaling is important -- it ensures
that the two quadratic forms have the same matrix condition number and
makes them as close as possible to 1. Besides absolute scaling, in the
matrix case the balancing transform diagonalizes both quadratic forms.

[1] B. Moore, “Principal component analysis in linear systems:
Controllability, observability, and model reduction,” IEEE Trans.
Automat. Contr., vol. 26, no. 1, pp. 17–32, Feb. 1981.)""";
      } BalanceQuadraticForms;
      // Symbol: drake::math::BarycentricMesh
      struct /* BarycentricMesh */ {
        // Source: drake/math/barycentric.h:27
        const char* doc =
R"""(Represents a multi-linear function (from vector inputs to vector
outputs) by interpolating between points on a mesh using (triangular)
barycentric interpolation.

For a technical description of barycentric interpolation, see e.g.
Remi Munos and Andrew Moore, "Barycentric Interpolators for Continuous
Space and Time Reinforcement Learning", NIPS 1998)""";
        // Symbol: drake::math::BarycentricMesh::BarycentricMesh<T>
        struct /* ctor */ {
          // Source: drake/math/barycentric.h:57
          const char* doc = R"""(Constructs the mesh.)""";
        } ctor;
        // Symbol: drake::math::BarycentricMesh::Coordinates
        struct /* Coordinates */ {
          // Source: drake/math/barycentric.h:53
          const char* doc =
R"""(The mesh is represented by a std::set (to ensure uniqueness and
provide logarithmic lookups) of coordinates in each input dimension.
Note: The values are type double, not T (We do not plan to take
gradients, etc w/ respect to them).)""";
        } Coordinates;
        // Symbol: drake::math::BarycentricMesh::Eval
        struct /* Eval */ {
          // Source: drake/math/barycentric.h:114
          const char* doc_3args =
R"""(Evaluates the function at the ``input`` values, by interpolating
between the values at ``mesh_values``. Inputs that are outside the
bounding box of the input_grid are interpolated as though they were
projected (elementwise) to the closest face of the defined mesh.

Note that the dimension of the output vector is completely defined by
the mesh_values argument. This class does not maintain any information
related to the size of the output.

Parameter ``mesh_values``:
    is a num_outputs by get_num_mesh_points() matrix containing the
    points to interpolate between. The order of the columns must be
    consistent with the mesh indices curated by this class, as exposed
    by get_mesh_point().

Parameter ``input``:
    must be a vector of length get_num_inputs().

Parameter ``output``:
    is the interpolated vector of length num_outputs)""";
          // Source: drake/math/barycentric.h:119
          const char* doc_2args =
R"""(Returns the function evaluated at ``input``.)""";
        } Eval;
        // Symbol: drake::math::BarycentricMesh::EvalBarycentricWeights
        struct /* EvalBarycentricWeights */ {
          // Source: drake/math/barycentric.h:95
          const char* doc =
R"""(Writes the mesh indices used for interpolation to ``mesh_indices``,
and the interpolating coefficients to ``weights``. Inputs that are
outside the bounding box of the input_grid are interpolated as though
they were projected (elementwise) to the closest face of the defined
mesh.

Parameter ``input``:
    must be a vector of length get_num_inputs().

Parameter ``mesh_indices``:
    is a pointer to a vector of length get_num_interpolants().

Parameter ``weights``:
    is a vector of coefficients (which sum to 1) of length
    get_num_interpolants().)""";
        } EvalBarycentricWeights;
        // Symbol: drake::math::BarycentricMesh::EvalWithMixedScalars
        struct /* EvalWithMixedScalars */ {
          // Source: drake/math/barycentric.h:129
          const char* doc_3args =
R"""(Performs Eval, but with the possibility of the values on the mesh
having a different scalar type than the values defining the mesh
(symbolic::Expression containing decision variables for an
optimization problem is an important example)

Template parameter ``ValueT``:
    defines the scalar type of the mesh_values and the output.

See also:
    Eval)""";
          // Source: drake/math/barycentric.h:150
          const char* doc_2args =
R"""(Returns the function evaluated at ``input``.)""";
        } EvalWithMixedScalars;
        // Symbol: drake::math::BarycentricMesh::MeshGrid
        struct /* MeshGrid */ {
          // Source: drake/math/barycentric.h:54
          const char* doc = R"""()""";
        } MeshGrid;
        // Symbol: drake::math::BarycentricMesh::MeshValuesFrom
        struct /* MeshValuesFrom */ {
          // Source: drake/math/barycentric.h:166
          const char* doc =
R"""(Evaluates ``vector_func`` at all input mesh points and extracts the
mesh value matrix that should be used to approximate the function with
this barycentric interpolation.


::

    MatrixXd mesh_values = bary.MeshValuesFrom(
        [](const auto& x) { return Vector1d(std::sin(x[0])); });)""";
        } MeshValuesFrom;
        // Symbol: drake::math::BarycentricMesh::get_all_mesh_points
        struct /* get_all_mesh_points */ {
          // Source: drake/math/barycentric.h:83
          const char* doc =
R"""(Returns a matrix with all of the mesh points, one per column.)""";
        } get_all_mesh_points;
        // Symbol: drake::math::BarycentricMesh::get_input_grid
        struct /* get_input_grid */ {
          // Source: drake/math/barycentric.h:60
          const char* doc = R"""()""";
        } get_input_grid;
        // Symbol: drake::math::BarycentricMesh::get_input_size
        struct /* get_input_size */ {
          // Source: drake/math/barycentric.h:61
          const char* doc = R"""()""";
        } get_input_size;
        // Symbol: drake::math::BarycentricMesh::get_mesh_point
        struct /* get_mesh_point */ {
          // Source: drake/math/barycentric.h:75
          const char* doc_2args =
R"""(Writes the position of a mesh point in the input space referenced by
its scalar index to ``point``.

Parameter ``index``:
    must be in [0, get_num_mesh_points).

Parameter ``point``:
    is set to the num_inputs-by-1 location of the mesh point.)""";
          // Source: drake/math/barycentric.h:80
          const char* doc_1args =
R"""(Returns the position of a mesh point in the input space referenced by
its scalar index to ``point``.

Parameter ``index``:
    must be in [0, get_num_mesh_points).)""";
        } get_mesh_point;
        // Symbol: drake::math::BarycentricMesh::get_num_interpolants
        struct /* get_num_interpolants */ {
          // Source: drake/math/barycentric.h:69
          const char* doc = R"""()""";
        } get_num_interpolants;
        // Symbol: drake::math::BarycentricMesh::get_num_mesh_points
        struct /* get_num_mesh_points */ {
          // Source: drake/math/barycentric.h:62
          const char* doc = R"""()""";
        } get_num_mesh_points;
      } BarycentricMesh;
      // Symbol: drake::math::BsplineBasis
      struct /* BsplineBasis */ {
        // Source: drake/math/bspline_basis.h:34
        const char* doc =
R"""(Given a set of non-descending breakpoints t₀ ≤ t₁ ≤ ⋅⋅⋅ ≤ tₘ, a
B-spline basis of order k is a set of n + 1 (where n = m - k)
piecewise polynomials of degree k - 1 defined over those breakpoints.
The elements of this set are called "B-splines". The vector (t₀, t₁,
..., tₘ)' is referred to as the "knot vector" of the basis and its
elements are referred to as "knots".

At a breakpoint with multiplicity p (i.e. a breakpoint that appears p
times in the knot vector), B-splines are guaranteed to have Cᵏ⁻ᵖ⁻¹
continuity.

A B-spline curve using a B-spline basis B, is a parametric curve
mapping parameter values in [tₖ₋₁, tₙ₊₁] to a vector space V. For t ∈
[tₖ₋₁, tₙ₊₁] the value of the curve is given by the linear combination
of n + 1 control points, pᵢ ∈ V, with the elements of B evaluated at
t.

For more information on B-splines and their uses, see (for example)
Patrikalakis et al. [1].

[1] https://web.mit.edu/hyperbook/Patrikalakis-Maekawa-Cho/node15.html)""";
        // Symbol: drake::math::BsplineBasis::BsplineBasis<T>
        struct /* ctor */ {
          // Source: drake/math/bspline_basis.h:43
          const char* doc_2args =
R"""(Constructs a B-spline basis with the specified ``order`` and
``knots``.

Precondition:
    ``knots`` is sorted in non-descending order.

Raises:
    ValueError if knots.size() < 2 * order.)""";
          // Source: drake/math/bspline_basis.h:50
          const char* doc_5args =
R"""(Constructs a B-spline basis with the specified ``order``,
`num_basis_functions`, ``initial_parameter_value``,
`final_parameter_value`, and an auto-generated knot vector of the
specified ``type``.

Raises:
    ValueError if num_basis_functions < order

Precondition:
    initial_parameter_value ≤ final_parameter_value)""";
        } ctor;
        // Symbol: drake::math::BsplineBasis::ComputeActiveBasisFunctionIndices
        struct /* ComputeActiveBasisFunctionIndices */ {
          // Source: drake/math/bspline_basis.h:114
          const char* doc_1args_parameter_interval =
R"""(Returns the indices of the basis functions which may evaluate to
non-zero values for some parameter value in ``parameter_interval``;
all other basis functions are strictly zero over
``parameter_interval``.

Precondition:
    parameter_interval[0] ≤ parameter_interval[1]

Precondition:
    parameter_interval[0] ≥ initial_parameter_value()

Precondition:
    parameter_interval[1] ≤ final_parameter_value())""";
          // Source: drake/math/bspline_basis.h:122
          const char* doc_1args_parameter_value =
R"""(Returns the indices of the basis functions which may evaluate to
non-zero values for ``parameter_value``; all other basis functions are
strictly zero at this point.

Precondition:
    parameter_value ≥ initial_parameter_value()

Precondition:
    parameter_value ≤ final_parameter_value())""";
        } ComputeActiveBasisFunctionIndices;
        // Symbol: drake::math::BsplineBasis::EvaluateBasisFunctionI
        struct /* EvaluateBasisFunctionI */ {
          // Source: drake/math/bspline_basis.h:184
          const char* doc =
R"""(Returns the value of the ``i``-th basis function evaluated at
``parameter_value``.)""";
        } EvaluateBasisFunctionI;
        // Symbol: drake::math::BsplineBasis::EvaluateCurve
        struct /* EvaluateCurve */ {
          // Source: drake/math/bspline_basis.h:134
          const char* doc =
R"""(Evaluates the B-spline curve defined by ``this`` and
``control_points`` at the given ``parameter_value``.

Parameter ``control_points``:
    Control points of the B-spline curve.

Parameter ``parameter_value``:
    Parameter value at which to evaluate the B-spline curve defined by
    ``this`` and ``control_points``.

Precondition:
    control_points.size() == num_basis_functions()

Precondition:
    parameter_value ≥ initial_parameter_value()

Precondition:
    parameter_value ≤ final_parameter_value())""";
        } EvaluateCurve;
        // Symbol: drake::math::BsplineBasis::FindContainingInterval
        struct /* FindContainingInterval */ {
          // Source: drake/math/bspline_basis.h:106
          const char* doc =
R"""(For a ``parameter_value`` = t, the interval that contains it is the
pair of knot values [tᵢ, tᵢ₊₁] for the greatest i such that tᵢ ≤ t and
tᵢ < final_parameter_value(). This function returns that value of i.

Precondition:
    parameter_value ≥ initial_parameter_value()

Precondition:
    parameter_value ≤ final_parameter_value())""";
        } FindContainingInterval;
        // Symbol: drake::math::BsplineBasis::Serialize
        struct /* Serialize */ {
          // Source: drake/math/bspline_basis.h:200
          const char* doc =
R"""(Passes this object to an Archive; see serialize_tips for background.
This method is only available when T = double.)""";
        } Serialize;
        // Symbol: drake::math::BsplineBasis::degree
        struct /* degree */ {
          // Source: drake/math/bspline_basis.h:81
          const char* doc =
R"""(The degree of the piecewise polynomials comprising this B-spline basis
(k - 1 in the class description).)""";
        } degree;
        // Symbol: drake::math::BsplineBasis::final_parameter_value
        struct /* final_parameter_value */ {
          // Source: drake/math/bspline_basis.h:97
          const char* doc =
R"""(The maximum allowable parameter value for B-spline curves using this
basis (tₙ₊₁ in the class description).)""";
        } final_parameter_value;
        // Symbol: drake::math::BsplineBasis::initial_parameter_value
        struct /* initial_parameter_value */ {
          // Source: drake/math/bspline_basis.h:93
          const char* doc =
R"""(The minimum allowable parameter value for B-spline curves using this
basis (tₖ₋₁ in the class description).)""";
        } initial_parameter_value;
        // Symbol: drake::math::BsplineBasis::knots
        struct /* knots */ {
          // Source: drake/math/bspline_basis.h:89
          const char* doc =
R"""(The knot vector of this B-spline basis (the vector (t₀, t₁, ..., tₘ)'
in the class description).)""";
        } knots;
        // Symbol: drake::math::BsplineBasis::num_basis_functions
        struct /* num_basis_functions */ {
          // Source: drake/math/bspline_basis.h:85
          const char* doc =
R"""(The number of basis functions in this B-spline basis (n + 1 in the
class description).)""";
        } num_basis_functions;
        // Symbol: drake::math::BsplineBasis::operator!=
        struct /* operator_ne */ {
          // Source: drake/math/bspline_basis.h:188
          const char* doc = R"""()""";
        } operator_ne;
        // Symbol: drake::math::BsplineBasis::order
        struct /* order */ {
          // Source: drake/math/bspline_basis.h:77
          const char* doc =
R"""(The order of this B-spline basis (k in the class description).)""";
        } order;
      } BsplineBasis;
      // Symbol: drake::math::CalculateAngularVelocityExpressedInBFromQuaternionDt
      struct /* CalculateAngularVelocityExpressedInBFromQuaternionDt */ {
        // Source: drake/math/quaternion.h:222
        const char* doc =
R"""(This function calculates angular velocity from a quaternion and its
time- derivative. Algorithm from [Kane, 1983] Section 1.13, Pages
58-59.

- [Kane, 1983] "Spacecraft Dynamics," McGraw-Hill Book Co., New York, 1983.
  (with P. W. Likins and D. A. Levinson).  Available for free .pdf download:
  https://ecommons.cornell.edu/handle/1813/637

Parameter ``quat_AB``:
    Quaternion [w, x, y, z] that relates two right-handed orthogonal
    unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note:
    quat_AB is analogous to the rotation matrix R_AB.

Parameter ``quatDt``:
    Time-derivative of ``quat_AB``, i.e. [ẇ, ẋ, ẏ, ż].

Returns ``w_AB_B``:
    B's angular velocity in A, expressed in B.)""";
      } CalculateAngularVelocityExpressedInBFromQuaternionDt;
      // Symbol: drake::math::CalculateQuaternionDtConstraintViolation
      struct /* CalculateQuaternionDtConstraintViolation */ {
        // Source: drake/math/quaternion.h:256
        const char* doc =
R"""(This function calculates how well a quaternion and its time-derivative
satisfy the quaternion time-derivative constraint specified in [Kane,
1983] Section 1.13, equations 12-13, page 59. For a quaternion [w, x,
y, z], the quaternion must satisfy: w^2 + x^2 + y^2 + z^2 = 1, hence
its time-derivative must satisfy: 2*(w*ẇ + x*ẋ + y*ẏ + z*ż) = 0.

- [Kane, 1983] "Spacecraft Dynamics," McGraw-Hill Book Co., New York, 1983.
  (with P. W. Likins and D. A. Levinson).  Available for free .pdf download:
  https://ecommons.cornell.edu/handle/1813/637

Parameter ``quat``:
    Quaternion [w, x, y, z] that relates two right-handed orthogonal
    unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: A
    quaternion like quat_AB is analogous to the rotation matrix R_AB.

Parameter ``quatDt``:
    Time-derivative of ``quat``, i.e., [ẇ, ẋ, ẏ, ż].

Returns ``quaternionDt_constraint_violation``:
    The amount the time- derivative of the quaternion constraint has
    been violated, which may be positive or negative (0 means the
    constraint is perfectly satisfied).)""";
      } CalculateQuaternionDtConstraintViolation;
      // Symbol: drake::math::CalculateQuaternionDtFromAngularVelocityExpressedInB
      struct /* CalculateQuaternionDtFromAngularVelocityExpressedInB */ {
        // Source: drake/math/quaternion.h:190
        const char* doc =
R"""(This function calculates a quaternion's time-derivative from its
quaternion and angular velocity. Algorithm from [Kane, 1983] Section
1.13, Pages 58-59.

- [Kane, 1983] "Spacecraft Dynamics," McGraw-Hill Book Co., New York, 1983.
  (With P. W. Likins and D. A. Levinson).  Available for free .pdf download:
  https://ecommons.cornell.edu/handle/1813/637

Parameter ``quat_AB``:
    Quaternion [w, x, y, z] that relates two right-handed orthogonal
    unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note:
    quat_AB is analogous to the rotation matrix R_AB.

Parameter ``w_AB_B``:
    B's angular velocity in A, expressed in B.

Returns ``quatDt``:
    Time-derivative of quat_AB, i.e., [ẇ, ẋ, ẏ, ż].)""";
      } CalculateQuaternionDtFromAngularVelocityExpressedInB;
      // Symbol: drake::math::CalculateReflectedGrayCodes
      struct /* CalculateReflectedGrayCodes */ {
        // Source: drake/math/gray_code.h:35
        const char* doc =
R"""(Returns a matrix whose i'th row is the Gray code for integer i.

Template parameter ``NumDigits``:
    The number of digits in the Gray code.

Parameter ``num_digits``:
    The number of digits in the Gray code.

Returns:
    M. M is a matrix of size 2ᵏ x k, where ``k`` is ``num_digits``.
    M.row(i) is the Gray code for integer i.)""";
      } CalculateReflectedGrayCodes;
      // Symbol: drake::math::ClosestQuaternion
      struct /* ClosestQuaternion */ {
        // Source: drake/math/quaternion.h:32
        const char* doc =
R"""(Returns a unit quaternion that represents the same orientation as
``q1``, and has the "shortest" geodesic distance on the unit sphere to
``q0``.)""";
      } ClosestQuaternion;
      // Symbol: drake::math::ComputeBasisFromAxis
      struct /* ComputeBasisFromAxis */ {
        // Source: drake/math/orthonormal_basis.h:25
        const char* doc =
R"""(Creates a right-handed local basis from a given axis. Defines two
other arbitrary axes such that the basis is orthonormal. The basis is
R_WL, where W is the frame in which the input axis is expressed and L
is a local basis such that v_W = R_WL * v_L.

Parameter ``axis_index``:
    The index of the axis (in the range [0,2]), with 0 corresponding
    to the x-axis, 1 corresponding to the y-axis, and z-corresponding
    to the z-axis.

Parameter ``axis_W``:
    The vector defining the basis's given axis expressed in frame W.
    The vector need not be a unit vector: this routine will normalize
    it.

Returns ``R_WL``:
    The computed basis.

Raises:
    RuntimeError if the norm of ``axis_W`` is within 1e-10 to zero or
    ``axis_index`` does not lie in the range [0,2].)""";
      } ComputeBasisFromAxis;
      // Symbol: drake::math::ComputeNumericalGradient
      struct /* ComputeNumericalGradient */ {
        // Source: drake/math/compute_numerical_gradient.h:94
        const char* doc =
R"""(Compute the gradient of a function f(x) through numerical difference.

Parameter ``calc_fun``:
    calc_fun(x, &y) computes the value of f(x), and stores the value
    in y. ``calc_fun`` is responsible for properly resizing the output
    ``y`` when it consists of an Eigen vector of Eigen::Dynamic size.

Parameter ``x``:
    The point at which the numerical gradient is computed.

Parameter ``option``:
    The options for computing numerical gradient.

Template parameter ``DerivedX``:
    an Eigen column vector.

Template parameter ``DerivedY``:
    an Eigen column vector.

Template parameter ``DerivedCalcX``:
    The type of x in the calc_fun. Must be an Eigen column vector. It
    is possible to have DerivedCalcX being different from DerivedX,
    for example, ``calc_fun`` could be solvers::EvaluatorBase(const
    Eigen::Ref<const Eigen::VectorXd>&, Eigen::VectorXd*), but ``x``
    could be of type Eigen::VectorXd. TODO(hongkai.dai): understand
    why the default template DerivedCalcX = DerivedX doesn't compile
    when I instantiate ComputeNumericalGradient<DerivedX,
    DerivedY>(calc_fun, x);

Returns ``gradient``:
    a matrix of size x.rows() x y.rows(). gradient(i, j) is ∂f(i) /
    ∂x(j)

Examples:


::

    {cc}
    // Create a std::function from a lambda expression.
    std::function<void (const Eigen::Vector2d&, Vector3d*)> foo = [](const
    Eigen::Vector2d& x, Vector3d*y) { (*y)(0) = x(0); (*y)(1) = x(0) * x(1);
    (*y)(2) = x(0) * std::sin(x(1));};
    Eigen::Vector3d x_eval(1, 2, 3);
    auto J = ComputeNumericalGradient(foo, x_eval);
    // Note that if we pass in a lambda to ComputeNumericalGradient, then
    // ComputeNumericalGradient has to instantiate the template types explicitly,
    // as in this example. The issue of template deduction with std::function is
    // explained in
    //
    https://stackoverflow.com/questions/48529410/template-arguments-deduction-failed-passing-func-pointer-to-stdfunction
    auto bar = [](const Eigen::Vector2d& x, Eigen::Vector2d* y) {*y = x; };
    auto J2 = ComputeNumericalGradient<Eigen::Vector2d,
    Eigen::Vector2d, Eigen::Vector2d>(bar, Eigen::Vector2d(2, 3));)""";
      } ComputeNumericalGradient;
      // Symbol: drake::math::ContinuousAlgebraicRiccatiEquation
      struct /* ContinuousAlgebraicRiccatiEquation */ {
        // Source: drake/math/continuous_algebraic_riccati_equation.h:20
        const char* doc_4args_A_B_Q_R =
R"""(Computes the unique stabilizing solution S to the continuous-time
algebraic Riccati equation:

.. math:: S A + A' S - S B R^{-1} B' S + Q = 0

Raises:
    RuntimeError if R is not positive definite.

Based on the Matrix Sign Function method outlined in this paper:
http://www.engr.iupui.edu/~skoskie/ECE684/Riccati_algorithms.pdf)""";
        // Source: drake/math/continuous_algebraic_riccati_equation.h:29
        const char* doc_4args_A_B_Q_R_cholesky =
R"""(This is functionally the same as ContinuousAlgebraicRiccatiEquation(A,
B, Q, R). The Cholesky decomposition of R is passed in instead of R.)""";
      } ContinuousAlgebraicRiccatiEquation;
      // Symbol: drake::math::ConvertTimeDerivativeToOtherFrame
      struct /* ConvertTimeDerivativeToOtherFrame */ {
        // Source: drake/math/convert_time_derivative.h:34
        const char* doc =
R"""(Given ᴮd/dt(v) (the time derivative in frame B of an arbitrary 3D
vector v) and given ᴬωᴮ (frame B's angular velocity in another frame
A), this method computes ᴬd/dt(v) (the time derivative in frame A of
v) by: ᴬd/dt(v) = ᴮd/dt(v) + ᴬωᴮ x v

This mathematical operation is known as the "Transport Theorem" or the
"Golden Rule for Vector Differentiation" [Mitiguy 2016, §7.3]. It was
discovered by Euler in 1758. Its explicit notation with superscript
frames was invented by Thomas Kane in 1950. Its use as the defining
property of angular velocity was by Mitiguy in 1993.

In source code and comments, we use the following monogram notations:
DtA_v = ᴬd/dt(v) denotes the time derivative in frame A of the vector
v. DtA_v_E = [ᴬd/dt(v)]_E denotes the time derivative in frame A of
vector v, with the resulting new vector quantity expressed in a frame
E.

In source code, this mathematical operation is performed with all
vectors expressed in the same frame E as [ᴬd/dt(v)]ₑ = [ᴮd/dt(v)]ₑ +
[ᴬωᴮ]ₑ x [v]ₑ which in monogram notation is:


::

    DtA_v_E = DtB_v_E + w_AB_E x v_E

[Mitiguy 2016] Mitiguy, P., 2016. Advanced Dynamics & Motion
Simulation.)""";
      } ConvertTimeDerivativeToOtherFrame;
      // Symbol: drake::math::DecomposePSDmatrixIntoXtransposeTimesX
      struct /* DecomposePSDmatrixIntoXtransposeTimesX */ {
        // Source: drake/math/quadratic_form.h:25
        const char* doc =
R"""(For a symmetric positive semidefinite matrix Y, decompose it into XᵀX,
where the number of rows in X equals to the rank of Y. Notice that
this decomposition is not unique. For any orthonormal matrix U, s.t
UᵀU = identity, X_prime = UX also satisfies X_primeᵀX_prime = Y. Here
we only return one valid decomposition.

Parameter ``Y``:
    A symmetric positive semidefinite matrix.

Parameter ``zero_tol``:
    We will need to check if some value (for example, the absolute
    value of Y's eigenvalues) is smaller than zero_tol. If it is, then
    we deem that value as 0.

Returns ``X``:
    . The matrix X satisfies XᵀX = Y and X.rows() = rank(Y).

Precondition:
1. Y is positive semidefinite.
     2. zero_tol is non-negative.

    $Raises:

RuntimeError when the pre-conditions are not satisfied.

Note:
    We only use the lower triangular part of Y.)""";
      } DecomposePSDmatrixIntoXtransposeTimesX;
      // Symbol: drake::math::DecomposePositiveQuadraticForm
      struct /* DecomposePositiveQuadraticForm */ {
        // Source: drake/math/quadratic_form.h:64
        const char* doc =
R"""(Rewrite a quadratic form xᵀQx + bᵀx + c to (Rx+d)ᵀ(Rx+d) where RᵀR = Q
Rᵀd = b / 2 Notice that this decomposition is not unique. For example,
with any permutation matrix P, we can define R₁ = P*R d₁ = P*d Then
(R₁*x+d₁)ᵀ(R₁*x+d₁) gives the same quadratic form.

Parameter ``Q``:
    The square matrix.

Parameter ``b``:
    The vector containing the linear coefficients.

Parameter ``c``:
    The constatnt term.

Parameter ``tol``:
    We will determine if this quadratic form is always non-negative,
    by checking the Eigen values of the matrix [Q b/2] [bᵀ/2 c] are
    all greater than -tol. $*Default:* is 0.

Returns ``(R``:
    , d). R and d have the same number of rows. R.cols() == x.rows().
    The matrix X = [R d] has the same number of rows as the rank of


::

    [Q    b/2]
       [bᵀ/2   c]

Precondition:
1. The quadratic form is always non-negative, namely the matrix
        


::

    [Q    b/2]
            [bᵀ/2   c]

is positive semidefinite. 2. ``Q`` and ``b`` are of the correct size.
3. ``tol`` is non-negative.

Raises:
    RuntimeError if the precondition is not satisfied.)""";
      } DecomposePositiveQuadraticForm;
      // Symbol: drake::math::DiscardGradient
      struct /* DiscardGradient */ {
        // Source: drake/math/autodiff.h:59
        const char* doc_was_unable_to_choose_unambiguous_names =
R"""(`B = DiscardGradient(A)` enables casting from a matrix of
AutoDiffScalars to AutoDiffScalar::Scalar type, explicitly throwing
away any gradient information. For a matrix of type, e.g.
``MatrixX<AutoDiffXd> A``, the comparable operation ``B =
A.cast<double>()`` should (and does) fail to compile. Use
``DiscardGradient(A)`` if you want to force the cast (and explicitly
declare that information is lost).

This method is overloaded to permit the user to call it for double
types and AutoDiffScalar types (to avoid the calling function having
to handle the two cases differently).

See also:
    DiscardZeroGradient)""";
      } DiscardGradient;
      // Symbol: drake::math::DiscardZeroGradient
      struct /* DiscardZeroGradient */ {
        // Source: drake/math/autodiff_gradient.h:165
        const char* doc_2args_constEigenMatrixBase_consttypenameEigenNumTraitsReal =
R"""(`B = DiscardZeroGradient(A, precision)` enables casting from a matrix
of AutoDiffScalars to AutoDiffScalar::Scalar type, but first checking
that the gradient matrix is empty or zero. For a matrix of type, e.g.
``MatrixX<AutoDiffXd> A``, the comparable operation ``B =
A.cast<double>()`` should (and does) fail to compile. Use
``DiscardZeroGradient(A)`` if you want to force the cast (and the
check).

This method is overloaded to permit the user to call it for double
types and AutoDiffScalar types (to avoid the calling function having
to handle the two cases differently).

Parameter ``precision``:
    is passed to Eigen's isZero(precision) to evaluate whether the
    gradients are zero.

Raises:
    RuntimeError if the gradients were not empty nor zero.

See also:
    DiscardGradient)""";
        // Source: drake/math/autodiff_gradient.h:182
        const char* doc_2args_constEigenMatrixBase_double =
R"""(See also:
    DiscardZeroGradient().)""";
      } DiscardZeroGradient;
      // Symbol: drake::math::DiscreteAlgebraicRiccatiEquation
      struct /* DiscreteAlgebraicRiccatiEquation */ {
        // Source: drake/math/discrete_algebraic_riccati_equation.h:25
        const char* doc =
R"""(Computes the unique stabilizing solution X to the discrete-time
algebraic Riccati equation:

.. math:: A'XA - X - A'XB(B'XB+R)^{-1}B'XA + Q = 0

Raises:
    RuntimeError if Q is not positive semi-definite.

Raises:
    RuntimeError if R is not positive definite.

Based on the Schur Vector approach outlined in this paper: "On the
Numerical Solution of the Discrete-Time Algebraic Riccati Equation" by
Thrasyvoulos Pappas, Alan J. Laub, and Nils R. Sandell)""";
      } DiscreteAlgebraicRiccatiEquation;
      // Symbol: drake::math::GetSubMatrixGradientArray
      struct /* GetSubMatrixGradientArray */ {
        // Source: drake/math/gradient_util.h:61
        const char* doc = R"""()""";
        // Symbol: drake::math::GetSubMatrixGradientArray::type
        struct /* type */ {
          // Source: drake/math/gradient_util.h:65
          const char* doc = R"""()""";
        } type;
      } GetSubMatrixGradientArray;
      // Symbol: drake::math::GetSubMatrixGradientSingleElement
      struct /* GetSubMatrixGradientSingleElement */ {
        // Source: drake/math/gradient_util.h:72
        const char* doc = R"""()""";
        // Symbol: drake::math::GetSubMatrixGradientSingleElement::type
        struct /* type */ {
          // Source: drake/math/gradient_util.h:76
          const char* doc = R"""()""";
        } type;
      } GetSubMatrixGradientSingleElement;
      // Symbol: drake::math::Gradient
      struct /* Gradient */ {
        // Source: drake/math/gradient.h:16
        const char* doc = R"""()""";
        // Symbol: drake::math::Gradient::type
        struct /* type */ {
          // Source: drake/math/gradient.h:23
          const char* doc = R"""()""";
        } type;
      } Gradient;
      // Symbol: drake::math::GrayCodeToInteger
      struct /* GrayCodeToInteger */ {
        // Source: drake/math/gray_code.h:59
        const char* doc =
R"""(Converts the Gray code to an integer. For example (0, 0) -> 0 (0, 1)
-> 1 (1, 1) -> 2 (1, 0) -> 3

Parameter ``gray_code``:
    The N-digit Gray code, where N is gray_code.rows()

Returns:
    The integer represented by the Gray code ``gray_code``.)""";
      } GrayCodeToInteger;
      // Symbol: drake::math::GrayCodesMatrix
      struct /* GrayCodesMatrix */ {
        // Source: drake/math/gray_code.h:14
        const char* doc =
R"""(GrayCodesMatrix::type returns an Eigen matrix of integers. The size of
this matrix is determined by the number of digits in the Gray code.)""";
        // Symbol: drake::math::GrayCodesMatrix::type
        struct /* type */ {
          // Source: drake/math/gray_code.h:18
          const char* doc = R"""()""";
        } type;
      } GrayCodesMatrix;
      // Symbol: drake::math::HopfCoordinateToQuaternion
      struct /* HopfCoordinateToQuaternion */ {
        // Source: drake/math/hopf_coordinate.h:34
        const char* doc =
R"""(Transforms Hopf coordinates to a quaternion w, x, y, z as w =
cos(θ/2)cos(ψ/2) x = cos(θ/2)sin(ψ/2) y = sin(θ/2)cos(φ+ψ/2) z =
sin(θ/2)sin(φ+ψ/2) The user can refer to equation 5 of Generating
Uniform Incremental Grids on SO(3) Using the Hopf Fibration by Anna
Yershova, Steven LaValle and Julie Mitchell, 2008

Parameter ``theta``:
    The θ angle.

Parameter ``phi``:
    The φ angle.

Parameter ``psi``:
    The ψ angle.)""";
      } HopfCoordinateToQuaternion;
      // Symbol: drake::math::IsBothQuaternionAndQuaternionDtOK
      struct /* IsBothQuaternionAndQuaternionDtOK */ {
        // Source: drake/math/quaternion.h:307
        const char* doc =
R"""(This function tests if a quaternion satisfies the time-derivative
constraint specified in [Kane, 1983] Section 1.13, equation 13, page
59. A quaternion [w, x, y, z] must satisfy w^2 + x^2 + y^2 + z^2 = 1,
hence its time-derivative must satisfy 2*(w*ẇ + x*ẋ + y*ẏ + z*ż) =
0. Note: To accurately test whether the time-derivative quaternion
constraint is satisfied, the quaternion constraint is also tested to
be accurate.

- [Kane, 1983] "Spacecraft Dynamics," McGraw-Hill Book Co., New York, 1983.
  (with P. W. Likins and D. A. Levinson).  Available for free .pdf download:
  https://ecommons.cornell.edu/handle/1813/637

Parameter ``quat``:
    Quaternion [w, x, y, z] that relates two right-handed orthogonal
    unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: A
    quaternion like quat_AB is analogous to the rotation matrix R_AB.

Parameter ``quatDt``:
    Time-derivative of ``quat``, i.e., [ẇ, ẋ, ẏ, ż].

Parameter ``tolerance``:
    Tolerance for quaternion constraints.

Returns:
    ``True`` if both of the two previous constraints are within
    tolerance.)""";
      } IsBothQuaternionAndQuaternionDtOK;
      // Symbol: drake::math::IsPositiveDefinite
      struct /* IsPositiveDefinite */ {
        // Source: drake/math/matrix_util.h:133
        const char* doc =
R"""(Checks if a matrix is symmetric (with tolerance ``symmetry_tolerance``
--

See also:
    IsSymmetric) and has all eigenvalues greater than
    ``eigenvalue_tolerance``. ``eigenvalue_tolerance`` must be >= 0 --
    where 0 implies positive semi-definite (but is of course subject
    to all of the pitfalls of floating point).

To consider the numerical robustness of the eigenvalue estimation, we
specifically check that min_eigenvalue >= eigenvalue_tolerance *
max(1, max_abs_eigenvalue).)""";
      } IsPositiveDefinite;
      // Symbol: drake::math::IsQuaternionAndQuaternionDtEqualAngularVelocityExpressedInB
      struct /* IsQuaternionAndQuaternionDtEqualAngularVelocityExpressedInB */ {
        // Source: drake/math/quaternion.h:336
        const char* doc =
R"""(This function tests if a quaternion and a quaternions time-derivative
can calculate and match an angular velocity to within a tolerance.
Note: This function first tests if the quaternion [w, x, y, z]
satisfies w^2 + x^2 + y^2 + z^2 = 1 (to within tolerance) and if its
time-derivative satisfies w*ẇ + x*ẋ + y*ẏ + z*ż = 0 (to within
tolerance). Lastly, it tests if each element of the angular velocity
calculated from quat and quatDt is within tolerance of w_B (described
below).

Parameter ``quat``:
    Quaternion [w, x, y, z] that relates two right-handed orthogonal
    unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: A
    quaternion like quat_AB is analogous to the rotation matrix R_AB.

Parameter ``quatDt``:
    Time-derivative of ``quat``, i.e., [ẇ, ẋ, ẏ, ż].

Parameter ``w_B``:
    Rigid body B's angular velocity in frame A, expressed in B.

Parameter ``tolerance``:
    Tolerance for quaternion constraints.

Returns:
    ``True`` if all three of the previous constraints are within
    tolerance.)""";
      } IsQuaternionAndQuaternionDtEqualAngularVelocityExpressedInB;
      // Symbol: drake::math::IsQuaternionValid
      struct /* IsQuaternionValid */ {
        // Source: drake/math/quaternion.h:280
        const char* doc =
R"""(This function tests if a quaternion satisfies the quaternion
constraint specified in [Kane, 1983] Section 1.3, equation 4, page 12,
i.e., a quaternion [w, x, y, z] must satisfy: w^2 + x^2 + y^2 + z^2 =
1.

- [Kane, 1983] "Spacecraft Dynamics," McGraw-Hill Book Co., New York, 1983.
  (with P. W. Likins and D. A. Levinson).  Available for free .pdf download:
  https://ecommons.cornell.edu/handle/1813/637

Parameter ``quat``:
    Quaternion [w, x, y, z] that relates two right-handed orthogonal
    unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: A
    quaternion like quat_AB is analogous to the rotation matrix R_AB.

Parameter ``tolerance``:
    Tolerance for quaternion constraint, i.e., how much is w^2 + x^2 +
    y^2 + z^2 allowed to differ from 1.

Returns:
    ``True`` if the quaternion constraint is satisfied within
    tolerance.)""";
      } IsQuaternionValid;
      // Symbol: drake::math::IsSymmetric
      struct /* IsSymmetric */ {
        // Source: drake/math/matrix_util.h:18
        const char* doc_1args =
R"""(Determines if a matrix is symmetric. If std::equal_to<>()(matrix(i,
j), matrix(j, i)) is true for all i, j, then the matrix is symmetric.)""";
        // Source: drake/math/matrix_util.h:38
        const char* doc_2args =
R"""(Determines if a matrix is symmetric based on whether the difference
between matrix(i, j) and matrix(j, i) is smaller than ``precision``
for all i, j. The precision is absolute. Matrix with nan or inf
entries is not allowed.)""";
      } IsSymmetric;
      // Symbol: drake::math::KnotVectorType
      struct /* KnotVectorType */ {
        // Source: drake/math/knot_vector_type.h:14
        const char* doc =
R"""(Enum representing types of knot vectors. "Uniform" refers to the
spacing between the knots. "Clamped" indicates that the first and last
knots have multiplicity equal to the order of the spline.

Reference:
http://web.mit.edu/hyperbook/Patrikalakis-Maekawa-Cho/node17.html)""";
        // Symbol: drake::math::KnotVectorType::kClampedUniform
        struct /* kClampedUniform */ {
          // Source: drake/math/knot_vector_type.h:14
          const char* doc = R"""()""";
        } kClampedUniform;
        // Symbol: drake::math::KnotVectorType::kUniform
        struct /* kUniform */ {
          // Source: drake/math/knot_vector_type.h:14
          const char* doc = R"""()""";
        } kUniform;
      } KnotVectorType;
      // Symbol: drake::math::MatGradMult
      struct /* MatGradMult */ {
        // Source: drake/math/gradient_util.h:43
        const char* doc = R"""()""";
        // Symbol: drake::math::MatGradMult::type
        struct /* type */ {
          // Source: drake/math/gradient_util.h:52
          const char* doc = R"""()""";
        } type;
      } MatGradMult;
      // Symbol: drake::math::MatGradMultMat
      struct /* MatGradMultMat */ {
        // Source: drake/math/gradient_util.h:28
        const char* doc = R"""()""";
        // Symbol: drake::math::MatGradMultMat::type
        struct /* type */ {
          // Source: drake/math/gradient_util.h:36
          const char* doc = R"""()""";
        } type;
      } MatGradMultMat;
      // Symbol: drake::math::NormalizeVector
      struct /* NormalizeVector */ {
        // Source: drake/math/normalize_vector.h:24
        const char* doc =
R"""(Computes the normalized vector, optionally with its gradient and
second derivative.

Parameter ``x``:
    An N x 1 vector to be normalized. Must not be zero.

Parameter ``x_norm``:
    The normalized vector (N x 1).

Parameter ``dx_norm``:
    If non-null, returned as an N x N matrix, where dx_norm(i,j) = D
    x_norm(i)/D x(j).

Parameter ``ddx_norm``:
    If non-null, and dx_norm is non-null, returned as an N^2 x N
    matrix, where ddx_norm.col(j) = D dx_norm/D x(j), with dx_norm
    stacked columnwise.

(D x / D y above means partial derivative of x with respect to y.))""";
      } NormalizeVector;
      // Symbol: drake::math::NumericalGradientMethod
      struct /* NumericalGradientMethod */ {
        // Source: drake/math/compute_numerical_gradient.h:10
        const char* doc = R"""()""";
        // Symbol: drake::math::NumericalGradientMethod::kBackward
        struct /* kBackward */ {
          // Source: drake/math/compute_numerical_gradient.h:12
          const char* doc =
R"""(Compute the gradient as (f(x) - f(x - Δx)) / Δx, with Δx > 0)""";
        } kBackward;
        // Symbol: drake::math::NumericalGradientMethod::kCentral
        struct /* kCentral */ {
          // Source: drake/math/compute_numerical_gradient.h:13
          const char* doc =
R"""(Compute the gradient as (f(x + Δx) - f(x - Δx)) / (2Δx), with Δx > 0)""";
        } kCentral;
        // Symbol: drake::math::NumericalGradientMethod::kForward
        struct /* kForward */ {
          // Source: drake/math/compute_numerical_gradient.h:11
          const char* doc =
R"""(Compute the gradient as (f(x + Δx) - f(x)) / Δx, with Δx > 0)""";
        } kForward;
      } NumericalGradientMethod;
      // Symbol: drake::math::NumericalGradientOption
      struct /* NumericalGradientOption */ {
        // Source: drake/math/compute_numerical_gradient.h:17
        const char* doc = R"""()""";
        // Symbol: drake::math::NumericalGradientOption::NumericalGradientOption
        struct /* ctor */ {
          // Source: drake/math/compute_numerical_gradient.h:24
          const char* doc =
R"""(Parameter ``function_accuracy``:
    The accuracy of evaluating function f(x). For double-valued
    functions (with magnitude around 1), the accuracy is usually about
    1E-15.)""";
        } ctor;
        // Symbol: drake::math::NumericalGradientOption::method
        struct /* method */ {
          // Source: drake/math/compute_numerical_gradient.h:32
          const char* doc = R"""()""";
        } method;
        // Symbol: drake::math::NumericalGradientOption::perturbation_size
        struct /* perturbation_size */ {
          // Source: drake/math/compute_numerical_gradient.h:34
          const char* doc = R"""()""";
        } perturbation_size;
      } NumericalGradientOption;
      // Symbol: drake::math::ProjectMatToRotMatWithAxis
      struct /* ProjectMatToRotMatWithAxis */ {
        // Source: drake/math/rotation_matrix.h:994
        const char* doc =
R"""(Projects an approximate 3 x 3 rotation matrix M onto an orthonormal
matrix R so that R is a rotation matrix associated with a angle-axis
rotation by an angle θ about a vector direction ``axis``, with
``angle_lb <= θ <= angle_ub``.

Template parameter ``Derived``:
    A 3 x 3 matrix

Parameter ``M``:
    the matrix to be projected.

Parameter ``axis``:
    vector direction associated with angle-axis rotation for R. axis
    can be a non-unit vector, but cannot be the zero vector.

Parameter ``angle_lb``:
    the lower bound of the rotation angle θ.

Parameter ``angle_ub``:
    the upper bound of the rotation angle θ.

Returns:
    Rotation angle θ of the projected matrix, angle_lb <= θ <=
    angle_ub

Raises:
    RuntimeError if M is not a 3 x 3 matrix or if axis is the zero
    vector or if angle_lb > angle_ub.

Note:
    This method is useful for reconstructing a rotation matrix for a
    revolute joint with joint limits.

Note:
    This can be formulated as an optimization problem


::

    min_θ trace((R - M)ᵀ*(R - M))
      subject to R = I + sinθ * A + (1 - cosθ) * A²   (1)
                 angle_lb <= θ <= angle_ub

where A is the cross product matrix of a = axis / axis.norm() = [a₁,
a₂, a₃]


::

    A = [ 0  -a₃  a₂]
        [ a₃  0  -a₁]
        [-a₂  a₁  0 ]

Equation (1) is the Rodriguez Formula that computes the rotation
matrix R from the angle-axis rotation with angle θ and vector
direction ``axis``. For details, see
http://mathworld.wolfram.com/RodriguesRotationFormula.html The
objective function can be simplified as


::

    max_θ trace(Rᵀ * M + Mᵀ * R)

By substituting the matrix ``R`` with the angle-axis representation,
the optimization problem is formulated as


::

    max_θ sinθ * trace(Aᵀ*M) - cosθ * trace(Mᵀ * A²)
       subject to angle_lb <= θ <= angle_ub

By introducing α = atan2(-trace(Mᵀ * A²), trace(Aᵀ*M)), we can compute
the optimal θ as


::

    θ = π/2 + 2kπ - α, if angle_lb <= π/2 + 2kπ - α <= angle_ub, k ∈ integers
    else
       θ = angle_lb, if sin(angle_lb + α) >= sin(angle_ub + α)
       θ = angle_ub, if sin(angle_lb + α) <  sin(angle_ub + α)

See also:
    GlobalInverseKinematics for an usage of this function.)""";
      } ProjectMatToRotMatWithAxis;
      // Symbol: drake::math::QuaternionToCanonicalForm
      struct /* QuaternionToCanonicalForm */ {
        // Source: drake/math/quaternion.h:142
        const char* doc =
R"""(This function returns a quaternion in its "canonical form" meaning
that it returns a quaternion [w, x, y, z] with a non-negative w. For
example, if passed a quaternion [-0.3, +0.4, +0.5, +0.707], the
function returns the quaternion's canonical form [+0.3, -0.4, -0.5,
-0.707].

Parameter ``quat``:
    Quaternion [w, x, y, z] that relates two right-handed orthogonal
    unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: quat
    is analogous to the rotation matrix R_AB.

Returns:
    Canonical form of quat, which means that either the original quat
    is returned or a quaternion representing the same orientation but
    with negated [w, x, y, z], to ensure a positive w in returned
    quaternion.)""";
      } QuaternionToCanonicalForm;
      // Symbol: drake::math::QuaternionToHopfCoordinate
      struct /* QuaternionToHopfCoordinate */ {
        // Source: drake/math/hopf_coordinate.h:63
        const char* doc =
R"""(Convert a unit-length quaternion (w, x, y, z) to Hopf coordinate as if
w >= 0 ψ = 2*atan2(x, w) else ψ = 2*atan2(-x, -w) φ = mod(atan2(z, y)
- ψ/2, 2pi) θ = 2*atan2(√(y²+z²), √(w²+x²)) ψ is in the range of [-pi,
pi]. φ is in the range of [0, 2pi]. θ is in the range of [0, pi].

Parameter ``quaternion``:
    A unit length quaternion.

Returns:
    hopf_coordinate (θ, φ, ψ) as an Eigen vector.)""";
      } QuaternionToHopfCoordinate;
      // Symbol: drake::math::RealContinuousLyapunovEquation
      struct /* RealContinuousLyapunovEquation */ {
        // Source: drake/math/continuous_lyapunov_equation.h:55
        const char* doc =
R"""(Parameter ``A``:
    A user defined real square matrix.

Parameter ``Q``:
    A user defined real symmetric matrix.

Precondition:
    Q is a symmetric matrix.

Computes a unique solution X to the continuous Lyapunov equation:
``AᵀX + XA + Q = 0``, where A is real and square, and Q is real,
symmetric and of equal size as A.

Raises:
    RuntimeError if A or Q are not square matrices or do not have the
    same size.

Limitations: Given the Eigenvalues of A as λ₁, ..., λₙ, there exists a
unique solution if and only if λᵢ + λ̅ⱼ ≠ 0 ∀ i,j, where λ̅ⱼ is the
complex conjugate of λⱼ.

Raises:
    RuntimeError if the solution is not unique.

There are no further limitations on the eigenvalues of A. Further, if
all λᵢ have negative real parts, and if Q is positive semi-definite,
then X is also positive semi-definite [1]. Therefore, if one searches
for a Lyapunov function V(z) = zᵀXz for the stable linear system ż =
Az, then the solution of the Lyapunov Equation ``AᵀX + XA + Q = 0``
only returns a valid Lyapunov function if Q is positive semi-definite.

The implementation is based on SLICOT routine SB03MD [2]. Note the
transformation Q = -C. The complexity of this routine is O(n³). If A
is larger than 2-by-2, then a Schur factorization is performed.

Raises:
    RuntimeError if Schur factorization failed.

A tolerance of ε is used to check if a double variable is equal to
zero, where the default value for ε is 1e-10. It has been used to
check (1) if λᵢ + λ̅ⱼ = 0, ∀ i,j; (2) if A is a 1-by-1 zero matrix;
(3) if A's trace or determinant is 0 when A is a 2-by-2 matrix.

[1] Bartels, R.H. and G.W. Stewart, "Solution of the Matrix Equation
AX + XB = C," Comm. of the ACM, Vol. 15, No. 9, 1972.

[2] http://slicot.org/objects/software/shared/doc/SB03MD.html)""";
      } RealContinuousLyapunovEquation;
      // Symbol: drake::math::RealDiscreteLyapunovEquation
      struct /* RealDiscreteLyapunovEquation */ {
        // Source: drake/math/discrete_lyapunov_equation.h:56
        const char* doc =
R"""(Parameter ``A``:
    A user defined real square matrix.

Parameter ``Q``:
    A user defined real symmetric matrix.

Precondition:
    Q is a symmetric matrix.

Computes the unique solution X to the discrete Lyapunov equation:
``AᵀXA - X + Q = 0``, where A is real and square, and Q is real,
symmetric and of equal size as A.

Raises:
    RuntimeError if A or Q are not square matrices or do not have the
    same size.

Limitations: Given the Eigenvalues of A as λ₁, ..., λₙ, there exists a
unique solution if and only if λᵢ * λⱼ ≠ 1 ∀ i,j and λᵢ ≠ ±1, ∀ i [1].

Raises:
    RuntimeError if the solution is not unique.[3]

There are no further limitations on the eigenvalues of A. Further, if
|λᵢ|<1, ∀ i, and if Q is positive semi-definite, then X is also
positive semi-definite [2]. Therefore, if one searches for a Lyapunov
function V(z) = zᵀXz for the stable linear system zₙ₊₁ = Azₙ, then the
solution of the Lyapunov Equation ``AᵀXA - X + Q = 0`` only returns a
valid Lyapunov function if Q is positive semi-definite.

The implementation is based on SLICOT routine SB03MD [2]. Note the
transformation Q = -C. The complexity of this routine is O(n³). If A
is larger than 2-by-2, then a Schur factorization is performed.

Raises:
    RuntimeError if Schur factorization fails.

A tolerance of ε is used to check if a double variable is equal to
zero, where the default value for ε is 1e-10. It has been used to
check (1) if λᵢ = ±1 ∀ i; (2) if λᵢ * λⱼ = 1, i ≠ j.

[1] Barraud, A.Y., "A numerical algorithm to solve AᵀXA - X = Q,"
IEEE® Trans. Auto. Contr., AC-22, pp. 883-885, 1977.

[2] http://slicot.org/objects/software/shared/doc/SB03MD.html

[3] https://www.mathworks.com/help/control/ref/dlyap.html)""";
      } RealDiscreteLyapunovEquation;
      // Symbol: drake::math::RigidTransform
      struct /* RigidTransform */ {
        // Source: drake/math/rigid_transform.h:69
        const char* doc =
R"""(This class represents a proper rigid transform between two frames
which can be regarded in two ways. A rigid transform describes the
"pose" between two frames A and B (i.e., the relative orientation and
position of A to B). Alternately, it can be regarded as a
distance-preserving operator that can rotate and/or translate a rigid
body without changing its shape or size (rigid) and without
mirroring/reflecting the body (proper), e.g., it can add one position
vector to another and express the result in a particular basis as
``p_AoQ_A = X_AB * p_BoQ_B`` (Q is any point). In many ways, this
rigid transform class is conceptually similar to using a homogeneous
matrix as a linear operator. See operator* documentation for an
exception.

The class stores a RotationMatrix that relates right-handed orthogonal
unit vectors Ax, Ay, Az fixed in frame A to right-handed orthogonal
unit vectors Bx, By, Bz fixed in frame B. The class also stores a
position vector from Ao (the origin of frame A) to Bo (the origin of
frame B). The position vector is expressed in frame A. The monogram
notation for the transform relating frame A to B is ``X_AB``. The
monogram notation for the rotation matrix relating A to B is ``R_AB``.
The monogram notation for the position vector from Ao to Bo is
``p_AoBo_A``. See multibody_quantities for monogram notation for
dynamics.

Note:
    This class does not store the frames associated with the transform
    and cannot enforce correct usage of this class. For example, it
    makes sense to multiply RigidTransforms as ``X_AB * X_BC``, but
    not ``X_AB * X_CB``.

Note:
    This class is not a 4x4 transformation matrix -- even though its
    operator*() methods act mostly like 4x4 matrix multiplication.
    Instead, this class contains a 3x3 rotation matrix class and a 3x1
    position vector. To convert this to a 3x4 matrix, use
    GetAsMatrix34(). To convert this to a 4x4 matrix, use
    GetAsMatrix4(). To convert this to an Eigen::Isometry, use
    GetAsIsometry().

Note:
    An isometry is sometimes regarded as synonymous with rigid
    transform. The RigidTransform class has important advantages over
    Eigen::Isometry. - RigidTransform is built on an underlying
    rigorous 3x3 RotationMatrix class that has significant
    functionality for 3D orientation. - In Debug builds,
    RigidTransform requires a valid 3x3 rotation matrix and a valid
    (non-NAN) position vector. Eigen::Isometry does not. -
    RigidTransform catches bugs that are undetected by
    Eigen::Isometry. - RigidTransform has additional functionality and
    ease-of-use, resulting in shorter, easier to write, and easier to
    read code. - The name Isometry is unfamiliar to many roboticists
    and dynamicists and for them Isometry.linear() is (for example) a
    counter-intuitive method name to return a rotation matrix.

Note:
    One of the constructors in this class provides an implicit
    conversion from an Eigen Translation to RigidTransform.

Authors:
    Paul Mitiguy (2018) Original author.

Authors:
    Drake team (see https://drake.mit.edu/credits).)""";
        // Symbol: drake::math::RigidTransform::GetAsIsometry3
        struct /* GetAsIsometry3 */ {
          // Source: drake/math/rigid_transform.h:374
          const char* doc =
R"""(Returns the isometry in ℜ³ that is equivalent to a RigidTransform.)""";
        } GetAsIsometry3;
        // Symbol: drake::math::RigidTransform::GetAsMatrix34
        struct /* GetAsMatrix34 */ {
          // Source: drake/math/rigid_transform.h:366
          const char* doc =
R"""(Returns the 3x4 matrix associated with this RigidTransform, i.e.,
X_AB.


::

    ┌                ┐
     │ R_AB  p_AoBo_A │
     └                ┘)""";
        } GetAsMatrix34;
        // Symbol: drake::math::RigidTransform::GetAsMatrix4
        struct /* GetAsMatrix4 */ {
          // Source: drake/math/rigid_transform.h:352
          const char* doc =
R"""(Returns the 4x4 matrix associated with this RigidTransform, i.e.,
X_AB.


::

    ┌                ┐
     │ R_AB  p_AoBo_A │
     │                │
     │   0      1     │
     └                ┘)""";
        } GetAsMatrix4;
        // Symbol: drake::math::RigidTransform::GetMaximumAbsoluteDifference
        struct /* GetMaximumAbsoluteDifference */ {
          // Source: drake/math/rigid_transform.h:553
          const char* doc =
R"""(Computes the infinity norm of ``this`` - `other` (i.e., the maximum
absolute value of the difference between the elements of ``this`` and
``other``).

Parameter ``other``:
    RigidTransform to subtract from ``this``.

Returns:
    ‖`this` - `other`‖∞)""";
        } GetMaximumAbsoluteDifference;
        // Symbol: drake::math::RigidTransform::GetMaximumAbsoluteTranslationDifference
        struct /* GetMaximumAbsoluteTranslationDifference */ {
          // Source: drake/math/rigid_transform.h:563
          const char* doc =
R"""(Returns the maximum absolute value of the difference in the position
vectors (translation) in ``this`` and ``other``. In other words,
returns the infinity norm of the difference in the position vectors.

Parameter ``other``:
    RigidTransform whose position vector is subtracted from the
    position vector in ``this``.)""";
        } GetMaximumAbsoluteTranslationDifference;
        // Symbol: drake::math::RigidTransform::Identity
        struct /* Identity */ {
          // Source: drake/math/rigid_transform.h:297
          const char* doc =
R"""(Returns the identity RigidTransform (corresponds to coincident
frames).

Returns:
    the RigidTransform that corresponds to aligning the two frames so
    unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is coincident
    with Bo. Hence, the returned RigidTransform contains a 3x3
    identity matrix and a zero position vector.)""";
        } Identity;
        // Symbol: drake::math::RigidTransform::IsExactlyEqualTo
        struct /* IsExactlyEqualTo */ {
          // Source: drake/math/rigid_transform.h:544
          const char* doc =
R"""(Returns true if ``this`` is exactly equal to ``other``.

Parameter ``other``:
    RigidTransform to compare to ``this``.

Returns:
    ``True`` if each element of ``this`` is exactly equal to the
    corresponding element of ``other``.)""";
        } IsExactlyEqualTo;
        // Symbol: drake::math::RigidTransform::IsExactlyIdentity
        struct /* IsExactlyIdentity */ {
          // Source: drake/math/rigid_transform.h:396
          const char* doc =
R"""(Returns ``True`` if ``this`` is exactly the identity RigidTransform.

See also:
    IsIdentityToEpsilon().)""";
        } IsExactlyIdentity;
        // Symbol: drake::math::RigidTransform::IsIdentityToEpsilon
        struct /* IsIdentityToEpsilon */ {
          // Source: drake/math/rigid_transform.h:410
          const char* doc =
R"""(Return true if ``this`` is within tolerance of the identity
RigidTransform.

Returns:
    ``True`` if the RotationMatrix portion of ``this`` satisfies
    RotationMatrix::IsIdentityToInternalTolerance() and if the
    position vector portion of ``this`` is equal to zero vector within
    ``translation_tolerance``.

Parameter ``translation_tolerance``:
    a non-negative number. One way to choose ``translation_tolerance``
    is to multiply a characteristic length (e.g., the magnitude of a
    characteristic position vector) by an epsilon (e.g.,
    RotationMatrix::get_internal_tolerance_for_orthonormality()).

See also:
    IsExactlyIdentity().)""";
        } IsIdentityToEpsilon;
        // Symbol: drake::math::RigidTransform::IsNearlyEqualTo
        struct /* IsNearlyEqualTo */ {
          // Source: drake/math/rigid_transform.h:535
          const char* doc =
R"""(Compares each element of ``this`` to the corresponding element of
``other`` to check if they are the same to within a specified
``tolerance``.

Parameter ``other``:
    RigidTransform to compare to ``this``.

Parameter ``tolerance``:
    maximum allowable absolute difference between the elements in
    ``this`` and ``other``.

Returns:
    ``True`` if ``‖this.matrix() - other.matrix()‖∞ <= tolerance``.

Note:
    Consider scaling tolerance with the largest of magA and magB,
    where magA and magB denoted the magnitudes of ``this`` position
    vector and ``other`` position vectors, respectively.)""";
        } IsNearlyEqualTo;
        // Symbol: drake::math::RigidTransform::RigidTransform<T>
        struct /* ctor */ {
          // Source: drake/math/rigid_transform.h:77
          const char* doc_0args =
R"""(Constructs the RigidTransform that corresponds to aligning the two
frames so unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is
coincident with Bo. Hence, the constructed RigidTransform contains an
identity RotationMatrix and a zero position vector.)""";
          // Source: drake/math/rigid_transform.h:86
          const char* doc_2args_R_p =
R"""(Constructs a RigidTransform from a rotation matrix and a position
vector.

Parameter ``R``:
    rotation matrix relating frames A and B (e.g., ``R_AB``).

Parameter ``p``:
    position vector from frame A's origin to frame B's origin,
    expressed in frame A. In monogram notation p is denoted
    ``p_AoBo_A``.)""";
          // Source: drake/math/rigid_transform.h:95
          const char* doc_2args_rpy_p =
R"""(Constructs a RigidTransform from a RollPitchYaw and a position vector.

Parameter ``rpy``:
    a RollPitchYaw which is a Space-fixed (extrinsic) X-Y-Z rotation
    with "roll-pitch-yaw" angles ``[r, p, y]`` or equivalently a Body-
    fixed (intrinsic) Z-Y-X rotation with "yaw-pitch-roll" angles
    ``[y, p, r]``.

See also:
    RotationMatrix::RotationMatrix(const RollPitchYaw<T>&)

Parameter ``p``:
    position vector from frame A's origin to frame B's origin,
    expressed in frame A. In monogram notation p is denoted
    ``p_AoBo_A``.)""";
          // Source: drake/math/rigid_transform.h:106
          const char* doc_2args_quaternion_p =
R"""(Constructs a RigidTransform from a Quaternion and a position vector.

Parameter ``quaternion``:
    a non-zero, finite quaternion which may or may not have unit
    length [i.e., ``quaternion.norm()`` does not have to be 1].

Parameter ``p``:
    position vector from frame A's origin to frame B's origin,
    expressed in frame A. In monogram notation p is denoted
    ``p_AoBo_A``.

Raises:
    RuntimeError in debug builds if the rotation matrix that is built
    from ``quaternion`` is invalid.

See also:
    RotationMatrix::RotationMatrix(const Eigen::Quaternion<T>&))""";
          // Source: drake/math/rigid_transform.h:118
          const char* doc_2args_theta_lambda_p =
R"""(Constructs a RigidTransform from an AngleAxis and a position vector.

Parameter ``theta_lambda``:
    an Eigen::AngleAxis whose associated axis (vector direction herein
    called ``lambda``) is non-zero and finite, but which may or may
    not have unit length [i.e., ``lambda.norm()`` does not have to be
    1].

Parameter ``p``:
    position vector from frame A's origin to frame B's origin,
    expressed in frame A. In monogram notation p is denoted ``p_AoBo_A

Raises:
    RuntimeError in debug builds if the rotation matrix that is built
    from `theta_lambda`` is invalid.

See also:
    RotationMatrix::RotationMatrix(const Eigen::AngleAxis<T>&))""";
          // Source: drake/math/rigid_transform.h:124
          const char* doc_1args_R =
R"""(Constructs a RigidTransform with a given RotationMatrix and a zero
position vector.

Parameter ``R``:
    rotation matrix relating frames A and B (e.g., ``R_AB``).)""";
          // Source: drake/math/rigid_transform.h:132
          const char* doc_1args_p =
R"""(Constructs a RigidTransform that contains an identity RotationMatrix
and a given position vector ``p``.

Parameter ``p``:
    position vector from frame A's origin to frame B's origin,
    expressed in frame A. In monogram notation p is denoted
    ``p_AoBo_A``.)""";
          // Source: drake/math/rigid_transform.h:143
          const char* doc_1args_translation =
R"""(Constructs a RigidTransform that contains an identity RotationMatrix
and the position vector underlying the given ``translation``.

Parameter ``translation``:
    translation-only transform that stores p_AoQ_A, the position
    vector from frame A's origin to a point Q, expressed in frame A.

Note:
    The constructed RigidTransform ``X_AAq`` relates frame A to a
    frame Aq whose basis unit vectors are aligned with Ax, Ay, Az and
    whose origin position is located at point Q.

Note:
    This constructor provides an implicit conversion from Translation
    to RigidTransform.)""";
          // Source: drake/math/rigid_transform.h:156
          const char* doc_1args_pose =
R"""(Constructs a RigidTransform from an Eigen Isometry3.

Parameter ``pose``:
    Isometry3 that contains an allegedly valid rotation matrix
    ``R_AB`` and also contains a position vector ``p_AoBo_A`` from
    frame A's origin to frame B's origin. ``p_AoBo_A`` must be
    expressed in frame A.

Raises:
    RuntimeError in debug builds if R_AB is not a proper orthonormal
    3x3 rotation matrix.

Note:
    No attempt is made to orthogonalize the 3x3 rotation matrix part
    of ``pose``. As needed, use
    RotationMatrix::ProjectToRotationMatrix().)""";
          // Source: drake/math/rigid_transform.h:225
          const char* doc_1args_constEigenMatrixBase =
R"""(Constructs a RigidTransform from an appropriate Eigen **expression**.

Parameter ``pose``:
    Generic Eigen matrix **expression**.

Raises:
    RuntimeError if the Eigen **expression** in pose does not resolve
    to a Vector3 or 3x4 matrix or 4x4 matrix or if the rotational part
    of ``pose`` is not a proper orthonormal 3x3 rotation matrix or if
    ``pose`` is a 4x4 matrix whose final row is not ``[0, 0, 0, 1]``.

Note:
    No attempt is made to orthogonalize the 3x3 rotation matrix part
    of ``pose``. As needed, use
    RotationMatrix::ProjectToRotationMatrix().

Note:
    This constructor prevents ambiguity that would otherwise exist for
    a RigidTransform constructor whose argument is an Eigen
    **expression**.


::

    const Vector3<double> position(4, 5, 6);
    const RigidTransform<double> X1(3 * position);
    ----------------------------------------------
    const RotationMatrix<double> R(RollPitchYaw<double>(1, 2, 3));
    Eigen::Matrix<double, 3, 4> pose34;
    pose34 << R.matrix(), position;
    const RigidTransform<double> X2(1.0 * pose34);
    ----------------------------------------------
    Eigen::Matrix<double, 4, 4> pose4;
    pose4 << R.matrix(), position,
             0, 0, 0, 1;
    const RigidTransform<double> X3(pose4 * pose4);)""";
        } ctor;
        // Symbol: drake::math::RigidTransform::SetFromIsometry3
        struct /* SetFromIsometry3 */ {
          // Source: drake/math/rigid_transform.h:268
          const char* doc =
R"""(Sets ``this`` RigidTransform from an Eigen Isometry3.

Parameter ``pose``:
    Isometry3 that contains an allegedly valid rotation matrix
    ``R_AB`` and also contains a position vector ``p_AoBo_A`` from
    frame A's origin to frame B's origin. ``p_AoBo_A`` must be
    expressed in frame A.

Raises:
    RuntimeError in debug builds if R_AB is not a proper orthonormal
    3x3 rotation matrix.

Note:
    No attempt is made to orthogonalize the 3x3 rotation matrix part
    of ``pose``. As needed, use
    RotationMatrix::ProjectToRotationMatrix().)""";
        } SetFromIsometry3;
        // Symbol: drake::math::RigidTransform::SetIdentity
        struct /* SetIdentity */ {
          // Source: drake/math/rigid_transform.h:389
          const char* doc =
R"""(Sets ``this`` RigidTransform so it corresponds to aligning the two
frames so unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is
coincident with Bo. Hence, ``this`` RigidTransform contains a 3x3
identity matrix and a zero position vector.)""";
        } SetIdentity;
        // Symbol: drake::math::RigidTransform::cast
        struct /* cast */ {
          // Source: drake/math/rigid_transform.h:286
          const char* doc =
R"""(Creates a RigidTransform templatized on a scalar type U from a
RigidTransform templatized on scalar type T. For example,


::

    RigidTransform<double> source = RigidTransform<double>::Identity();
    RigidTransform<AutoDiffXd> foo = source.cast<AutoDiffXd>();

Template parameter ``U``:
    Scalar type on which the returned RigidTransform is templated.

Note:
    ``RigidTransform<From>::cast<To>()`` creates a new
    ``RigidTransform<To>`` from a ``RigidTransform<From>`` but only if
    type ``To`` is constructible from type ``From``. This cast method
    works in accordance with Eigen's cast method for Eigen's objects
    that underlie this RigidTransform. For example, Eigen currently
    allows cast from type double to AutoDiffXd, but not vice-versa.)""";
        } cast;
        // Symbol: drake::math::RigidTransform::inverse
        struct /* inverse */ {
          // Source: drake/math/rigid_transform.h:423
          const char* doc =
R"""(Returns X_BA = X_AB⁻¹, the inverse of ``this`` RigidTransform.

Note:
    The inverse of RigidTransform X_AB is X_BA, which contains the
    rotation matrix R_BA = R_AB⁻¹ = R_ABᵀ and the position vector
    ``p_BoAo_B_`` (position from B's origin Bo to A's origin Ao,
    expressed in frame B).

Note:
    : The square-root of a RigidTransform's condition number is
    roughly the magnitude of the position vector. The accuracy of the
    calculation for the inverse of a RigidTransform drops off with the
    sqrt condition number.)""";
        } inverse;
        // Symbol: drake::math::RigidTransform::operator*
        struct /* operator_mul */ {
          // Source: drake/math/rigid_transform.h:442
          const char* doc_1args_other =
R"""(Multiplies ``this`` RigidTransform ``X_AB`` by the ``other``
RigidTransform ``X_BC`` and returns the RigidTransform ``X_AC = X_AB *
X_BC``.)""";
          // Source: drake/math/rigid_transform.h:452
          const char* doc_1args_X_BBq =
R"""(Multiplies ``this`` RigidTransform ``X_AB`` by the translation-only
transform ``X_BBq`` and returns the RigidTransform ``X_ABq = X_AB *
X_BBq``.

Note:
    The rotation matrix in the returned RigidTransform ``X_ABq`` is
    equal to the rotation matrix in ``X_AB``. `X_ABq` and ``X_AB``
    only differ by origin location.)""";
          // Source: drake/math/rigid_transform.h:476
          const char* doc_1args_p_BoQ_B =
R"""(Multiplies ``this`` RigidTransform ``X_AB`` by the position vector
``p_BoQ_B`` which is from Bo (B's origin) to an arbitrary point Q.

Parameter ``p_BoQ_B``:
    position vector from Bo to Q, expressed in frame B.

Returns ``p_AoQ_A``:
    position vector from Ao to Q, expressed in frame A.)""";
          // Source: drake/math/rigid_transform.h:504
          const char* doc_1args_constEigenMatrixBase =
R"""(Multiplies ``this`` RigidTransform ``X_AB`` by the n position vectors
``p_BoQ1_B`` ... `p_BoQn_B`, where ``p_BoQi_B`` is the iᵗʰ position
vector from Bo (frame B's origin) to an arbitrary point Qi, expressed
in frame B.

Parameter ``p_BoQ_B``:
    ``3 x n`` matrix with n position vectors ``p_BoQi_B`` or an
    expression that resolves to a ``3 x n`` matrix of position
    vectors.

Returns ``p_AoQ_A``:
    ``3 x n`` matrix with n position vectors ``p_AoQi_A``, i.e., n
    position vectors from Ao (frame A's origin) to Qi, expressed in
    frame A. Specifically, this operator* is defined so that ``X_AB *
    p_BoQ_B`` returns ``p_AoQ_A = p_AoBo_A + R_AB * p_BoQ_B``, where
    ``p_AoBo_A`` is the position vector from Ao to Bo expressed in A
    and ``R_AB`` is the rotation matrix relating the orientation of
    frames A and B.

Note:
    As needed, use parentheses. This operator* is not associative. To
    see this, let ``p = p_AoBo_A``, `q = p_BoQ_B` and note (X_AB * q)
    * 7 = (p + R_AB * q) * 7 ≠ X_AB * (q * 7) = p + R_AB * (q * 7).


::

    const RollPitchYaw<double> rpy(0.1, 0.2, 0.3);
    const RigidTransform<double> X_AB(rpy, Vector3d(1, 2, 3));
    Eigen::Matrix<double, 3, 2> p_BoQ_B;
    p_BoQ_B.col(0) = Vector3d(4, 5, 6);
    p_BoQ_B.col(1) = Vector3d(9, 8, 7);
    const Eigen::Matrix<double, 3, 2> p_AoQ_A = X_AB * p_BoQ_B;)""";
        } operator_mul;
        // Symbol: drake::math::RigidTransform::operator*=
        struct /* operator_imul */ {
          // Source: drake/math/rigid_transform.h:434
          const char* doc =
R"""(In-place multiply of ``this`` RigidTransform ``X_AB`` by ``other``
RigidTransform ``X_BC``.

Parameter ``other``:
    RigidTransform that post-multiplies ``this``.

Returns:
    ``this`` RigidTransform which has been multiplied by ``other``. On
    return, ``this = X_AC``, where ``X_AC = X_AB * X_BC``.)""";
        } operator_imul;
        // Symbol: drake::math::RigidTransform::rotation
        struct /* rotation */ {
          // Source: drake/math/rigid_transform.h:305
          const char* doc =
R"""(Returns R_AB, the rotation matrix portion of ``this`` RigidTransform.

Returns ``R_AB``:
    the rotation matrix portion of ``this`` RigidTransform.)""";
        } rotation;
        // Symbol: drake::math::RigidTransform::set
        struct /* set */ {
          // Source: drake/math/rigid_transform.h:255
          const char* doc =
R"""(Sets ``this`` RigidTransform from a RotationMatrix and a position
vector.

Parameter ``R``:
    rotation matrix relating frames A and B (e.g., ``R_AB``).

Parameter ``p``:
    position vector from frame A's origin to frame B's origin,
    expressed in frame A. In monogram notation p is denoted
    ``p_AoBo_A``.)""";
        } set;
        // Symbol: drake::math::RigidTransform::set_rotation
        struct /* set_rotation */ {
          // Source: drake/math/rigid_transform.h:309
          const char* doc_1args_R =
R"""(Sets the RotationMatrix portion of ``this`` RigidTransform.

Parameter ``R``:
    rotation matrix relating frames A and B (e.g., ``R_AB``).)""";
          // Source: drake/math/rigid_transform.h:315
          const char* doc_1args_rpy =
R"""(Sets the rotation part of ``this`` RigidTransform from a RollPitchYaw.

Parameter ``rpy``:
    "roll-pitch-yaw" angles.

See also:
    RotationMatrix::RotationMatrix(const RollPitchYaw<T>&) which
    describes the parameter, preconditions, etc.)""";
          // Source: drake/math/rigid_transform.h:323
          const char* doc_1args_quaternion =
R"""(Sets the rotation part of ``this`` RigidTransform from a Quaternion.

Parameter ``quaternion``:
    a quaternion which may or may not have unit length.

See also:
    RotationMatrix::RotationMatrix(const Eigen::Quaternion<T>&) which
    describes the parameter, preconditions, exception conditions, etc.)""";
          // Source: drake/math/rigid_transform.h:331
          const char* doc_1args_theta_lambda =
R"""(Sets the rotation part of ``this`` RigidTransform from an AngleAxis.

Parameter ``theta_lambda``:
    an angle ``theta`` (in radians) and vector ``lambda``.

See also:
    RotationMatrix::RotationMatrix(const Eigen::AngleAxis<T>&) which
    describes the parameter, preconditions, exception conditions, etc.)""";
        } set_rotation;
        // Symbol: drake::math::RigidTransform::set_translation
        struct /* set_translation */ {
          // Source: drake/math/rigid_transform.h:342
          const char* doc =
R"""(Sets the position vector portion of ``this`` RigidTransform.

Parameter ``p``:
    position vector from Ao (frame A's origin) to Bo (frame B's
    origin) expressed in frame A. In monogram notation p is denoted
    p_AoBo_A.)""";
        } set_translation;
        // Symbol: drake::math::RigidTransform::translation
        struct /* translation */ {
          // Source: drake/math/rigid_transform.h:337
          const char* doc =
R"""(Returns ``p_AoBo_A``, the position vector portion of ``this``
RigidTransform, i.e., position vector from Ao (frame A's origin) to Bo
(frame B's origin).)""";
        } translation;
      } RigidTransform;
      // Symbol: drake::math::RigidTransformd
      struct /* RigidTransformd */ {
        // Source: drake/math/rigid_transform.h:618
        const char* doc =
R"""(Abbreviation (alias/typedef) for a RigidTransform double scalar type.)""";
      } RigidTransformd;
      // Symbol: drake::math::RollPitchYaw
      struct /* RollPitchYaw */ {
        // Source: drake/math/roll_pitch_yaw.h:57
        const char* doc =
R"""(This class represents the orientation between two arbitrary frames A
and D associated with a Space-fixed (extrinsic) X-Y-Z rotation by
"roll-pitch-yaw" angles ``[r, p, y]``, which is equivalent to a
Body-fixed (intrinsic) Z-Y-X rotation by "yaw-pitch-roll" angles ``[y,
p, r]``. The rotation matrix ``R_AD`` associated with this
roll-pitch-yaw ``[r, p, y]`` rotation sequence is equal to the matrix
multiplication shown below.


::

    ⎡cos(y) -sin(y)  0⎤   ⎡ cos(p)  0  sin(p)⎤   ⎡1      0        0 ⎤
    R_AD = ⎢sin(y)  cos(y)  0⎥ * ⎢     0   1      0 ⎥ * ⎢0  cos(r)  -sin(r)⎥
           ⎣    0       0   1⎦   ⎣-sin(p)  0  cos(p)⎦   ⎣0  sin(r)   cos(r)⎦
         =       R_AB          *        R_BC          *        R_CD

Note:
    In this discussion, A is the Space frame and D is the Body frame.
    One way to visualize this rotation sequence is by introducing
    intermediate frames B and C (useful constructs to understand this
    rotation sequence). Initially, the frames are aligned so ``Di = Ci
    = Bi = Ai (i = x, y, z)`` where Dx, Dy, Dz and Ax, Ay, Az are
    orthogonal unit vectors fixed in frames D and A respectively.
    Similarly for Bx, By, Bz and Cx, Cy, Cz in frame B, C. Then D is
    subjected to successive right-handed rotations relative to A.

* 1st rotation R_CD: Frame D rotates relative to frames C, B, A by a
roll angle ``r`` about ``Dx = Cx``.  Note: D and C are no longer aligned.

* 2nd rotation R_BC: Frames D, C (collectively -- as if welded together)
rotate relative to frame B, A by a pitch angle ``p`` about ``Cy = By``.
Note: C and B are no longer aligned.

* 3rd rotation R_AB: Frames D, C, B (collectively -- as if welded)
rotate relative to frame A by a roll angle ``y`` about ``Bz = Az``.
Note: B and A are no longer aligned.
The monogram notation for the rotation matrix relating A to D is ``R_AD``.

See also:
    multibody_quantities for monogram notation for dynamics and
    orientation_discussion "a discussion on rotation matrices".

Note:
    This class does not store the frames associated with this rotation
    sequence.)""";
        // Symbol: drake::math::RollPitchYaw::CalcAngularVelocityInChildFromRpyDt
        struct /* CalcAngularVelocityInChildFromRpyDt */ {
          // Source: drake/math/roll_pitch_yaw.h:296
          const char* doc =
R"""(Calculates angular velocity from ``this`` RollPitchYaw whose
roll-pitch-yaw angles ``[r; p; y]`` relate the orientation of two
generic frames A and D.

Parameter ``rpyDt``:
    Time-derivative of ``[r; p; y]``, i.e., ``[ṙ; ṗ; ẏ]``.

Returns:
    w_AD_D, frame D's angular velocity in frame A, expressed in D.)""";
        } CalcAngularVelocityInChildFromRpyDt;
        // Symbol: drake::math::RollPitchYaw::CalcAngularVelocityInParentFromRpyDt
        struct /* CalcAngularVelocityInParentFromRpyDt */ {
          // Source: drake/math/roll_pitch_yaw.h:283
          const char* doc =
R"""(Calculates angular velocity from ``this`` RollPitchYaw whose
roll-pitch-yaw angles ``[r; p; y]`` relate the orientation of two
generic frames A and D.

Parameter ``rpyDt``:
    Time-derivative of ``[r; p; y]``, i.e., ``[ṙ; ṗ; ẏ]``.

Returns:
    w_AD_A, frame D's angular velocity in frame A, expressed in A.)""";
        } CalcAngularVelocityInParentFromRpyDt;
        // Symbol: drake::math::RollPitchYaw::CalcMatrixRelatingRpyDtToAngularVelocityInParent
        struct /* CalcMatrixRelatingRpyDtToAngularVelocityInParent */ {
          // Source: drake/math/roll_pitch_yaw.h:339
          const char* doc =
R"""(For ``this`` RollPitchYaw with roll-pitch-yaw angles ``[r; p; y]``
which relate the orientation of two generic frames A and D, returns
the 3x3 matrix M that contains the partial derivatives of [ṙ, ṗ, ẏ]
with respect to ``[wx; wy; wz]ₐ`` (which is w_AD_A expressed in A). In
other words, ``rpyDt = M * w_AD_A``.

Parameter ``function_name``:
    name of the calling function/method.

Raises:
    RuntimeError if ``cos(p) ≈ 0`` (`p` is near gimbal-lock).

Note:
    This method has a divide-by-zero error (singularity) when the
    cosine of the pitch angle ``p`` is zero [i.e., ``cos(p) = 0`].
    This problem (called "gimbal lock") occurs when `p = n π + π /
    2``, where n is any integer. There are associated precision
    problems (inaccuracies) in the neighborhood of these pitch angles,
    i.e., when ``cos(p) ≈ 0``.)""";
        } CalcMatrixRelatingRpyDtToAngularVelocityInParent;
        // Symbol: drake::math::RollPitchYaw::CalcRotationMatrixDt
        struct /* CalcRotationMatrixDt */ {
          // Source: drake/math/roll_pitch_yaw.h:266
          const char* doc =
R"""(Forms Ṙ, the ordinary derivative of the RotationMatrix ``R`` with
respect to an independent variable ``t`` (`t` usually denotes time)
and ``R`` is the RotationMatrix formed by ``this`` RollPitchYaw. The
roll-pitch-yaw angles r, p, y are regarded as functions of ``t``
[i.e., r(t), p(t), y(t)].

Parameter ``rpyDt``:
    Ordinary derivative of rpy with respect to an independent variable
    ``t`` (`t` usually denotes time, but not necessarily).

Returns:
    Ṙ, the ordinary derivative of ``R`` with respect to ``t``,
    calculated as Ṙ = ∂R/∂r * ṙ + ∂R/∂p * ṗ + ∂R/∂y * ẏ. In other
    words, the returned (i, j) element is ∂Rij/∂r * ṙ + ∂Rij/∂p * ṗ
    + ∂Rij/∂y * ẏ.)""";
        } CalcRotationMatrixDt;
        // Symbol: drake::math::RollPitchYaw::CalcRpyDDtFromAngularAccelInChild
        struct /* CalcRpyDDtFromAngularAccelInChild */ {
          // Source: drake/math/roll_pitch_yaw.h:381
          const char* doc =
R"""(Uses angular acceleration to compute the 2ⁿᵈ time-derivative of
``this`` RollPitchYaw whose angles ``[r; p; y]`` orient two generic
frames A and D.

Parameter ``rpyDt``:
    time-derivative of ``[r; p; y]``, i.e., ``[ṙ; ṗ; ẏ]``.

Parameter ``alpha_AD_D``:
    , frame D's angular acceleration in frame A, expressed in frame D.

Returns:
    ``[r̈, p̈, ÿ]``, the 2ⁿᵈ time-derivative of ``this``
    RollPitchYaw.

Raises:
    RuntimeError if ``cos(p) ≈ 0`` (`p` is near gimbal-lock).

Note:
    This method has a divide-by-zero error (singularity) when the
    cosine of the pitch angle ``p`` is zero [i.e., ``cos(p) = 0`].
    This problem (called "gimbal lock") occurs when `p = n π + π /
    2``, where n is any integer. There are associated precision
    problems (inaccuracies) in the neighborhood of these pitch angles,
    i.e., when ``cos(p) ≈ 0``.)""";
        } CalcRpyDDtFromAngularAccelInChild;
        // Symbol: drake::math::RollPitchYaw::CalcRpyDDtFromRpyDtAndAngularAccelInParent
        struct /* CalcRpyDDtFromRpyDtAndAngularAccelInParent */ {
          // Source: drake/math/roll_pitch_yaw.h:357
          const char* doc =
R"""(Uses angular acceleration to compute the 2ⁿᵈ time-derivative of
``this`` RollPitchYaw whose angles ``[r; p; y]`` orient two generic
frames A and D.

Parameter ``rpyDt``:
    time-derivative of ``[r; p; y]``, i.e., ``[ṙ; ṗ; ẏ]``.

Parameter ``alpha_AD_A``:
    , frame D's angular acceleration in frame A, expressed in frame A.

Returns:
    ``[r̈, p̈, ÿ]``, the 2ⁿᵈ time-derivative of ``this``
    RollPitchYaw.

Raises:
    RuntimeError if ``cos(p) ≈ 0`` (`p` is near gimbal-lock).

Note:
    This method has a divide-by-zero error (singularity) when the
    cosine of the pitch angle ``p`` is zero [i.e., ``cos(p) = 0`].
    This problem (called "gimbal lock") occurs when `p = n π + π /
    2``, where n is any integer. There are associated precision
    problems (inaccuracies) in the neighborhood of these pitch angles,
    i.e., when ``cos(p) ≈ 0``.)""";
        } CalcRpyDDtFromRpyDtAndAngularAccelInParent;
        // Symbol: drake::math::RollPitchYaw::CalcRpyDtFromAngularVelocityInParent
        struct /* CalcRpyDtFromAngularVelocityInParent */ {
          // Source: drake/math/roll_pitch_yaw.h:315
          const char* doc =
R"""(Uses angular velocity to compute the 1ˢᵗ time-derivative of ``this``
RollPitchYaw whose angles ``[r; p; y]`` orient two generic frames A
and D.

Parameter ``w_AD_A``:
    , frame D's angular velocity in frame A, expressed in A.

Returns:
    ``[ṙ; ṗ; ẏ]``, the 1ˢᵗ time-derivative of ``this``
    RollPitchYaw.

Raises:
    RuntimeError if ``cos(p) ≈ 0`` (`p` is near gimbal-lock).

Note:
    This method has a divide-by-zero error (singularity) when the
    cosine of the pitch angle ``p`` is zero [i.e., ``cos(p) = 0`].
    This problem (called "gimbal lock") occurs when `p = n π + π /
    2``, where n is any integer. There are associated precision
    problems (inaccuracies) in the neighborhood of these pitch angles,
    i.e., when ``cos(p) ≈ 0``.)""";
        } CalcRpyDtFromAngularVelocityInParent;
        // Symbol: drake::math::RollPitchYaw::DoesCosPitchAngleViolateGimbalLockTolerance
        struct /* DoesCosPitchAngleViolateGimbalLockTolerance */ {
          // Source: drake/math/roll_pitch_yaw.h:225
          const char* doc =
R"""(Returns true if the pitch-angle ``p`` is close to gimbal-lock, which
means ``cos(p) ≈ 0`` or ``p ≈ (n*π + π/2)`` where ``n = 0, ±1, ±2,
...``. More specifically, returns true if ``abs(cos_pitch_angle)`` is
less than an internally-defined tolerance of gimbal-lock.

Parameter ``cos_pitch_angle``:
    cosine of the pitch angle, i.e., ``cos(p)``.

Note:
    Pitch-angles close to gimbal-lock can can cause problems with
    numerical precision and numerical integration.)""";
        } DoesCosPitchAngleViolateGimbalLockTolerance;
        // Symbol: drake::math::RollPitchYaw::DoesPitchAngleViolateGimbalLockTolerance
        struct /* DoesPitchAngleViolateGimbalLockTolerance */ {
          // Source: drake/math/roll_pitch_yaw.h:237
          const char* doc =
R"""(Returns true if the pitch-angle ``p`` is within an internally-defined
tolerance of gimbal-lock. In other words, this method returns true if
``p ≈ (n*π + π/2)`` where ``n = 0, ±1, ±2, ...``.

Note:
    To improve efficiency when cos(pitch_angle()) is already
    calculated, instead use the function
    DoesCosPitchAngleViolateGimbalLockTolerance().

See also:
    DoesCosPitchAngleViolateGimbalLockTolerance())""";
        } DoesPitchAngleViolateGimbalLockTolerance;
        // Symbol: drake::math::RollPitchYaw::GimbalLockPitchAngleTolerance
        struct /* GimbalLockPitchAngleTolerance */ {
          // Source: drake/math/roll_pitch_yaw.h:245
          const char* doc =
R"""(Returns the internally-defined allowable closeness (in radians) of the
pitch angle ``p`` to gimbal-lock, i.e., the allowable proximity of
``p`` to ``(n*π + π/2)`` where ``n = 0, ±1, ±2, ...``.)""";
        } GimbalLockPitchAngleTolerance;
        // Symbol: drake::math::RollPitchYaw::IsNearlyEqualTo
        struct /* IsNearlyEqualTo */ {
          // Source: drake/math/roll_pitch_yaw.h:193
          const char* doc =
R"""(Compares each element of ``this`` to the corresponding element of
``other`` to check if they are the same to within a specified
``tolerance``.

Parameter ``other``:
    RollPitchYaw to compare to ``this``.

Parameter ``tolerance``:
    maximum allowable absolute difference between the matrix elements
    in ``this`` and ``other``.

Returns:
    ``True`` if ``‖this - other‖∞ <= tolerance``.)""";
        } IsNearlyEqualTo;
        // Symbol: drake::math::RollPitchYaw::IsNearlySameOrientation
        struct /* IsNearlySameOrientation */ {
          // Source: drake/math/roll_pitch_yaw.h:205
          const char* doc =
R"""(Compares each element of the RotationMatrix R1 produced by ``this`` to
the corresponding element of the RotationMatrix R2 produced by
``other`` to check if they are the same to within a specified
``tolerance``.

Parameter ``other``:
    RollPitchYaw to compare to ``this``.

Parameter ``tolerance``:
    maximum allowable absolute difference between R1, R2.

Returns:
    ``True`` if ``‖R1 - R2‖∞ <= tolerance``.)""";
        } IsNearlySameOrientation;
        // Symbol: drake::math::RollPitchYaw::IsRollPitchYawInCanonicalRange
        struct /* IsRollPitchYawInCanonicalRange */ {
          // Source: drake/math/roll_pitch_yaw.h:210
          const char* doc =
R"""(Returns true if roll-pitch-yaw angles ``[r, p, y]`` are in the range
``-π <= r <= π``, `-π/2 <= p <= π/2`, ``-π <= y <= π``.)""";
        } IsRollPitchYawInCanonicalRange;
        // Symbol: drake::math::RollPitchYaw::IsValid
        struct /* IsValid */ {
          // Source: drake/math/roll_pitch_yaw.h:252
          const char* doc =
R"""(Returns true if ``rpy`` contains valid roll, pitch, yaw angles.

Parameter ``rpy``:
    allegedly valid roll, pitch, yaw angles.

Note:
    an angle is invalid if it is NaN or infinite.)""";
        } IsValid;
        // Symbol: drake::math::RollPitchYaw::RollPitchYaw<T>
        struct /* ctor */ {
          // Source: drake/math/roll_pitch_yaw.h:64
          const char* doc_1args_rpy =
R"""(Constructs a RollPitchYaw from a 3x1 array of angles.

Parameter ``rpy``:
    3x1 array with roll, pitch, yaw angles (units of radians).

Raises:
    RuntimeError in debug builds if !IsValid(rpy).)""";
          // Source: drake/math/roll_pitch_yaw.h:72
          const char* doc_3args_roll_pitch_yaw =
R"""(Constructs a RollPitchYaw from roll, pitch, yaw angles (radian units).

Parameter ``roll``:
    x-directed angle in SpaceXYZ rotation sequence.

Parameter ``pitch``:
    y-directed angle in SpaceXYZ rotation sequence.

Parameter ``yaw``:
    z-directed angle in SpaceXYZ rotation sequence.

Raises:
    RuntimeError in debug builds if !IsValid(Vector3<T>(roll, pitch,
    yaw)).)""";
          // Source: drake/math/roll_pitch_yaw.h:82
          const char* doc_1args_R =
R"""(Uses a RotationMatrix to construct a RollPitchYaw with roll-pitch-yaw
angles ``[r, p, y]`` in the range ``-π <= r <= π``, `-π/2 <= p <=
π/2`, ``-π <= y <= π``.

Parameter ``R``:
    a RotationMatrix.

Note:
    This new high-accuracy algorithm avoids numerical round-off issues
    encountered by some algorithms when pitch is within 1E-6 of π/2 or
    -π/2.)""";
          // Source: drake/math/roll_pitch_yaw.h:93
          const char* doc_1args_quaternion =
R"""(Uses a Quaternion to construct a RollPitchYaw with roll-pitch-yaw
angles ``[r, p, y]`` in the range ``-π <= r <= π``, `-π/2 <= p <=
π/2`, ``-π <= y <= π``.

Parameter ``quaternion``:
    unit Quaternion.

Note:
    This new high-accuracy algorithm avoids numerical round-off issues
    encountered by some algorithms when pitch is within 1E-6 of π/2 or
    -π/2.

Raises:
    RuntimeError in debug builds if !IsValid(rpy).)""";
        } ctor;
        // Symbol: drake::math::RollPitchYaw::SetFromQuaternion
        struct /* SetFromQuaternion */ {
          // Source: drake/math/roll_pitch_yaw.h:121
          const char* doc =
R"""(Uses a Quaternion to set ``this`` RollPitchYaw with roll-pitch-yaw
angles ``[r, p, y]`` in the range ``-π <= r <= π``, `-π/2 <= p <=
π/2`, ``-π <= y <= π``.

Parameter ``quaternion``:
    unit Quaternion.

Note:
    This new high-accuracy algorithm avoids numerical round-off issues
    encountered by some algorithms when pitch is within 1E-6 of π/2 or
    -π/2.

Raises:
    RuntimeError in debug builds if !IsValid(rpy).)""";
        } SetFromQuaternion;
        // Symbol: drake::math::RollPitchYaw::SetFromRotationMatrix
        struct /* SetFromRotationMatrix */ {
          // Source: drake/math/roll_pitch_yaw.h:132
          const char* doc =
R"""(Uses a high-accuracy efficient algorithm to set the roll-pitch-yaw
angles ``[r, p, y]`` that underlie ``this`` @RollPitchYaw, even when
the pitch angle p is very near a singularity (when p is within 1E-6 of
π/2 or -π/2). After calling this method, the underlying roll-pitch-yaw
``[r, p, y]`` has range ``-π <= r <= π``, `-π/2 <= p <= π/2`, ``-π <=
y <= π``.

Parameter ``R``:
    a RotationMatrix.

Note:
    This high-accuracy algorithm was invented at TRI in October 2016
    and avoids numerical round-off issues encountered by some
    algorithms when pitch is within 1E-6 of π/2 or -π/2.)""";
        } SetFromRotationMatrix;
        // Symbol: drake::math::RollPitchYaw::ToMatrix3ViaRotationMatrix
        struct /* ToMatrix3ViaRotationMatrix */ {
          // Source: drake/math/roll_pitch_yaw.h:183
          const char* doc =
R"""(Returns the 3x3 matrix representation of the RotationMatrix that
corresponds to ``this`` RollPitchYaw. This is a convenient "sugar"
method that is exactly equivalent to RotationMatrix(rpy).ToMatrix3().)""";
        } ToMatrix3ViaRotationMatrix;
        // Symbol: drake::math::RollPitchYaw::ToQuaternion
        struct /* ToQuaternion */ {
          // Source: drake/math/roll_pitch_yaw.h:159
          const char* doc =
R"""(Returns a quaternion representation of ``this`` RollPitchYaw.)""";
        } ToQuaternion;
        // Symbol: drake::math::RollPitchYaw::ToRotationMatrix
        struct /* ToRotationMatrix */ {
          // Source: drake/math/roll_pitch_yaw.h:178
          const char* doc =
R"""(Returns the RotationMatrix representation of ``this`` RollPitchYaw.)""";
        } ToRotationMatrix;
        // Symbol: drake::math::RollPitchYaw::pitch_angle
        struct /* pitch_angle */ {
          // Source: drake/math/roll_pitch_yaw.h:141
          const char* doc =
R"""(Returns the pitch-angle underlying ``this`` RollPitchYaw.)""";
        } pitch_angle;
        // Symbol: drake::math::RollPitchYaw::roll_angle
        struct /* roll_angle */ {
          // Source: drake/math/roll_pitch_yaw.h:138
          const char* doc =
R"""(Returns the roll-angle underlying ``this`` RollPitchYaw.)""";
        } roll_angle;
        // Symbol: drake::math::RollPitchYaw::set
        struct /* set */ {
          // Source: drake/math/roll_pitch_yaw.h:100
          const char* doc_1args =
R"""(Sets ``this`` RollPitchYaw from a 3x1 array of angles.

Parameter ``rpy``:
    3x1 array with roll, pitch, yaw angles (units of radians).

Raises:
    RuntimeError in debug builds if !IsValid(rpy).)""";
          // Source: drake/math/roll_pitch_yaw.h:110
          const char* doc_3args =
R"""(Sets ``this`` RollPitchYaw from roll, pitch, yaw angles (units of
radians).

Parameter ``roll``:
    x-directed angle in SpaceXYZ rotation sequence.

Parameter ``pitch``:
    y-directed angle in SpaceXYZ rotation sequence.

Parameter ``yaw``:
    z-directed angle in SpaceXYZ rotation sequence.

Raises:
    RuntimeError in debug builds if !IsValid(Vector3<T>(roll, pitch,
    yaw)).)""";
        } set;
        // Symbol: drake::math::RollPitchYaw::set_pitch_angle
        struct /* set_pitch_angle */ {
          // Source: drake/math/roll_pitch_yaw.h:152
          const char* doc =
R"""(Set the pitch-angle underlying ``this`` RollPitchYaw.

Parameter ``p``:
    pitch angle (in units of radians).)""";
        } set_pitch_angle;
        // Symbol: drake::math::RollPitchYaw::set_roll_angle
        struct /* set_roll_angle */ {
          // Source: drake/math/roll_pitch_yaw.h:148
          const char* doc =
R"""(Set the roll-angle underlying ``this`` RollPitchYaw.

Parameter ``r``:
    roll angle (in units of radians).)""";
        } set_roll_angle;
        // Symbol: drake::math::RollPitchYaw::set_yaw_angle
        struct /* set_yaw_angle */ {
          // Source: drake/math/roll_pitch_yaw.h:156
          const char* doc =
R"""(Set the yaw-angle underlying ``this`` RollPitchYaw.

Parameter ``y``:
    yaw angle (in units of radians).)""";
        } set_yaw_angle;
        // Symbol: drake::math::RollPitchYaw::vector
        struct /* vector */ {
          // Source: drake/math/roll_pitch_yaw.h:135
          const char* doc =
R"""(Returns the Vector3 underlying ``this`` RollPitchYaw.)""";
        } vector;
        // Symbol: drake::math::RollPitchYaw::yaw_angle
        struct /* yaw_angle */ {
          // Source: drake/math/roll_pitch_yaw.h:144
          const char* doc =
R"""(Returns the yaw-angle underlying ``this`` RollPitchYaw.)""";
        } yaw_angle;
      } RollPitchYaw;
      // Symbol: drake::math::RollPitchYawd
      struct /* RollPitchYawd */ {
        // Source: drake/math/roll_pitch_yaw.h:655
        const char* doc =
R"""(Abbreviation (alias/typedef) for a RollPitchYaw double scalar type.)""";
      } RollPitchYawd;
      // Symbol: drake::math::RotationMatrix
      struct /* RotationMatrix */ {
        // Source: drake/math/rotation_matrix.h:50
        const char* doc =
R"""(This class represents a 3x3 rotation matrix between two arbitrary
frames A and B and helps ensure users create valid rotation matrices.
This class relates right-handed orthogonal unit vectors Ax, Ay, Az
fixed in frame A to right-handed orthogonal unit vectors Bx, By, Bz
fixed in frame B. The monogram notation for the rotation matrix
relating A to B is ``R_AB``. An example that gives context to this
rotation matrix is ``v_A = R_AB * v_B``, where ``v_B`` denotes an
arbitrary vector v expressed in terms of Bx, By, Bz and ``v_A``
denotes vector v expressed in terms of Ax, Ay, Az. See
multibody_quantities for monogram notation for dynamics. See
orientation_discussion "a discussion on rotation matrices".

Note:
    This class does not store the frames associated with a rotation
    matrix nor does it enforce strict proper usage of this class with
    vectors.

Note:
    When assertions are enabled, several methods in this class do a
    validity check and throw an exception (RuntimeError) if the
    rotation matrix is invalid. When assertions are disabled, many of
    these validity checks are skipped (which helps improve speed). In
    addition, these validity tests are only performed for scalar types
    for which drake::scalar_predicate<T>::is_bool is ``True``. For
    instance, validity checks are not performed when T is
    symbolic::Expression.

Authors:
    Paul Mitiguy (2018) Original author.

Authors:
    Drake team (see https://drake.mit.edu/credits).)""";
        // Symbol: drake::math::RotationMatrix::GetMaximumAbsoluteDifference
        struct /* GetMaximumAbsoluteDifference */ {
          // Source: drake/math/rotation_matrix.h:518
          const char* doc =
R"""(Computes the infinity norm of ``this`` - `other` (i.e., the maximum
absolute value of the difference between the elements of ``this`` and
``other``).

Parameter ``other``:
    RotationMatrix to subtract from ``this``.

Returns:
    ``‖this - other‖∞``)""";
        } GetMaximumAbsoluteDifference;
        // Symbol: drake::math::RotationMatrix::GetMeasureOfOrthonormality
        struct /* GetMeasureOfOrthonormality */ {
          // Source: drake/math/rotation_matrix.h:444
          const char* doc =
R"""(Returns how close the matrix R is to to being a 3x3 orthonormal matrix
by computing ``‖R ⋅ Rᵀ - I‖∞`` (i.e., the maximum absolute value of
the difference between the elements of R ⋅ Rᵀ and the 3x3 identity
matrix).

Parameter ``R``:
    matrix being checked for orthonormality.

Returns:
    ``‖R ⋅ Rᵀ - I‖∞``)""";
        } GetMeasureOfOrthonormality;
        // Symbol: drake::math::RotationMatrix::Identity
        struct /* Identity */ {
          // Source: drake/math/rotation_matrix.h:318
          const char* doc = R"""()""";
        } Identity;
        // Symbol: drake::math::RotationMatrix::IsExactlyEqualTo
        struct /* IsExactlyEqualTo */ {
          // Source: drake/math/rotation_matrix.h:510
          const char* doc =
R"""(Compares each element of ``this`` to the corresponding element of
``other`` to check if they are exactly the same.

Parameter ``other``:
    RotationMatrix to compare to ``this``.

Returns:
    true if each element of ``this`` is exactly equal to the
    corresponding element in ``other``.)""";
        } IsExactlyEqualTo;
        // Symbol: drake::math::RotationMatrix::IsExactlyIdentity
        struct /* IsExactlyIdentity */ {
          // Source: drake/math/rotation_matrix.h:483
          const char* doc =
R"""(Returns ``True`` if ``this`` is exactly equal to the identity matrix.)""";
        } IsExactlyIdentity;
        // Symbol: drake::math::RotationMatrix::IsIdentityToInternalTolerance
        struct /* IsIdentityToInternalTolerance */ {
          // Source: drake/math/rotation_matrix.h:489
          const char* doc =
R"""(Returns true if ``this`` is equal to the identity matrix to within the
threshold of get_internal_tolerance_for_orthonormality().)""";
        } IsIdentityToInternalTolerance;
        // Symbol: drake::math::RotationMatrix::IsNearlyEqualTo
        struct /* IsNearlyEqualTo */ {
          // Source: drake/math/rotation_matrix.h:500
          const char* doc =
R"""(Compares each element of ``this`` to the corresponding element of
``other`` to check if they are the same to within a specified
``tolerance``.

Parameter ``other``:
    RotationMatrix to compare to ``this``.

Parameter ``tolerance``:
    maximum allowable absolute difference between the matrix elements
    in ``this`` and ``other``.

Returns:
    ``True`` if ``‖this - other‖∞ <= tolerance``.)""";
        } IsNearlyEqualTo;
        // Symbol: drake::math::RotationMatrix::IsOrthonormal
        struct /* IsOrthonormal */ {
          // Source: drake/math/rotation_matrix.h:455
          const char* doc =
R"""(Tests if a generic Matrix3 has orthonormal vectors to within the
threshold specified by ``tolerance``.

Parameter ``R``:
    an allegedly orthonormal rotation matrix.

Parameter ``tolerance``:
    maximum allowable absolute difference between R * Rᵀ and the
    identity matrix I, i.e., checks if ``‖R ⋅ Rᵀ - I‖∞ <= tolerance``.

Returns:
    ``True`` if R is an orthonormal matrix.)""";
        } IsOrthonormal;
        // Symbol: drake::math::RotationMatrix::IsValid
        struct /* IsValid */ {
          // Source: drake/math/rotation_matrix.h:465
          const char* doc_2args =
R"""(Tests if a generic Matrix3 seems to be a proper orthonormal rotation
matrix to within the threshold specified by ``tolerance``.

Parameter ``R``:
    an allegedly valid rotation matrix.

Parameter ``tolerance``:
    maximum allowable absolute difference of ``R * Rᵀ`` and the
    identity matrix I (i.e., checks if ``‖R ⋅ Rᵀ - I‖∞ <=
    tolerance``).

Returns:
    ``True`` if R is a valid rotation matrix.)""";
          // Source: drake/math/rotation_matrix.h:473
          const char* doc_1args =
R"""(Tests if a generic Matrix3 is a proper orthonormal rotation matrix to
within the threshold of get_internal_tolerance_for_orthonormality().

Parameter ``R``:
    an allegedly valid rotation matrix.

Returns:
    ``True`` if R is a valid rotation matrix.)""";
          // Source: drake/math/rotation_matrix.h:480
          const char* doc_0args =
R"""(Tests if ``this`` rotation matrix R is a proper orthonormal rotation
matrix to within the threshold of
get_internal_tolerance_for_orthonormality().

Returns:
    ``True`` if ``this`` is a valid rotation matrix.)""";
        } IsValid;
        // Symbol: drake::math::RotationMatrix::MakeFromOrthonormalColumns
        struct /* MakeFromOrthonormalColumns */ {
          // Source: drake/math/rotation_matrix.h:176
          const char* doc =
R"""((Advanced) Makes the RotationMatrix ``R_AB`` from right-handed
orthogonal unit vectors ``Bx``, `By`, ``Bz`` so the columns of
``R_AB`` are ``[Bx, By, Bz]``.

Parameter ``Bx``:
    first unit vector in right-handed orthogonal set.

Parameter ``By``:
    second unit vector in right-handed orthogonal set.

Parameter ``Bz``:
    third unit vector in right-handed orthogonal set.

Raises:
    RuntimeError in debug builds if ``R_AB`` fails IsValid(R_AB).

Note:
    In release builds, the caller can subsequently test if ``R_AB``
    is, in fact, a valid RotationMatrix by calling ``R_AB.IsValid()``.

Note:
    The rotation matrix ``R_AB`` relates two sets of right-handed
    orthogonal unit vectors, namely Ax, Ay, Az and Bx, By, Bz. The
    rows of ``R_AB`` are Ax, Ay, Az expressed in frame B
    (i.e.,``Ax_B``, `Ay_B`, ``Az_B``). The columns of ``R_AB`` are Bx,
    By, Bz expressed in frame A (i.e., ``Bx_A``, `By_A`, ``Bz_A``).)""";
        } MakeFromOrthonormalColumns;
        // Symbol: drake::math::RotationMatrix::MakeFromOrthonormalRows
        struct /* MakeFromOrthonormalRows */ {
          // Source: drake/math/rotation_matrix.h:196
          const char* doc =
R"""((Advanced) Makes the RotationMatrix ``R_AB`` from right-handed
orthogonal unit vectors ``Ax``, `Ay`, ``Az`` so the rows of ``R_AB``
are ``[Ax, Ay, Az]``.

Parameter ``Ax``:
    first unit vector in right-handed orthogonal set.

Parameter ``Ay``:
    second unit vector in right-handed orthogonal set.

Parameter ``Az``:
    third unit vector in right-handed orthogonal set.

Raises:
    RuntimeError in debug builds if ``R_AB`` fails IsValid(R_AB).

Note:
    In release builds, the caller can subsequently test if ``R_AB``
    is, in fact, a valid RotationMatrix by calling ``R_AB.IsValid()``.

Note:
    The rotation matrix ``R_AB`` relates two sets of right-handed
    orthogonal unit vectors, namely Ax, Ay, Az and Bx, By, Bz. The
    rows of ``R_AB`` are Ax, Ay, Az expressed in frame B
    (i.e.,``Ax_B``, `Ay_B`, ``Az_B``). The columns of ``R_AB`` are Bx,
    By, Bz expressed in frame A (i.e., ``Bx_A``, `By_A`, ``Bz_A``).)""";
        } MakeFromOrthonormalRows;
        // Symbol: drake::math::RotationMatrix::MakeXRotation
        struct /* MakeXRotation */ {
          // Source: drake/math/rotation_matrix.h:215
          const char* doc =
R"""(Makes the RotationMatrix ``R_AB`` associated with rotating a frame B
relative to a frame A by an angle ``theta`` about unit vector ``Ax =
Bx``.

Parameter ``theta``:
    radian measure of rotation angle about Ax.

Note:
    Orientation is same as Eigen::AngleAxis<T>(theta,
    Vector3d::UnitX().

Note:
    ``R_AB`` relates two frames A and B having unit vectors Ax, Ay, Az
    and Bx, By, Bz. Initially, ``Bx = Ax``, `By = Ay`, ``Bz = Az``,
    then B undergoes a right-handed rotation relative to A by an angle
    ``theta`` about ``Ax = Bx``.


::

    ⎡ 1       0                 0  ⎤
    R_AB = ⎢ 0   cos(theta)   -sin(theta) ⎥
           ⎣ 0   sin(theta)    cos(theta) ⎦)""";
        } MakeXRotation;
        // Symbol: drake::math::RotationMatrix::MakeYRotation
        struct /* MakeYRotation */ {
          // Source: drake/math/rotation_matrix.h:240
          const char* doc =
R"""(Makes the RotationMatrix ``R_AB`` associated with rotating a frame B
relative to a frame A by an angle ``theta`` about unit vector ``Ay =
By``.

Parameter ``theta``:
    radian measure of rotation angle about Ay.

Note:
    Orientation is same as Eigen::AngleAxis<T>(theta,
    Vector3d::UnitY().

Note:
    ``R_AB`` relates two frames A and B having unit vectors Ax, Ay, Az
    and Bx, By, Bz. Initially, ``Bx = Ax``, `By = Ay`, ``Bz = Az``,
    then B undergoes a right-handed rotation relative to A by an angle
    ``theta`` about ``Ay = By``.


::

    ⎡  cos(theta)   0   sin(theta) ⎤
    R_AB = ⎢          0    1           0  ⎥
           ⎣ -sin(theta)   0   cos(theta) ⎦)""";
        } MakeYRotation;
        // Symbol: drake::math::RotationMatrix::MakeZRotation
        struct /* MakeZRotation */ {
          // Source: drake/math/rotation_matrix.h:265
          const char* doc =
R"""(Makes the RotationMatrix ``R_AB`` associated with rotating a frame B
relative to a frame A by an angle ``theta`` about unit vector ``Az =
Bz``.

Parameter ``theta``:
    radian measure of rotation angle about Az.

Note:
    Orientation is same as Eigen::AngleAxis<T>(theta,
    Vector3d::UnitZ().

Note:
    ``R_AB`` relates two frames A and B having unit vectors Ax, Ay, Az
    and Bx, By, Bz. Initially, ``Bx = Ax``, `By = Ay`, ``Bz = Az``,
    then B undergoes a right-handed rotation relative to A by an angle
    ``theta`` about ``Az = Bz``.


::

    ⎡ cos(theta)  -sin(theta)   0 ⎤
    R_AB = ⎢ sin(theta)   cos(theta)   0 ⎥
           ⎣         0            0    1 ⎦)""";
        } MakeZRotation;
        // Symbol: drake::math::RotationMatrix::ProjectToRotationMatrix
        struct /* ProjectToRotationMatrix */ {
          // Source: drake/math/rotation_matrix.h:555
          const char* doc =
R"""(Given an approximate rotation matrix M, finds the RotationMatrix R
closest to M. Closeness is measured with a matrix-2 norm (or
equivalently with a Frobenius norm). Hence, this method creates a
RotationMatrix R from a 3x3 matrix M by minimizing ``‖R - M‖₂`` (the
matrix-2 norm of (R-M)) subject to ``R * Rᵀ = I``, where I is the 3x3
identity matrix. For this problem, closeness can also be measured by
forming the orthonormal matrix R whose elements minimize the
double-summation ``∑ᵢ ∑ⱼ (R(i,j) - M(i,j))²`` where ``i = 1:3, j =
1:3``, subject to ``R * Rᵀ = I``. The square-root of this
double-summation is called the Frobenius norm.

Parameter ``M``:
    a 3x3 matrix.

Parameter ``quality_factor``:
    . The quality of M as a rotation matrix. ``quality_factor`` = 1 is
    perfect (M = R). ``quality_factor`` = 1.25 means that when M
    multiplies a unit vector (magnitude 1), a vector of magnitude as
    large as 1.25 may result. ``quality_factor`` = 0.8 means that when
    M multiplies a unit vector, a vector of magnitude as small as 0.8
    may result. ``quality_factor`` = 0 means M is singular, so at
    least one of the bases related by matrix M does not span 3D space
    (when M multiples a unit vector, a vector of magnitude as small as
    0 may result).

Returns:
    proper orthonormal matrix R that is closest to M.

Raises:
    RuntimeError if R fails IsValid(R).

Note:
    William Kahan (UC Berkeley) and Hongkai Dai (Toyota Research
    Institute) proved that for this problem, the same R that minimizes
    the Frobenius norm also minimizes the matrix-2 norm (a.k.a an
    induced-2 norm), which is defined [Dahleh, Section 4.2] as the
    column matrix u which maximizes ``‖(R - M) u‖ / ‖u‖``, where ``u ≠
    0``. Since the matrix-2 norm of any matrix A is equal to the
    maximum singular value of A, minimizing the matrix-2 norm of (R -
    M) is equivalent to minimizing the maximum singular value of (R -
    M).

- [Dahleh] "Lectures on Dynamic Systems and Controls: Electrical
Engineering and Computer Science, Massachusetts Institute of Technology"
https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-241j-dynamic-systems-and-control-spring-2011/readings/MIT6_241JS11_chap04.pdf)""";
        } ProjectToRotationMatrix;
        // Symbol: drake::math::RotationMatrix::RotationMatrix<T>
        struct /* ctor */ {
          // Source: drake/math/rotation_matrix.h:56
          const char* doc_0args =
R"""(Constructs a 3x3 identity RotationMatrix -- which corresponds to
aligning two frames (so that unit vectors Ax = Bx, Ay = By, Az = Bz).)""";
          // Source: drake/math/rotation_matrix.h:61
          const char* doc_1args_R =
R"""(Constructs a RotationMatrix from a Matrix3.

Parameter ``R``:
    an allegedly valid rotation matrix.

Raises:
    RuntimeError in debug builds if R fails IsValid(R).)""";
          // Source: drake/math/rotation_matrix.h:71
          const char* doc_1args_quaternion =
R"""(Constructs a RotationMatrix from an Eigen::Quaternion.

Parameter ``quaternion``:
    a non-zero, finite quaternion which may or may not have unit
    length [i.e., ``quaternion.norm()`` does not have to be 1].

Raises:
    RuntimeError in debug builds if the rotation matrix R that is
    built from ``quaternion`` fails IsValid(R). For example, an
    exception is thrown if ``quaternion`` is zero or contains a NaN or
    infinity.

Note:
    This method has the effect of normalizing its ``quaternion``
    argument, without the inefficiency of the square-root associated
    with normalization.)""";
          // Source: drake/math/rotation_matrix.h:96
          const char* doc_1args_theta_lambda =
R"""(Constructs a RotationMatrix from an Eigen::AngleAxis.

Parameter ``theta_lambda``:
    an Eigen::AngleAxis whose associated axis (vector direction herein
    called ``lambda``) is non-zero and finite, but which may or may
    not have unit length [i.e., ``lambda.norm()`` does not have to be
    1].

Raises:
    RuntimeError in debug builds if the rotation matrix R that is
    built from ``theta_lambda`` fails IsValid(R). For example, an
    exception is thrown if ``lambda`` is zero or contains a NaN or
    infinity.)""";
          // Source: drake/math/rotation_matrix.h:138
          const char* doc_1args_rpy =
R"""(Constructs a RotationMatrix from an RollPitchYaw. In other words,
makes the RotationMatrix for a Space-fixed (extrinsic) X-Y-Z rotation
by "roll-pitch-yaw" angles ``[r, p, y]``, which is equivalent to a
Body-fixed (intrinsic) Z-Y-X rotation by "yaw-pitch-roll" angles ``[y,
p, r]``.

Parameter ``rpy``:
    radian measures of three angles [roll, pitch, yaw].

Parameter ``rpy``:
    a RollPitchYaw which is a Space-fixed (extrinsic) X-Y-Z rotation
    with "roll-pitch-yaw" angles ``[r, p, y]`` or equivalently a Body-
    fixed (intrinsic) Z-Y-X rotation with "yaw-pitch-roll" angles
    ``[y, p, r]``.

Note:
    Denoting roll ``r``, pitch ``p``, yaw ``y``, this method returns a
    rotation matrix ``R_AD`` equal to the matrix multiplication shown
    below.


::

    ⎡cos(y) -sin(y)  0⎤   ⎡ cos(p)  0  sin(p)⎤   ⎡1      0        0 ⎤
    R_AD = ⎢sin(y)  cos(y)  0⎥ * ⎢     0   1      0 ⎥ * ⎢0  cos(r)  -sin(r)⎥
           ⎣    0       0   1⎦   ⎣-sin(p)  0  cos(p)⎦   ⎣0  sin(r)   cos(r)⎦
         =       R_AB          *        R_BC          *        R_CD

Note:
    In this discussion, A is the Space frame and D is the Body frame.
    One way to visualize this rotation sequence is by introducing
    intermediate frames B and C (useful constructs to understand this
    rotation sequence). Initially, the frames are aligned so ``Di = Ci
    = Bi = Ai (i = x, y, z)``. Then D is subjected to successive
    right-handed rotations relative to A.

* 1st rotation R_CD: Frame D rotates relative to frames C, B, A by a
roll angle ``r`` about ``Dx = Cx``.  Note: D and C are no longer aligned.

* 2nd rotation R_BC: Frames D, C (collectively -- as if welded together)
rotate relative to frame B, A by a pitch angle ``p`` about ``Cy = By``.
Note: C and B are no longer aligned.

* 3rd rotation R_AB: Frames D, C, B (collectively -- as if welded)
rotate relative to frame A by a roll angle ``y`` about ``Bz = Az``.
Note: B and A are no longer aligned.

Note:
    This method constructs a RotationMatrix from a RollPitchYaw.
    Vice-versa, there are high-accuracy RollPitchYaw
    constructor/methods that form a RollPitchYaw from a rotation
    matrix.)""";
        } ctor;
        // Symbol: drake::math::RotationMatrix::ToAngleAxis
        struct /* ToAngleAxis */ {
          // Source: drake/math/rotation_matrix.h:626
          const char* doc =
R"""(Returns an AngleAxis ``theta_lambda`` containing an angle ``theta``
and unit vector (axis direction) ``lambda`` that represents ``this``
RotationMatrix.

Note:
    The orientation and RotationMatrix associated with ``theta *
    lambda`` is identical to that of ``(-theta) * (-lambda)``. The
    AngleAxis returned by this method chooses to have ``0 <= theta <=
    pi``.

Returns:
    an AngleAxis with ``0 <= theta <= pi`` and a unit vector
    ``lambda``.)""";
        } ToAngleAxis;
        // Symbol: drake::math::RotationMatrix::ToQuaternion
        struct /* ToQuaternion */ {
          // Source: drake/math/rotation_matrix.h:577
          const char* doc_0args =
R"""(Returns a quaternion q that represents ``this`` RotationMatrix. Since
the quaternion ``q`` and ``-q`` represent the same RotationMatrix,
this method chooses to return a canonical quaternion, i.e., with q(0)
>= 0.

Note:
    There is a constructor in the RollPitchYaw class that converts a
    rotation matrix to roll-pitch-yaw angles.)""";
          // Source: drake/math/rotation_matrix.h:587
          const char* doc_1args =
R"""(Returns a unit quaternion q associated with the 3x3 matrix M. Since
the quaternion ``q`` and ``-q`` represent the same RotationMatrix,
this method chooses to return a canonical quaternion, i.e., with q(0)
>= 0.

Parameter ``M``:
    3x3 matrix to be made into a quaternion.

Returns:
    a unit quaternion q in canonical form, i.e., with q(0) >= 0.

Raises:
    RuntimeError in debug builds if the quaternion ``q`` returned by
    this method cannot construct a valid RotationMatrix. For example,
    if ``M`` contains NaNs, ``q`` will not be a valid quaternion.)""";
        } ToQuaternion;
        // Symbol: drake::math::RotationMatrix::ToQuaternionAsVector4
        struct /* ToQuaternionAsVector4 */ {
          // Source: drake/math/rotation_matrix.h:608
          const char* doc_0args =
R"""(Utility method to return the Vector4 associated with ToQuaternion().

See also:
    ToQuaternion().)""";
          // Source: drake/math/rotation_matrix.h:615
          const char* doc_1args =
R"""(Utility method to return the Vector4 associated with ToQuaternion(M).

Parameter ``M``:
    3x3 matrix to be made into a quaternion.

See also:
    ToQuaternion().)""";
        } ToQuaternionAsVector4;
        // Symbol: drake::math::RotationMatrix::cast
        struct /* cast */ {
          // Source: drake/math/rotation_matrix.h:292
          const char* doc =
R"""(Creates a RotationMatrix templatized on a scalar type U from a
RotationMatrix templatized on scalar type T. For example,


::

    RotationMatrix<double> source = RotationMatrix<double>::Identity();
    RotationMatrix<AutoDiffXd> foo = source.cast<AutoDiffXd>();

Template parameter ``U``:
    Scalar type on which the returned RotationMatrix is templated.

Note:
    ``RotationMatrix<From>::cast<To>()`` creates a new
    ``RotationMatrix<To>`` from a ``RotationMatrix<From>`` but only if
    type ``To`` is constructible from type ``From``. This cast method
    works in accordance with Eigen's cast method for Eigen's Matrix3
    that underlies this RotationMatrix. For example, Eigen currently
    allows cast from type double to AutoDiffXd, but not vice-versa.)""";
        } cast;
        // Symbol: drake::math::RotationMatrix::col
        struct /* col */ {
          // Source: drake/math/rotation_matrix.h:376
          const char* doc =
R"""(Returns ``this`` rotation matrix's iᵗʰ column (i = 0, 1, 2). For
``this`` rotation matrix R_AB (which relates right-handed sets of
orthogonal unit vectors Ax, Ay, Az to Bx, By, Bz), - col(0) returns
Bx_A (Bx expressed in terms of Ax, Ay, Az). - col(1) returns By_A (By
expressed in terms of Ax, Ay, Az). - col(2) returns Bz_A (Bz expressed
in terms of Ax, Ay, Az).

Parameter ``index``:
    requested column index (0 <= index <= 2).

See also:
    row(), matrix()

Raises:
    In debug builds, asserts (0 <= index <= 2).

Note:
    For efficiency and consistency with Eigen, this method returns the
    same quantity returned by Eigen's col() operator. The returned
    quantity can be assigned in various ways, e.g., as ``const auto&
    Bz_A = col(2);`` or ``Vector3<T> Bz_A = col(2);``)""";
        } col;
        // Symbol: drake::math::RotationMatrix::get_internal_tolerance_for_orthonormality
        struct /* get_internal_tolerance_for_orthonormality */ {
          // Source: drake/math/rotation_matrix.h:568
          const char* doc =
R"""(Returns an internal tolerance that checks rotation matrix
orthonormality.

Returns:
    internal tolerance (small multiplier of double-precision epsilon)
    used to check whether or not a rotation matrix is orthonormal.

Note:
    The tolerance is chosen by developers to ensure a reasonably valid
    (orthonormal) rotation matrix.

Note:
    To orthonormalize a 3x3 matrix, use ProjectToRotationMatrix().)""";
        } get_internal_tolerance_for_orthonormality;
        // Symbol: drake::math::RotationMatrix::inverse
        struct /* inverse */ {
          // Source: drake/math/rotation_matrix.h:326
          const char* doc = R"""()""";
        } inverse;
        // Symbol: drake::math::RotationMatrix::matrix
        struct /* matrix */ {
          // Source: drake/math/rotation_matrix.h:339
          const char* doc =
R"""(Returns the Matrix3 underlying a RotationMatrix.

See also:
    col(), row())""";
        } matrix;
        // Symbol: drake::math::RotationMatrix::operator*
        struct /* operator_mul */ {
          // Source: drake/math/rotation_matrix.h:402
          const char* doc_1args_other =
R"""(Calculates ``this`` rotation matrix ``R_AB`` multiplied by ``other``
rotation matrix ``R_BC``, returning the composition ``R_AB * R_BC``.

Parameter ``other``:
    RotationMatrix that post-multiplies ``this``.

Returns:
    rotation matrix that results from ``this`` multiplied by
    ``other``.

Note:
    It is possible (albeit improbable) to create an invalid rotation
    matrix by accumulating round-off error with a large number of
    multiplies.)""";
          // Source: drake/math/rotation_matrix.h:410
          const char* doc_1args_v_B =
R"""(Calculates ``this`` rotation matrix ``R_AB`` multiplied by an
arbitrary Vector3 expressed in the B frame.

Parameter ``v_B``:
    3x1 vector that post-multiplies ``this``.

Returns:
    3x1 vector ``v_A = R_AB * v_B``.)""";
          // Source: drake/math/rotation_matrix.h:430
          const char* doc_1args_constEigenMatrixBase =
R"""(Multiplies ``this`` RotationMatrix ``R_AB`` by the n vectors ``v1``,
... `vn`, where each vector has 3 elements and is expressed in frame
B.

Parameter ``v_B``:
    ``3 x n`` matrix whose n columns are regarded as arbitrary vectors
    ``v1``, ... `vn` expressed in frame B.

Returns ``v_A``:
    ``3 x n`` matrix whose n columns are vectors ``v1``, ... `vn`
    expressed in frame A.


::

    const RollPitchYaw<double> rpy(0.1, 0.2, 0.3);
    const RotationMatrix<double> R_AB(rpy);
    Eigen::Matrix<double, 3, 2> v_B;
    v_B.col(0) = Vector3d(4, 5, 6);
    v_B.col(1) = Vector3d(9, 8, 7);
    const Eigen::Matrix<double, 3, 2> v_A = R_AB * v_B;)""";
        } operator_mul;
        // Symbol: drake::math::RotationMatrix::operator*=
        struct /* operator_imul */ {
          // Source: drake/math/rotation_matrix.h:391
          const char* doc =
R"""(In-place multiply of ``this`` rotation matrix ``R_AB`` by ``other``
rotation matrix ``R_BC``. On return, ``this`` is set to equal ``R_AB *
R_BC``.

Parameter ``other``:
    RotationMatrix that post-multiplies ``this``.

Returns:
    ``this`` rotation matrix which has been multiplied by ``other``.

Note:
    It is possible (albeit improbable) to create an invalid rotation
    matrix by accumulating round-off error with a large number of
    multiplies.)""";
        } operator_imul;
        // Symbol: drake::math::RotationMatrix::row
        struct /* row */ {
          // Source: drake/math/rotation_matrix.h:354
          const char* doc =
R"""(Returns ``this`` rotation matrix's iᵗʰ row (i = 0, 1, 2). For ``this``
rotation matrix R_AB (which relates right-handed sets of orthogonal
unit vectors Ax, Ay, Az to Bx, By, Bz), - row(0) returns Ax_B (Ax
expressed in terms of Bx, By, Bz). - row(1) returns Ay_B (Ay expressed
in terms of Bx, By, Bz). - row(2) returns Az_B (Az expressed in terms
of Bx, By, Bz).

Parameter ``index``:
    requested row index (0 <= index <= 2).

See also:
    col(), matrix()

Raises:
    In debug builds, asserts (0 <= index <= 2).

Note:
    For efficiency and consistency with Eigen, this method returns the
    same quantity returned by Eigen's row() operator. The returned
    quantity can be assigned in various ways, e.g., as ``const auto&
    Az_B = row(2);`` or ``RowVector3<T> Az_B = row(2);``)""";
        } row;
        // Symbol: drake::math::RotationMatrix::set
        struct /* set */ {
          // Source: drake/math/rotation_matrix.h:311
          const char* doc =
R"""(Sets ``this`` RotationMatrix from a Matrix3.

Parameter ``R``:
    an allegedly valid rotation matrix.

Raises:
    RuntimeError in debug builds if R fails IsValid(R).)""";
        } set;
        // Symbol: drake::math::RotationMatrix::transpose
        struct /* transpose */ {
          // Source: drake/math/rotation_matrix.h:333
          const char* doc = R"""()""";
        } transpose;
      } RotationMatrix;
      // Symbol: drake::math::RotationMatrixd
      struct /* RotationMatrixd */ {
        // Source: drake/math/rotation_matrix.h:943
        const char* doc =
R"""(Abbreviation (alias/typedef) for a RotationMatrix double scalar type.)""";
      } RotationMatrixd;
      // Symbol: drake::math::SparseMatrixToRowColumnValueVectors
      struct /* SparseMatrixToRowColumnValueVectors */ {
        // Source: drake/math/eigen_sparse_triplet.h:61
        const char* doc =
R"""(For a sparse matrix, return the row indices, the column indices, and
value of the non-zero entries. For example, the matrix

.. math:: mat = \begin{bmatrix} 1 & 0 & 2\
                      0 & 3 & 4\end{bmatrix}

has

.. math:: row = \begin{bmatrix} 0 & 1 & 0 & 1\end{bmatrix}\
col = \begin{bmatrix} 0 & 1 & 2 & 2\end{bmatrix}\
val = \begin{bmatrix} 1 & 3 & 2 & 4\end{bmatrix}

Parameter ``matrix``:
    the input sparse matrix

Parameter ``row_indices``:
    a vector containing the row indices of the non-zero entries

Parameter ``col_indices``:
    a vector containing the column indices of the non-zero entries

Parameter ``val``:
    a vector containing the values of the non-zero entries.)""";
      } SparseMatrixToRowColumnValueVectors;
      // Symbol: drake::math::SparseMatrixToTriplets
      struct /* SparseMatrixToTriplets */ {
        // Source: drake/math/eigen_sparse_triplet.h:18
        const char* doc =
R"""(For a sparse matrix, return a vector of triplets, such that we can
reconstruct the matrix using setFromTriplet function

Parameter ``matrix``:
    A sparse matrix

Returns:
    A triplet with the row, column and value of the non-zero entries.
    See https://eigen.tuxfamily.org/dox/group__TutorialSparse.html for
    more information on the triplet)""";
      } SparseMatrixToTriplets;
      // Symbol: drake::math::ToSymmetricMatrixFromLowerTriangularColumns
      struct /* ToSymmetricMatrixFromLowerTriangularColumns */ {
        // Source: drake/math/matrix_util.h:91
        const char* doc_was_unable_to_choose_unambiguous_names =
R"""(Given a column vector containing the stacked columns of the lower
triangular part of a square matrix, returning a symmetric matrix whose
lower triangular part is the same as the original matrix.)""";
      } ToSymmetricMatrixFromLowerTriangularColumns;
      // Symbol: drake::math::UniformPtsOnSphereFibonacci
      struct /* UniformPtsOnSphereFibonacci */ {
        // Source: drake/math/evenly_distributed_pts_on_sphere.h:17
        const char* doc =
R"""(Deterministically generates approximate evenly distributed points on a
unit sphere. This method uses Fibonacci number. For the detailed math,
please refer to
http://stackoverflow.com/questions/9600801/evenly-distributing-n-points-on-a-sphere
This algorithm generates the points in O(n) time, where ``n`` is the
number of points.

Parameter ``num_points``:
    The number of points we want on the unit sphere.

Returns:
    The generated points.

Precondition:
    num_samples >= 1. Throw RuntimeError if num_points < 1)""";
      } UniformPtsOnSphereFibonacci;
      // Symbol: drake::math::UniformlyRandomAngleAxis
      struct /* UniformlyRandomAngleAxis */ {
        // Source: drake/math/random_rotation.h:45
        const char* doc =
R"""(Generates a rotation (in the axis-angle representation) that rotates a
point on the unit sphere to another point on the unit sphere with a
uniform distribution over the sphere.)""";
      } UniformlyRandomAngleAxis;
      // Symbol: drake::math::UniformlyRandomQuaternion
      struct /* UniformlyRandomQuaternion */ {
        // Source: drake/math/random_rotation.h:24
        const char* doc =
R"""(Generates a rotation (in the quaternion representation) that rotates a
point on the unit sphere to another point on the unit sphere with a
uniform distribution over the sphere. This method is briefly explained
in http://planning.cs.uiuc.edu/node198.html, a full explanation can be
found in K. Shoemake. Uniform Random Rotations in D. Kirk, editor,
Graphics Gems III, pages 124-132. Academic, New York, 1992.)""";
      } UniformlyRandomQuaternion;
      // Symbol: drake::math::UniformlyRandomRPY
      struct /* UniformlyRandomRPY */ {
        // Source: drake/math/random_rotation.h:67
        const char* doc =
R"""(Generates a rotation (in the roll-pitch-yaw representation) that
rotates a point on the unit sphere to another point on the unit sphere
with a uniform distribution over the sphere.)""";
      } UniformlyRandomRPY;
      // Symbol: drake::math::UniformlyRandomRotationMatrix
      struct /* UniformlyRandomRotationMatrix */ {
        // Source: drake/math/random_rotation.h:56
        const char* doc =
R"""(Generates a rotation (in the rotation matrix representation) that
rotates a point on the unit sphere to another point on the unit sphere
with a uniform distribution over the sphere.)""";
      } UniformlyRandomRotationMatrix;
      // Symbol: drake::math::VectorToSkewSymmetric
      struct /* VectorToSkewSymmetric */ {
        // Source: drake/math/cross_product.h:11
        const char* doc = R"""()""";
      } VectorToSkewSymmetric;
      // Symbol: drake::math::autoDiffToGradientMatrix
      struct /* autoDiffToGradientMatrix */ {
        // Source: drake/math/autodiff_gradient.h:28
        const char* doc = R"""()""";
      } autoDiffToGradientMatrix;
      // Symbol: drake::math::autoDiffToValueMatrix
      struct /* autoDiffToValueMatrix */ {
        // Source: drake/math/autodiff.h:27
        const char* doc = R"""()""";
      } autoDiffToValueMatrix;
      // Symbol: drake::math::dquat2rotmat
      struct /* dquat2rotmat */ {
        // Source: drake/math/rotation_conversion_gradient.h:21
        const char* doc =
R"""(Computes the gradient of the function that converts a unit length
quaternion to a rotation matrix.

Parameter ``quaternion``:
    A unit length quaternion [w;x;y;z]

Returns:
    The gradient)""";
      } dquat2rotmat;
      // Symbol: drake::math::drotmat2quat
      struct /* drotmat2quat */ {
        // Source: drake/math/rotation_conversion_gradient.h:120
        const char* doc =
R"""(Computes the gradient of the function that converts rotation matrix to
quaternion.

Parameter ``R``:
    A 3 x 3 rotation matrix

Parameter ``dR``:
    A 9 x N matrix, dR(i,j) is the gradient of R(i) w.r.t x_var(j)

Returns:
    The gradient G. G is a 4 x N matrix G(0,j) is the gradient of w
    w.r.t x_var(j) G(1,j) is the gradient of x w.r.t x_var(j) G(2,j)
    is the gradient of y w.r.t x_var(j) G(3,j) is the gradient of z
    w.r.t x_var(j))""";
      } drotmat2quat;
      // Symbol: drake::math::drotmat2rpy
      struct /* drotmat2rpy */ {
        // Source: drake/math/rotation_conversion_gradient.h:58
        const char* doc =
R"""(Computes the gradient of the function that converts a rotation matrix
to body-fixed z-y'-x'' Euler angles.

Parameter ``R``:
    A 3 x 3 rotation matrix

Parameter ``dR``:
    A 9 x N matrix, dR(i,j) is the gradient of R(i) w.r.t x(j)

Returns:
    The gradient G. G is a 3 x N matrix. G(0,j) is the gradient of
    roll w.r.t x(j) G(1,j) is the gradient of pitch w.r.t x(j) G(2,j)
    is the gradient of yaw w.r.t x(j))""";
      } drotmat2rpy;
      // Symbol: drake::math::getSubMatrixGradient
      struct /* getSubMatrixGradient */ {
        // Source: drake/math/gradient_util.h:173
        const char* doc = R"""()""";
      } getSubMatrixGradient;
      // Symbol: drake::math::gradientMatrixToAutoDiff
      struct /* gradientMatrixToAutoDiff */ {
        // Source: drake/math/autodiff_gradient.h:126
        const char* doc = R"""()""";
      } gradientMatrixToAutoDiff;
      // Symbol: drake::math::hessian
      struct /* hessian */ {
        // Source: drake/math/jacobian.h:163
        const char* doc =
R"""(Computes a matrix of AutoDiffScalars from which the value, Jacobian,
and Hessian of a function

.. math:: f:\mathbb{R}^{n\times m}\rightarrow\mathbb{R}^{p\times q}

(f: R^n*m -> R^p*q) can be extracted.

The output is a matrix of nested AutoDiffScalars, being the result of
calling ::jacobian on a function that returns the output of
::jacobian, called on ``f``.

``MaxChunkSizeOuter`` and ``MaxChunkSizeInner`` can be used to control
chunk sizes (see ::jacobian).

See ::jacobian for requirements on the function ``f`` and the argument
``x``.

Parameter ``f``:
    function

Parameter ``x``:
    function argument value at which Hessian will be evaluated

Returns:
    AutoDiffScalar matrix corresponding to the Hessian of f evaluated
    at x)""";
      } hessian;
      // Symbol: drake::math::initializeAutoDiff
      struct /* initializeAutoDiff */ {
        // Source: drake/math/autodiff.h:112
        const char* doc_4args =
R"""(Initialize a single autodiff matrix given the corresponding value
matrix.

Set the values of ``auto_diff_matrix`` to be equal to ``val``, and for
each element i of ``auto_diff_matrix``, resize the derivatives vector
to ``num_derivatives``, and set derivative number ``deriv_num_start``
+ i to one (all other elements of the derivative vector set to zero).

Parameter ``mat``:
    'regular' matrix of values

Parameter ``ret``:
    AutoDiff matrix

Parameter ``num_derivatives``:
    the size of the derivatives vector $*Default:* the size of mat

Parameter ``deriv_num_start``:
    starting index into derivative vector (i.e. element
    deriv_num_start in derivative vector corresponds to mat(0, 0)).

*Default:* 0)""";
        // Source: drake/math/autodiff.h:161
        const char* doc_3args =
R"""(Initialize a single autodiff matrix given the corresponding value
matrix.

Create autodiff matrix that matches ``mat`` in size with derivatives
of compile time size ``Nq`` and runtime size ``num_derivatives``. Set
its values to be equal to ``val``, and for each element i of
``auto_diff_matrix``, set derivative number ``deriv_num_start`` + i to
one (all other derivatives set to zero).

Parameter ``mat``:
    'regular' matrix of values

Parameter ``num_derivatives``:
    the size of the derivatives vector $*Default:* the size of mat

Parameter ``deriv_num_start``:
    starting index into derivative vector (i.e. element
    deriv_num_start in derivative vector corresponds to mat(0, 0)).

*Default:* 0
    $Returns:

AutoDiff matrix)""";
      } initializeAutoDiff;
      // Symbol: drake::math::initializeAutoDiffGivenGradientMatrix
      struct /* initializeAutoDiffGivenGradientMatrix */ {
        // Source: drake/math/autodiff_gradient.h:74
        const char* doc_3args =
R"""(Initializes an autodiff matrix given a matrix of values and gradient
matrix

Parameter ``val``:
    value matrix

Parameter ``gradient``:
    gradient matrix; the derivatives of val(j) are stored in row j of
    the gradient matrix.

Parameter ``autodiff_matrix``:
    matrix of AutoDiffScalars with the same size as ``val``)""";
        // Source: drake/math/autodiff_gradient.h:116
        const char* doc_2args =
R"""(Creates and initializes an autodiff matrix given a matrix of values
and gradient matrix

Parameter ``val``:
    value matrix

Parameter ``gradient``:
    gradient matrix; the derivatives of val(j) are stored in row j of
    the gradient matrix.

Returns:
    autodiff_matrix matrix of AutoDiffScalars with the same size as
    ``val``)""";
      } initializeAutoDiffGivenGradientMatrix;
      // Symbol: drake::math::initializeAutoDiffTuple
      struct /* initializeAutoDiffTuple */ {
        // Source: drake/math/autodiff.h:314
        const char* doc =
R"""(Given a series of Eigen matrices, create a tuple of corresponding
AutoDiff matrices with values equal to the input matrices and properly
initialized derivative vectors.

The size of the derivative vector of each element of the matrices in
the output tuple will be the same, and will equal the sum of the
number of elements of the matrices in ``args``. If all of the matrices
in ``args`` have fixed size, then the derivative vectors will also
have fixed size (being the sum of the sizes at compile time of all of
the input arguments), otherwise the derivative vectors will have
dynamic size. The 0th element of the derivative vectors will
correspond to the derivative with respect to the 0th element of the
first argument. Subsequent derivative vector elements correspond first
to subsequent elements of the first input argument (traversed first by
row, then by column), and so on for subsequent arguments.

Parameter ``args``:
    a series of Eigen matrices

Returns:
    a tuple of properly initialized AutoDiff matrices corresponding to
    ``args``)""";
      } initializeAutoDiffTuple;
      // Symbol: drake::math::intRange
      struct /* intRange */ {
        // Source: drake/math/gradient_util.h:16
        const char* doc = R"""()""";
      } intRange;
      // Symbol: drake::math::is_quaternion_in_canonical_form
      struct /* is_quaternion_in_canonical_form */ {
        // Source: drake/math/quaternion.h:124
        const char* doc =
R"""(This function tests whether a quaternion is in "canonical form"
meaning that it tests whether the quaternion [w, x, y, z] has a
non-negative w value. Example: [-0.3, +0.4, +0.5, +0.707] is not in
canonical form. Example: [+0.3, -0.4, -0.5, -0.707] is in canonical
form.

Parameter ``quat``:
    Quaternion [w, x, y, z] that relates two right-handed orthogonal
    unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: quat
    is analogous to the rotation matrix R_AB.

Returns:
    ``True`` if quat.w() is nonnegative (in canonical form), else
    ``False``.)""";
      } is_quaternion_in_canonical_form;
      // Symbol: drake::math::jacobian
      struct /* jacobian */ {
        // Source: drake/math/jacobian.h:57
        const char* doc =
R"""(Computes a matrix of AutoDiffScalars from which both the value and the
Jacobian of a function

.. math:: f:\mathbb{R}^{n\times m}\rightarrow\mathbb{R}^{p\times q}

(f: R^n*m -> R^p*q) can be extracted.

The derivative vector for each AutoDiffScalar in the output contains
the derivatives with respect to all components of the argument
:math:`x`.

The return type of this function is a matrix with the `best' possible
AutoDiffScalar scalar type, in the following sense: - If the number of
derivatives can be determined at compile time, the AutoDiffScalar
derivative vector will have that fixed size. - If the maximum number
of derivatives can be determined at compile time, the AutoDiffScalar
derivative vector will have that maximum fixed size. - If neither the
number, nor the maximum number of derivatives can be determined at
compile time, the output AutoDiffScalar derivative vector will be
dynamically sized.

``f`` should have a templated call operator that maps an Eigen matrix
argument to another Eigen matrix. The scalar type of the output of
:math:`f` need not match the scalar type of the input (useful in
recursive calls to the function to determine higher order
derivatives). The easiest way to create an ``f`` is using a C++14
generic lambda.

The algorithm computes the Jacobian in chunks of up to
``MaxChunkSize`` derivatives at a time. This has three purposes: - It
makes it so that derivative vectors can be allocated on the stack,
eliminating dynamic allocations and improving performance if the
maximum number of derivatives cannot be determined at compile time. -
It gives control over, and limits the number of required
instantiations of the call operator of f and all the functions it
calls. - Excessively large derivative vectors can result in CPU
capacity cache misses; even if the number of derivatives is fixed at
compile time, it may be better to break up into chunks if that means
that capacity cache misses can be prevented.

Parameter ``f``:
    function

Parameter ``x``:
    function argument value at which Jacobian will be evaluated

Returns:
    AutoDiffScalar matrix corresponding to the Jacobian of f evaluated
    at x.)""";
      } jacobian;
      // Symbol: drake::math::matGradMult
      struct /* matGradMult */ {
        // Source: drake/math/gradient_util.h:139
        const char* doc = R"""()""";
      } matGradMult;
      // Symbol: drake::math::matGradMultMat
      struct /* matGradMultMat */ {
        // Source: drake/math/gradient_util.h:102
        const char* doc = R"""()""";
      } matGradMultMat;
      // Symbol: drake::math::quatConjugate
      struct /* quatConjugate */ {
        // Source: drake/math/quaternion.h:43
        const char* doc = R"""()""";
      } quatConjugate;
      // Symbol: drake::math::quatDiff
      struct /* quatDiff */ {
        // Source: drake/math/quaternion.h:92
        const char* doc = R"""()""";
      } quatDiff;
      // Symbol: drake::math::quatDiffAxisInvar
      struct /* quatDiffAxisInvar */ {
        // Source: drake/math/quaternion.h:101
        const char* doc = R"""()""";
      } quatDiffAxisInvar;
      // Symbol: drake::math::quatProduct
      struct /* quatProduct */ {
        // Source: drake/math/quaternion.h:54
        const char* doc = R"""()""";
      } quatProduct;
      // Symbol: drake::math::quatRotateVec
      struct /* quatRotateVec */ {
        // Source: drake/math/quaternion.h:74
        const char* doc = R"""()""";
      } quatRotateVec;
      // Symbol: drake::math::resizeDerivativesToMatchScalar
      struct /* resizeDerivativesToMatchScalar */ {
        // Source: drake/math/autodiff.h:210
        const char* doc =
R"""(Resize derivatives vector of each element of a matrix to to match the
size of the derivatives vector of a given scalar. If the mat and
scalar inputs are AutoDiffScalars, resize the derivatives vector of
each element of the matrix mat to match the number of derivatives of
the scalar. This is useful in functions that return matrices that do
not depend on an AutoDiffScalar argument (e.g. a function with a
constant output), while it is desired that information about the
number of derivatives is preserved.

Parameter ``mat``:
    matrix, for which the derivative vectors of the elements will be
    resized

Parameter ``scalar``:
    scalar to match the derivative size vector against.)""";
      } resizeDerivativesToMatchScalar;
      // Symbol: drake::math::saturate
      struct /* saturate */ {
        // Source: drake/math/saturate.h:14
        const char* doc =
R"""(Saturates the input ``value`` between upper and lower bounds. If
``value`` is within ``[low, high]`` then return it; else return the
boundary.)""";
      } saturate;
      // Symbol: drake::math::setSubMatrixGradient
      struct /* setSubMatrixGradient */ {
        // Source: drake/math/gradient_util.h:235
        const char* doc = R"""()""";
      } setSubMatrixGradient;
      // Symbol: drake::math::transposeGrad
      struct /* transposeGrad */ {
        // Source: drake/math/gradient_util.h:85
        const char* doc = R"""()""";
      } transposeGrad;
      // Symbol: drake::math::wrap_to
      struct /* wrap_to */ {
        // Source: drake/math/wrap_to.h:19
        const char* doc =
R"""(For variables that are meant to be periodic, (e.g. over a 2π
interval), wraps ``value`` into the interval ``[low, high)``.
Precisely, ``wrap_to`` returns: value + k*(high-low) for the unique
integer value ``k`` that lands the output in the desired interval.
``low`` and ``high`` must be finite, and low < high.)""";
      } wrap_to;
    } math;
    // Symbol: drake::multibody
    struct /* multibody */ {
      // Symbol: drake::multibody::AddMultibodyPlantSceneGraph
      struct /* AddMultibodyPlantSceneGraph */ {
        // Source: drake/multibody/plant/multibody_plant.h:4680
        const char* doc_3args_systemsDiagramBuilder_double_stduniqueptr =
R"""(Makes a new MultibodyPlant with discrete update period ``time_step``
and adds it to a diagram builder together with the provided SceneGraph
instance, connecting the geometry ports.

Note:
    Usage examples in add_multibody_plant_scene_graph
    "AddMultibodyPlantSceneGraph".

Parameter ``builder``:
    Builder to add to.

Parameter ``time_step``:
    The discrete update period for the new MultibodyPlant to be added.
    Please refer to the documentation provided in
    MultibodyPlant::MultibodyPlant(double) for further details on the
    parameter ``time_step``.

Parameter ``scene_graph``:
    (optional) Constructed scene graph. If none is provided, one will
    be created and used.

Returns:
    Pair of the registered plant and scene graph.

Precondition:
    ``builder`` must be non-null.)""";
        // Source: drake/multibody/plant/multibody_plant.h:4702
        const char* doc_3args_systemsDiagramBuilder_stduniqueptr_stduniqueptr =
R"""(Adds a MultibodyPlant and a SceneGraph instance to a diagram builder,
connecting the geometry ports.

Note:
    Usage examples in add_multibody_plant_scene_graph
    "AddMultibodyPlantSceneGraph".

Parameter ``builder``:
    Builder to add to.

Parameter ``plant``:
    Plant to be added to the builder.

Parameter ``scene_graph``:
    (optional) Constructed scene graph. If none is provided, one will
    be created and used.

Returns:
    Pair of the registered plant and scene graph.

Precondition:
    ``builder`` and ``plant`` must be non-null.)""";
      } AddMultibodyPlantSceneGraph;
      // Symbol: drake::multibody::AddMultibodyPlantSceneGraphResult
      struct /* AddMultibodyPlantSceneGraphResult */ {
        // Source: drake/multibody/plant/multibody_plant.h:4712
        const char* doc =
R"""(Temporary result from ``AddMultibodyPlantSceneGraph``. This cannot be
constructed outside of this method.

Warning:
    Do NOT use this as a function argument or member variable. The
    lifetime of this object should be as short as possible.)""";
        // Symbol: drake::multibody::AddMultibodyPlantSceneGraphResult::AddMultibodyPlantSceneGraphResult<T>
        struct /* ctor */ {
          // Source: drake/multibody/plant/multibody_plant.h:4740
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::multibody::AddMultibodyPlantSceneGraphResult::get
        struct /* get */ {
          // Source: drake/multibody/plant/multibody_plant.h:4730
          const char* doc = R"""()""";
        } get;
        // Symbol: drake::multibody::AddMultibodyPlantSceneGraphResult::operator MultibodyPlant<type-parameter-0-0> &
        struct /* operator_MultibodyPlant_ */ {
          // Source: drake/multibody/plant/multibody_plant.h:4717
          const char* doc =
R"""(For assignment to a plant reference (ignoring the scene graph).)""";
        } operator_MultibodyPlant_;
        // Symbol: drake::multibody::AddMultibodyPlantSceneGraphResult::operator tuple<MultibodyPlant<type-parameter-0-0> *&, SceneGraph<type-parameter-0-0> *&>
        struct /* operator_tuple */ {
          // Source: drake/multibody/plant/multibody_plant.h:4720
          const char* doc =
R"""(For assignment to a std::tie of pointers.)""";
        } operator_tuple;
        // Symbol: drake::multibody::AddMultibodyPlantSceneGraphResult::plant
        struct /* plant */ {
          // Source: drake/multibody/plant/multibody_plant.h:4713
          const char* doc = R"""()""";
        } plant;
        // Symbol: drake::multibody::AddMultibodyPlantSceneGraphResult::scene_graph
        struct /* scene_graph */ {
          // Source: drake/multibody/plant/multibody_plant.h:4714
          const char* doc = R"""()""";
        } scene_graph;
      } AddMultibodyPlantSceneGraphResult;
      // Symbol: drake::multibody::AddSlidingFrictionComplementarityExplicitContactConstraint
      struct /* AddSlidingFrictionComplementarityExplicitContactConstraint */ {
        // Source: drake/multibody/optimization/sliding_friction_complementarity_constraint.h:166
        const char* doc =
R"""(For a pair of geometries in explicit contact, adds the sliding
friction complementarity constraint explained in
sliding_friction_complementarity_constraint to an optimization
program. This function adds the slack variables (f_static, f_sliding,
c), and impose all the constraints in
sliding_friction_complementarity_constraint.

Parameter ``contact_wrench_evaluator``:
    Evaluates the contact wrench between a pair of geometries.

Parameter ``complementarity_tolerance``:
    The tolerance on the complementarity constraint.

Parameter ``q_vars``:
    The variable for the generalized position q in ``prog``.

Parameter ``v_vars``:
    The variable for the generalized velocity v in ``prog``.

Parameter ``lambda_vars``:
    The variables to parameterize the contact wrench between this pair
    of geometry.

Parameter ``prog``:
    The optimization program to which the sliding friction
    complementarity constraint is imposed.

Returns:
    (sliding_friction_complementarity_constraint,
    static_friction_cone_constraint), the pair of constraint that
    imposes (1)-(4) and (6) in
    sliding_friction_complementarity_constraint.)""";
      } AddSlidingFrictionComplementarityExplicitContactConstraint;
      // Symbol: drake::multibody::AddSlidingFrictionComplementarityImplicitContactConstraint
      struct /* AddSlidingFrictionComplementarityImplicitContactConstraint */ {
        // Source: drake/multibody/optimization/sliding_friction_complementarity_constraint.h:187
        const char* doc =
R"""(For a pair of geometries in implicit contact (they may or may not be
in contact, adds the sliding friction complementarity constraint
explained in sliding_friction_complementarity_constraint. The input
arguments are the same as those in
AddSlidingFrictionComplementarityExplicitContactConstraint(). The
difference is that the returned argument includes the nonlinear
complementarity binding 0 ≤ φ(q) ⊥ fₙ≥ 0, which imposes the constraint
for implicit contact.)""";
      } AddSlidingFrictionComplementarityImplicitContactConstraint;
      // Symbol: drake::multibody::AddStaticFrictionConeComplementarityConstraint
      struct /* AddStaticFrictionConeComplementarityConstraint */ {
        // Source: drake/multibody/optimization/static_friction_cone_complementarity_constraint.h:118
        const char* doc =
R"""(Adds the complementarity constraint on the static friction force
between a pair of contacts |ft_W| <= μ * n_Wᵀ * f_W (static friction
force in the friction cone). fn_W * sdf = 0 (complementarity
condition) sdf >= 0 (no penetration) where sdf stands for signed
distance function, ft_W stands for the tangential friction force
expressed in the world frame.

Mathematically, we add the following constraints to the optimization
program

f_Wᵀ * ((μ² + 1)* n_W * n_Wᵀ - I) * f_W ≥ 0 (1) n_Wᵀ * f_W = α (2)
sdf(q) = β (3) 0 ≤ α * β ≤ ε (4) α ≥ 0 (5) β ≥ 0 (6) the slack
variables α and β are added to the optimization program as well.

Parameter ``contact_wrench_evaluator``:
    The evaluator to compute the contact wrench expressed in the world
    frame.

Parameter ``complementarity_tolerance``:
    ε in the documentation above.

Parameter ``q_vars``:
    The decision variable for the generalized configuration q.

Parameter ``lambda_vars``:
    The decision variable to parameterize the contact wrench.

Parameter ``prog``:
    The optimization program to which the constraint is added.

Returns:
    binding The binding containing the nonlinear constraints (1)-(4).

Precondition:
    Both ``q_vars`` and ``lambda_vars`` have been added to ``prog``
    before calling this function.)""";
      } AddStaticFrictionConeComplementarityConstraint;
      // Symbol: drake::multibody::AddUnitQuaternionConstraintOnPlant
      struct /* AddUnitQuaternionConstraintOnPlant */ {
        // Source: drake/multibody/inverse_kinematics/unit_quaternion_constraint.h:50
        const char* doc =
R"""(Add unit length constraints to all the variables representing
quaternion in ``q_vars``. Namely the quaternions for floating base
joints in ``plant`` will be enforced to have a unit length.

Parameter ``plant``:
    The plant on which we impose the unit quaternion constraints.

Parameter ``q_vars``:
    The decision variables for the generalized position of the plant.

Parameter ``prog``:
    The unit quaternion constraints are added to this prog.)""";
      } AddUnitQuaternionConstraintOnPlant;
      // Symbol: drake::multibody::AngleBetweenVectorsConstraint
      struct /* AngleBetweenVectorsConstraint */ {
        // Source: drake/multibody/inverse_kinematics/angle_between_vectors_constraint.h:19
        const char* doc =
R"""(Constrains that the angle between a vector ``a`` and another vector
``b`` is between [θ_lower, θ_upper]. ``a`` is fixed to a frame A,
while ``b`` is fixed to a frame B. Mathematically, if we denote
a_unit_A as ``a`` expressed in frame A after normalization (a_unit_A
has unit length), and b_unit_B as ``b`` expressed in frame B after
normalization, the constraint is cos(θ_upper) ≤ a_unit_Aᵀ * R_AB *
b_unit_B ≤ cos(θ_lower))""";
        // Symbol: drake::multibody::AngleBetweenVectorsConstraint::AngleBetweenVectorsConstraint
        struct /* ctor */ {
          // Source: drake/multibody/inverse_kinematics/angle_between_vectors_constraint.h:46
          const char* doc =
R"""(Constructs an AngleBetweenVectorsConstraint.

Parameter ``plant``:
    The MultibodyPlant on which the constraint is imposed. ``plant``
    should be alive during the lifetime of this constraint.

Parameter ``frameA``:
    The Frame object for frame A.

Parameter ``a_A``:
    The vector ``a`` fixed to frame A, expressed in frame A.

Parameter ``frameB``:
    The Frame object for frame B.

Parameter ``b_B``:
    The vector ``b`` fixed to frame B, expressed in frameB.

Parameter ``angle_lower``:
    The lower bound on the angle between ``a`` and ``b``. It is
    denoted as θ_lower in the class documentation.

Parameter ``angle_upper``:
    The upper bound on the angle between ``a`` and ``b``. it is
    denoted as θ_upper in the class documentation.

Parameter ``plant_context``:
    The Context that has been allocated for this ``plant``. We will
    update the context when evaluating the constraint.
    ``plant_context`` should be alive during the lifetime of this
    constraint.

Precondition:
    ``frameA`` and ``frameB`` must belong to ``plant``.

Raises:
    ValueError if ``plant`` is nullptr.

Raises:
    ValueError if ``a_A`` is close to zero.

Raises:
    ValueError if ``b_B`` is close to zero.

Raises:
    ValueError if ``angle_lower`` is negative.

Raises:
    ValueError if ``angle_upper`` ∉ [`angle_lower`, π].

Raises:
    ValueError if ``plant_context`` is nullptr.)""";
        } ctor;
      } AngleBetweenVectorsConstraint;
      // Symbol: drake::multibody::ArticulatedBodyInertia
      struct /* ArticulatedBodyInertia */ {
        // Source: drake/multibody/tree/articulated_body_inertia.h:94
        const char* doc =
R"""(_Articulated Body Inertia_ is the inertia that a body appears to have
when it is the base (or root) of a rigid-body system, also referred to
as *Articulated Body* in the context of articulated body algorithms.
The *Articulated Body Inertia* is a very useful multibody dynamics
concept that was introduced by Featherstone [Featherstone 1983] to
develop the remarkable ``O(n)`` Articulated Body Algorithm (ABA) for
solving forward dynamics. Recall that the Newton-Euler equations allow
us to describe the combined rotational and translational dynamics of a
rigid body:


::

    F_BBo_W = M_B_W * A_WB + Fb_Bo_W                                     (1)

where the spatial inertia (see SpatialInertia) ``M_B_W`` of body B
expressed in the world frame W linearly relates the spatial
acceleration (see SpatialAcceleration) of body B in the world frame
with the total applied spatial forces (see SpatialForce) ``F_BBo`` on
body B and where ``Fb_Bo_W`` contains the velocity dependent
gyroscopic terms.

A similar relationship is found for an articulated body with a rigid
body B at the base (or root). Even though the bodies in this multibody
system are allowed to have relative motions among them, there still is
a linear relationship between the spatial force ``F_BBo_W`` applied on
this body and the resulting acceleration ``A_WB``:


::

    F_BBo_W = P_B_W * A_WB + Z_Bo_W                                       (2)

where ``P_B_W`` is the articulated body inertia of body B and
``Z_Bo_W`` is a bias force that includes the gyroscopic and Coriolis
forces and becomes zero when all body velocities and all applied
generalized forces outboard from body B are zero [Jain 2010, §7.2.1].
The articulated body inertia ``P_B_W`` is related to the multibody
subsystem consisting only of bodies that are outboard of body B. We
refer to this subsystem as the *articulated body subsystem* associated
with body B. Equation (2) describes the acceleration response of body
B, but also taking into account all outboard bodies connected to B. A
special case is that of an articulated body composed of a single rigid
body. For this special case, Eq. (2) reduces to Eq. (1) for the
dynamics of rigid body B. In other words, the ABI for an articulated
body consisting of a single rigid body exactly equals the spatial
inertia of that body.

Articulated body inertias are elements of ℝ⁶ˣ⁶ that, as for spatial
inertias, are symmetric and positive semi-definite. However, ABI
objects **are not** spatial inertias. The spatial inertia of a rigid
body can be described by a reduced set of ten parameters, namely the
mass, center of mass and the six components of the rotational inertia
for that body. However, this parametrization by ten parameters is just
not possible for an ABI and the full 21 elements of the symmetric
``6x6`` matrix must be specified [Jain 2010, §6.4]. As a result ABI
objects can have different properties than spatial inertia objects. As
an example, the apparent mass of an articulated body will in general
depend on the direction of the applied force. That is, the simple
relationship ``F = m * a`` is no longer valid for an articulated
body's center of mass (refer to the excellent example 7.1 in
[Featherstone 2008]).

We adopt the notation introduced by [Jain 2010] and generally we will
use an uppercase P to represent an ABI. Thus, in typeset material we
use the symbol :math:`[P^{A/Q}]_E` to represent the spatial inertia of
an articulated body A, about a point Q, expressed in a frame E. For
this inertia, the monogram notation reads ``P_AQ_E``.

Note:
    This class does not implement any mechanism to track the frame E
    in which an articulated body inertia is expressed or about what
    point is computed. Methods and operators on this class have no
    means to determine frame consistency through operations. It is
    therefore the responsibility of users of this class to keep track
    of frames in which operations are performed. We suggest doing that
    using disciplined notation, as described above.

- [Featherstone 1983] Featherstone, R., 1983.
    The calculation of robot dynamics using articulated-body inertias. The
    International Journal of Robotics Research, 2(1), pp.13-30.
- [Featherstone 2008] Featherstone, R., 2008.
    Rigid body dynamics algorithms. Springer.
- [Jain 2010]  Jain, A., 2010.
    Robot and multibody dynamics: analysis and algorithms.
    Springer Science & Business Media.)""";
        // Symbol: drake::multibody::ArticulatedBodyInertia::ArticulatedBodyInertia<T>
        struct /* ctor */ {
          // Source: drake/multibody/tree/articulated_body_inertia.h:100
          const char* doc_0args =
R"""(Default ArticulatedBodyInertia constructor initializes all matrix
values to NaN for a quick detection of uninitialized values.)""";
          // Source: drake/multibody/tree/articulated_body_inertia.h:110
          const char* doc_1args_M_SQ_E =
R"""(Constructs an articulated body inertia for an articulated body
consisting of a single rigid body given its spatial inertia. From an
input spatial inertia ``M_SQ_E`` for a body or composite body S, about
point Q, and expressed in a frame E, this constructor creates an
articulated body inertia about the same point Q and expressed in the
same frame E.

Parameter ``M_SQ_E``:
    The spatial inertia of a body or composite body S about point Q
    and expressed in frame E.)""";
          // Source: drake/multibody/tree/articulated_body_inertia.h:129
          const char* doc_1args_constEigenMatrixBase =
R"""(Constructs an articulated body inertia from an input matrix.

In Debug, this constructor checks for the physical validity of the
resulting ArticulatedBodyInertia with IsPhysicallyValid() and throws a
RuntimeError exception in the event the provided input matrix leads to
a non-physically viable articulated body inertia.

Parameter ``matrix``:
    A matrix or matrix expression representing the articulated body
    inertia. Only the lower triangular region is used and the strictly
    upper part is ignored.

Raises:
    RuntimeError in Debug builds if IsPhysicallyValid() for ``this``
    inertia is ``False``.)""";
        } ctor;
        // Symbol: drake::multibody::ArticulatedBodyInertia::CopyToFullMatrix6
        struct /* CopyToFullMatrix6 */ {
          // Source: drake/multibody/tree/articulated_body_inertia.h:196
          const char* doc =
R"""(Copy to a full 6x6 matrix representation.)""";
        } CopyToFullMatrix6;
        // Symbol: drake::multibody::ArticulatedBodyInertia::IsPhysicallyValid
        struct /* IsPhysicallyValid */ {
          // Source: drake/multibody/tree/articulated_body_inertia.h:161
          const char* doc_was_unable_to_choose_unambiguous_names =
R"""(Performs a number of checks to verify that this is a physically valid
articulated body inertia.

The checks performed are: - The matrix is positive semi-definite.)""";
        } IsPhysicallyValid;
        // Symbol: drake::multibody::ArticulatedBodyInertia::Shift
        struct /* Shift */ {
          // Source: drake/multibody/tree/articulated_body_inertia.h:289
          const char* doc =
R"""(Given ``this`` articulated body inertia ``P_AQ_E`` for some
articulated body A, computed about point Q, and expressed in frame E,
this method uses the rigid body shift operator to compute the same
articulated body inertia about a new point R. The result still is
expressed in frame E.

See also:
    ShiftInPlace() for more details.

Parameter ``p_QR_E``:
    Vector from the original about point Q to the new about point R,
    expressed in the same frame E ``this`` articulated body inertia is
    expressed in.

Returns ``P_AR_E``:
    This same articulated body inertia for articulated body A but now
    computed about about a new point R.)""";
        } Shift;
        // Symbol: drake::multibody::ArticulatedBodyInertia::ShiftInPlace
        struct /* ShiftInPlace */ {
          // Source: drake/multibody/tree/articulated_body_inertia.h:233
          const char* doc =
R"""(Given ``this`` articulated body inertia ``P_AQ_E`` for some
articulated body A, computed about point Q, and expressed in frame E,
this method uses the rigid body shift operator to compute the same
articulated body inertia about a new point R. The result still is
expressed in frame E.

Mathematically, this is equivalent to:


::

    P_AR_E = Φ(P_RQ_E) P_AQ_E Φ(p_RQ_E)ᵀ

where ``Φ(p_RQ_E)`` is the rigid body shift operator as defined by
[Jain 2010]. The definition of ``Φ(p_RQ_E)`` uses ``p_QR_E×``, which
is the skew-symmetric cross product matrix (defined such that ``a× b =
a.cross(b)``).


::

    Φ(p_RQ_E) =
    | I₃  p_RQ_E× |
    | 0        I₃ |

where ``p_RQ_E× = -p_QR_E×``.

This operation is performed in-place modifying the original object.

See also:
    Shift() which does not modify this object.

For details see Section 6.2.5, Page 105 of [Jain 2010].

Parameter ``p_QR_E``:
    Vector from the original about point Q to the new about point R,
    expressed in the same frame E ``this`` articulated body inertia is
    expressed in.

Returns:
    A reference to ``this`` articulated body inertia for articulated
    body A but now computed about a new point R.)""";
        } ShiftInPlace;
        // Symbol: drake::multibody::ArticulatedBodyInertia::cast
        struct /* cast */ {
          // Source: drake/multibody/tree/articulated_body_inertia.h:147
          const char* doc =
R"""(Returns a new ArticulatedBodyInertia object templated on ``Scalar``
with casted values of ``this`` articulated body inertia.

Template parameter ``Scalar``:
    The scalar type on which the new articulated body inertia will be
    templated.

Note:
    ``ArticulatedBodyInertia<From>::cast<To>()`` creates a new
    ``ArticulatedBodyInertia<To>`` from an
    ``ArticulatedBodyInertia<From>`` but only if type ``To`` is
    constructible from type ``From``. As an example of this,
    ``ArticulatedBodyInertia<double>::cast<AutoDiffXd>()`` is valid
    since ``AutoDiffXd a(1.0)`` is valid. However,
    ``ArticulatedBodyInertia<AutoDiffXd>::cast<double>()`` is not.)""";
        } cast;
        // Symbol: drake::multibody::ArticulatedBodyInertia::operator*
        struct /* operator_mul */ {
          // Source: drake/multibody/tree/articulated_body_inertia.h:338
          const char* doc_1args_constEigenMatrixBase =
R"""(Multiplies ``this`` articulated body inertia on the right by a matrix
or vector.

Note:
    This method does not evaluate the product immediately. Instead, it
    returns an intermediate Eigen quantity that can be optimized
    automatically during compile time.)""";
          // Source: drake/multibody/tree/articulated_body_inertia.h:344
          const char* doc_1args_A_WB_E =
R"""(Multiplies ``this`` articulated body inertia on the right by a spatial
acceleration. See abi_eq_definition "Eq. (2)" for an example.)""";
        } operator_mul;
        // Symbol: drake::multibody::ArticulatedBodyInertia::operator+=
        struct /* operator_iadd */ {
          // Source: drake/multibody/tree/articulated_body_inertia.h:314
          const char* doc =
R"""(Adds in to this articulated body inertia ``P_AQ_E`` for an articulated
body A about a point Q and expressed in a frame E the articulated body
inertia ``P_BQ_E`` for a second articulated body B about the same
point Q and expressed in the same frame E. The result is equivalent to
the articulated body inertia ``P_CQ_E`` for the composite articulated
body C which has at its base a rigid body composed of the bases of A
and B welded together [Featherstone 2008, example 7.1]. The composite
articulated body inertia ``P_CQ_E`` is also about the same point Q and
expressed in the same frame E as the addends.

Parameter ``P_BQ_E``:
    An articulated body inertia of some articulated body B to be added
    to ``this`` articulated body inertia. It must be defined about the
    same point Q as ``this`` inertia, and expressed in the same frame
    E.

Returns:
    A reference to ``this`` articulated body inertia, which has been
    updated to include the given articulated body inertia ``P_BQ_E``.

Warning:
    This operation is only valid if both articulated body inertias are
    computed about the same point Q and expressed in the same frame E.)""";
        } operator_iadd;
        // Symbol: drake::multibody::ArticulatedBodyInertia::operator-=
        struct /* operator_isub */ {
          // Source: drake/multibody/tree/articulated_body_inertia.h:324
          const char* doc =
R"""(Subtracts ``P_BQ_E`` from ``this`` articulated body inertia.
``P_BQ_E`` must be for the same articulated body B as this ABI (about
the same point Q and expressed in the same frame E). The resulting
inertia will have the same properties.)""";
        } operator_isub;
      } ArticulatedBodyInertia;
      // Symbol: drake::multibody::BallRpyJoint
      struct /* BallRpyJoint */ {
        // Source: drake/multibody/tree/ball_rpy_joint.h:27
        const char* doc =
R"""(This Joint allows two bodies to rotate freely relative to one another.
That is, given a frame F attached to the parent body P and a frame M
attached to the child body B (see the Joint class's documentation),
this Joint allows frame M to rotate freely with respect to F, while
the origins, Mo and Fo, of frames M and F respectively remain
coincident. The orientation of M relative to F is parameterized with
space ``x-y-z`` Euler angles.)""";
        // Symbol: drake::multibody::BallRpyJoint::BallRpyJoint<T>
        struct /* ctor */ {
          // Source: drake/multibody/tree/ball_rpy_joint.h:55
          const char* doc =
R"""(Constructor to create a ball rpy joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B rotate freely relative to one another. See this class's
documentation for further details on the definition of these frames,
get_angles() for an explanation of the angles defining orientation,
and get_angular_velocity() for an explanation of the generalized
velocities. This constructor signature creates a joint with no joint
limits, i.e. the joint position, velocity and acceleration limits are
the pair ``(-∞, ∞)``. These can be set using the Joint methods
set_position_limits(), set_velocity_limits() and
set_acceleration_limits(). The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class's documentation for details. The additional parameters are:

Parameter ``damping``:
    Viscous damping coefficient, in N⋅m⋅s, used to model losses within
    the joint. See documentation of damping() for details on modelling
    of the damping torque.

Raises:
    RuntimeError if damping is negative.)""";
        } ctor;
        // Symbol: drake::multibody::BallRpyJoint::DoAddInDamping
        struct /* DoAddInDamping */ {
          // Source: drake/multibody/tree/ball_rpy_joint.h:202
          const char* doc =
R"""(Joint<T> override called through public NVI, Joint::AddInDamping().
Therefore arguments were already checked to be valid. This method adds
into ``forces`` a dissipative torque according to the viscous law ``τ
= -d⋅ω``, with d the damping coefficient (see damping()).)""";
        } DoAddInDamping;
        // Symbol: drake::multibody::BallRpyJoint::DoAddInOneForce
        struct /* DoAddInOneForce */ {
          // Source: drake/multibody/tree/ball_rpy_joint.h:191
          const char* doc =
R"""(Joint<T> override called through public NVI, Joint::AddInForce().
Adding forces per-dof makes no physical sense. Therefore, this method
throws an exception if invoked.)""";
        } DoAddInOneForce;
        // Symbol: drake::multibody::BallRpyJoint::damping
        struct /* damping */ {
          // Source: drake/multibody/tree/ball_rpy_joint.h:83
          const char* doc =
R"""(Returns ``this`` joint's damping constant in N⋅m⋅s. The damping torque
(in N⋅m) is modeled as ``τ = -damping⋅ω``, i.e. opposing motion, with
ω the angular velocity of frame M in F (see get_angular_velocity())
and τ the torque on child body B (to which M is rigidly attached).)""";
        } damping;
        // Symbol: drake::multibody::BallRpyJoint::get_angles
        struct /* get_angles */ {
          // Source: drake/multibody/tree/ball_rpy_joint.h:117
          const char* doc =
R"""(Gets the rotation angles of ``this`` joint from ``context``.

The orientation ``R_FM`` of the child frame M in parent frame F is
parameterized with space ``x-y-z`` Euler angles (also known as
extrinsic angles). That is, the angles θr, θp, θy, correspond to a
sequence of rotations about the x̂, ŷ, ẑ axes of parent frame F,
respectively. Mathematically, rotation ``R_FM`` is given in terms of
angles θr, θp, θy by:


::

    R_FM(q) = Rz(θy) * Ry(θp) * Rx(θr)

where ``Rx(θ)``, `Ry(θ)` and ``Rz(θ)`` correspond to the elemental
rotations in amount of θ about the x, y and z axes respectively. Zero
θr, θp, θy angles corresponds to frames F and M being coincident.
Angles θr, θp, θy are defined to be positive according to the
right-hand-rule with the thumb aligned in the direction of their
respective axes.

Note:
    Space ``x-y-z`` angles (extrinsic) are equivalent to Body
    ``z-y-x`` angles (intrinsic).

Note:
    This particular choice of angles θr, θp, θy for this joint are
    many times referred to as the roll, pitch and yaw angles by many
    dynamicists. They are also known as the Tait-Bryan angles or
    Cardan angles.

Parameter ``context``:
    The context of the model this joint belongs to.

Returns:
    The angle coordinates of ``this`` joint stored in the ``context``
    ordered as θr, θp, θy.)""";
        } get_angles;
        // Symbol: drake::multibody::BallRpyJoint::get_angular_velocity
        struct /* get_angular_velocity */ {
          // Source: drake/multibody/tree/ball_rpy_joint.h:152
          const char* doc =
R"""(Retrieves from ``context`` the angular velocity ``w_FM`` of the child
frame M in the parent frame F, expressed in F.

Parameter ``context``:
    The context of the model this joint belongs to.

Returns ``w_FM``:
    A vector in ℝ³ with the angular velocity of the child frame M in
    the parent frame F, expressed in F. Refer to this class's
    documentation for further details and definitions of these frames.)""";
        } get_angular_velocity;
        // Symbol: drake::multibody::BallRpyJoint::get_default_angles
        struct /* get_default_angles */ {
          // Source: drake/multibody/tree/ball_rpy_joint.h:176
          const char* doc =
R"""(Gets the default angles for ``this`` joint. Wrapper for the more
general ``Joint::default_positions()``.

Returns:
    The default angles of ``this`` stored in ``default_positions_``)""";
        } get_default_angles;
        // Symbol: drake::multibody::BallRpyJoint::set_angles
        struct /* set_angles */ {
          // Source: drake/multibody/tree/ball_rpy_joint.h:129
          const char* doc =
R"""(Sets the ``context`` so that the generalized coordinates corresponding
to the rotation angles of ``this`` joint equals ``angles``.

Parameter ``context``:
    The context of the model this joint belongs to.

Parameter ``angles``:
    The desired angles in radians to be stored in ``context`` ordered
    as θr, θp, θy. See get_angles() for details.

Returns:
    a constant reference to ``this`` joint.)""";
        } set_angles;
        // Symbol: drake::multibody::BallRpyJoint::set_angular_velocity
        struct /* set_angular_velocity */ {
          // Source: drake/multibody/tree/ball_rpy_joint.h:165
          const char* doc =
R"""(Sets in ``context`` the state for ``this`` joint so that the angular
velocity of the child frame M in the parent frame F is ``w_FM``.

Parameter ``context``:
    The context of the model this joint belongs to.

Parameter ``w_FM``:
    A vector in ℝ³ with the angular velocity of the child frame M in
    the parent frame F, expressed in F. Refer to this class's
    documentation for further details and definitions of these frames.

Returns:
    a constant reference to ``this`` joint.)""";
        } set_angular_velocity;
        // Symbol: drake::multibody::BallRpyJoint::set_default_angles
        struct /* set_default_angles */ {
          // Source: drake/multibody/tree/ball_rpy_joint.h:183
          const char* doc =
R"""(Sets the default angles of this joint.

Parameter ``angles``:
    The desired default angles of the joint)""";
        } set_default_angles;
        // Symbol: drake::multibody::BallRpyJoint::set_random_angles_distribution
        struct /* set_random_angles_distribution */ {
          // Source: drake/multibody/tree/ball_rpy_joint.h:137
          const char* doc =
R"""(Sets the random distribution that angles of this joint will be
randomly sampled from. See get_angles() for details on the angle
representation.)""";
        } set_random_angles_distribution;
        // Symbol: drake::multibody::BallRpyJoint::type_name
        struct /* type_name */ {
          // Source: drake/multibody/tree/ball_rpy_joint.h:74
          const char* doc = R"""()""";
        } type_name;
      } BallRpyJoint;
      // Symbol: drake::multibody::Body
      struct /* Body */ {
        // Source: drake/multibody/tree/body.h:183
        const char* doc =
R"""(%Body provides the general abstraction of a body with an API that
makes no assumption about whether a body is rigid or deformable and
neither does it make any assumptions about the underlying physical
model or approximation. As an element or component of a MultibodyTree,
a body is a MultibodyElement, and therefore it has a unique index of
type BodyIndex within the multibody tree it belongs to.

A Body contains a unique BodyFrame; see BodyFrame class documentation
for more information.)""";
        // Symbol: drake::multibody::Body::AddInForce
        struct /* AddInForce */ {
          // Source: drake/multibody/tree/body.h:365
          const char* doc =
R"""(Adds the spatial force on ``this`` body B, applied at point P and
expressed in a frame E into ``forces``.

Parameter ``context``:
    The context containing the current state of the model.

Parameter ``p_BP_E``:
    The position of point P in B, expressed in a frame E.

Parameter ``F_Bp_E``:
    The spatial force to be applied on body B at point P, expressed in
    frame E.

Parameter ``frame_E``:
    The expressed-in frame E.

Parameter ``forces``:
    A multibody forces objects that on output will have ``F_Bp_E``
    added.

Raises:
    RuntimeError if ``forces`` is nullptr or if it is not consistent
    with the model to which ``this`` body belongs.)""";
        } AddInForce;
        // Symbol: drake::multibody::Body::AddInForceInWorld
        struct /* AddInForceInWorld */ {
          // Source: drake/multibody/tree/body.h:341
          const char* doc =
R"""(Adds the spatial force on ``this`` body B, applied at body B's origin
Bo and expressed in the world frame W into ``forces``.)""";
        } AddInForceInWorld;
        // Symbol: drake::multibody::Body::Body<T>
        struct /* ctor */ {
          // Source: drake/multibody/tree/body.h:189
          const char* doc =
R"""(Creates a Body named ``name`` in model instance ``model_instance``
with a given ``default_mass`` and a BodyFrame associated with it.)""";
        } ctor;
        // Symbol: drake::multibody::Body::CalcCenterOfMassInBodyFrame
        struct /* CalcCenterOfMassInBodyFrame */ {
          // Source: drake/multibody/tree/body.h:279
          const char* doc =
R"""((Advanced) Computes the center of mass ``p_BoBcm_B`` (or ``p_Bcm`` for
short) of this body measured from this body's frame origin ``Bo`` and
expressed in the body frame B.)""";
        } CalcCenterOfMassInBodyFrame;
        // Symbol: drake::multibody::Body::CalcCenterOfMassTranslationalVelocityInWorld
        struct /* CalcCenterOfMassTranslationalVelocityInWorld */ {
          // Source: drake/multibody/tree/body.h:286
          const char* doc =
R"""(Calculates v_WBcm, Bcm's translational velocity in the world frame W.

Parameter ``context``:
    The context contains the state of the model.

Returns ``v_WBcm_W``:
    Bcm's (``this`` body's center of mass) translational velocity in
    the world frame W, expressed in W.)""";
        } CalcCenterOfMassTranslationalVelocityInWorld;
        // Symbol: drake::multibody::Body::CalcSpatialInertiaInBodyFrame
        struct /* CalcSpatialInertiaInBodyFrame */ {
          // Source: drake/multibody/tree/body.h:297
          const char* doc =
R"""((Advanced) Computes the SpatialInertia ``I_BBo_B`` of ``this`` body
about its frame origin ``Bo`` (not necessarily its center of mass) and
expressed in its body frame ``B``. In general, the spatial inertia of
a body is a function of state. Consider for instance the case of a
flexible body for which its spatial inertia in the body frame depends
on the generalized coordinates describing its state of deformation. As
a particular case, the spatial inertia of a RigidBody in its body
frame is constant.)""";
        } CalcSpatialInertiaInBodyFrame;
        // Symbol: drake::multibody::Body::CloneToScalar
        struct /* CloneToScalar */ {
          // Source: drake/multibody/tree/body.h:386
          const char* doc =
R"""(NVI (Non-Virtual Interface) to DoCloneToScalar() templated on the
scalar type of the new clone to be created. This method is mostly
intended to be called by MultibodyTree::CloneToScalar(). Most users
should not call this clone method directly but rather clone the entire
parent MultibodyTree if needed.

See also:
    MultibodyTree::CloneToScalar())""";
        } CloneToScalar;
        // Symbol: drake::multibody::Body::DoCloneToScalar
        struct /* DoCloneToScalar */ {
          // Source: drake/multibody/tree/body.h:408
          const char* doc_was_unable_to_choose_unambiguous_names =
R"""(Clones this Body (templated on T) to a body templated on ``double``.)""";
        } DoCloneToScalar;
        // Symbol: drake::multibody::Body::EvalPoseInWorld
        struct /* EvalPoseInWorld */ {
          // Source: drake/multibody/tree/body.h:302
          const char* doc =
R"""(Returns the pose ``X_WB`` of this body B in the world frame W as a
function of the state of the model stored in ``context``.)""";
        } EvalPoseInWorld;
        // Symbol: drake::multibody::Body::EvalSpatialAccelerationInWorld
        struct /* EvalSpatialAccelerationInWorld */ {
          // Source: drake/multibody/tree/body.h:324
          const char* doc =
R"""(Evaluates A_WB, ``this`` body B's spatial acceleration in the world
frame W.

Parameter ``context``:
    Contains the state of the model.

Returns ``A_WB_W``:
    ``this`` body B's spatial acceleration in the world frame W,
    expressed in W (for point Bo, the body's origin).

Note:
    When cached values are out of sync with the state stored in
    context, this method performs an expensive forward dynamics
    computation, whereas once evaluated, successive calls to this
    method are inexpensive.)""";
        } EvalSpatialAccelerationInWorld;
        // Symbol: drake::multibody::Body::EvalSpatialVelocityInWorld
        struct /* EvalSpatialVelocityInWorld */ {
          // Source: drake/multibody/tree/body.h:311
          const char* doc =
R"""(Evaluates V_WB, ``this`` body B's spatial velocity in the world frame
W.

Parameter ``context``:
    Contains the state of the model.

Returns ``V_WB_W``:
    ``this`` body B's spatial velocity in the world frame W, expressed
    in W (for point Bo, the body frame's origin).)""";
        } EvalSpatialVelocityInWorld;
        // Symbol: drake::multibody::Body::GetForceInWorld
        struct /* GetForceInWorld */ {
          // Source: drake/multibody/tree/body.h:332
          const char* doc =
R"""(Gets the sptatial force on ``this`` body B from ``forces`` as F_BBo_W:
applied at body B's origin Bo and expressed in world world frame W.)""";
        } GetForceInWorld;
        // Symbol: drake::multibody::Body::body_frame
        struct /* body_frame */ {
          // Source: drake/multibody/tree/body.h:207
          const char* doc =
R"""(Returns a const reference to the associated BodyFrame.)""";
        } body_frame;
        // Symbol: drake::multibody::Body::floating_positions_start
        struct /* floating_positions_start */ {
          // Source: drake/multibody/tree/body.h:249
          const char* doc =
R"""((Advanced) For floating bodies (see is_floating()) this method returns
the index of the first generalized position in the state vector for a
MultibodyPlant model. Positions for this body are then contiguous
starting at this index. When a floating body is modeled with a
quaternion mobilizer (see has_quaternion_dofs()), the four consecutive
entries in the state starting at this index correspond to the
quaternion that parametrizes this body's orientation.

Raises:
    RuntimeError if called pre-finalize, see
    MultibodyPlant::Finalize().)""";
        } floating_positions_start;
        // Symbol: drake::multibody::Body::floating_velocities_start
        struct /* floating_velocities_start */ {
          // Source: drake/multibody/tree/body.h:260
          const char* doc =
R"""((Advanced) For floating bodies (see is_floating()) this method returns
the index of the first generalized velocity in the state vector for a
MultibodyPlant model. Velocities for this body are then contiguous
starting at this index.

Raises:
    RuntimeError if called pre-finalize, see
    MultibodyPlant::Finalize().)""";
        } floating_velocities_start;
        // Symbol: drake::multibody::Body::get_default_mass
        struct /* get_default_mass */ {
          // Source: drake/multibody/tree/body.h:270
          const char* doc =
R"""(Returns the default mass (not Context dependent) for ``this`` body. In
general, the mass for a body can be a parameter of the model that can
be retrieved with the method get_mass(). When the mass of a body is a
parameter, the value returned by get_default_mass() is used to
initialize the mass parameter in the context.)""";
        } get_default_mass;
        // Symbol: drake::multibody::Body::get_mass
        struct /* get_mass */ {
          // Source: drake/multibody/tree/body.h:273
          const char* doc =
R"""((Advanced) Returns the mass of this body stored in ``context``.)""";
        } get_mass;
        // Symbol: drake::multibody::Body::get_num_flexible_positions
        struct /* get_num_flexible_positions */ {
          // Source: drake/multibody/tree/body.h:200
          const char* doc =
R"""(Returns the number of generalized positions q describing flexible
deformations for this body. A rigid body will therefore return zero.)""";
        } get_num_flexible_positions;
        // Symbol: drake::multibody::Body::get_num_flexible_velocities
        struct /* get_num_flexible_velocities */ {
          // Source: drake/multibody/tree/body.h:204
          const char* doc =
R"""(Returns the number of generalized velocities v describing flexible
deformations for this body. A rigid body will therefore return zero.)""";
        } get_num_flexible_velocities;
        // Symbol: drake::multibody::Body::has_quaternion_dofs
        struct /* has_quaternion_dofs */ {
          // Source: drake/multibody/tree/body.h:234
          const char* doc =
R"""((Advanced) If ``True``, this body is a floating body modeled with a
quaternion floating mobilizer. By implication, is_floating() is also
``True``.

See also:
    floating_positions_start(), floating_velocities_start().

Raises:
    RuntimeError if called pre-finalize, see
    MultibodyPlant::Finalize().)""";
        } has_quaternion_dofs;
        // Symbol: drake::multibody::Body::is_floating
        struct /* is_floating */ {
          // Source: drake/multibody/tree/body.h:223
          const char* doc =
R"""((Advanced) Returns ``True`` if ``this`` body is granted 6-dofs by a
Mobilizer.

Note:
    A floating body is not necessarily modeled with a quaternion
    mobilizer, see has_quaternion_dofs(). Alternative options include
    a space XYZ parametrization of rotations, see SpaceXYZMobilizer.

Raises:
    RuntimeError if called pre-finalize, see
    MultibodyPlant::Finalize().)""";
        } is_floating;
        // Symbol: drake::multibody::Body::name
        struct /* name */ {
          // Source: drake/multibody/tree/body.h:196
          const char* doc =
R"""(Gets the ``name`` associated with ``this`` body.)""";
        } name;
        // Symbol: drake::multibody::Body::node_index
        struct /* node_index */ {
          // Source: drake/multibody/tree/body.h:213
          const char* doc =
R"""((Advanced) Returns the index of the node in the underlying tree
structure of the parent MultibodyTree to which this body belongs.)""";
        } node_index;
      } Body;
      // Symbol: drake::multibody::BodyFrame
      struct /* BodyFrame */ {
        // Source: drake/multibody/tree/body.h:66
        const char* doc =
R"""(A BodyFrame is a material Frame that serves as the unique reference
frame for a Body.

Each Body B, regardless of whether it represents a rigid body or a
flexible body, has a unique body frame for which we use the same
symbol B (with meaning clear from context). The body frame is also
referred to as a *reference frame* in the literature for flexible body
mechanics modeling using the Finite Element Method. All properties of
a body are defined with respect to its body frame, including its mass
properties and attachment locations for joints, constraints,
actuators, geometry and so on. Run time motion of the body is defined
with respect to the motion of its body frame. We represent a body
frame by a BodyFrame object that is created whenever a Body is
constructed and is owned by the Body.

Note that the BodyFrame associated with a body does not necessarily
need to be located at its center of mass nor does it need to be
aligned with the body's principal axes, although, in practice, it
frequently is. For flexible bodies, BodyFrame provides a
representation for the body's reference frame. The flexible degrees of
freedom associated with a flexible body describe the body's
deformation in this frame. Therefore, the motion of a flexible body is
defined by the motion of its BodyFrame, or reference frame, plus the
motion of the material points on the body with respect to its
BodyFrame.

A BodyFrame and Body are tightly coupled concepts; neither makes sense
without the other. Therefore, a BodyFrame instance is constructed in
conjunction with its Body and cannot be constructed anywhere else.
However, you can still access the frame associated with a body, see
Body::body_frame(). This access is more than a convenience; you can
use the BodyFrame to define other frames on the body and to attach
other multibody elements to it.)""";
        // Symbol: drake::multibody::BodyFrame::BodyFrame<T>
        struct /* ctor */ {
          // Source: drake/multibody/tree/body.h:68
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::multibody::BodyFrame::CalcOffsetPoseInBody
        struct /* CalcOffsetPoseInBody */ {
          // Source: drake/multibody/tree/body.h:80
          const char* doc = R"""()""";
        } CalcOffsetPoseInBody;
        // Symbol: drake::multibody::BodyFrame::CalcOffsetRotationMatrixInBody
        struct /* CalcOffsetRotationMatrixInBody */ {
          // Source: drake/multibody/tree/body.h:86
          const char* doc = R"""()""";
        } CalcOffsetRotationMatrixInBody;
        // Symbol: drake::multibody::BodyFrame::CalcPoseInBodyFrame
        struct /* CalcPoseInBodyFrame */ {
          // Source: drake/multibody/tree/body.h:70
          const char* doc = R"""()""";
        } CalcPoseInBodyFrame;
        // Symbol: drake::multibody::BodyFrame::CalcRotationMatrixInBodyFrame
        struct /* CalcRotationMatrixInBodyFrame */ {
          // Source: drake/multibody/tree/body.h:75
          const char* doc = R"""()""";
        } CalcRotationMatrixInBodyFrame;
        // Symbol: drake::multibody::BodyFrame::DoCloneToScalar
        struct /* DoCloneToScalar */ {
          // Source: drake/multibody/tree/body.h:112
          const char* doc = R"""()""";
        } DoCloneToScalar;
        // Symbol: drake::multibody::BodyFrame::GetFixedOffsetPoseInBody
        struct /* GetFixedOffsetPoseInBody */ {
          // Source: drake/multibody/tree/body.h:100
          const char* doc = R"""()""";
        } GetFixedOffsetPoseInBody;
        // Symbol: drake::multibody::BodyFrame::GetFixedPoseInBodyFrame
        struct /* GetFixedPoseInBodyFrame */ {
          // Source: drake/multibody/tree/body.h:92
          const char* doc = R"""()""";
        } GetFixedPoseInBodyFrame;
        // Symbol: drake::multibody::BodyFrame::GetFixedRotationMatrixInBody
        struct /* GetFixedRotationMatrixInBody */ {
          // Source: drake/multibody/tree/body.h:105
          const char* doc = R"""()""";
        } GetFixedRotationMatrixInBody;
        // Symbol: drake::multibody::BodyFrame::GetFixedRotationMatrixInBodyFrame
        struct /* GetFixedRotationMatrixInBodyFrame */ {
          // Source: drake/multibody/tree/body.h:96
          const char* doc = R"""()""";
        } GetFixedRotationMatrixInBodyFrame;
      } BodyFrame;
      // Symbol: drake::multibody::BodyIndex
      struct /* BodyIndex */ {
        // Source: drake/multibody/tree/multibody_tree_indexes.h:25
        const char* doc =
R"""(Type used to identify bodies by index in a multibody tree system.)""";
      } BodyIndex;
      // Symbol: drake::multibody::CalcContactFrictionFromSurfaceProperties
      struct /* CalcContactFrictionFromSurfaceProperties */ {
        // Source: drake/multibody/plant/coulomb_friction.h:123
        const char* doc =
R"""(Given the surface properties of two different surfaces, this method
computes the Coulomb's law coefficients of friction characterizing the
interaction by friction of the given surface pair. The surface
properties are specified by individual Coulomb's law coefficients of
friction. As outlined in the class's documentation for
CoulombFriction, friction coefficients characterize a surface pair and
not individual surfaces. However, we find it useful in practice to
associate the abstract **idea** of friction coefficients to a single
surface. Please refer to the documentation for CoulombFriction for
details on this topic.

More specifically, this method computes the contact coefficients for
the given surface pair as:


::

    μ = 2μₘμₙ/(μₘ + μₙ)

where the operation above is performed separately on the static and
dynamic friction coefficients.

Parameter ``surface_properties1``:
    Surface properties for surface 1. Specified as an individual set
    of Coulomb's law coefficients of friction.

Parameter ``surface_properties2``:
    Surface properties for surface 2. Specified as an individual set
    of Coulomb's law coefficients of friction.

Returns:
    the combined friction coefficients for the interacting surfaces.)""";
      } CalcContactFrictionFromSurfaceProperties;
      // Symbol: drake::multibody::CalcDistanceAndTimeDerivative
      struct /* CalcDistanceAndTimeDerivative */ {
        // Source: drake/multibody/plant/calc_distance_and_time_derivative.h:37
        const char* doc =
R"""(Given a pair of geometries and the generalized position/velocity of
the plant, compute the signed distance between the pair of geometries
and the time derivative of the signed distance. This function is
similar to QueryObject::ComputeSignedDistancePairClosestPoints(), but
it also provides the time derivative of the signed distance.

Parameter ``plant``:
    The plant on which the geometries are attached. This plant must
    have been connected to a SceneGraph.

Parameter ``geometry_pair``:
    The pair of geometries whose distance and time derivative are
    computed.

Parameter ``context``:
    The context of the plant. This must store both q and v. This
    context must have been extracted from the diagram context which
    contains both MultibodyPlant and SceneGraph contexts.

Parameter ``distance``:
    The signed distance between the pair of geometry.

Parameter ``distance_time_derivative``:
    The time derivative of the signed distance.)""";
      } CalcDistanceAndTimeDerivative;
      // Symbol: drake::multibody::ConnectContactResultsToDrakeVisualizer
      struct /* ConnectContactResultsToDrakeVisualizer */ {
        // Source: drake/multibody/plant/contact_results_to_lcm.h:98
        const char* doc_3args =
R"""(Extends a Diagram with the required components to publish contact
results to drake_visualizer. This must be called *during* Diagram
building and uses the given ``builder`` to add relevant subsystems and
connections.

This is a convenience method to simplify some common boilerplate for
adding contact results visualization capability to a Diagram. What it
does is:

- adds systems ContactResultsToLcmSystem and LcmPublisherSystem to
the Diagram and connects the draw message output to the publisher input,
- connects the ``multibody_plant`` contact results output to the
ContactResultsToLcmSystem system, and
- sets the publishing rate to 1/60 of a second (simulated time).

Parameter ``builder``:
    The diagram builder being used to construct the Diagram.

Parameter ``multibody_plant``:
    The System in ``builder`` containing the plant whose contact
    results are to be visualized.

Parameter ``lcm``:
    An optional lcm interface through which lcm messages will be
    dispatched. Will be allocated internally if none is supplied.

Precondition:
    The given ``multibody_plant`` must be contained within the
    supplied DiagramBuilder.

Returns:
    the LcmPublisherSystem (in case callers, e.g., need to change the
    default publishing rate).)""";
        // Source: drake/multibody/plant/contact_results_to_lcm.h:115
        const char* doc_4args =
R"""(Implements ConnectContactResultsToDrakeVisualizer, but using
explicitly specified ``contact_results_port`` and
``geometry_input_port`` arguments. This call is required, for
instance, when the MultibodyPlant is inside a Diagram, and the Diagram
exports the pose bundle port.

Precondition:
    contact_results_port must be connected to the contact_results_port
    of ``multibody_plant``.

See also:
    ConnectContactResultsToDrakeVisualizer().)""";
      } ConnectContactResultsToDrakeVisualizer;
      // Symbol: drake::multibody::ContactModel
      struct /* ContactModel */ {
        // Source: drake/multibody/plant/multibody_plant.h:71
        const char* doc = R"""(Enumeration for contact model options.)""";
        // Symbol: drake::multibody::ContactModel::kHydroelasticWithFallback
        struct /* kHydroelasticWithFallback */ {
          // Source: drake/multibody/plant/multibody_plant.h:85
          const char* doc =
R"""(Contact forces are computed using the hydroelastic model, where
possible. For most other unsupported colliding pairs, the point model
from kPointContactOnly is used. See
geometry::QueryObject:ComputeContactSurfacesWithFallback for more
details.)""";
        } kHydroelasticWithFallback;
        // Symbol: drake::multibody::ContactModel::kHydroelasticsOnly
        struct /* kHydroelasticsOnly */ {
          // Source: drake/multibody/plant/multibody_plant.h:74
          const char* doc =
R"""(Contact forces are computed using the Hydroelastic model. Conctact
between unsupported geometries will cause a runtime exception.)""";
        } kHydroelasticsOnly;
        // Symbol: drake::multibody::ContactModel::kPointContactOnly
        struct /* kPointContactOnly */ {
          // Source: drake/multibody/plant/multibody_plant.h:78
          const char* doc =
R"""(Contact forces are computed using a point contact model, see
point_contact_approximation "Numerical Approximation of Point
Contact".)""";
        } kPointContactOnly;
      } ContactModel;
      // Symbol: drake::multibody::ContactResults
      struct /* ContactResults */ {
        // Source: drake/multibody/plant/contact_results.h:27
        const char* doc =
R"""(A container class storing the contact results information for each
contact pair for a given state of the simulation. Note that copying
this data structure is expensive when ``num_hydroelastic_contacts() >
0`` because a deep copy is performed.)""";
        // Symbol: drake::multibody::ContactResults::AddContactInfo
        struct /* AddContactInfo */ {
          // Source: drake/multibody/plant/contact_results.h:61
          const char* doc = R"""()""";
        } AddContactInfo;
        // Symbol: drake::multibody::ContactResults::Clear
        struct /* Clear */ {
          // Source: drake/multibody/plant/contact_results.h:58
          const char* doc = R"""()""";
        } Clear;
        // Symbol: drake::multibody::ContactResults::ContactResults<T>
        struct /* ctor */ {
          // Source: drake/multibody/plant/contact_results.h:29
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::multibody::ContactResults::hydroelastic_contact_info
        struct /* hydroelastic_contact_info */ {
          // Source: drake/multibody/plant/contact_results.h:51
          const char* doc =
R"""(Retrieves the ith HydroelasticContactInfo instance. The input index i
must be in the range [0, ``num_hydroelastic_contacts()`` - 1] or this
method aborts.)""";
        } hydroelastic_contact_info;
        // Symbol: drake::multibody::ContactResults::num_hydroelastic_contacts
        struct /* num_hydroelastic_contacts */ {
          // Source: drake/multibody/plant/contact_results.h:41
          const char* doc =
R"""(Returns the number of hydroelastic contacts.)""";
        } num_hydroelastic_contacts;
        // Symbol: drake::multibody::ContactResults::num_point_pair_contacts
        struct /* num_point_pair_contacts */ {
          // Source: drake/multibody/plant/contact_results.h:36
          const char* doc =
R"""(Returns the number of point pair contacts.)""";
        } num_point_pair_contacts;
        // Symbol: drake::multibody::ContactResults::point_pair_contact_info
        struct /* point_pair_contact_info */ {
          // Source: drake/multibody/plant/contact_results.h:46
          const char* doc =
R"""(Retrieves the ith PointPairContactInfo instance. The input index i
must be in the range [0, ``num_point_pair_contacts()`` - 1] or this
method aborts.)""";
        } point_pair_contact_info;
      } ContactResults;
      // Symbol: drake::multibody::ContactResultsToLcmSystem
      struct /* ContactResultsToLcmSystem */ {
        // Source: drake/multibody/plant/contact_results_to_lcm.h:29
        const char* doc =
R"""(A System that encodes ContactResults into a
lcmt_contact_results_for_viz message. It has a single input port with
type ContactResults<T> and a single output port with
lcmt_contact_results_for_viz.)""";
        // Symbol: drake::multibody::ContactResultsToLcmSystem::ContactResultsToLcmSystem<T>
        struct /* ctor */ {
          // Source: drake/multibody/plant/contact_results_to_lcm.h:39
          const char* doc =
R"""(Constructs a ContactResultsToLcmSystem.

Parameter ``plant``:
    The MultibodyPlant that the ContactResults are generated from.

Precondition:
    The ``plant`` must be finalized already. The input port of this
    system must be connected to the corresponding output port of
    ``plant`` (either directly or from an exported port in a Diagram).)""";
          // Source: drake/multibody/plant/contact_results_to_lcm.h:43
          const char* doc_copyconvert = R"""(Scalar-converting copy constructor.)""";
        } ctor;
        // Symbol: drake::multibody::ContactResultsToLcmSystem::get_contact_result_input_port
        struct /* get_contact_result_input_port */ {
          // Source: drake/multibody/plant/contact_results_to_lcm.h:46
          const char* doc = R"""()""";
        } get_contact_result_input_port;
        // Symbol: drake::multibody::ContactResultsToLcmSystem::get_lcm_message_output_port
        struct /* get_lcm_message_output_port */ {
          // Source: drake/multibody/plant/contact_results_to_lcm.h:47
          const char* doc = R"""()""";
        } get_lcm_message_output_port;
      } ContactResultsToLcmSystem;
      // Symbol: drake::multibody::ContactWrench
      struct /* ContactWrench */ {
        // Source: drake/multibody/optimization/contact_wrench.h:15
        const char* doc =
R"""(Stores the contact wrench (spatial force) from Body A to Body B
applied at point Cb.)""";
        // Symbol: drake::multibody::ContactWrench::ContactWrench
        struct /* ctor */ {
          // Source: drake/multibody/optimization/contact_wrench.h:19
          const char* doc =
R"""(Refer to the documentation for each attribute.)""";
        } ctor;
        // Symbol: drake::multibody::ContactWrench::F_Cb_W
        struct /* F_Cb_W */ {
          // Source: drake/multibody/optimization/contact_wrench.h:37
          const char* doc =
R"""(F_Cb_W_in The wrench (spatial force) applied at point Cb from Body A
to Body B, measured in the world frame.)""";
        } F_Cb_W;
        // Symbol: drake::multibody::ContactWrench::bodyA_index
        struct /* bodyA_index */ {
          // Source: drake/multibody/optimization/contact_wrench.h:27
          const char* doc = R"""(The index of Body A.)""";
        } bodyA_index;
        // Symbol: drake::multibody::ContactWrench::bodyB_index
        struct /* bodyB_index */ {
          // Source: drake/multibody/optimization/contact_wrench.h:29
          const char* doc = R"""(The index of Body B.)""";
        } bodyB_index;
        // Symbol: drake::multibody::ContactWrench::p_WCb_W
        struct /* p_WCb_W */ {
          // Source: drake/multibody/optimization/contact_wrench.h:33
          const char* doc =
R"""(The position of the point Cb (where the wrench is applied) expressed
in the world frame W.)""";
        } p_WCb_W;
      } ContactWrench;
      // Symbol: drake::multibody::ContactWrenchEvaluator
      struct /* ContactWrenchEvaluator */ {
        // Source: drake/multibody/optimization/contact_wrench_evaluator.h:19
        const char* doc = R"""()""";
        // Symbol: drake::multibody::ContactWrenchEvaluator::ComposeVariableValues
        struct /* ComposeVariableValues */ {
          // Source: drake/multibody/optimization/contact_wrench_evaluator.h:38
          const char* doc_2args_constsystemsContext_constDerived = R"""(Overloads ComposeVariableValues)""";
          // Source: drake/multibody/optimization/contact_wrench_evaluator.h:56
          const char* doc_2args_constEigenMatrixBase_constEigenMatrixBase =
R"""(Overloads ComposeVariableValues with q, λ as the input instead of
context, λ.)""";
        } ComposeVariableValues;
        // Symbol: drake::multibody::ContactWrenchEvaluator::ContactWrenchEvaluator
        struct /* ctor */ {
          // Source: drake/multibody/optimization/contact_wrench_evaluator.h:102
          const char* doc =
R"""(Each derived class should call this constructor.

Parameter ``plant``:
    The MultibodyPlant on which the contact wrench is computed. The
    lifetime of plant should outlive this object.

Parameter ``context``:
    The context of ``plant``. The lifetime of context should outlive
    this object.

Parameter ``num_lambda``:
    The size of lambda.

Parameter ``geometry_id_pair``:
    The pair of geometries for which the contact wrench is computed.
    Notice that the order of the geometries in the pair should match
    with that in SceneGraphInspector::GetCollisionCandidates().)""";
        } ctor;
        // Symbol: drake::multibody::ContactWrenchEvaluator::context
        struct /* context */ {
          // Source: drake/multibody/optimization/contact_wrench_evaluator.h:85
          const char* doc = R"""(Getter for const context)""";
        } context;
        // Symbol: drake::multibody::ContactWrenchEvaluator::geometry_id_pair
        struct /* geometry_id_pair */ {
          // Source: drake/multibody/optimization/contact_wrench_evaluator.h:78
          const char* doc = R"""(Returns the pair of geometry IDs.)""";
        } geometry_id_pair;
        // Symbol: drake::multibody::ContactWrenchEvaluator::get_mutable_context
        struct /* get_mutable_context */ {
          // Source: drake/multibody/optimization/contact_wrench_evaluator.h:88
          const char* doc = R"""(Getter for the mutable context)""";
        } get_mutable_context;
        // Symbol: drake::multibody::ContactWrenchEvaluator::lambda
        struct /* lambda */ {
          // Source: drake/multibody/optimization/contact_wrench_evaluator.h:130
          const char* doc =
R"""(Extract lambda from x (x is used in Eval(x, &y)).)""";
        } lambda;
        // Symbol: drake::multibody::ContactWrenchEvaluator::num_lambda
        struct /* num_lambda */ {
          // Source: drake/multibody/optimization/contact_wrench_evaluator.h:73
          const char* doc = R"""(Returns the size of lambda.)""";
        } num_lambda;
        // Symbol: drake::multibody::ContactWrenchEvaluator::plant
        struct /* plant */ {
          // Source: drake/multibody/optimization/contact_wrench_evaluator.h:82
          const char* doc = R"""()""";
        } plant;
        // Symbol: drake::multibody::ContactWrenchEvaluator::q
        struct /* q */ {
          // Source: drake/multibody/optimization/contact_wrench_evaluator.h:122
          const char* doc =
R"""(Extract the generalized configuration q from x (x is used in Eval(x,
&y)).)""";
        } q;
      } ContactWrenchEvaluator;
      // Symbol: drake::multibody::ContactWrenchFromForceInWorldFrameEvaluator
      struct /* ContactWrenchFromForceInWorldFrameEvaluator */ {
        // Source: drake/multibody/optimization/contact_wrench_evaluator.h:148
        const char* doc =
R"""(The contact wrench is τ_AB_W = 0, f_AB_W = λ Namely we assume that λ
is the contact force from A to B, applied directly at B's witness
point.)""";
        // Symbol: drake::multibody::ContactWrenchFromForceInWorldFrameEvaluator::ContactWrenchFromForceInWorldFrameEvaluator
        struct /* ctor */ {
          // Source: drake/multibody/optimization/contact_wrench_evaluator.h:163
          const char* doc =
R"""(Parameter ``plant``:
    The MultibodyPlant on which the contact wrench is computed. The
    lifetime of ``plant`` should outlive this object.

Parameter ``context``:
    The context of the MultibodyPlant. The lifetime of ``context``
    should outlive this object.

Parameter ``geometry_id_pair``:
    The pair of geometries for which the contact wrench is computed.
    Notice that the order of the geometries in the pair should match
    with that in SceneGraphInspector::GetCollisionCandidates().

Parameter ``description``:
    The description of this evaluator. Default to none.)""";
        } ctor;
      } ContactWrenchFromForceInWorldFrameEvaluator;
      // Symbol: drake::multibody::CoulombFriction
      struct /* CoulombFriction */ {
        // Source: drake/multibody/plant/coulomb_friction.h:62
        const char* doc =
R"""(Parameters for Coulomb's Law of Friction, namely:

- Static friction coefficient, for a pair of surfaces at rest relative to
  each other.
- Dynamic (or kinematic) friction coefficient, for a pair of surfaces in
  relative motion.

These coefficients are an empirical property characterizing the
interaction by friction between a pair of contacting surfaces.
Friction coefficients depend upon the mechanical properties of the
surfaces' materials and on the roughness of the surfaces. They are
determined experimentally.

Even though the Coulomb's law coefficients of friction characterize a
pair of surfaces interacting by friction, we associate the abstract
**idea** of friction coefficients to a single surface by considering
the coefficients for contact between two identical surfaces. For this
case of two identical surfaces, the friction coefficients that
describe the surface pair are taken to equal those of one of the
identical surfaces. We extend this idea to the case of different
surfaces by defining a **combination law** that allow us to obtain the
Coulomb's law coefficients of friction characterizing the pair of
surfaces, given the individual friction coefficients of each surface.
We would like this **combination law** to satisfy:

- The friction coefficient of two identical surfaces is the friction
  coefficient of one of the surfaces.
- The combination law is commutative. That is, surface A combined with
  surface B gives the same results as surface B combined with surface A.
- For two surfaces M and N with very different friction coefficients, say
  ``μₘ ≪ μₙ``, the combined friction coefficient should be in the order of
  magnitude of the smallest friction coefficient (in the example μₘ). To
  understand this requirement, consider rubber (high friction coefficient)
  sliding on ice (low friction coefficient). We'd like the surface pair
  to be defined by a friction coefficient close to that of ice, since rubber
  will easily slide on ice.

These requirements are met by the following ad-hoc combination law:


::

    μ = 2μₘμₙ/(μₘ + μₙ)

See CalcContactFrictionFromSurfaceProperties(), which implements this
law. More complex combination laws could also be a function of other
parameters such as the mechanical properties of the interacting
surfaces or even their roughnesses. For instance, if the the rubber
surface above has metal studs (somehow making the surface "rougher"),
it will definitely have a better grip on an ice surface. Therefore
this new variable should be taken into account in the combination law.
Notice that in this example, this new combination law model for tires,
will have a different set of requirements from the ones stated above.)""";
        // Symbol: drake::multibody::CoulombFriction::CoulombFriction<T>
        struct /* ctor */ {
          // Source: drake/multibody/plant/coulomb_friction.h:68
          const char* doc_0args =
R"""(Default constructor for a frictionless surface, i.e. with zero static
and dynamic coefficients of friction.)""";
          // Source: drake/multibody/plant/coulomb_friction.h:74
          const char* doc_2args =
R"""(Specifies both the static and dynamic friction coefficients for a
given surface.

Raises:
    RuntimeError if any of the friction coefficients are negative or
    if ``dynamic_friction > static_friction`` (they can be equal.))""";
        } ctor;
        // Symbol: drake::multibody::CoulombFriction::dynamic_friction
        struct /* dynamic_friction */ {
          // Source: drake/multibody/plant/coulomb_friction.h:80
          const char* doc =
R"""(Returns the coefficient of dynamic friction.)""";
        } dynamic_friction;
        // Symbol: drake::multibody::CoulombFriction::static_friction
        struct /* static_friction */ {
          // Source: drake/multibody/plant/coulomb_friction.h:77
          const char* doc =
R"""(Returns the coefficient of static friction.)""";
        } static_friction;
      } CoulombFriction;
      // Symbol: drake::multibody::DistanceConstraint
      struct /* DistanceConstraint */ {
        // Source: drake/multibody/inverse_kinematics/distance_constraint.h:16
        const char* doc =
R"""(Constrains the distance between a pair of geometries to be within a
range [distance_lower, distance_upper].)""";
        // Symbol: drake::multibody::DistanceConstraint::DistanceConstraint
        struct /* ctor */ {
          // Source: drake/multibody/inverse_kinematics/distance_constraint.h:32
          const char* doc =
R"""(Parameter ``plant``:
    The plant to which the pair of geometries belong. ``plant`` should
    outlive this DistanceConstraint object.

Parameter ``geometry_pair``:
    The pair of geometries between which the distance is constrained.
    Notice that we only consider the distance between a static
    geometry and a dynamic geometry, or a pair of dynamic geometries.
    We don't allow constraining the distance between two static
    geometries.

Parameter ``plant_context``:
    The context for the plant. ``plant_context`` should outlive this
    DistanceConstraint object.

Parameter ``distance_lower``:
    The lower bound on the distance.

Parameter ``distance_upper``:
    The upper bound on the distance.)""";
        } ctor;
      } DistanceConstraint;
      // Symbol: drake::multibody::DoorHinge
      struct /* DoorHinge */ {
        // Source: drake/multibody/tree/door_hinge.h:124
        const char* doc =
R"""(This ForceElement models a revolute DoorHinge joint that could exhibit
different force/torque characteristics at different states due to the
existence of different type of torques on the joint. This class
implements a "christmas tree" accumulation of these different torques
in an empirical and unprincipled way. Specifically, different curves
are assigned to different torques to mimic their evolution based on
the joint state and some prespecified parameters.

Torques considered in this implementation include: * torsional spring
torque (τ_ts) -- position dependent * catch torque (τ_c) -- position
dependent * dynamic friction torque (τ_df) -- velocity dependent *
static friction torque (τ_sf) -- velocity dependent * viscous friction
torque (τ_vf) -- velocity dependent

We then implement two curves to approximate the progression of
different torques. A curve ``s(t, x) = tanh(x/t)`` uses the ``tanh``
function to approximate a step curve ({`x<0`: -1 ; ``x>0``: 1})
outside of ``-t < x < t``. The curve ``doublet(t, x) = 2 * s * (1 −
s²)`` is the second derivative of ``s`` scaled by ``-t²``, which
yields a lump at negative ``x`` that integrates to -1 and a lump at
positive ``x`` that integrates to 1. Finally, the total external
torque on the hinge joint would be:

``τ = τ_ts + τ_c + τ_df + τ_sf + τ_vf``.

where ``τ_ts = -k_ts * (q − qs₀)``, `τ_c = k_c * doublet(qc₀/2, q −
qc₀/2)``, `τ_df = -k_df * s(k_q̇₀, q̇)``, `τ_sf = -k_sf *
doublet(k_q̇₀, q̇)` and ``τ_vf = -k_vf * q̇``. The door is assumed to
be closed at ``q=0``, opening in the positive-q direction. Note that,
the sign of the torques depends on two elements: one is the sign of
the torque related constants and another one is the sign of the
assigned curves. For example, as defined above, the static friction
torque ``τ_sf`` should be opposite to the direction of the velocity
q̇. The catch torque ``τ_c`` should be negative when ``q < qc₀/2`` and
positive otherwise. This class applies all hinge-originating forces,
so it can be used instead of the SDF viscous damping. The users could
change the values of these different elements to obtain different
characteristics for the DoorHinge joint that the users want to model.
A jupyter notebook tool is also provided to help the users visualize
the curves and design parameters. Run ``bazel run
//bindings/pydrake/multibody:examples/door_hinge_inspector`` to bring
up the notebook.

**To give an example**, a common dishwasher door has a frictional
torque sufficient for it to rest motionless at any angle, a catch at
the top to hold it in place, a dashpot (viscous friction source) to
prevent it from swinging too fast, and a spring to counteract some of
its mass. Two figures are provided to illustrate the dishwasher
DoorHinge torque with the given default parameters. Figure 1 shows the
static characteristic of the dishwasher door. At q = 0, there exists a
negative catch torque to prevent the door from moving. After that, the
torsional spring torque will dominate to compensate part of the door
gravity. Figure 2 shows the dynamic feature of the dishwasher door at
q = 30 deg. It shows the door can be closed easily since the torque is
small when the velocity is negative. However, whenever the door
intends to open further, there will be a counter torque to prevent
that movement, which therefore keeps the door at rest. Note that, due
to the gravity, the dishwasher door will be fully open eventually.
This process can be really slow because of the default
``motion_threshold`` is set to be very small. You can change the
``motion_threshold`` parameter to adjust the time. @image html
multibody/tree/images/torque_vs_angle.svg "Figure 1" @image html
multibody/tree/images/torque_vs_velocity.svg "Figure 2")""";
        // Symbol: drake::multibody::DoorHinge::CalcConservativePower
        struct /* CalcConservativePower */ {
          // Source: drake/multibody/tree/door_hinge.h:141
          const char* doc = R"""()""";
        } CalcConservativePower;
        // Symbol: drake::multibody::DoorHinge::CalcHingeConservativePower
        struct /* CalcHingeConservativePower */ {
          // Source: drake/multibody/tree/door_hinge.h:173
          const char* doc =
R"""(Calculate the total conservative power with the given ``angle``,
``angular_rate``, and the internal DoorHingeConfig.)""";
        } CalcHingeConservativePower;
        // Symbol: drake::multibody::DoorHinge::CalcHingeFrictionalTorque
        struct /* CalcHingeFrictionalTorque */ {
          // Source: drake/multibody/tree/door_hinge.h:161
          const char* doc =
R"""(Calculates the total frictional torque with the given ``angular_rate``
and the internal DoorHingeConfig.)""";
        } CalcHingeFrictionalTorque;
        // Symbol: drake::multibody::DoorHinge::CalcHingeNonConservativePower
        struct /* CalcHingeNonConservativePower */ {
          // Source: drake/multibody/tree/door_hinge.h:177
          const char* doc =
R"""(Calculate the total non-conservative power with the given
``angular_rate`` and the internal DoorHingeConfig.)""";
        } CalcHingeNonConservativePower;
        // Symbol: drake::multibody::DoorHinge::CalcHingeSpringTorque
        struct /* CalcHingeSpringTorque */ {
          // Source: drake/multibody/tree/door_hinge.h:165
          const char* doc =
R"""(Calculate the total spring related torque with the given ``angle`` and
the internal DoorHingeConfig.)""";
        } CalcHingeSpringTorque;
        // Symbol: drake::multibody::DoorHinge::CalcHingeStoredEnergy
        struct /* CalcHingeStoredEnergy */ {
          // Source: drake/multibody/tree/door_hinge.h:181
          const char* doc =
R"""(Calculate the total potential energy of the DoorHinge ForceElement
with the given ``angle`` and the internal DoorHingeConfig.)""";
        } CalcHingeStoredEnergy;
        // Symbol: drake::multibody::DoorHinge::CalcHingeTorque
        struct /* CalcHingeTorque */ {
          // Source: drake/multibody/tree/door_hinge.h:169
          const char* doc =
R"""(Calculate the total torque with the given ``angle`` and
``angular_rate`` and the internal DoorHingeConfig.)""";
        } CalcHingeTorque;
        // Symbol: drake::multibody::DoorHinge::CalcNonConservativePower
        struct /* CalcNonConservativePower */ {
          // Source: drake/multibody/tree/door_hinge.h:146
          const char* doc = R"""()""";
        } CalcNonConservativePower;
        // Symbol: drake::multibody::DoorHinge::CalcPotentialEnergy
        struct /* CalcPotentialEnergy */ {
          // Source: drake/multibody/tree/door_hinge.h:137
          const char* doc = R"""()""";
        } CalcPotentialEnergy;
        // Symbol: drake::multibody::DoorHinge::DoCalcAndAddForceContribution
        struct /* DoCalcAndAddForceContribution */ {
          // Source: drake/multibody/tree/door_hinge.h:185
          const char* doc = R"""()""";
        } DoCalcAndAddForceContribution;
        // Symbol: drake::multibody::DoorHinge::DoCloneToScalar
        struct /* DoCloneToScalar */ {
          // Source: drake/multibody/tree/door_hinge.h:191
          const char* doc = R"""()""";
        } DoCloneToScalar;
        // Symbol: drake::multibody::DoorHinge::DoorHinge<T>
        struct /* ctor */ {
          // Source: drake/multibody/tree/door_hinge.h:131
          const char* doc =
R"""(Constructs a hinge force element with parameters ``config`` applied to
the specified ``joint``. It will throw an exception if the
DoorHingeConfig is invalid.)""";
        } ctor;
        // Symbol: drake::multibody::DoorHinge::config
        struct /* config */ {
          // Source: drake/multibody/tree/door_hinge.h:135
          const char* doc = R"""()""";
        } config;
        // Symbol: drake::multibody::DoorHinge::joint
        struct /* joint */ {
          // Source: drake/multibody/tree/door_hinge.h:133
          const char* doc = R"""()""";
        } joint;
      } DoorHinge;
      // Symbol: drake::multibody::DoorHingeConfig
      struct /* DoorHingeConfig */ {
        // Source: drake/multibody/tree/door_hinge.h:15
        const char* doc =
R"""(Configuration structure for the DoorHinge.)""";
        // Symbol: drake::multibody::DoorHingeConfig::DoorHingeConfig
        struct /* ctor */ {
          // Source: drake/multibody/tree/door_hinge.h:49
          const char* doc =
R"""(Initialize to empirically reasonable values measured approximately by
banging on the door of a dishwasher with a force gauge.)""";
        } ctor;
        // Symbol: drake::multibody::DoorHingeConfig::catch_torque
        struct /* catch_torque */ {
          // Source: drake/multibody/tree/door_hinge.h:35
          const char* doc =
R"""(k_c maximum catch torque applied over ``catch_width`` [Nm]. It should
be non-negative.)""";
        } catch_torque;
        // Symbol: drake::multibody::DoorHingeConfig::catch_width
        struct /* catch_width */ {
          // Source: drake/multibody/tree/door_hinge.h:32
          const char* doc =
R"""(qc₀ measured from closed (q=0) position [radian]. It should be
non-negative.)""";
        } catch_width;
        // Symbol: drake::multibody::DoorHingeConfig::dynamic_friction_torque
        struct /* dynamic_friction_torque */ {
          // Source: drake/multibody/tree/door_hinge.h:23
          const char* doc =
R"""(k_df maximum dynamic friction torque measured opposite direction of
motion [Nm]. It should be non-negative.)""";
        } dynamic_friction_torque;
        // Symbol: drake::multibody::DoorHingeConfig::motion_threshold
        struct /* motion_threshold */ {
          // Source: drake/multibody/tree/door_hinge.h:45
          const char* doc =
R"""(k_q̇₀ motion threshold to start to apply friction torques [rad/s]. It
should be non-negative. Realistic frictional force is very stiff,
reversing entirely over zero change in position or velocity, which
kills integrators. We approximate it with a continuous function. This
constant [rad/s] is the scaling factor on that function -- very
approximately the rad/s at which half of the full frictional force is
applied. This number is nonphysical; make it small but not so small
that the simulation vibrates or explodes.)""";
        } motion_threshold;
        // Symbol: drake::multibody::DoorHingeConfig::spring_constant
        struct /* spring_constant */ {
          // Source: drake/multibody/tree/door_hinge.h:20
          const char* doc =
R"""(k_ts torsional spring constant measured toward the spring zero angle
[Nm/rad]. It should be non-negative.)""";
        } spring_constant;
        // Symbol: drake::multibody::DoorHingeConfig::spring_zero_angle_rad
        struct /* spring_zero_angle_rad */ {
          // Source: drake/multibody/tree/door_hinge.h:17
          const char* doc =
R"""(qs₀ measured outward from the closed position [radian].)""";
        } spring_zero_angle_rad;
        // Symbol: drake::multibody::DoorHingeConfig::static_friction_torque
        struct /* static_friction_torque */ {
          // Source: drake/multibody/tree/door_hinge.h:26
          const char* doc =
R"""(k_sf maximum static friction measured opposite direction of motion
[Nm]. It should be non-negative.)""";
        } static_friction_torque;
        // Symbol: drake::multibody::DoorHingeConfig::viscous_friction
        struct /* viscous_friction */ {
          // Source: drake/multibody/tree/door_hinge.h:29
          const char* doc =
R"""(k_vf viscous friction measured opposite direction of motion [Nm]. It
should be non-negative.)""";
        } viscous_friction;
      } DoorHingeConfig;
      // Symbol: drake::multibody::ExternallyAppliedSpatialForce
      struct /* ExternallyAppliedSpatialForce */ {
        // Source: drake/multibody/plant/externally_applied_spatial_force.h:11
        const char* doc = R"""()""";
        // Symbol: drake::multibody::ExternallyAppliedSpatialForce::F_Bq_W
        struct /* F_Bq_W */ {
          // Source: drake/multibody/plant/externally_applied_spatial_force.h:21
          const char* doc =
R"""(A spatial force applied to Body B at point Bq, expressed in the world
frame.)""";
        } F_Bq_W;
        // Symbol: drake::multibody::ExternallyAppliedSpatialForce::body_index
        struct /* body_index */ {
          // Source: drake/multibody/plant/externally_applied_spatial_force.h:13
          const char* doc =
R"""(The index of the body that the force is to be applied to.)""";
        } body_index;
        // Symbol: drake::multibody::ExternallyAppliedSpatialForce::p_BoBq_B
        struct /* p_BoBq_B */ {
          // Source: drake/multibody/plant/externally_applied_spatial_force.h:17
          const char* doc =
R"""(A position vector from Body B's origin (Bo) to a point Bq (a point of
B), expressed in B's frame.)""";
        } p_BoBq_B;
      } ExternallyAppliedSpatialForce;
      // Symbol: drake::multibody::FixedOffsetFrame
      struct /* FixedOffsetFrame */ {
        // Source: drake/multibody/tree/fixed_offset_frame.h:34
        const char* doc =
R"""(%FixedOffsetFrame represents a material frame F whose pose is fixed
with respect to a *parent* material frame P. The pose offset is given
by a spatial transform ``X_PF``, which is constant after construction.
For instance, we could rigidly attach a frame F to move with a rigid
body B at a fixed pose ``X_BF``, where B is the BodyFrame associated
with body B. Thus, the World frame pose ``X_WF`` of a FixedOffsetFrame
F depends only on the World frame pose ``X_WP`` of its parent P, and
the constant pose ``X_PF``, with ``X_WF=X_WP*X_PF``.

For more information about spatial transforms, see
multibody_spatial_pose.)""";
        // Symbol: drake::multibody::FixedOffsetFrame::CalcPoseInBodyFrame
        struct /* CalcPoseInBodyFrame */ {
          // Source: drake/multibody/tree/fixed_offset_frame.h:81
          const char* doc = R"""()""";
        } CalcPoseInBodyFrame;
        // Symbol: drake::multibody::FixedOffsetFrame::CalcRotationMatrixInBodyFrame
        struct /* CalcRotationMatrixInBodyFrame */ {
          // Source: drake/multibody/tree/fixed_offset_frame.h:92
          const char* doc = R"""()""";
        } CalcRotationMatrixInBodyFrame;
        // Symbol: drake::multibody::FixedOffsetFrame::DoCloneToScalar
        struct /* DoCloneToScalar */ {
          // Source: drake/multibody/tree/fixed_offset_frame.h:136
          const char* doc =
R"""(Precondition:
    The parent frame to this frame already has a clone in
    ``tree_clone``.)""";
        } DoCloneToScalar;
        // Symbol: drake::multibody::FixedOffsetFrame::FixedOffsetFrame<T>
        struct /* ctor */ {
          // Source: drake/multibody/tree/fixed_offset_frame.h:52
          const char* doc_4args =
R"""(Creates a material Frame F whose pose is fixed with respect to its
parent material Frame P. The pose is given by a spatial transform
``X_PF``; see class documentation for more information.

Parameter ``name``:
    The name of this frame.

Parameter ``P``:
    The frame to which this frame is attached with a fixed pose.

Parameter ``X_PF``:
    The *default* transform giving the pose of F in P, therefore only
    the value (as a RigidTransform<double>) is provided.

Parameter ``model_instance``:
    The model instance to which this frame belongs to. If unspecified,
    will use P.body().model_instance().)""";
          // Source: drake/multibody/tree/fixed_offset_frame.h:59
          const char* doc_2args =
R"""(Creates an unnamed material Frame F. See overload with name for more
information.)""";
          // Source: drake/multibody/tree/fixed_offset_frame.h:71
          const char* doc_3args =
R"""(Creates a material Frame F whose pose is fixed with respect to the
BodyFrame B of the given Body, which serves as F's parent frame. The
pose is given by a spatial transform ``X_BF``; see class documentation
for more information.

Parameter ``name``:
    The name of this frame.

Parameter ``bodyB``:
    The body whose BodyFrame B is to be F's parent frame.

Parameter ``X_BF``:
    The transform giving the pose of F in B.)""";
        } ctor;
        // Symbol: drake::multibody::FixedOffsetFrame::GetFixedPoseInBodyFrame
        struct /* GetFixedPoseInBodyFrame */ {
          // Source: drake/multibody/tree/fixed_offset_frame.h:113
          const char* doc =
R"""(Returns:
    The default fixed pose in the body frame.)""";
        } GetFixedPoseInBodyFrame;
        // Symbol: drake::multibody::FixedOffsetFrame::GetFixedRotationMatrixInBodyFrame
        struct /* GetFixedRotationMatrixInBodyFrame */ {
          // Source: drake/multibody/tree/fixed_offset_frame.h:119
          const char* doc =
R"""(Returns:
    The default rotation matrix of this fixed pose in the body frame.)""";
        } GetFixedRotationMatrixInBodyFrame;
        // Symbol: drake::multibody::FixedOffsetFrame::SetPoseInBodyFrame
        struct /* SetPoseInBodyFrame */ {
          // Source: drake/multibody/tree/fixed_offset_frame.h:104
          const char* doc = R"""()""";
        } SetPoseInBodyFrame;
      } FixedOffsetFrame;
      // Symbol: drake::multibody::ForceElement
      struct /* ForceElement */ {
        // Source: drake/multibody/tree/force_element.h:38
        const char* doc =
R"""(A ForceElement allows modeling state and time dependent forces in a
MultibodyTree model. Examples of such forces are springs, dampers,
drag and gravity. Forces that depend on accelerations such as virtual
mass cannot be modeled with a ForceElement. This abstract class
provides an API that all force elements subclasses must implement in
order to be fully defined. These are:

- CalcAndAddForceContribution(): computes the force contribution of a force
  element in a MultibodyTree model.
- CalcPotentialEnergy(): computes a force element potential energy
  contribution.
- CalcConservativePower(): computes the power generated by conservative
  forces.
- CalcNonConservativePower(): computes the power dissipated by
  non-conservative forces.)""";
        // Symbol: drake::multibody::ForceElement::CalcAndAddForceContribution
        struct /* CalcAndAddForceContribution */ {
          // Source: drake/multibody/tree/force_element.h:72
          const char* doc =
R"""((Advanced) Computes the force contribution for ``this`` force element
and **adds** it to the output arrays of forces. Depending on their
model, different force elements may write into the array of spatial
forces ``F_B_W`` or the array of generalized forces ``tau``.

Parameter ``context``:
    The context containing the state of the MultibodyTree model.

Parameter ``pc``:
    A position kinematics cache object already updated to be in sync
    with ``context``.

Parameter ``vc``:
    A velocity kinematics cache object already updated to be in sync
    with ``context``.

Parameter ``forces``:
    A pointer to a valid, non nullptr, multibody forces object. On
    output ``this`` force element adds its contribution into
    ``forces``. This method will abort if the ``forces`` pointer is
    null or if the forces object is not compatible with ``this``
    MultibodyTree, see MultibodyForces::CheckInvariants().

Precondition:
    The position kinematics ``pc`` must have been previously updated
    with a call to CalcPositionKinematicsCache().

Precondition:
    The velocity kinematics ``vc`` must have been previously updated
    with a call to CalcVelocityKinematicsCache().)""";
        } CalcAndAddForceContribution;
        // Symbol: drake::multibody::ForceElement::CalcConservativePower
        struct /* CalcConservativePower */ {
          // Source: drake/multibody/tree/force_element.h:131
          const char* doc =
R"""((Advanced) Calculates and returns the power generated by conservative
force elements or zero if ``this`` force element is non-conservative.
This quantity is defined to be positive when the potential energy is
decreasing. In other words, if ``PE`` is the potential energy as
defined by CalcPotentialEnergy(), then the conservative power, ``Pc``,
is ``Pc = -d(PE)/dt``.

See also:
    CalcPotentialEnergy(), CalcNonConservativePower())""";
        } CalcConservativePower;
        // Symbol: drake::multibody::ForceElement::CalcNonConservativePower
        struct /* CalcNonConservativePower */ {
          // Source: drake/multibody/tree/force_element.h:144
          const char* doc =
R"""((Advanced) Calculates the rate at which mechanical energy is being
generated (positive) or dissipated (negative) *other than* by
conversion between potential and kinetic energy. Integrating this
quantity yields work W, and the total energy ``E = PE + KE - W``
should be conserved by any physically-correct model, to within
integration accuracy of W.

See also:
    CalcConservativePower())""";
        } CalcNonConservativePower;
        // Symbol: drake::multibody::ForceElement::CalcPotentialEnergy
        struct /* CalcPotentialEnergy */ {
          // Source: drake/multibody/tree/force_element.h:118
          const char* doc =
R"""((Advanced) Calculates the potential energy currently stored given the
configuration provided in ``context``. Non-conservative force elements
will return zero.

Parameter ``context``:
    The context containing the state of the MultibodyTree model.

Parameter ``pc``:
    A position kinematics cache object already updated to be in sync
    with ``context``.

Precondition:
    The position kinematics ``pc`` must have been previously updated
    with a call to CalcPositionKinematicsCache().

Returns:
    For conservative force models, the potential energy stored by
    ``this`` force element. For non-conservative force models, zero.

See also:
    CalcConservativePower())""";
        } CalcPotentialEnergy;
        // Symbol: drake::multibody::ForceElement::CloneToScalar
        struct /* CloneToScalar */ {
          // Source: drake/multibody/tree/force_element.h:158
          const char* doc = R"""()""";
        } CloneToScalar;
        // Symbol: drake::multibody::ForceElement::DoCalcAndAddForceContribution
        struct /* DoCalcAndAddForceContribution */ {
          // Source: drake/multibody/tree/force_element.h:177
          const char* doc =
R"""(This method is called only from the public non-virtual
CalcAndAddForceContributions() which will already have error-checked
the parameters so you don't have to. Refer to the documentation for
CalcAndAddForceContribution() for details describing the purpose and
parameters of this method. It assumes ``forces`` to be a valid pointer
to a MultibodyForces object compatible with the MultibodyTree model
owning ``this`` force element.

Precondition:
    The position kinematics ``pc`` must have been previously updated
    with a call to CalcPositionKinematicsCache().

Precondition:
    The velocity kinematics ``vc`` must have been previously updated
    with a call to CalcVelocityKinematicsCache().)""";
        } DoCalcAndAddForceContribution;
        // Symbol: drake::multibody::ForceElement::DoCloneToScalar
        struct /* DoCloneToScalar */ {
          // Source: drake/multibody/tree/force_element.h:235
          const char* doc_was_unable_to_choose_unambiguous_names =
R"""(Clones this ForceElement (templated on T) to a mobilizer templated on
``double``.)""";
        } DoCloneToScalar;
        // Symbol: drake::multibody::ForceElement::ForceElement<T>
        struct /* ctor */ {
          // Source: drake/multibody/tree/force_element.h:44
          const char* doc =
R"""(Default constructor for a generic force element.)""";
        } ctor;
      } ForceElement;
      // Symbol: drake::multibody::ForceElementIndex
      struct /* ForceElementIndex */ {
        // Source: drake/multibody/tree/multibody_tree_indexes.h:29
        const char* doc =
R"""(Type used to identify force elements by index within a multibody tree
system.)""";
      } ForceElementIndex;
      // Symbol: drake::multibody::Frame
      struct /* Frame */ {
        // Source: drake/multibody/tree/frame.h:44
        const char* doc =
R"""(%Frame is an abstract class representing a *material frame* (also
called a *physical frame*), meaning that it is associated with a
material point of a Body. A material frame can be used to apply forces
and torques to a multibody system, and can be used as an attachment
point for force-producing elements like joints, actuators, and
constraints. Despite its name, Frame is not the most general frame
representation in Drake; see FrameBase for a more-general discussion.

The pose and motion of a Frame object is always calculated relative to
the BodyFrame of the body with which it is associated, and every Frame
object can report which Body object that is. Concrete classes derived
from Frame differ only in how those kinematic properties are
calculated. For soft bodies that calculation may depend on the body's
deformation state variables. A Frame on a rigid body will usually have
a fixed offset from its BodyFrame, but that is not required -- a frame
that moves with respect to its BodyFrame can still be a material frame
on that rigid body.

As always in Drake, runtime numerical quantities are stored in a
Context. A Frame object does not store runtime values, but provides
methods for extracting frame-associated values (such as the Frame
object's kinematics) from a given Context.)""";
        // Symbol: drake::multibody::Frame::CalcOffsetPoseInBody
        struct /* CalcOffsetPoseInBody */ {
          // Source: drake/multibody/tree/frame.h:123
          const char* doc =
R"""(Given the offset pose ``X_FQ`` of a frame Q in ``this`` frame F, this
method computes the pose ``X_BQ`` of frame Q in the body frame B to
which this frame is attached. In other words, if the pose of ``this``
frame F in the body frame B is ``X_BF``, this method computes the pose
``X_BQ`` of frame Q in the body frame B as ``X_BQ = X_BF * X_FQ``. In
particular, if ``this`` **is**` the body frame B, i.e. ``X_BF`` is the
identity transformation, this method directly returns ``X_FQ``.
Specific frame subclasses can override this method to provide faster
implementations if needed.)""";
        } CalcOffsetPoseInBody;
        // Symbol: drake::multibody::Frame::CalcOffsetRotationMatrixInBody
        struct /* CalcOffsetRotationMatrixInBody */ {
          // Source: drake/multibody/tree/frame.h:133
          const char* doc =
R"""(Calculates and returns the rotation matrix ``R_BQ`` that relates body
frame B to frame Q via ``this`` intermediate frame F, i.e., ``R_BQ =
R_BF * R_FQ`` (B is the body frame to which ``this`` frame F is
attached).

Parameter ``R_FQ``:
    rotation matrix that relates frame F to frame Q.)""";
        } CalcOffsetRotationMatrixInBody;
        // Symbol: drake::multibody::Frame::CalcPose
        struct /* CalcPose */ {
          // Source: drake/multibody/tree/frame.h:173
          const char* doc =
R"""(Computes and returns the pose ``X_MF`` of ``this`` frame F in measured
in ``frame_M`` as a function of the state of the model stored in
``context``.

See also:
    CalcPoseInWorld().)""";
        } CalcPose;
        // Symbol: drake::multibody::Frame::CalcPoseInBodyFrame
        struct /* CalcPoseInBodyFrame */ {
          // Source: drake/multibody/tree/frame.h:73
          const char* doc =
R"""(Returns the pose ``X_BF`` of ``this`` frame F in the body frame B
associated with this frame. In particular, if ``this`` **is** the body
frame B, this method directly returns the identity transformation.)""";
        } CalcPoseInBodyFrame;
        // Symbol: drake::multibody::Frame::CalcPoseInWorld
        struct /* CalcPoseInWorld */ {
          // Source: drake/multibody/tree/frame.h:164
          const char* doc =
R"""(Computes and returns the pose ``X_WF`` of ``this`` frame F in the
world frame W as a function of the state of the model stored in
``context``.

Note:
    Body::EvalPoseInWorld() provides a more efficient way to obtain
    the pose for a body frame.)""";
        } CalcPoseInWorld;
        // Symbol: drake::multibody::Frame::CalcRotationMatrix
        struct /* CalcRotationMatrix */ {
          // Source: drake/multibody/tree/frame.h:181
          const char* doc =
R"""(Calculates and returns the rotation matrix ``R_MF`` that relates
``frame_M`` and ``this`` frame F as a function of the state stored in
``context``.)""";
        } CalcRotationMatrix;
        // Symbol: drake::multibody::Frame::CalcRotationMatrixInBodyFrame
        struct /* CalcRotationMatrixInBodyFrame */ {
          // Source: drake/multibody/tree/frame.h:79
          const char* doc =
R"""(Returns the rotation matrix ``R_BF`` that relates body frame B to
``this`` frame F (B is the body frame to which ``this`` frame F is
attached).

Note:
    If ``this`` is B, this method returns the identity RotationMatrix.)""";
        } CalcRotationMatrixInBodyFrame;
        // Symbol: drake::multibody::Frame::CalcRotationMatrixInWorld
        struct /* CalcRotationMatrixInWorld */ {
          // Source: drake/multibody/tree/frame.h:189
          const char* doc =
R"""(Calculates and returns the rotation matrix ``R_WF`` that relates the
world frame W and ``this`` frame F as a function of the state stored
in ``context``.)""";
        } CalcRotationMatrixInWorld;
        // Symbol: drake::multibody::Frame::CalcSpatialAccelerationInWorld
        struct /* CalcSpatialAccelerationInWorld */ {
          // Source: drake/multibody/tree/frame.h:240
          const char* doc =
R"""(Computes and returns the spatial acceleration A_WF_W of ``this`` frame
F in world frame W expressed in W as a function of the state stored in
context.

Note:
    Body::EvalSpatialAccelerationInWorld() provides a more efficient
    way to obtain the spatial acceleration for a body frame.

Note:
    When cached values are out of sync with the state stored in
    context, this method performs an expensive forward dynamics
    computation, whereas once evaluated, successive calls to this
    method are inexpensive.)""";
        } CalcSpatialAccelerationInWorld;
        // Symbol: drake::multibody::Frame::CalcSpatialVelocity
        struct /* CalcSpatialVelocity */ {
          // Source: drake/multibody/tree/frame.h:214
          const char* doc =
R"""(Computes and returns the spatial velocity ``V_MF_E`` of ``this`` frame
F measured in ``frame_M`` and expressed in ``frame_E`` as a function
of the state of the model stored in ``context``.

See also:
    CalcSpatialVelocityInWorld().)""";
        } CalcSpatialVelocity;
        // Symbol: drake::multibody::Frame::CalcSpatialVelocityInWorld
        struct /* CalcSpatialVelocityInWorld */ {
          // Source: drake/multibody/tree/frame.h:199
          const char* doc =
R"""(Computes and returns the spatial velocity ``V_WF`` of ``this`` frame F
in the world frame W as a function of the state of the model stored in
``context``.

Note:
    Body::EvalSpatialVelocityInWorld() provides a more efficient way
    to obtain the spatial velocity for a body frame.)""";
        } CalcSpatialVelocityInWorld;
        // Symbol: drake::multibody::Frame::CloneToScalar
        struct /* CloneToScalar */ {
          // Source: drake/multibody/tree/frame.h:268
          const char* doc =
R"""((Advanced) NVI to DoCloneToScalar() templated on the scalar type of
the new clone to be created. This method is mostly intended to be
called by MultibodyTree::CloneToScalar(). Most users should not call
this clone method directly but rather clone the entire parent
MultibodyTree if needed.

See also:
    MultibodyTree::CloneToScalar())""";
        } CloneToScalar;
        // Symbol: drake::multibody::Frame::DoCloneToScalar
        struct /* DoCloneToScalar */ {
          // Source: drake/multibody/tree/frame.h:300
          const char* doc_was_unable_to_choose_unambiguous_names =
R"""(Clones this Frame (templated on T) to a frame templated on ``double``.)""";
        } DoCloneToScalar;
        // Symbol: drake::multibody::Frame::Frame<T>
        struct /* ctor */ {
          // Source: drake/multibody/tree/frame.h:277
          const char* doc_3args =
R"""(Only derived classes can use this constructor. It creates a Frame
object attached to ``body`` and puts the frame in the body's model
instance.)""";
          // Source: drake/multibody/tree/frame.h:284
          const char* doc_1args =
R"""(Overload to permit constructing an unnamed frame.)""";
        } ctor;
        // Symbol: drake::multibody::Frame::GetFixedOffsetPoseInBody
        struct /* GetFixedOffsetPoseInBody */ {
          // Source: drake/multibody/tree/frame.h:144
          const char* doc =
R"""(Variant of CalcOffsetPoseInBody() that given the offset pose ``X_FQ``
of a frame Q in ``this`` frame F, returns the pose ``X_BQ`` of frame Q
in the body frame B to which this frame is attached.

Raises:
    RuntimeError if called on a Frame that does not have a fixed
    offset in the body frame.)""";
        } GetFixedOffsetPoseInBody;
        // Symbol: drake::multibody::Frame::GetFixedPoseInBodyFrame
        struct /* GetFixedPoseInBodyFrame */ {
          // Source: drake/multibody/tree/frame.h:91
          const char* doc =
R"""(Variant of CalcPoseInBodyFrame() that returns the fixed pose ``X_BF``
of ``this`` frame F in the body frame B associated with this frame.

Raises:
    RuntimeError if called on a Frame that does not have a fixed
    offset in the body frame.)""";
        } GetFixedPoseInBodyFrame;
        // Symbol: drake::multibody::Frame::GetFixedRotationMatrixInBody
        struct /* GetFixedRotationMatrixInBody */ {
          // Source: drake/multibody/tree/frame.h:155
          const char* doc =
R"""(Calculates and returns the rotation matrix ``R_BQ`` that relates body
frame B to frame Q via ``this`` intermediate frame F, i.e., ``R_BQ =
R_BF * R_FQ`` (B is the body frame to which ``this`` frame F is
attached).

Parameter ``R_FQ``:
    rotation matrix that relates frame F to frame Q.

Raises:
    RuntimeError if ``this`` frame F is a Frame that does not have a
    fixed offset in the body frame B (i.e., ``R_BF`` is not constant).)""";
        } GetFixedRotationMatrixInBody;
        // Symbol: drake::multibody::Frame::GetFixedRotationMatrixInBodyFrame
        struct /* GetFixedRotationMatrixInBodyFrame */ {
          // Source: drake/multibody/tree/frame.h:106
          const char* doc =
R"""(Returns the rotation matrix ``R_BF`` that relates body frame B to
``this`` frame F (B is the body frame to which ``this`` frame F is
attached).

Raises:
    RuntimeError if ``this`` frame F is a Frame that does not have a
    fixed offset in the body frame B (i.e., ``R_BF`` is not constant).
    Frame sub-classes that have a constant ``R_BF`` must override this
    method. An example of a frame sub-class not implementing this
    method would be that of a frame on a soft body, for which its pose
    in the body frame depends on the state of deformation of the body.)""";
        } GetFixedRotationMatrixInBodyFrame;
        // Symbol: drake::multibody::Frame::body
        struct /* body */ {
          // Source: drake/multibody/tree/frame.h:49
          const char* doc =
R"""(Returns a const reference to the body associated to this Frame.)""";
        } body;
        // Symbol: drake::multibody::Frame::is_body_frame
        struct /* is_body_frame */ {
          // Source: drake/multibody/tree/frame.h:59
          const char* doc =
R"""(Returns true if ``this`` is the body frame.)""";
        } is_body_frame;
        // Symbol: drake::multibody::Frame::is_world_frame
        struct /* is_world_frame */ {
          // Source: drake/multibody/tree/frame.h:54
          const char* doc =
R"""(Returns true if ``this`` is the world frame.)""";
        } is_world_frame;
        // Symbol: drake::multibody::Frame::name
        struct /* name */ {
          // Source: drake/multibody/tree/frame.h:65
          const char* doc =
R"""(Returns the name of this frame. It may be empty if unnamed.)""";
        } name;
      } Frame;
      // Symbol: drake::multibody::FrameBase
      struct /* FrameBase */ {
        // Source: drake/multibody/tree/frame_base.h:46
        const char* doc =
R"""(%FrameBase is an abstract representation of the concept of a *frame*
in multibody dynamics. A frame F is a mathematical object consisting
of a set of three orthogonal unit vector axes Fx,Fy,Fz forming a
right-handed orthogonal basis located at a point Fo called the frame's
origin. If the frame origin Fo is a material point of a body, then F
is a *material frame* (also called a *physical frame*) and can be used
to apply forces and torques to its body. A material frame can serve as
an attachment point for force-producing elements such as joints and
constraints. Otherwise, we call the frame a *free-floating* or
*computed* frame and it is still suited for observation,
visualization, and measurement but cannot be used to apply forces.
Because material frames are by far the most common and useful frames
encountered in multibody systems, the derived class with the simple
name Frame is used to represent them.

Given numerical values in a Context for the associated multibody
system, *every* frame has a location and orientation (collectively,
*pose*) in space that can be obtained through this base class. Most
frames will also move based on the multibody system's configuration,
or on general runtime computations, so may have meaningful spatial
velocity and acceleration -- that will always be the case for material
frames during a dynamic simulation. Such kinematic quantities must
always be measured with respect to some other specified frame. The
only frame we can be sure exists is the World frame W, so pose and
motion with respect to W are always available. Utilities are provided
for calculating frame motion with respect to other frames. Derived
frame objects will have additional properties. For example, material
frames have an associated Body.

Summarizing, FrameBase serves as an abstraction for a general frame
object; it doesn't store any values itself. As always in Drake,
runtime values are obtained from a Context object. FrameBase provides
an interface through which the pose of a frame may be obtained from a
given Context. Classes derived from FrameBase are used to represent
more specific types of frames, most importantly whether a frame is
associated with a material point of a body.)""";
        // Symbol: drake::multibody::FrameBase::FrameBase<T>
        struct /* ctor */ {
          // Source: drake/multibody/tree/frame_base.h:60
          const char* doc = R"""()""";
        } ctor;
      } FrameBase;
      // Symbol: drake::multibody::FrameIndex
      struct /* FrameIndex */ {
        // Source: drake/multibody/tree/multibody_tree_indexes.h:22
        const char* doc =
R"""(Type used to identify frames by index in a multibody tree system.)""";
      } FrameIndex;
      // Symbol: drake::multibody::GaussianTriangleQuadratureRule
      struct /* GaussianTriangleQuadratureRule */ {
        // Source: drake/multibody/triangle_quadrature/gaussian_triangle_quadrature_rule.h:11
        const char* doc = R"""()""";
        // Symbol: drake::multibody::GaussianTriangleQuadratureRule::GaussianTriangleQuadratureRule
        struct /* ctor */ {
          // Source: drake/multibody/triangle_quadrature/gaussian_triangle_quadrature_rule.h:15
          const char* doc =
R"""(Constructs the Gaussian quadrature rule of the specified order, which
must be between 1 and 5.)""";
        } ctor;
      } GaussianTriangleQuadratureRule;
      // Symbol: drake::multibody::GazeTargetConstraint
      struct /* GazeTargetConstraint */ {
        // Source: drake/multibody/inverse_kinematics/gaze_target_constraint.h:25
        const char* doc =
R"""(Constrains a target point T to be within a cone K. The point T ("T"
stands for "target") is fixed in a frame B, with position p_BT. The
cone originates from a point S ("S" stands for "source"), fixed in
frame A with position p_AS, with the axis of the cone being n, also
fixed in frame A. The half angle of the cone is θ. A common usage of
this constraint is that a camera should gaze at some target; namely
the target falls within a gaze cone, originating from the camera eye.

Mathematically the constraint is p_ST_Aᵀ * n_unit_A ≥ 0 (p_ST_Aᵀ *
n_unit_A)² ≥ (cosθ)²p_ST_Aᵀ * p_ST_A where p_ST_A is the vector from S
to T, expressed in frame A. n_unit_A is the unit length directional
vector representing the center ray of the cone.)""";
        // Symbol: drake::multibody::GazeTargetConstraint::GazeTargetConstraint
        struct /* ctor */ {
          // Source: drake/multibody/inverse_kinematics/gaze_target_constraint.h:51
          const char* doc =
R"""(Parameter ``plant``:
    The MultibodyPlant on which the constraint is imposed. ``plant``
    should be alive during the lifetime of this constraint.

Parameter ``frameA``:
    The frame to which the gaze cone is fixed.

Parameter ``p_AS``:
    The position of the cone source point S, measured and expressed in
    frame A.

Parameter ``n_A``:
    The directional vector representing the center ray of the cone,
    expressed in frame A.

Parameter ``frameB``:
    The frame to which the target point T is fixed.

Parameter ``p_BT``:
    The position of the target point T, measured and expressed in
    frame B.

Parameter ``cone_half_angle``:
    The half angle of the cone. We denote it as θ in the class
    documentation. ``cone_half_angle`` is in radians.

Parameter ``plant_context``:
    The Context that has been allocated for this ``plant``. We will
    update the context when evaluating the constraint.
    ``plant_context`` should be alive during the lifetime of this
    constraint.

Precondition:
    ``frameA`` and ``frameB`` must belong to ``plant``.

Raises:
    ValueError if ``plant`` is nullptr.

Raises:
    ValueError if ``n_A`` is close to zero.

Raises:
    ValueError if ``cone_half_angle`` ∉ [0, π/2].

Raises:
    ValueError if ``plant_context`` is nullptr.)""";
        } ctor;
      } GazeTargetConstraint;
      // Symbol: drake::multibody::GlobalInverseKinematics
      struct /* GlobalInverseKinematics */ {
        // Source: drake/multibody/inverse_kinematics/global_inverse_kinematics.h:25
        const char* doc =
R"""(Solves the inverse kinematics problem as a mixed integer convex
optimization problem. We use a mixed-integer convex relaxation of the
rotation matrix. So if this global inverse kinematics problem says the
solution is infeasible, then it is guaranteed that the kinematics
constraints are not satisfiable. If the global inverse kinematics
returns a solution, the posture should approximately satisfy the
kinematics constraints, with some error. The approach is described in
Global Inverse Kinematics via Mixed-integer Convex Optimization by
Hongkai Dai, Gregory Izatt and Russ Tedrake, International Journal of
Robotics Research, 2019.)""";
        // Symbol: drake::multibody::GlobalInverseKinematics::AddJointLimitConstraint
        struct /* AddJointLimitConstraint */ {
          // Source: drake/multibody/inverse_kinematics/global_inverse_kinematics.h:325
          const char* doc =
R"""(Adds joint limits on a specified joint.

Parameter ``body_index``:
    The joint connecting the parent link to this body will be
    constrained.

Parameter ``joint_lower_bound``:
    The lower bound for the joint.

Parameter ``joint_upper_bound``:
    The upper bound for the joint.

Parameter ``linear_constraint_approximation``:
    If true, joint limits are approximated as linear constraints on
    parent and child link orientations, otherwise they are imposed as
    Lorentz cone constraints. With the Lorentz cone formulation, the
    joint limit constraint would be tight if our mixed-integer
    constraint on SO(3) were tight. By enforcing the joint limits as
    linear constraint, the original inverse kinematics problem is
    further relaxed, on top of SO(3) relaxation, but potentially with
    faster computation. $*Default:* is false.)""";
        } AddJointLimitConstraint;
        // Symbol: drake::multibody::GlobalInverseKinematics::AddPostureCost
        struct /* AddPostureCost */ {
          // Source: drake/multibody/inverse_kinematics/global_inverse_kinematics.h:215
          const char* doc =
R"""(Penalizes the deviation to the desired posture. For each body (except
the world) in the kinematic tree, we add the cost

∑ᵢ body_position_cost(i) * body_position_error(i) +
body_orientation_cost(i) * body_orientation_error(i) where
``body_position_error(i)`` is computed as the Euclidean distance error
|p_WBo(i) - p_WBo_desired(i)| where - p_WBo(i) : position of body i'th
origin ``Bo`` in the world frame ``W``. - p_WBo_desired(i): position
of body i'th origin ``Bo`` in the world frame ``W``, computed from the
desired posture ``q_desired``.

body_orientation_error(i) is computed as (1 - cos(θ)), where θ is the
angle between the orientation of body i'th frame and body i'th frame
using the desired posture. Notice that 1 - cos(θ) = θ²/2 + O(θ⁴), so
this cost is on the square of θ, when θ is small. Notice that since
body 0 is the world, the cost on that body is always 0, no matter what
value ``body_position_cost(0)`` and ``body_orientation_cost(0)`` take.

Parameter ``q_desired``:
    The desired posture.

Parameter ``body_position_cost``:
    The cost for each body's position error. Unit is [1/m] (one over
    meters).

Precondition:
1. body_position_cost.rows() == plant.num_bodies(), where ``plant``
   is the input argument in the constructor of the class.
2. body_position_cost(i) is non-negative.

    $Raises:

RuntimeError if the precondition is not satisfied.

Parameter ``body_orientation_cost``:
    The cost for each body's orientation error.

Precondition:
1. body_orientation_cost.rows() == plant.num_bodies() , where
   ``plant`` is the input argument in the constructor of the class.
2. body_position_cost(i) is non-negative.

    $Raises:

RuntimeError if the precondition is not satisfied.)""";
        } AddPostureCost;
        // Symbol: drake::multibody::GlobalInverseKinematics::AddWorldOrientationConstraint
        struct /* AddWorldOrientationConstraint */ {
          // Source: drake/multibody/inverse_kinematics/global_inverse_kinematics.h:176
          const char* doc =
R"""(Adds a constraint that the angle between the body orientation and the
desired orientation should not be larger than ``angle_tol``. If we
denote the angle between two rotation matrices ``R1`` and ``R2`` as
``θ``, i.e. θ is the angle of the angle-axis representation of the
rotation matrix ``R1ᵀ * R2``, we then know

trace(R1ᵀ * R2) = 2 * cos(θ) + 1 as in
http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/
To constraint ``θ < angle_tol``, we can impose the following
constraint

2 * cos(angle_tol) + 1 <= trace(R1ᵀ * R2) <= 3

Parameter ``body_idx``:
    The index of the body whose orientation will be constrained.

Parameter ``desired_orientation``:
    The desired orientation of the body.

Parameter ``angle_tol``:
    The tolerance on the angle between the body orientation and the
    desired orientation. Unit is radians.

Returns ``binding``:
    The newly added constraint, together with the bound variables.)""";
        } AddWorldOrientationConstraint;
        // Symbol: drake::multibody::GlobalInverseKinematics::AddWorldPositionConstraint
        struct /* AddWorldPositionConstraint */ {
          // Source: drake/multibody/inverse_kinematics/global_inverse_kinematics.h:149
          const char* doc =
R"""(Adds the constraint that the position of a point ``Q`` on a body ``B``
(whose index is ``body_idx``), is within a box in a specified frame
``F``. The constraint is that the point ``Q`'s position should lie
within a bounding box in the frame `F``. Namely

box_lb_F <= p_FQ <= box_ub_F

where p_FQ is the position of the point Q measured and expressed in
the ``F``, computed as

p_FQ = X_FW * (p_WBo + R_WB * p_BQ)

hence this is a linear constraint on the decision variables p_WBo and
R_WB. The inequality is imposed elementwise.

Note:
    since the rotation matrix ``R_WB`` does not lie exactly on the
    SO(3), due to the McCormick envelope relaxation, this constraint
    is subject to the accumulated error from the root of the
    kinematics tree.

Parameter ``body_idx``:
    The index of the body on which the position of a point is
    constrained.

Parameter ``p_BQ``:
    The position of the point Q measured and expressed in the body
    frame B.

Parameter ``box_lb_F``:
    The lower bound of the box in frame ``F``.

Parameter ``box_ub_F``:
    The upper bound of the box in frame ``F``.

Parameter ``X_WF``:
    . The frame in which the box is specified. This frame is
    represented by an isometry transform X_WF, the transform from the
    constraint frame F to the world frame W. Namely if the position of
    the point ``Q`` in the world frame is ``p_WQ``, then the
    constraint is

box_lb_F <= R_FW * (p_WQ-p_WFo) <= box_ub_F where - R_FW is the
rotation matrix of frame ``W`` expressed and measured in frame ``F``.
`R_FW = X_WF.linear().transpose()``. - p_WFo is the position of frame
`F`'s origin, expressed and measured in frame `W``. `p_WFo =
X_WF.translation()`.

*Default:* is the identity transform.
    $Returns ``binding``:

The newly added constraint, together with the bound variables.)""";
        } AddWorldPositionConstraint;
        // Symbol: drake::multibody::GlobalInverseKinematics::BodyPointInOneOfRegions
        struct /* BodyPointInOneOfRegions */ {
          // Source: drake/multibody/inverse_kinematics/global_inverse_kinematics.h:252
          const char* doc =
R"""(Constrain the point ``Q`` lying within one of the convex polytopes.
Each convex polytope Pᵢ is represented by its vertices as Pᵢ =
ConvexHull(v_i1, v_i2, ... v_in). Mathematically we want to impose the
constraint that the p_WQ, i.e., the position of point ``Q`` in world
frame ``W``, satisfies

p_WQ ∈ Pᵢ for one i. To impose this constraint, we consider to
introduce binary variable zᵢ, and continuous variables w_i1, w_i2,
..., w_in for each vertex of Pᵢ, with the following constraints

p_WQ = sum_i (w_i1 * v_i1 + w_i2 * v_i2 + ... + w_in * v_in) w_ij >=
0, ∀i,j w_i1 + w_i2 + ... + w_in = zᵢ sum_i zᵢ = 1 zᵢ ∈ {0, 1} Notice
that if zᵢ = 0, then w_i1 * v_i1 + w_i2 * v_i2 + ... + w_in * v_in is
just 0. This function can be used for collision avoidance, where each
region Pᵢ is a free space region. It can also be used for grasping,
where each region Pᵢ is a surface patch on the grasped object. Note
this approach also works if the region Pᵢ overlaps with each other.

Parameter ``body_index``:
    The index of the body to on which point ``Q`` is attached.

Parameter ``p_BQ``:
    The position of point ``Q`` in the body frame ``B``.

Parameter ``region_vertices``:
    region_vertices[i] is the vertices for the i'th region.

Returns ``z``:
    The newly added binary variables. If point ``Q`` is in the i'th
    region, z(i) = 1.

Precondition:
    region_vertices[i] has at least 3 columns. Throw a RuntimeError if
    the precondition is not satisfied.)""";
        } BodyPointInOneOfRegions;
        // Symbol: drake::multibody::GlobalInverseKinematics::BodySphereInOneOfPolytopes
        struct /* BodySphereInOneOfPolytopes */ {
          // Source: drake/multibody/inverse_kinematics/global_inverse_kinematics.h:306
          const char* doc =
R"""(Adds the constraint that a sphere rigidly attached to a body has to be
within at least one of the given bounded polytopes. If the polytopes
don't intersect, then the sphere is in one and only one polytope.
Otherwise the sphere is in at least one of the polytopes (could be in
the intersection of multiple polytopes.) If the i'th polytope is
described as

Aᵢ * x ≤ bᵢ where Aᵢ ∈ ℝⁿ ˣ ³, bᵢ ∈ ℝⁿ. Then a sphere with center
position p_WQ and radius r is within the i'th polytope, if

Aᵢ * p_WQ ≤ bᵢ - aᵢr where aᵢ(j) = Aᵢ.row(j).norm() To constrain that
the sphere is in one of the n polytopes, we introduce the binary
variable z ∈{0, 1}ⁿ, together with continuous variables yᵢ ∈ ℝ³, i =
1, ..., n, such that p_WQ = y₁ + ... + yₙ Aᵢ * yᵢ ≤ (bᵢ - aᵢr)zᵢ z₁ +
... +zₙ = 1 Notice that when zᵢ = 0, Aᵢ * yᵢ ≤ 0 implies that yᵢ = 0.
This is due to the boundedness of the polytope. If Aᵢ * yᵢ ≤ 0 has a
non-zero solution y̅, that y̅ ≠ 0 and Aᵢ * y̅ ≤ 0. Then for any point
x̂ in the polytope satisfying Aᵢ * x̂ ≤ bᵢ, we know the ray x̂ + ty̅,
∀ t ≥ 0 also satisfies Aᵢ * (x̂ + ty̅) ≤ bᵢ, thus the ray is within
the polytope, violating the boundedness assumption.

Parameter ``body_index``:
    The index of the body to which the sphere is attached.

Parameter ``p_BQ``:
    The position of the sphere center in the body frame B.

Parameter ``radius``:
    The radius of the sphere.

Parameter ``polytopes``:
    . polytopes[i] = (Aᵢ, bᵢ). We assume that Aᵢx≤ bᵢ is a bounded
    polytope. It is the user's responsibility to guarantee the
    boundedness.

Returns ``z``:
    The newly added binary variables. If z(i) = 1, then the sphere is
    in the i'th polytope. If two or more polytopes are intersecting,
    and the sphere is in the intersection region, then it is up to the
    solver to choose one of z(i) to be 1.)""";
        } BodySphereInOneOfPolytopes;
        // Symbol: drake::multibody::GlobalInverseKinematics::GlobalInverseKinematics
        struct /* ctor */ {
          // Source: drake/multibody/inverse_kinematics/global_inverse_kinematics.h:60
          const char* doc =
R"""(Parses the robot kinematics tree. The decision variables include the
pose for each body (position/orientation). This constructor loops
through each body inside the robot kinematics tree, adds the
constraint on each body pose, so that the adjacent bodies are
connected correctly by the joint in between the bodies.

Parameter ``plant``:
    The robot on which the inverse kinematics problem is solved. plant
    must be alive for as long as this object is around.

Parameter ``options``:
    The options to relax SO(3) constraint as mixed-integer convex
    constraints. Refer to MixedIntegerRotationConstraintGenerator for
    more details on the parameters in options.)""";
        } ctor;
        // Symbol: drake::multibody::GlobalInverseKinematics::Options
        struct /* Options */ {
          // Source: drake/multibody/inverse_kinematics/global_inverse_kinematics.h:29
          const char* doc = R"""()""";
          // Symbol: drake::multibody::GlobalInverseKinematics::Options::Options
          struct /* ctor */ {
            // Source: drake/multibody/inverse_kinematics/global_inverse_kinematics.h:31
            const char* doc = R"""()""";
          } ctor;
          // Symbol: drake::multibody::GlobalInverseKinematics::Options::approach
          struct /* approach */ {
            // Source: drake/multibody/inverse_kinematics/global_inverse_kinematics.h:34
            const char* doc = R"""()""";
          } approach;
          // Symbol: drake::multibody::GlobalInverseKinematics::Options::interval_binning
          struct /* interval_binning */ {
            // Source: drake/multibody/inverse_kinematics/global_inverse_kinematics.h:37
            const char* doc = R"""()""";
          } interval_binning;
          // Symbol: drake::multibody::GlobalInverseKinematics::Options::linear_constraint_only
          struct /* linear_constraint_only */ {
            // Source: drake/multibody/inverse_kinematics/global_inverse_kinematics.h:45
            const char* doc =
R"""(If true, add only mixed-integer linear constraints in the constructor
of GlobalInverseKinematics. The mixed-integer relaxation is tighter
with nonlinear constraints (such as Lorentz cone constraint) than with
linear constraints, but the optimization takes more time with
nonlinear constraints.)""";
          } linear_constraint_only;
          // Symbol: drake::multibody::GlobalInverseKinematics::Options::num_intervals_per_half_axis
          struct /* num_intervals_per_half_axis */ {
            // Source: drake/multibody/inverse_kinematics/global_inverse_kinematics.h:33
            const char* doc = R"""()""";
          } num_intervals_per_half_axis;
        } Options;
        // Symbol: drake::multibody::GlobalInverseKinematics::Polytope3D
        struct /* Polytope3D */ {
          // Source: drake/multibody/inverse_kinematics/global_inverse_kinematics.h:260
          const char* doc =
R"""(Describes a polytope in 3D as 𝐀 * 𝐱 ≤ 𝐛 (a set of half-spaces), where
𝐀 ∈ ℝⁿˣ³, 𝐱 ∈ ℝ³, 𝐛 ∈ ℝⁿ.)""";
          // Symbol: drake::multibody::GlobalInverseKinematics::Polytope3D::A
          struct /* A */ {
            // Source: drake/multibody/inverse_kinematics/global_inverse_kinematics.h:264
            const char* doc = R"""()""";
          } A;
          // Symbol: drake::multibody::GlobalInverseKinematics::Polytope3D::Polytope3D
          struct /* ctor */ {
            // Source: drake/multibody/inverse_kinematics/global_inverse_kinematics.h:261
            const char* doc = R"""()""";
          } ctor;
          // Symbol: drake::multibody::GlobalInverseKinematics::Polytope3D::b
          struct /* b */ {
            // Source: drake/multibody/inverse_kinematics/global_inverse_kinematics.h:265
            const char* doc = R"""()""";
          } b;
        } Polytope3D;
        // Symbol: drake::multibody::GlobalInverseKinematics::ReconstructGeneralizedPositionSolution
        struct /* ReconstructGeneralizedPositionSolution */ {
          // Source: drake/multibody/inverse_kinematics/global_inverse_kinematics.h:105
          const char* doc =
R"""(After solving the inverse kinematics problem and finding out the pose
of each body, reconstruct the robot generalized position (joint
angles, etc) that matches with the body poses. Notice that since the
rotation matrix is approximated, that the solution of body_rotmat()
might not be on SO(3) exactly, the reconstructed body posture might
not match with the body poses exactly, and the kinematics constraint
might not be satisfied exactly with this reconstructed posture.

Warning:
    Do not call this method if the problem is not solved successfully!
    The returned value can be NaN or meaningless number if the problem
    is not solved.

Returns ``q``:
    The reconstructed posture of the robot of the generalized
    coordinates, corresponding to the RigidBodyTree on which the
    inverse kinematics problem is solved.)""";
        } ReconstructGeneralizedPositionSolution;
        // Symbol: drake::multibody::GlobalInverseKinematics::body_position
        struct /* body_position */ {
          // Source: drake/multibody/inverse_kinematics/global_inverse_kinematics.h:87
          const char* doc =
R"""(Getter for the decision variables on the position p_WBo of the body
B's origin measured and expressed in the world frame.

Parameter ``body_index``:
    The index of the queried body. Notice that body 0 is the world,
    and thus not a decision variable.

Raises:
    RuntimeError if the index is smaller than 1, or greater than or
    equal to the total number of bodies in the robot.)""";
        } body_position;
        // Symbol: drake::multibody::GlobalInverseKinematics::body_rotation_matrix
        struct /* body_rotation_matrix */ {
          // Source: drake/multibody/inverse_kinematics/global_inverse_kinematics.h:77
          const char* doc =
R"""(Getter for the decision variables on the rotation matrix ``R_WB`` for
a body with the specified index. This is the orientation of body i's
frame measured and expressed in the world frame.

Parameter ``body_index``:
    The index of the queried body. Notice that body 0 is the world,
    and thus not a decision variable.

Raises:
    RuntimeError if the index is smaller than 1, or greater than or
    equal to the total number of bodies in the robot.)""";
        } body_rotation_matrix;
        // Symbol: drake::multibody::GlobalInverseKinematics::get_mutable_prog
        struct /* get_mutable_prog */ {
          // Source: drake/multibody/inverse_kinematics/global_inverse_kinematics.h:67
          const char* doc = R"""()""";
        } get_mutable_prog;
        // Symbol: drake::multibody::GlobalInverseKinematics::prog
        struct /* prog */ {
          // Source: drake/multibody/inverse_kinematics/global_inverse_kinematics.h:65
          const char* doc = R"""()""";
        } prog;
      } GlobalInverseKinematics;
      // Symbol: drake::multibody::HydroelasticContactInfo
      struct /* HydroelasticContactInfo */ {
        // Source: drake/multibody/plant/hydroelastic_contact_info.h:37
        const char* doc =
R"""(A class containing information regarding contact and contact response
between two geometries attached to a pair of bodies. This class
provides the output from the Hydroelastic contact model and includes:

- The shared contact surface between the two geometries, which includes
the virtual pressures acting at every point on the contact surface.
- The tractions acting at the quadrature points on the contact surface.
- The slip speeds at the quadrature points on the contact surface.
- The spatial force from the integrated tractions that is applied at the
centroid of the contact surface.

The two geometries, denoted M and N (and obtainable via
``contact_surface().id_M()`` and ``contact_surface().id_N()``) are
attached to bodies A and B, respectively.)""";
        // Symbol: drake::multibody::HydroelasticContactInfo::F_Ac_W
        struct /* F_Ac_W */ {
          // Source: drake/multibody/plant/hydroelastic_contact_info.h:151
          const char* doc =
R"""(Gets the spatial force applied on body A, at the centroid point C of
the surface mesh M, and expressed in the world frame W. The position
``p_WC`` of the centroid point C in the world frame W can be obtained
with ``contact_surface().mesh_W().centroid()``.)""";
        } F_Ac_W;
        // Symbol: drake::multibody::HydroelasticContactInfo::HydroelasticContactInfo<T>
        struct /* ctor */ {
          // Source: drake/multibody/plant/hydroelastic_contact_info.h:71
          const char* doc_was_unable_to_choose_unambiguous_names =
R"""(Constructs this structure using the given contact surface, traction
field, and slip field. This constructor does not own the
ContactSurface; it points to a ContactSurface that another owns, see
contact_surface().

Parameter ``contact_surface``:
    Contact surface between two geometries M and N, see
    geometry::ContactSurface::id_M() and
    geometry::ContactSurface::id_N().

Parameter ``F_Ac_W``:
    Spatial force applied on body A, at contact surface centroid C,
    and expressed in the world frame W. The position ``p_WC`` of C in
    the world frame W can be obtained with
    ``ContactSurface::mesh_W().centroid()``.

Parameter ``quadrature_point_data``:
    Hydroelastic field data at each quadrature point. Data must be
    provided in accordance to the convention that geometry M and N are
    attached to bodies A and B, respectively. Refer to
    HydroelasticQuadraturePointData for further details.)""";
        } ctor;
        // Symbol: drake::multibody::HydroelasticContactInfo::contact_surface
        struct /* contact_surface */ {
          // Source: drake/multibody/plant/hydroelastic_contact_info.h:130
          const char* doc =
R"""(Returns a reference to the ContactSurface data structure. Note that
the mesh and gradient vector fields are expressed in the world frame.)""";
        } contact_surface;
        // Symbol: drake::multibody::HydroelasticContactInfo::quadrature_point_data
        struct /* quadrature_point_data */ {
          // Source: drake/multibody/plant/hydroelastic_contact_info.h:142
          const char* doc =
R"""(Gets the intermediate data, including tractions, computed by the
quadrature process.)""";
        } quadrature_point_data;
      } HydroelasticContactInfo;
      // Symbol: drake::multibody::HydroelasticQuadraturePointData
      struct /* HydroelasticQuadraturePointData */ {
        // Source: drake/multibody/plant/hydroelastic_quadrature_point_data.h:15
        const char* doc =
R"""(Results from intermediate calculations used during the quadrature
routine. These results allow reporting quantities like slip velocity
and traction that are used to compute the spatial forces acting on two
contacting bodies.)""";
        // Symbol: drake::multibody::HydroelasticQuadraturePointData::face_index
        struct /* face_index */ {
          // Source: drake/multibody/plant/hydroelastic_quadrature_point_data.h:21
          const char* doc =
R"""(The triangle on the ContactSurface that contains Q.)""";
        } face_index;
        // Symbol: drake::multibody::HydroelasticQuadraturePointData::p_WQ
        struct /* p_WQ */ {
          // Source: drake/multibody/plant/hydroelastic_quadrature_point_data.h:18
          const char* doc =
R"""(Q, the point at which quantities (traction, slip velocity) are
computed, as an offset vector expressed in the world frame.)""";
        } p_WQ;
        // Symbol: drake::multibody::HydroelasticQuadraturePointData::traction_Aq_W
        struct /* traction_Aq_W */ {
          // Source: drake/multibody/plant/hydroelastic_quadrature_point_data.h:32
          const char* doc =
R"""(The traction vector, expressed in the world frame and with units of
Pa, applied to Body A at Point Q (i.e., Frame A is shifted to Aq).)""";
        } traction_Aq_W;
        // Symbol: drake::multibody::HydroelasticQuadraturePointData::vt_BqAq_W
        struct /* vt_BqAq_W */ {
          // Source: drake/multibody/plant/hydroelastic_quadrature_point_data.h:28
          const char* doc =
R"""(Denoting Point Aq as the point of Body A coincident with Q and Point
Bq as the point of Body B coincident with Q, calculates vr (the
velocity of Bq relative to Aq) and then calculates the component
perpendicular to the unit surface normal n̂ as vt = vr - (vr⋅n̂)n̂.
The resulting vector vt is expressed in the world frame W.)""";
        } vt_BqAq_W;
      } HydroelasticQuadraturePointData;
      // Symbol: drake::multibody::InverseKinematics
      struct /* InverseKinematics */ {
        // Source: drake/multibody/inverse_kinematics/inverse_kinematics.h:19
        const char* doc =
R"""(Solves an inverse kinematics (IK) problem on a MultibodyPlant, to find
the postures of the robot satisfying certain constraints. The decision
variables include the generalized position of the robot.)""";
        // Symbol: drake::multibody::InverseKinematics::AddAngleBetweenVectorsConstraint
        struct /* AddAngleBetweenVectorsConstraint */ {
          // Source: drake/multibody/inverse_kinematics/inverse_kinematics.h:193
          const char* doc =
R"""(Constrains that the angle between a vector na and another vector nb is
between [θ_lower, θ_upper]. na is fixed to a frame A, while nb is
fixed to a frame B. Mathematically, if we denote na_unit_A as na
expressed in frame A after normalization (na_unit_A has unit length),
and nb_unit_B as nb expressed in frame B after normalization, the
constraint is cos(θ_upper) ≤ na_unit_Aᵀ * R_AB * nb_unit_B ≤
cos(θ_lower), where R_AB is the rotation matrix, representing the
orientation of frame B expressed in frame A.

Parameter ``frameA``:
    The frame to which na is fixed.

Parameter ``na_A``:
    The vector na fixed to frame A, expressed in frame A.

Precondition:
    na_A should be a non-zero vector.

Raises:
    ValueError if na_A is close to zero.

Parameter ``frameB``:
    The frame to which nb is fixed.

Parameter ``nb_B``:
    The vector nb fixed to frame B, expressed in frame B.

Precondition:
    nb_B should be a non-zero vector.

Raises:
    ValueError if nb_B is close to zero.

Parameter ``angle_lower``:
    The lower bound on the angle between na and nb. It is denoted as
    θ_lower in the documentation. ``angle_lower`` is in radians.

Precondition:
    angle_lower >= 0.

Raises:
    ValueError if angle_lower is negative.

Parameter ``angle_upper``:
    The upper bound on the angle between na and nb. it is denoted as
    θ_upper in the class documentation. ``angle_upper`` is in radians.

Precondition:
    angle_lower <= angle_upper <= pi.

Raises:
    ValueError if angle_upper is outside the bounds.)""";
        } AddAngleBetweenVectorsConstraint;
        // Symbol: drake::multibody::InverseKinematics::AddDistanceConstraint
        struct /* AddDistanceConstraint */ {
          // Source: drake/multibody/inverse_kinematics/inverse_kinematics.h:235
          const char* doc =
R"""(Adds the constraint that the distance between a pair of geometries is
within some bounds.

Parameter ``geometry_pair``:
    The pair of geometries between which the distance is constrained.
    Notice that we only consider the distance between a static
    geometry and a dynamic geometry, or a pair of dynamic geometries.
    We don't allow constraining the distance between two static
    geometries.

Parameter ``distance_lower``:
    The lower bound on the distance.

Parameter ``distance_upper``:
    The upper bound on the distance.)""";
        } AddDistanceConstraint;
        // Symbol: drake::multibody::InverseKinematics::AddGazeTargetConstraint
        struct /* AddGazeTargetConstraint */ {
          // Source: drake/multibody/inverse_kinematics/inverse_kinematics.h:159
          const char* doc =
R"""(Constrains a target point T to be within a cone K. The point T ("T"
stands for "target") is fixed in a frame B, with position p_BT. The
cone originates from a point S ("S" stands for "source"), fixed in
frame A with position p_AS, with the axis of the cone being n, also
fixed in frame A. The half angle of the cone is θ. A common usage of
this constraint is that a camera should gaze at some target; namely
the target falls within a gaze cone, originating from the camera eye.

Parameter ``frameA``:
    The frame where the gaze cone is fixed to.

Parameter ``p_AS``:
    The position of the cone source point S, measured and expressed in
    frame A.

Parameter ``n_A``:
    The directional vector representing the center ray of the cone,
    expressed in frame A.

Precondition:
    ``n_A`` cannot be a zero vector.

Raises:
    ValueError is n_A is close to a zero vector.

Parameter ``frameB``:
    The frame where the target point T is fixed to.

Parameter ``p_BT``:
    The position of the target point T, measured and expressed in
    frame B.

Parameter ``cone_half_angle``:
    The half angle of the cone. We denote it as θ in the
    documentation. ``cone_half_angle`` is in radians.

Precondition:
    ``0`` <= cone_half_angle <= pi.

Raises:
    ValueError if cone_half_angle is outside of the bound.)""";
        } AddGazeTargetConstraint;
        // Symbol: drake::multibody::InverseKinematics::AddMinimumDistanceConstraint
        struct /* AddMinimumDistanceConstraint */ {
          // Source: drake/multibody/inverse_kinematics/inverse_kinematics.h:222
          const char* doc =
R"""(Adds the constraint that the pairwise distance between objects should
be no smaller than ``minimum_distance``. We consider the distance
between pairs of 1. Anchored (static) object and a dynamic object. 2.
A dynamic object and another dynamic object, if one is not the parent
link of the other.

Parameter ``minimum_distance``:
    The minimum allowed value, dₘᵢₙ, of the signed distance between
    any candidate pair of geometries.

Parameter ``influence_distance_offset``:
    The difference (in meters) between the influence distance,
    d_influence, and the minimum distance, dₘᵢₙ. This value must be
    finite and strictly positive, as it is used to scale the signed
    distances between pairs of geometries. Smaller values may improve
    performance, as fewer pairs of geometries need to be considered in
    each constraint evaluation. $*Default:* 1 meter

See also:
    MinimumDistanceConstraint for more details on the constraint
    formulation.

Precondition:
    The MultibodyPlant passed to the constructor of ``this`` has
    registered its geometry with a SceneGraph.

Precondition:
    0 < ``influence_distance_offset`` < ∞)""";
        } AddMinimumDistanceConstraint;
        // Symbol: drake::multibody::InverseKinematics::AddOrientationConstraint
        struct /* AddOrientationConstraint */ {
          // Source: drake/multibody/inverse_kinematics/inverse_kinematics.h:130
          const char* doc =
R"""(Constrains that the angle difference θ between the orientation of
frame A and the orientation of frame B to satisfy θ ≤ θ_bound. Frame A
is fixed to frame A_bar, with orientation R_AbarA measured in frame
A_bar. Frame B is fixed to frame B_bar, with orientation R_BbarB
measured in frame B_bar. The angle difference between frame A's
orientation R_WA and B's orientation R_WB is θ, (θ ∈ [0, π]), if there
exists a rotation axis a, such that rotating frame A by angle θ about
axis a aligns it with frame B. Namely R_AB = I + sinθ â + (1-cosθ)â²
(1) where R_AB is the orientation of frame B expressed in frame A. â
is the skew symmetric matrix of the rotation axis a. Equation (1) is
the Rodrigues formula that computes the rotation matrix from a
rotation axis a and an angle θ,
https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula If the
users want frame A and frame B to align perfectly, they can set
θ_bound = 0. Mathematically, this constraint is imposed as trace(R_AB)
≥ 2cos(θ_bound) + 1 (1) To derive (1), using Rodrigues formula R_AB =
I + sinθ â + (1-cosθ)â² where trace(R_AB) = 2cos(θ) + 1 ≥
2cos(θ_bound) + 1

Parameter ``frameAbar``:
    frame A_bar, the frame A is fixed to frame A_bar.

Parameter ``R_AbarA``:
    The orientation of frame A measured in frame A_bar.

Parameter ``frameBbar``:
    frame B_bar, the frame B is fixed to frame B_bar.

Parameter ``R_BbarB``:
    The orientation of frame B measured in frame B_bar.

Parameter ``theta_bound``:
    The bound on the angle difference between frame A's orientation
    and frame B's orientation. It is denoted as θ_bound in the
    documentation. ``theta_bound`` is in radians.)""";
        } AddOrientationConstraint;
        // Symbol: drake::multibody::InverseKinematics::AddPointToPointDistanceConstraint
        struct /* AddPointToPointDistanceConstraint */ {
          // Source: drake/multibody/inverse_kinematics/inverse_kinematics.h:250
          const char* doc =
R"""(Add a constraint that the distance between point P1 attached to frame
1 and point P2 attached to frame 2 is within the range
[distance_lower, distance_upper].

Parameter ``frame1``:
    The frame to which P1 is attached.

Parameter ``p_B1P1``:
    The position of P1 measured and expressed in frame 1.

Parameter ``frame2``:
    The frame to which P2 is attached.

Parameter ``p_B2P2``:
    The position of P2 measured and expressed in frame 2.

Parameter ``distance_lower``:
    The lower bound on the distance.

Parameter ``distance_upper``:
    The upper bound on the distance.)""";
        } AddPointToPointDistanceConstraint;
        // Symbol: drake::multibody::InverseKinematics::AddPositionConstraint
        struct /* AddPositionConstraint */ {
          // Source: drake/multibody/inverse_kinematics/inverse_kinematics.h:94
          const char* doc =
R"""(Adds the kinematic constraint that a point Q, fixed in frame B, should
lie within a bounding box expressed in another frame A as p_AQ_lower
<= p_AQ <= p_AQ_upper, where p_AQ is the position of point Q measured
and expressed in frame A.

Parameter ``frameB``:
    The frame in which point Q is fixed.

Parameter ``p_BQ``:
    The position of the point Q, rigidly attached to frame B, measured
    and expressed in frame B.

Parameter ``frameA``:
    The frame in which the bounding box p_AQ_lower <= p_AQ <=
    p_AQ_upper is expressed.

Parameter ``p_AQ_lower``:
    The lower bound on the position of point Q, measured and expressed
    in frame A.

Parameter ``p_AQ_upper``:
    The upper bound on the position of point Q, measured and expressed
    in frame A.)""";
        } AddPositionConstraint;
        // Symbol: drake::multibody::InverseKinematics::InverseKinematics
        struct /* ctor */ {
          // Source: drake/multibody/inverse_kinematics/inverse_kinematics.h:40
          const char* doc_2args =
R"""(Constructs an inverse kinematics problem for a MultibodyPlant. This
constructor will create and own a context for

Parameter ``plant``:
    .

Parameter ``plant``:
    The robot on which the inverse kinematics problem will be solved.

Parameter ``with_joint_limits``:
    If set to true, then the constructor imposes the joint limit
    (obtained from plant.GetPositionLowerLimits() and
    plant.GetPositionUpperLimits(). If set to false, then the
    constructor does not impose the joint limit constraints in the
    constructor.

Note:
    The inverse kinematics problem constructed in this way doesn't
    permit collision related constraint (such as calling
    AddMinimumDistanceConstraint). To enable collision related
    constraint, call InverseKinematics(const MultibodyPlant<double>&
    plant, systems::Context<double>* plant_context);)""";
          // Source: drake/multibody/inverse_kinematics/inverse_kinematics.h:76
          const char* doc_3args =
R"""(Constructs an inverse kinematics problem for a MultibodyPlant. If the
user wants to solve the problem with collision related constraint
(like calling AddMinimumDistanceConstraint), please use this
constructor.

Parameter ``plant``:
    The robot on which the inverse kinematics problem will be solved.
    This plant should have been connected to a SceneGraph within a
    Diagram

Parameter ``context``:
    The context for the plant. This context should be a part of the
    Diagram context. To construct a plant connected to a SceneGraph,
    with the corresponding plant_context, the steps are // 1. Add a
    diagram containing the MultibodyPlant and SceneGraph
    systems::DiagramBuilder<double> builder; auto items =
    AddMultibodyPlantSceneGraph(&builder, 0.0); // 2. Add collision
    geometries to the plant
    Parser(&(items.plant)).AddModelFromFile("model.sdf"); // 3.
    Construct the diagram auto diagram = builder.Build(); // 4. Create
    diagram context. auto diagram_context=
    diagram->CreateDefaultContext(); // 5. Get the context for the
    plant. auto plant_context =
    &(diagram->GetMutableSubsystemContext(items.plant,
    diagram_context.get())); This context will be modified during
    calling ik.prog.Solve(...). When Solve() returns ``result``,
    context will store the optimized posture, namely
    plant.GetPositions(*context) will be the same as in
    result.GetSolution(ik.q()). The user could then use this context
    to perform kinematic computation (like computing the position of
    the end-effector etc.).

Parameter ``with_joint_limits``:
    If set to true, then the constructor imposes the joint limit
    (obtained from plant.GetPositionLowerLimits() and
    plant.GetPositionUpperLimits(). If set to false, then the
    constructor does not impose the joint limit constraints in the
    constructor.)""";
        } ctor;
        // Symbol: drake::multibody::InverseKinematics::context
        struct /* context */ {
          // Source: drake/multibody/inverse_kinematics/inverse_kinematics.h:268
          const char* doc = R"""(Getter for the plant context.)""";
        } context;
        // Symbol: drake::multibody::InverseKinematics::get_mutable_context
        struct /* get_mutable_context */ {
          // Source: drake/multibody/inverse_kinematics/inverse_kinematics.h:271
          const char* doc = R"""(Getter for the mutable plant context.)""";
        } get_mutable_context;
        // Symbol: drake::multibody::InverseKinematics::get_mutable_prog
        struct /* get_mutable_prog */ {
          // Source: drake/multibody/inverse_kinematics/inverse_kinematics.h:265
          const char* doc =
R"""(Getter for the optimization program constructed by InverseKinematics.)""";
        } get_mutable_prog;
        // Symbol: drake::multibody::InverseKinematics::prog
        struct /* prog */ {
          // Source: drake/multibody/inverse_kinematics/inverse_kinematics.h:262
          const char* doc =
R"""(Getter for the optimization program constructed by InverseKinematics.)""";
        } prog;
        // Symbol: drake::multibody::InverseKinematics::q
        struct /* q */ {
          // Source: drake/multibody/inverse_kinematics/inverse_kinematics.h:259
          const char* doc =
R"""(Getter for q. q is the decision variable for the generalized positions
of the robot.)""";
        } q;
      } InverseKinematics;
      // Symbol: drake::multibody::JacobianWrtVariable
      struct /* JacobianWrtVariable */ {
        // Source: drake/multibody/tree/multibody_tree.h:47
        const char* doc =
R"""(Enumeration that indicates whether the Jacobian is partial
differentiation with respect to q̇ (time-derivatives of generalized
positions) or with respect to v (generalized velocities).)""";
        // Symbol: drake::multibody::JacobianWrtVariable::kQDot
        struct /* kQDot */ {
          // Source: drake/multibody/tree/multibody_tree.h:48
          const char* doc = R"""(J = ∂V/∂q̇)""";
        } kQDot;
        // Symbol: drake::multibody::JacobianWrtVariable::kV
        struct /* kV */ {
          // Source: drake/multibody/tree/multibody_tree.h:49
          const char* doc = R"""(J = ∂V/∂v)""";
        } kV;
      } JacobianWrtVariable;
      // Symbol: drake::multibody::Joint
      struct /* Joint */ {
        // Source: drake/multibody/tree/joint.h:70
        const char* doc =
R"""(A Joint models the kinematical relationship which characterizes the
possible relative motion between two bodies. The two bodies connected
by this Joint object are referred to as *parent* and *child* bodies.
The parent/child ordering defines the sign conventions for the
generalized coordinates and the coordinate ordering for multi-DOF
joints. A Joint is a model of a physical kinematic constraint between
two bodies, a constraint that in the real physical system does not
specify a tree ordering. @image html
multibody/plant/images/BodyParentChildJoint.png width=50%

In Drake we define a frame F rigidly attached to the parent body P
with pose ``X_PF`` and a frame M rigidly attached to the child body B
with pose ``X_BM``. A Joint object specifies a kinematic relation
between frames F and M, which in turn imposes a kinematic relation
between bodies P and B.

Typical joints include the ball joint, to allow unrestricted rotations
about a given point, the revolute joint, that constraints two bodies
to rotate about a given common axis, etc.

Consider the following example to build a simple pendulum system:


::

    MultibodyPlant<double> plant(0.0);
    // ... Code here to setup quantities below as mass, com, etc. ...
    const Body<double>& pendulum =
      plant.AddBody<RigidBody>(SpatialInertia<double>(mass, com, unit_inertia));
    // We will connect the pendulum body to the world using a RevoluteJoint.
    // In this simple case the parent body P is the model's world body and frame
    // F IS the world frame.
    // Additionally, we need to specify the pose of frame M on the pendulum's
    // body frame B.
    // Say we declared and initialized X_BM...
    const RevoluteJoint<double>& elbow =
      plant.AddJoint<RevoluteJoint>(
        "Elbow",                /* joint name 
        plant.world_body(),     /* parent body 
        {},                     /* frame F IS the world frame W 
        pendulum,               /* child body, the pendulum 
        X_BM,                   /* pose of frame M in the body frame B 
        Vector3d::UnitZ());     /* revolute axis in this case

Warning:
    Do not ever attempt to instantiate and manipulate Joint objects on
    the stack; it will fail. Add joints to your plant using the
    provided API MultibodyPlant::AddJoint() as in the example above.)""";
        // Symbol: drake::multibody::Joint::AddInDamping
        struct /* AddInDamping */ {
          // Source: drake/multibody/tree/joint.h:271
          const char* doc =
R"""(Adds into ``forces`` the force due to damping within ``this`` joint.

Parameter ``context``:
    The context storing the state and parameters for the model to
    which ``this`` joint belongs.

Parameter ``forces``:
    On return, this method will add the force due to damping within
    ``this`` joint. This method aborts if ``forces`` is ``nullptr`` or
    if ``forces`` does not have the right sizes to accommodate a set
    of forces for the model to which this joint belongs.)""";
        } AddInDamping;
        // Symbol: drake::multibody::Joint::AddInOneForce
        struct /* AddInOneForce */ {
          // Source: drake/multibody/tree/joint.h:249
          const char* doc =
R"""(Adds into ``forces`` a force along the one of the joint's degrees of
freedom indicated by index ``joint_dof``. The meaning for this degree
of freedom and even its dimensional units depend on the specific joint
sub-class. For a RevoluteJoint for instance, ``joint_dof`` can only be
0 since revolute joints's motion subspace only has one degree of
freedom, while the units of ``joint_tau`` are those of torque (N⋅m in
the MKS system of units). For multi-dof joints please refer to the
documentation provided by specific joint sub-classes regarding the
meaning of ``joint_dof``.

Parameter ``context``:
    The context storing the state and parameters for the model to
    which ``this`` joint belongs.

Parameter ``joint_dof``:
    Index specifying one of the degrees of freedom for this joint. The
    index must be in the range ``0 <= joint_dof < num_velocities()``
    or otherwise this method will abort.

Parameter ``joint_tau``:
    Generalized force corresponding to the degree of freedom indicated
    by ``joint_dof`` to be added into ``forces``.

Parameter ``forces``:
    On return, this method will add force ``joint_tau`` for the degree
    of freedom ``joint_dof`` into the output ``forces``. This method
    aborts if ``forces`` is ``nullptr`` or if ``forces`` doest not
    have the right sizes to accommodate a set of forces for the model
    to which this joint belongs.)""";
        } AddInOneForce;
        // Symbol: drake::multibody::Joint::BluePrint
        struct /* BluePrint */ {
          // Source: drake/multibody/tree/joint.h:402
          const char* doc =
R"""((Advanced) Structure containing all the information needed to build
the MultibodyTree implementation for a Joint. At
MultibodyTree::Finalize() a Joint creates a BluePrint of its
implementation with MakeModelBlueprint() so that MultibodyTree can
build an implementation for it.)""";
          // Symbol: drake::multibody::Joint::BluePrint::mobilizers_
          struct /* mobilizers_ */ {
            // Source: drake/multibody/tree/joint.h:403
            const char* doc = R"""()""";
          } mobilizers_;
        } BluePrint;
        // Symbol: drake::multibody::Joint::CloneToScalar
        struct /* CloneToScalar */ {
          // Source: drake/multibody/tree/joint.h:383
          const char* doc = R"""()""";
        } CloneToScalar;
        // Symbol: drake::multibody::Joint::DoAddInDamping
        struct /* DoAddInDamping */ {
          // Source: drake/multibody/tree/joint.h:537
          const char* doc =
R"""(Adds into MultibodyForces the forces due to damping within ``this``
joint. How forces are added to a MultibodyTree model depends on the
underlying implementation of a particular joint (for instance,
mobilizer vs. constraint) and therefore specific Joint subclasses must
provide a definition for this method. The default implementation is a
no-op for joints with no damping.)""";
        } DoAddInDamping;
        // Symbol: drake::multibody::Joint::DoAddInOneForce
        struct /* DoAddInOneForce */ {
          // Source: drake/multibody/tree/joint.h:525
          const char* doc =
R"""(Adds into ``forces`` a force along the one of the joint's degrees of
freedom given by ``joint_dof``. How forces are added to a
MultibodyTree model depends on the underlying implementation of a
particular joint and therefore specific Joint subclasses must provide
a definition for this method. For instance, a revolute joint could be
modeled with a single generalized coordinate for the angular rotation
(implemented through a RevoluteMobilizer) or it could be modeled using
a constraint that only allows rotation about the joint's axis but that
constrains the motion in the other five degrees of freedom. This
method is only called by the public NVI AddInOneForce() and therefore
input arguments were checked to be valid.

See also:
    The public NVI AddInOneForce() for details.)""";
        } DoAddInOneForce;
        // Symbol: drake::multibody::Joint::DoCloneToScalar
        struct /* DoCloneToScalar */ {
          // Source: drake/multibody/tree/joint.h:547
          const char* doc_was_unable_to_choose_unambiguous_names =
R"""(@name Methods to make a clone templated on different scalar types.
Clones this Joint (templated on T) to a joint templated on ``double``.)""";
        } DoCloneToScalar;
        // Symbol: drake::multibody::Joint::DoGetOnePosition
        struct /* DoGetOnePosition */ {
          // Source: drake/multibody/tree/joint.h:497
          const char* doc =
R"""(Implementation to the NVI GetOnePosition() that must only be
implemented by those joint subclasses that have a single degree of
freedom. The default implementation for all other joints is to abort
with an appropriate message. Revolute and prismatic are examples of
joints that will want to implement this method.)""";
        } DoGetOnePosition;
        // Symbol: drake::multibody::Joint::DoGetOneVelocity
        struct /* DoGetOneVelocity */ {
          // Source: drake/multibody/tree/joint.h:508
          const char* doc =
R"""(Implementation to the NVI GetOneVelocity() that must only be
implemented by those joint subclasses that have a single degree of
freedom. The default implementation for all other joints is to abort
with an appropriate message. Revolute and prismatic are examples of
joints that will want to implement this method.)""";
        } DoGetOneVelocity;
        // Symbol: drake::multibody::Joint::DoSetTopology
        struct /* DoSetTopology */ {
          // Source: drake/multibody/tree/joint.h:542
          const char* doc = R"""()""";
        } DoSetTopology;
        // Symbol: drake::multibody::Joint::GetOnePosition
        struct /* GetOnePosition */ {
          // Source: drake/multibody/tree/joint.h:209
          const char* doc =
R"""(Returns the position coordinate for joints with a single degree of
freedom.

Raises:
    RuntimeError if the joint does not have a single degree of
    freedom.)""";
        } GetOnePosition;
        // Symbol: drake::multibody::Joint::GetOneVelocity
        struct /* GetOneVelocity */ {
          // Source: drake/multibody/tree/joint.h:218
          const char* doc =
R"""(Returns the velocity coordinate for joints with a single degree of
freedom.

Raises:
    RuntimeError if the joint does not have a single degree of
    freedom.)""";
        } GetOneVelocity;
        // Symbol: drake::multibody::Joint::Joint<T>
        struct /* ctor */ {
          // Source: drake/multibody/tree/joint.h:111
          const char* doc =
R"""(Creates a joint between two Frame objects which imposes a given
kinematic relation between frame F attached on the parent body P and
frame M attached on the child body B. The joint will be initialized to
the model instance from ``frame_on_child`` (this is the typical
convention for joints between the world and a model, or between two
models (e.g. an arm to a gripper)). See this class's documentation for
further details.

Parameter ``name``:
    A string with a name identifying ``this`` joint.

Parameter ``frame_on_parent``:
    The frame F attached on the parent body connected by this joint.

Parameter ``frame_on_child``:
    The frame M attached on the child body connected by this joint.

Parameter ``pos_lower_limits``:
    A vector storing the lower limit for each generalized position. It
    must have the same size as ``pos_upper_limit``. A value equal to
    -∞ implies no lower limit.

Parameter ``pos_upper_limits``:
    A vector storing the upper limit for each generalized position. It
    must have the same size as ``pos_lower_limit``. A value equal to
    +∞ implies no upper limit.

Parameter ``vel_lower_limits``:
    A vector storing the lower limit for each generalized velocity. It
    must have the same size as ``vel_upper_limit``. A value equal to
    -∞ implies no lower limit.

Parameter ``vel_upper_limits``:
    A vector storing the upper limit for each generalized velocity. It
    must have the same size as ``vel_lower_limit``. A value equal to
    +∞ implies no upper limit.

Parameter ``acc_lower_limits``:
    A vector storing the lower limit for each generalized
    acceleration. It must have the same size as ``acc_upper_limit``. A
    value equal to -∞ implies no lower limit.

Parameter ``acc_upper_limits``:
    A vector storing the upper limit for each generalized
    acceleration. It must have the same size as ``acc_lower_limit``. A
    value equal to +∞ implies no upper limit.)""";
        } ctor;
        // Symbol: drake::multibody::Joint::JointImplementation
        struct /* JointImplementation */ {
          // Source: drake/multibody/tree/joint.h:414
          const char* doc =
R"""((Advanced) A Joint is implemented in terms of MultibodyTree elements
such as bodies, mobilizers, force elements and constraints. This
object contains the internal details of the MultibodyTree
implementation for a joint. The implementation does not own the MBT
elements, it just keeps references to them. This is intentionally made
a protected member so that derived classes have access to its
definition.)""";
          // Symbol: drake::multibody::Joint::JointImplementation::CloneToScalar
          struct /* CloneToScalar */ {
            // Source: drake/multibody/tree/joint.h:439
            const char* doc = R"""()""";
          } CloneToScalar;
          // Symbol: drake::multibody::Joint::JointImplementation::JointImplementation
          struct /* ctor */ {
            // Source: drake/multibody/tree/joint.h:417
            const char* doc_0args =
R"""(Default constructor to create an empty implementation. Used by
Joint::CloneToScalar().)""";
            // Source: drake/multibody/tree/joint.h:421
            const char* doc_1args =
R"""(This constructor creates an implementation for ``this`` joint from the
blueprint provided.)""";
          } ctor;
          // Symbol: drake::multibody::Joint::JointImplementation::mobilizers_
          struct /* mobilizers_ */ {
            // Source: drake/multibody/tree/joint.h:454
            const char* doc =
R"""(References (raw pointers) to the mobilizers that make part of this
implementation.)""";
          } mobilizers_;
          // Symbol: drake::multibody::Joint::JointImplementation::num_mobilizers
          struct /* num_mobilizers */ {
            // Source: drake/multibody/tree/joint.h:429
            const char* doc =
R"""(Returns the number of mobilizers in this implementation.)""";
          } num_mobilizers;
        } JointImplementation;
        // Symbol: drake::multibody::Joint::MakeImplementationBlueprint
        struct /* MakeImplementationBlueprint */ {
          // Source: drake/multibody/tree/joint.h:561
          const char* doc =
R"""(This method must be implemented by derived classes in order to provide
JointImplementationBuilder a BluePrint of their internal
implementation JointImplementation.)""";
        } MakeImplementationBlueprint;
        // Symbol: drake::multibody::Joint::acceleration_lower_limits
        struct /* acceleration_lower_limits */ {
          // Source: drake/multibody/tree/joint.h:305
          const char* doc = R"""(Returns the acceleration lower limits.)""";
        } acceleration_lower_limits;
        // Symbol: drake::multibody::Joint::acceleration_upper_limits
        struct /* acceleration_upper_limits */ {
          // Source: drake/multibody/tree/joint.h:310
          const char* doc = R"""(Returns the acceleration upper limits.)""";
        } acceleration_upper_limits;
        // Symbol: drake::multibody::Joint::child_body
        struct /* child_body */ {
          // Source: drake/multibody/tree/joint.h:161
          const char* doc =
R"""(Returns a const reference to the child body B.)""";
        } child_body;
        // Symbol: drake::multibody::Joint::default_positions
        struct /* default_positions */ {
          // Source: drake/multibody/tree/joint.h:315
          const char* doc = R"""(Returns the default positions.)""";
        } default_positions;
        // Symbol: drake::multibody::Joint::do_get_num_positions
        struct /* do_get_num_positions */ {
          // Source: drake/multibody/tree/joint.h:480
          const char* doc =
R"""(Implementation to the NVI num_positions(), see num_positions() for
details.

Note:
    Implementations must meet the styleguide requirements for
    snake_case accessor methods.)""";
        } do_get_num_positions;
        // Symbol: drake::multibody::Joint::do_get_num_velocities
        struct /* do_get_num_velocities */ {
          // Source: drake/multibody/tree/joint.h:468
          const char* doc =
R"""(Implementation to the NVI num_velocities(), see num_velocities() for
details.

Note:
    Implementations must meet the styleguide requirements for
    snake_case accessor methods.)""";
        } do_get_num_velocities;
        // Symbol: drake::multibody::Joint::do_get_position_start
        struct /* do_get_position_start */ {
          // Source: drake/multibody/tree/joint.h:474
          const char* doc =
R"""(Implementation to the NVI position_start(), see position_start() for
details.

Note:
    Implementations must meet the styleguide requirements for
    snake_case accessor methods.)""";
        } do_get_position_start;
        // Symbol: drake::multibody::Joint::do_get_velocity_start
        struct /* do_get_velocity_start */ {
          // Source: drake/multibody/tree/joint.h:462
          const char* doc =
R"""(Implementation to the NVI velocity_start(), see velocity_start() for
details.

Note:
    Implementations must meet the styleguide requirements for
    snake_case accessor methods.)""";
        } do_get_velocity_start;
        // Symbol: drake::multibody::Joint::do_set_default_positions
        struct /* do_set_default_positions */ {
          // Source: drake/multibody/tree/joint.h:488
          const char* doc =
R"""(Implementation to the NVI set_default_positions(), see
set_default_positions() for details. It is the responsibility of the
subclass to ensure that their joint implementation, should they have
one, is updated with ``default_positions``.

Note:
    Implementations must meet the styleguide requirements for
    snake_case accessor methods.)""";
        } do_set_default_positions;
        // Symbol: drake::multibody::Joint::frame_on_child
        struct /* frame_on_child */ {
          // Source: drake/multibody/tree/joint.h:171
          const char* doc =
R"""(Returns a const reference to the frame M attached on the child body B.)""";
        } frame_on_child;
        // Symbol: drake::multibody::Joint::frame_on_parent
        struct /* frame_on_parent */ {
          // Source: drake/multibody/tree/joint.h:166
          const char* doc =
R"""(Returns a const reference to the frame F attached on the parent body
P.)""";
        } frame_on_parent;
        // Symbol: drake::multibody::Joint::get_implementation
        struct /* get_implementation */ {
          // Source: drake/multibody/tree/joint.h:566
          const char* doc =
R"""(Returns a const reference to the internal implementation of ``this``
joint.

Warning:
    The MultibodyTree model must have already been finalized, or this
    method will abort.)""";
        } get_implementation;
        // Symbol: drake::multibody::Joint::has_implementation
        struct /* has_implementation */ {
          // Source: drake/multibody/tree/joint.h:575
          const char* doc =
R"""(Returns whether ``this`` joint owns a particular implementation. If
the MultibodyTree has been finalized, this will return true.)""";
        } has_implementation;
        // Symbol: drake::multibody::Joint::name
        struct /* name */ {
          // Source: drake/multibody/tree/joint.h:153
          const char* doc = R"""(Returns the name of this joint.)""";
        } name;
        // Symbol: drake::multibody::Joint::num_positions
        struct /* num_positions */ {
          // Source: drake/multibody/tree/joint.h:200
          const char* doc =
R"""(Returns the number of generalized positions describing this joint.)""";
        } num_positions;
        // Symbol: drake::multibody::Joint::num_velocities
        struct /* num_velocities */ {
          // Source: drake/multibody/tree/joint.h:187
          const char* doc =
R"""(Returns the number of generalized velocities describing this joint.)""";
        } num_velocities;
        // Symbol: drake::multibody::Joint::parent_body
        struct /* parent_body */ {
          // Source: drake/multibody/tree/joint.h:156
          const char* doc =
R"""(Returns a const reference to the parent body P.)""";
        } parent_body;
        // Symbol: drake::multibody::Joint::position_lower_limits
        struct /* position_lower_limits */ {
          // Source: drake/multibody/tree/joint.h:285
          const char* doc =
R"""(@name Methods to get and set the limits of ``this`` joint. For
position limits, the layout is the same as the generalized position's.
For velocity and acceleration limits, the layout is the same as the
generalized velocity's. A limit with value +/- ∞ implies no upper or
lower limit. Returns the position lower limits.)""";
        } position_lower_limits;
        // Symbol: drake::multibody::Joint::position_start
        struct /* position_start */ {
          // Source: drake/multibody/tree/joint.h:195
          const char* doc =
R"""(Returns the index to the first generalized position for this joint
within the vector q of generalized positions for the full multibody
system.)""";
        } position_start;
        // Symbol: drake::multibody::Joint::position_upper_limits
        struct /* position_upper_limits */ {
          // Source: drake/multibody/tree/joint.h:290
          const char* doc = R"""(Returns the position upper limits.)""";
        } position_upper_limits;
        // Symbol: drake::multibody::Joint::set_acceleration_limits
        struct /* set_acceleration_limits */ {
          // Source: drake/multibody/tree/joint.h:355
          const char* doc =
R"""(Sets the acceleration limits to ``lower_limits`` and ``upper_limits``.

Raises:
    RuntimeError if the dimension of ``lower_limits`` or
    ``upper_limits`` does not match num_velocities().

Raises:
    RuntimeError if any of ``lower_limits`` is larger than the
    corresponding term in ``upper_limits``.)""";
        } set_acceleration_limits;
        // Symbol: drake::multibody::Joint::set_default_positions
        struct /* set_default_positions */ {
          // Source: drake/multibody/tree/joint.h:370
          const char* doc =
R"""(Sets the default positions to ``default_positions``. Joint subclasses
are expected to implement the do_set_default_positions().

Raises:
    RuntimeError if the dimension of ``default_positions`` does not
    match num_positions().

Note:
    The values in ``default_positions`` are NOT constrained to be
    within ``position_lower_limits()`` and
    ``position_upper_limits()``.)""";
        } set_default_positions;
        // Symbol: drake::multibody::Joint::set_position_limits
        struct /* set_position_limits */ {
          // Source: drake/multibody/tree/joint.h:327
          const char* doc =
R"""(Sets the position limits to ``lower_limits`` and ``upper_limits``.

Raises:
    RuntimeError if the dimension of ``lower_limits`` or
    ``upper_limits`` does not match num_positions().

Raises:
    RuntimeError if any of ``lower_limits`` is larger than the
    corresponding term in ``upper_limits``.

Note:
    Setting the position limits does not affect the
    ``default_positions()``, regardless of whether the current
    ``default_positions()`` satisfy the new position limits.)""";
        } set_position_limits;
        // Symbol: drake::multibody::Joint::set_velocity_limits
        struct /* set_velocity_limits */ {
          // Source: drake/multibody/tree/joint.h:341
          const char* doc =
R"""(Sets the velocity limits to ``lower_limits`` and ``upper_limits``.

Raises:
    RuntimeError if the dimension of ``lower_limits`` or
    ``upper_limits`` does not match num_velocities().

Raises:
    RuntimeError if any of ``lower_limits`` is larger than the
    corresponding term in ``upper_limits``.)""";
        } set_velocity_limits;
        // Symbol: drake::multibody::Joint::type_name
        struct /* type_name */ {
          // Source: drake/multibody/tree/joint.h:177
          const char* doc =
R"""(Returns a string identifying the type of ``this`` joint, such as
"revolute" or "prismatic".)""";
        } type_name;
        // Symbol: drake::multibody::Joint::velocity_lower_limits
        struct /* velocity_lower_limits */ {
          // Source: drake/multibody/tree/joint.h:295
          const char* doc = R"""(Returns the velocity lower limits.)""";
        } velocity_lower_limits;
        // Symbol: drake::multibody::Joint::velocity_start
        struct /* velocity_start */ {
          // Source: drake/multibody/tree/joint.h:182
          const char* doc =
R"""(Returns the index to the first generalized velocity for this joint
within the vector v of generalized velocities for the full multibody
system.)""";
        } velocity_start;
        // Symbol: drake::multibody::Joint::velocity_upper_limits
        struct /* velocity_upper_limits */ {
          // Source: drake/multibody/tree/joint.h:300
          const char* doc = R"""(Returns the velocity upper limits.)""";
        } velocity_upper_limits;
      } Joint;
      // Symbol: drake::multibody::JointActuator
      struct /* JointActuator */ {
        // Source: drake/multibody/tree/joint_actuator.h:30
        const char* doc =
R"""(The JointActuator class is mostly a simple bookkeeping structure to
represent an actuator acting on a given Joint. It helps to flag
whether a given Joint is actuated or not so that MultibodyTree clients
can apply forces on actuated joints through their actuators, see
AddInOneForce().)""";
        // Symbol: drake::multibody::JointActuator::AddInOneForce
        struct /* AddInOneForce */ {
          // Source: drake/multibody/tree/joint_actuator.h:86
          const char* doc =
R"""(Adds into ``forces`` a force along one of the degrees of freedom of
the Joint actuated by ``this`` actuator. The meaning for this degree
of freedom, sign conventions and even its dimensional units depend on
the specific joint sub-class being actuated. For a RevoluteJoint for
instance, ``joint_dof`` can only be 0 since revolute joints's motion
subspace only has one degree of freedom, while the units of ``tau``
are those of torque (N⋅m in the MKS system of units). For multi-dof
joints please refer to the documentation provided by specific joint
sub-classes regarding the meaning of ``joint_dof``.

Parameter ``context``:
    The context storing the state and parameters for the model to
    which ``this`` joint belongs.

Parameter ``joint_dof``:
    Index specifying one of the degrees of freedom for this joint. The
    index must be in the range ``0 <= joint_dof < num_velocities()``
    or otherwise this method will throw an exception.

Parameter ``joint_tau``:
    Generalized force corresponding to the degree of freedom indicated
    by ``joint_dof`` to be added into ``forces``. Refere to the
    specific Joint sub-class documentation for details on the meaning
    and units for this degree of freedom.

Parameter ``forces``:
    On return, this method will add force ``tau`` for the degree of
    freedom ``joint_dof`` into the output ``forces``. This method
    aborts if ``forces`` is ``nullptr`` or if ``forces`` doest not
    have the right sizes to accommodate a set of forces for the model
    to which this actuator belongs.)""";
        } AddInOneForce;
        // Symbol: drake::multibody::JointActuator::CloneToScalar
        struct /* CloneToScalar */ {
          // Source: drake/multibody/tree/joint_actuator.h:243
          const char* doc = R"""()""";
        } CloneToScalar;
        // Symbol: drake::multibody::JointActuator::JointActuator<T>
        struct /* ctor */ {
          // Source: drake/multibody/tree/joint_actuator.h:49
          const char* doc =
R"""(Creates an actuator for ``joint`` with the given ``name``. The name
must be unique within the given multibody model. This is enforced by
MultibodyPlant::AddJointActuator().

Parameter ``name``:
    A string with a name identifying ``this`` actuator.

Parameter ``joint``:
    The ``joint`` that the created actuator will act on.

Parameter ``effort_limit``:
    The maximum effort for the actuator. It must be strictly positive,
    otherwise an RuntimeError is thrown. If +∞, the actuator has no
    limit, which is the default. The effort limit has physical units
    in accordance to the joint type it actuates. For instance, it will
    have units of N⋅m (torque) for revolute joints while it will have
    units of N (force) for prismatic joints.)""";
        } ctor;
        // Symbol: drake::multibody::JointActuator::SetGearRatio
        struct /* SetGearRatio */ {
          // Source: drake/multibody/tree/joint_actuator.h:223
          const char* doc =
R"""(Sets the associated gear ratio value for this actuator in ``context``.
See reflected_inertia.)""";
        } SetGearRatio;
        // Symbol: drake::multibody::JointActuator::SetRotorInertia
        struct /* SetRotorInertia */ {
          // Source: drake/multibody/tree/joint_actuator.h:216
          const char* doc =
R"""(Sets the associated rotor inertia value for this actuator in
``context``. See reflected_inertia.)""";
        } SetRotorInertia;
        // Symbol: drake::multibody::JointActuator::calc_reflected_inertia
        struct /* calc_reflected_inertia */ {
          // Source: drake/multibody/tree/joint_actuator.h:230
          const char* doc =
R"""(Calculates the reflected inertia value for this actuator in
``context``. See reflected_inertia.)""";
        } calc_reflected_inertia;
        // Symbol: drake::multibody::JointActuator::default_gear_ratio
        struct /* default_gear_ratio */ {
          // Source: drake/multibody/tree/joint_actuator.h:178
          const char* doc =
R"""(Gets the default value for this actuator's gear ratio. See
reflected_inertia.)""";
        } default_gear_ratio;
        // Symbol: drake::multibody::JointActuator::default_reflected_inertia
        struct /* default_reflected_inertia */ {
          // Source: drake/multibody/tree/joint_actuator.h:196
          const char* doc =
R"""(Returns the default value for this actuator's reflected inertia. It is
calculated as ρ²⋅Iᵣ, where ρ is the default gear ratio and Iᵣ is the
default rotor inertia for this actuator. See reflected_inertia.)""";
        } default_reflected_inertia;
        // Symbol: drake::multibody::JointActuator::default_rotor_inertia
        struct /* default_rotor_inertia */ {
          // Source: drake/multibody/tree/joint_actuator.h:174
          const char* doc =
R"""(Gets the default value for this actuator's rotor inertia. See
reflected_inertia.)""";
        } default_rotor_inertia;
        // Symbol: drake::multibody::JointActuator::effort_limit
        struct /* effort_limit */ {
          // Source: drake/multibody/tree/joint_actuator.h:123
          const char* doc = R"""(Returns the actuator effort limit.)""";
        } effort_limit;
        // Symbol: drake::multibody::JointActuator::gear_ratio
        struct /* gear_ratio */ {
          // Source: drake/multibody/tree/joint_actuator.h:210
          const char* doc =
R"""(Returns the associated gear ratio value for this actuator, stored in
``context``. See reflected_inertia.)""";
        } gear_ratio;
        // Symbol: drake::multibody::JointActuator::get_actuation_vector
        struct /* get_actuation_vector */ {
          // Source: drake/multibody/tree/joint_actuator.h:96
          const char* doc =
R"""(Gets the actuation values for ``this`` actuator from the actuation
vector u for the entire model.

Returns:
    a reference to a nv-dimensional vector, where nv is the number of
    velocity variables of joint().)""";
        } get_actuation_vector;
        // Symbol: drake::multibody::JointActuator::joint
        struct /* joint */ {
          // Source: drake/multibody/tree/joint_actuator.h:56
          const char* doc =
R"""(Returns a reference to the joint actuated by this JointActuator.)""";
        } joint;
        // Symbol: drake::multibody::JointActuator::name
        struct /* name */ {
          // Source: drake/multibody/tree/joint_actuator.h:53
          const char* doc = R"""(Returns the name of the actuator.)""";
        } name;
        // Symbol: drake::multibody::JointActuator::rotor_inertia
        struct /* rotor_inertia */ {
          // Source: drake/multibody/tree/joint_actuator.h:203
          const char* doc =
R"""(Returns the associated rotor inertia value for this actuator, stored
in ``context``. See reflected_inertia.)""";
        } rotor_inertia;
        // Symbol: drake::multibody::JointActuator::set_actuation_vector
        struct /* set_actuation_vector */ {
          // Source: drake/multibody/tree/joint_actuator.h:118
          const char* doc =
R"""(Given the actuation values u_instance for ``this`` actuator, this
method sets the actuation vector u for the entire MultibodyTree model
to which this actuator belongs to.

Parameter ``u_instance``:
    Actuation values for ``this`` actuator. It must be of size equal
    to the number of degrees of freedom of the actuated Joint, see
    Joint::num_velocities(). For units and sign conventions refer to
    the specific Joint sub-class documentation.

Parameter ``u``:
    The vector containing the actuation values for the entire
    MultibodyTree model to which ``this`` actuator belongs to.

Raises:
    RuntimeError if ``u_instance.size() !=
    this->joint().num_velocities()``.

Raises:
    RuntimeError if u is nullptr.

Raises:
    RuntimeError if ``u.size() !=
    this->get_parent_tree().num_actuated_dofs()``.)""";
        } set_actuation_vector;
        // Symbol: drake::multibody::JointActuator::set_default_gear_ratio
        struct /* set_default_gear_ratio */ {
          // Source: drake/multibody/tree/joint_actuator.h:188
          const char* doc =
R"""(Sets the default value for this actuator's gear ratio. See
reflected_inertia.)""";
        } set_default_gear_ratio;
        // Symbol: drake::multibody::JointActuator::set_default_rotor_inertia
        struct /* set_default_rotor_inertia */ {
          // Source: drake/multibody/tree/joint_actuator.h:182
          const char* doc =
R"""(Sets the default value for this actuator's rotor inertia. See
reflected_inertia.)""";
        } set_default_rotor_inertia;
      } JointActuator;
      // Symbol: drake::multibody::JointActuatorIndex
      struct /* JointActuatorIndex */ {
        // Source: drake/multibody/tree/multibody_tree_indexes.h:35
        const char* doc =
R"""(Type used to identify actuators by index within a multibody tree
system.)""";
      } JointActuatorIndex;
      // Symbol: drake::multibody::JointIndex
      struct /* JointIndex */ {
        // Source: drake/multibody/tree/multibody_tree_indexes.h:32
        const char* doc =
R"""(Type used to identify joints by index within a multibody tree system.)""";
      } JointIndex;
      // Symbol: drake::multibody::LinearBushingRollPitchYaw
      struct /* LinearBushingRollPitchYaw */ {
        // Source: drake/multibody/tree/linear_bushing_roll_pitch_yaw.h:319
        const char* doc =
R"""(This ForceElement models a massless flexible bushing that connects a
frame A of a link (body) L0 to a frame C of a link (body) L1. The
bushing can apply a torque and force due to stiffness (spring) and
dissipation (damper) properties. Frame B is the bushing frame whose
origin Bo is halfway between Ao (A's origin) and Co (C's origin) and
whose unit vectors 𝐁𝐱, 𝐁𝐲, 𝐁𝐳 are "halfway" (in an angle-axis sense)
between the unit vectors of frame A and frame C. Frame B is a
"floating" frame in the sense that it is calculated from the position
and orientation of frames A and C (B is not welded to the bushing).
@image html multibody/tree/images/LinearBushingRollPitchYaw.png
width=80%

The set of forces on frame C from the bushing is equivalent to a
torque 𝐭 on frame C and a force 𝐟 applied to a point Cp of C. The set
of forces on frame A from the bushing is equivalent to a torque −𝐭 on
frame A and a force −𝐟 applied to a point Ap of A. Points Ap and Cp
are coincident with Bo (frame B's origin).

This "quasi-symmetric" bushing force/torque model was developed at
Toyota Research Institute and has advantages compared to traditional
bushing models because it employs a bushing-centered "symmetric" frame
B and it ensures the moment of −𝐟 on A about Ao is equal to the moment
of 𝐟 on C about Co. Traditional models differ as they lack a
"symmetric" frame B and apply −𝐟 at Ao, which means the moment of −𝐟
on A about Ao is always zero. Note: This bushing model is not fully
symmetric since the orientation between frames A and C is
parameterized with roll-pitch-yaw angles [q₀ q₁ q₂]. Since these
angles have an inherent sequence, they are not mathematically
symmetric.

The torque model depends on spring-damper "gimbal" torques ``τ ≜ [τ₀
τ₁ τ₂]`` which themselves depend on roll-pitch-yaw angles ``q ≜ [q₀ q₁
q₂]`` and rates ``q̇ = [q̇₀ q̇₁ q̇₂]`` via a diagonal torque-stiffness
matrix K₀₁₂ and a diagonal torque-damping matrix D₀₁₂ as


::

    ⌈ τ₀ ⌉     ⌈k₀    0    0⌉ ⌈ q₀ ⌉     ⌈d₀    0    0⌉ ⌈ q̇₀ ⌉
    τ ≜ | τ₁ | = − | 0   k₁    0| | q₁ |  −  | 0   d₁    0| | q̇₁ |
        ⌊ τ₂ ⌋     ⌊ 0    0   k₂⌋ ⌊ q₂ ⌋     ⌊ 0    0   d₂⌋ ⌊ q̇₂ ⌋

where k₀, k₁, k₂ and d₀, d₁, d₂ are torque stiffness and damping
constants and must have non-negative values.

Note:
    τ does not represent a vector expressed in one frame. Instead it
    is regarded as a 3x1 array of torque scalars associated with
    roll-pitch yaw.

Note:
    As discussed in the Advanced section below, τ is not 𝐭 ``(τ ≠
    𝐭)``.

Note:
    This is a "linear" bushing model as gimbal torque τ varies
    linearly with q and q̇ as τ = τᴋ + τᴅ where τᴋ = −K₀₁₂ ⋅ q and τᴅ
    = −D₀₁₂ ⋅ q̇.

The bushing model for the net force 𝐟 on frame C from the bushing
depends on scalars x, y, z which are defined so 𝐫 (the position vector
from Ao to Co) can be expressed in frame B as ``𝐫 ≜ p_AoCo = [x y z]ʙ
= x 𝐁𝐱 + y 𝐁𝐲 + z 𝐁𝐳``. The model for 𝐟 uses a diagonal
force-stiffness matrix Kxyᴢ, a diagonal force-damping matrix Dxyᴢ, and
defines fx, fy, fz so ``𝐟 = [fx fy fz]ʙ``.


::

    ⌈ fx ⌉      ⌈kx    0    0⌉ ⌈ x ⌉     ⌈dx    0    0⌉ ⌈ ẋ ⌉
    | fy | =  − | 0   ky    0| | y |  −  | 0   dy    0| | ẏ |
    ⌊ fz ⌋      ⌊ 0    0   kz⌋ ⌊ z ⌋     ⌊ 0    0   dz⌋ ⌊ ż ⌋

where kx, ky, kz and dx, dy, dz are force stiffness and damping
constants and must have non-negative values.

Note:
    This is a "linear" bushing model as the force 𝐟 varies linearly
    with 𝐫 and 𝐫̇̇ as 𝐟 = 𝐟ᴋ + 𝐟ᴅ where 𝐟ᴋ = −Kxyz ⋅ 𝐫 and 𝐟ᴅ = −Dxyz
    ⋅ 𝐫̇̇.

This bushing's constructor sets the torque stiffness/damping constants
``[k₀ k₁ k₂]`` and ``[d₀ d₁ d₂]`` and the force stiffness/damping
constants ``[kx ky kz]`` and ``[dx dy dz]``. The examples below
demonstrate how to model various joints that have a flexible (e.g.,
rubber) mount. The damping values below with ? may be set to 0 or a
reasonable positive number.

Bushing type | torque constants | force constants
--------------------------------|:--------------------|:------------------
z-axis revolute joint | k₀₁₂ = ``[k₀ k₁ 0]`` | kxyz = ``[kx ky kz]`` ^
| d₀₁₂ = ``[d₀ d₁ ?]`` | dxyz = ``[dx dy dz]`` x-axis prismatic joint
| k₀₁₂ = ``[k₀ k₁ k₂]`` | kxyz = ``[0 ky kz]`` ^ | d₀₁₂ = ``[d₀ d₁
d₂]`` | dxyz = ``[? dy dz]`` Ball and socket joint | k₀₁₂ = ``[0 0
0]`` | kxyz = ``[kx ky kz]`` ^ | d₀₁₂ = ``[? ? ?]`` | dxyz = ``[dx dy
dz]`` Weld/fixed joint | k₀₁₂ = ``[k₀ k₁ k₂]`` | kxyz = ``[kx ky kz]``
^ | d₀₁₂ = ``[d₀ d₁ d₂]`` | dxyz = ``[dx dy dz]``

Angles q₀, q₁, q₂ are calculated from frame C's orientation relative
to frame A, with ``[−π < q₀ ≤ π, −π/2 ≤ q₁ ≤ π/2, −π < q₂ ≤ π]``,
hence, there is no angle wrapping and torque stiffness has a limited
range. Gimbal torques τ can be discontinuous if one of q₀, q₁, q₂ is
discontinuous and its associated torque spring constant is nonzero.
For example, τ₂ is discontinuous if ``k₂ ≠ 0`` and the bushing has a
large rotation so q₂ jumps from ``≈ −π to π``. τ can also be
discontinuous if one of q̇₀, q̇₁, q̇₂ is discontinuous and its
associated torque damper constant is nonzero. For example, τ₀ is
discontinuous if ``d₀ ≠ 0`` and q̇₀ is undefined (which occurs when
``pitch = q₁ = π/2``). Note: Due to the relationship of 𝐭 to τ shown
below, 𝐭 is discontinuous if τ is discontinuous.

As shown below, there are multiple ways to estimate torque and force
stiffness and damping constants. Use a method or combination of
methods appropriate for your application. For example, some methods
are more useful for a real physical bushing whereas other methods
(called "penalty methods") can be more useful when replacing an ideal
joint (such as a revolute or fixed/weld joint) with a bushing.

Consider a penalty method if you want a bushing to substitute for a
"hard" constraint (e.g., an ideal joint). Since a bushing is
inherently compliant it will violate a hard constraint somewhat. The
stiffer the bushing, the more accurately it enforces the hard
constraint, but at a cost of more computational time. To balance
accuracy versus time, consider your tolerance for constraint errors.
For example, is it OK for your bushing to displace xₘₐₓ = 1 mm for an
estimated Fxₘₐₓ = 100 N? Also, one way to choose a force damping
constant dx is by choosing a "reasonably small" settling time tₛ,
where settling time tₛ is the interval of time for a system to settle
to within 1% (0.01) of an equilibrium solution). Is tₛ = 0.01 s
negligible for a robot arm with a 10 s reach maneuver?

**** How to choose a torque stiffness constant k₀ or damping constant
d₀. The estimate of stiffness k₀ depends on whether you are modeling a
physical bushing (consider stiffness methods 1 or 2 below) or whether
you are using a bushing to replace an ideal joint such as a revolute
or fixed/weld joint (consider stiffness "penalty methods" 3 or 4
below). 1. Use a static experiment, e.g., apply a known moment load
Mx, measure the associated angular displacement Δq (radians), and
estimate k₀ = Mx / Δq. 2. Use FEA (finite element analysis) software
to estimate k₀. 3. Pick a desired maximum angular displacement qₘₐₓ,
estimate a maximum moment load Mxₘₐₓ, and estimate ``k₀ = Mxₘₐₓ /
qₘₐₓ`` (units of N*m/rad). 4. Choose a characteristic moment of
inertia I₀ (directionally dependent), choose a desired angular
frequency ωₙ > 0 (in rad/s) and estimate ``k₀ = I₀ ωₙ²`` (units of
N*m/rad).

The estimate of damping d₀ depends on whether you are modeling a
physical bushing (consider damping method 1 below) or whether you are
using a bushing to enforce a constraint (consider damping methods 2 or
3 below). 1. Use experiments to estimate a damping ratio ζ and
settling time tₛ. Compute "undamped natural frequency" ωₙ from ζ and
tₛ (as shown below in the Advanced section), then ``d₀ = 2 ζ k₀ / ωₙ``
(units of N*m*s/rad). 2. Choose a damping ratio ζ (e.g., ζ = 1,
critical damping) and a desired settling time tₛ, calculate ωₙ (as
shown below in the Advanced section), then ``d₀ = 2 ζ k₀ / ωₙ`` (units
of N*m*s/rad). 3. Choose a damping ratio ζ (e.g., ζ = 1, critical
damping), estimate a characteristic moment of inertia and calculate
``d₀ = 2 ζ √(I₀ k₀)``.

Refer to Advanced_bushing_stiffness_and_damping "Advanced bushing
stiffness and damping" for more details.

**** How to choose a force stiffness constant kx or damping constant
dx. The estimate of stiffness kx depends on whether you are modeling a
real bushing (consider stiffness methods 1 or 2 below) or whether you
are using a bushing to replace an ideal joint such as a revolute or
fixed/weld joint (consider stiffness "penalty methods" 3 or 4 below).
1. Use a static experiment, e.g., apply a known force load Fx, measure
the associated displacement (stretch) Δx (in meters), and estimate kx
= Fx / Δx. 2. Use FEA (finite element analysis) software to estimate
kx (units of N/m). 3. Pick a desired maximum displacement xₘₐₓ,
estimate a maximum force load Fxₘₐₓ, and estimate ``kx = Fxₘₐₓ /
xₘₐₓ`` (units of N/m). 4. Choose a characteristic mass m (which may be
directionally dependent), choose a desired angular frequency ωₙ > 0
(in rad/s) and estimate ``kx = m ωₙ²`` (units of N/m).

The estimate of damping dx depends on whether you are modeling a
physical bushing (consider damping method 1 below) or whether you are
using a bushing to enforce a constraint (consider damping methods 2 or
3 below). 1. Use experiments to estimate a damping ratio ζ and
settling time tₛ. Compute "undamped natural frequency" ωₙ from ζ and
tₛ (as shown below in the Advanced section), then ``dx = 2 ζ kx / ωₙ``
(units of N*s/m). 2. Choose a damping ratio ζ (e.g., ζ = 1, critical
damping) and a desired settling time tₛ, calculate ωₙ (as shown below
in the Advanced section), then ``dx = 2 ζ kx / ωₙ`` (units of N*s/m).
3. Choose a damping ratio ζ (e.g., ζ = 1, critical damping), estimate
a characteristic mass m and calculate ``dx = 2 ζ √(m kx)`` (units of
N*s/m).

Refer to Advanced_bushing_stiffness_and_damping "Advanced bushing
stiffness and damping" for more details.

**** Advanced: Relationship of 𝐭 to τ. To understand how "gimbal
torques" τ relate to 𝐭, it helps to remember that the RollPitchYaw
class documentation states that a Space-fixed (extrinsic) X-Y-Z
rotation with roll-pitch-yaw angles [q₀ q₁ q₂] is equivalent to a
Body-fixed (intrinsic) Z-Y-X rotation by yaw-pitch-roll angles [q₂ q₁
q₀]. In the context of "gimbal torques", the Body-fixed Z-Y-X rotation
sequence with angles [q₂ q₁ q₀] is physical meaningful as it produces
torques associated with successive frames in a gimbal as τ₂ 𝐀𝐳, τ₁ 𝐏𝐲,
τ₀ 𝐂𝐱, where each of 𝐀𝐳, 𝐏𝐲, 𝐂𝐱 are unit vectors associated with a
frame in the yaw-pitch-roll rotation sequence and 𝐏𝐲 is a unit vector
of the "pitch" intermediate frame. As described earlier, torque 𝐭 is
the moment of the bushing forces on frame C about Cp. Scalars tx, ty,
tz are defined so 𝐭 can be expressed ``𝐭 = [tx ty tz]ᴀ = tx 𝐀𝐱 + ty 𝐀𝐲
+ tz 𝐀𝐳``. As shown in code documentation, the relationship of [tx ty
tz] to [τ₀ τ₁ τ₂] was found by equating 𝐭's power to τ's power as 𝐭 ⋅
w_AC = τ ⋅ q̇.


::

    ⌈ tx ⌉      ⌈ τ₀ ⌉            ⌈ cos(q₂)/cos(q₁)  sin(q₂)/cos(q₁)   0 ⌉
    | ty | = Nᵀ | τ₁ |  where N = |   −sin(q2)            cos(q2)      0 |
    ⌊ tz ⌋      ⌊ τ₂ ⌋            ⌊ cos(q₂)*tan(q₁)   sin(q₂)*tan(q₁)  1 ⌋

**** Advanced: More on how to choose bushing stiffness and damping
constants. The basics on how to choose bushing stiffness and damping
constants are at: - Basic_bushing_torque_stiffness_and_damping "How to
choose torque stiffness and damping constants" -
Basic_bushing_force_stiffness_and_damping "How to choose force
stiffness and damping constants"

The list below provides more detail on: The performance tradeoff
between high stiffness and long simulation time; loads that affect
estimates of Mxₘₐₓ or Fxₘₐₓ; and how a linear 2ⁿᵈ-order ODE provides
insight on how to experimentally determine stiffness and damping
constants. - Stiffness [k₀ k₁ k₂] and [kx ky kz] affect simulation
time and accuracy. Generally, a stiffer bushing better resembles an
ideal joint (e.g., a revolute joint or fixed/weld joint). However
(depending on integrator), a stiffer bushing usually increases
numerical integration time. - An estimate for a maximum load Mxₘₐₓ or
Fxₘₐₓ accounts for gravity forces, applied forces, inertia forces
(centripetal, Coriolis, gyroscopic), etc. - One way to determine
physical stiffness and damping constants is through the mathematical
intermediaries ωₙ (units of rad/s) and ζ (no units). The constant ωₙ
(called "undamped natural frequency" or "angular frequency") and
constant ζ (called "damping ratio") relate to the physical constants
mass m, damping constant dx, and stiffness constant kx via the
following prototypical linear constant-coefficient 2ⁿᵈ-order ODEs.


::

    m ẍ +     dx ẋ +  kx x = 0   or alternatively as
       ẍ + 2 ζ ωₙ ẋ + ωₙ² x = 0   where ωₙ² = kx/m,  ζ = dx / (2 √(m kx))

ωₙ and ζ also appear in the related ODEs for rotational systems,
namely


::

    I₀ q̈ +     d₀ q̇ +  k₀ q = 0   or alternatively as
        q̈ + 2 ζ ωₙ q̇ + ωₙ² q = 0   where ωₙ² = k₀/I₀,  ζ = d₀ / (2 √(I₀ k₀))

One way to determine ωₙ is from settling time tₛ which approximates
the time for a system to settle to within a specified settling ratio
of an equilibrium solutions. Typical values for settling ratio are 1%
(0.01), 2% (0.02), 5% (0.05), and 10% (0.10). - When ζ < 0.7
(underdamped), a commonly used approximation is ωₙ ≈
-ln(settling_ratio) / (ζ tₛ) which for settling ratios 0.01 and 0.05
give ωₙ ≈ 4.6 / (ζ tₛ) and ωₙ ≈ 3 / (ζ tₛ). Another commonly used
approximation is ωₙ ≈ -ln(settling_ratio √(1- ζ²)) / (ζ tₛ). See
https://en.wikipedia.org/wiki/Settling_time or the book Modern Control
Engineering by Katsuhiko Ogata. Although these approximate formulas
for ωₙ are common, they are somewhat inaccurate. Settling time for
underdamped systems is discontinuous and requires solving a nonlinear
algebraic equation (an iterative process). For more information, see
http://www.scielo.org.co/pdf/rfiua/n66/n66a09.pdf [Ramos-Paja, et. al
2012], "Accurate calculation of settling time in second order systems:
a photovoltaic application". Another reference is
https://courses.grainger.illinois.edu/ece486/sp2020/laboratory/docs/lab2/estimates.html
- When ζ ≈ 1 (critically damped), ωₙ is determined by choosing a
settling ratio and then solving for (ωₙ tₛ) via the nonlinear
algebraic equation (1 + ωₙ tₛ)*exp(-ωₙ tₛ) = settling_ratio. Settling
ratio | ωₙ -------------- | ------------- 0.01 | 6.64 / tₛ 0.02 | 5.83
/ tₛ 0.05 | 4.74 / tₛ 0.10 | 3.89 / tₛ See
https://electronics.stackexchange.com/questions/296567/over-and-critically-damped-systems-settling-time
- When ζ ≥ 1.01 (overdamped), ωₙ ≈ -ln(2 settling_ratio sz/s₂) / (s₁
tₛ) where sz = √(ζ² - 1), s₁ = ζ - sz, s₂ = ζ + sz. The derivation and
approximation error estimates for this overdamped settling time
formula is ApproximateOverdampedSettlingTime "below".

- For a real physical bushing, an experiment is one way to estimate damping
constants.  For example, to estimate a torque damping constant d₀ associated
with underdamped vibrations (damping ratio 0 < ζ < 1), attach the bushing to
a massive rod, initially displace the rod by angle Δq, release the rod and
measure q(t).  From the q(t) measurement, estimate decay ratio (the ratio of
successive peak heights above the final steady-state value) calculate
logarithmic decrement δ = -ln(decay_ratio), calculate damping ratio
ζ = √(δ² / (4π² + δ²)), then calculate d₀ using d₀ = 2 ζ √(I₀ k₀) or
d₀ = 2 ζ k₀ / ωₙ. For more information, see
https://en.wikipedia.org/wiki/Damping_ratio#Logarithmic_decrement

**** Derivation: Approximate formula for overdamped settling time.
Since a literature reference for this formula was not found, the
derivation below was done at TRI (it has not been peer reviewed). This
formula results from the "dominant pole" solution in the prototypical
constant-coefficient linear 2ⁿᵈ-order ODE. For ẋ(0) = 0, mathematics
shows poles p₁ = -ωₙ s₁, p₂ = -ωₙ s₂, where sz = √(ζ² - 1), s₁ = ζ -
sz, s₂ = ζ + sz. and


::

    x(t) / x(0) = p₂/(p₂-p₁) exp(p₁ t) - p₁/(p₂-p₁) exp(p₂ t)
                 = s₂/(s₂-s₁) exp(p₁ t) - s₁/(s₂-s₁) exp(p₂ t)
                 =  k/( k-1 ) exp(p₁ t) -  1/( k-1 ) exp(p₂ t) where k = s₂ / s₁
                 ≈  k/( k-1 ) exp(p₁ t)                        since p₁ > p₂

Note: k = s₂ / s₁ is real, k > 0, s₂ = k s₁, and p₁ > p₂ (p₁ is less
negative then p₂), so exp(p₁ t) decays to zero slower than exp(p₂ t)
and exp(p₁ t) ≫ exp(p₂ t) for sufficiently large t. Hence we assume
exp(p₂ t) ≈ 0 (which is why p₁ is called the "dominant pole"). Next,


::

    k/(k - 1) = s₂ / s₁ / (s₂/s₁ -1) = s₂ / (s₂ - s₁) = s₂ / (2 sz),  so
      x(t) / x(0)  ≈  s₂ / (2 sz) exp(-s₁ ωₙ t),                        hence
      settling_ratio ≈ s₂ / (2 sz) exp(-s₁ ωₙ tₛ),                      finally
      ωₙ ≈ -ln(settling_ratio 2 sz / s₂) / (s₁ tₛ)

The table below shows that there is little error in this approximate
formula for various settling ratios and ζ, particularly for ζ ≥ 1.1.
For 1.0 ≤ ζ < 1.1, the critical damping estimates of ωₙ work well.
Settling ratio | ζ = 1.01 | ζ = 1.1 | ζ = 1.2 | ζ = 1.3 | ζ = 1.5
-------------- | -------- | ------- | ------- | ------- | --------
0.01 | 1.98% | 0.005% | 2.9E-5% | 1.6E-7% | 2.4E-12% 0.02 | 2.91% |
0.016% | 1.8E-4% | 2.1E-6% | 1.6E-10% 0.05 | 5.10% | 0.076% | 2.3E-3%
| 7.0E-5% | 4.4E-8% 0.10 | 8.28% | 0.258% | 1.6E-2% | 1.0E-3% |
3.3E-6% Note: There is a related derivation in the reference below,
however, it needlessly makes the oversimplified approximation k/(k -
1) ≈ 1.
https://electronics.stackexchange.com/questions/296567/over-and-critically-damped-systems-settling-time

Note:
    The complete theory for this bushing is documented in the source
    code. Please look there if you want more information.

Template parameter ``T``:
    The underlying scalar type. Must be a valid Eigen scalar.

See also:
    math::RollPitchYaw for definitions of roll, pitch, yaw ``[q₀ q₁
    q₂]``.

Note:
    Per issue #12982, do not directly or indirectly call the following
    methods as they have not yet been implemented and throw an
    exception: CalcPotentialEnergy(), CalcConservativePower(),
    CalcNonConservativePower().)""";
        // Symbol: drake::multibody::LinearBushingRollPitchYaw::CalcBushingSpatialForceOnFrameA
        struct /* CalcBushingSpatialForceOnFrameA */ {
          // Source: drake/multibody/tree/linear_bushing_roll_pitch_yaw.h:492
          const char* doc =
R"""(Calculate F_A_A, the bushing's spatial force on frame A expressed in
A. F_A_A contains two vectors: the moment of all bushing forces on A
about Ao (−𝐭 + p_AoAp × −𝐟) and the net bushing force on A (−𝐟
expressed in A).

Parameter ``context``:
    The state of the multibody system.

See also:
    CalcBushingSpatialForceOnFrameC().

Raises:
    RuntimeError if pitch angle is near gimbal-lock. For more info,

See also:
    RollPitchYaw::DoesCosPitchAngleViolateGimbalLockTolerance().)""";
        } CalcBushingSpatialForceOnFrameA;
        // Symbol: drake::multibody::LinearBushingRollPitchYaw::CalcBushingSpatialForceOnFrameC
        struct /* CalcBushingSpatialForceOnFrameC */ {
          // Source: drake/multibody/tree/linear_bushing_roll_pitch_yaw.h:502
          const char* doc =
R"""(Calculate F_C_C, the bushing's spatial force on frame C expressed in
C. F_C_C contains two vectors: the moment of all bushing forces on C
about Co (𝐭 + p_CoCp × 𝐟) and the resultant bushing force on C (𝐟
expressed in C).

Parameter ``context``:
    The state of the multibody system.

See also:
    CalcBushingSpatialForceOnFrameA().

Raises:
    RuntimeError if pitch angle is near gimbal-lock. For more info,

See also:
    RollPitchYaw::DoesCosPitchAngleViolateGimbalLockTolerance().)""";
        } CalcBushingSpatialForceOnFrameC;
        // Symbol: drake::multibody::LinearBushingRollPitchYaw::DoDeclareParameters
        struct /* DoDeclareParameters */ {
          // Source: drake/multibody/tree/linear_bushing_roll_pitch_yaw.h:507
          const char* doc = R"""()""";
        } DoDeclareParameters;
        // Symbol: drake::multibody::LinearBushingRollPitchYaw::GetForceDampingConstants
        struct /* GetForceDampingConstants */ {
          // Source: drake/multibody/tree/linear_bushing_roll_pitch_yaw.h:439
          const char* doc =
R"""(Returns the force damping constants ``[dx dy dz]`` (units of N*s/m)
stored in ``context``.)""";
        } GetForceDampingConstants;
        // Symbol: drake::multibody::LinearBushingRollPitchYaw::GetForceStiffnessConstants
        struct /* GetForceStiffnessConstants */ {
          // Source: drake/multibody/tree/linear_bushing_roll_pitch_yaw.h:430
          const char* doc =
R"""(Returns the force stiffness constants ``[kx ky kz]`` (units of N/m)
stored in ``context``.)""";
        } GetForceStiffnessConstants;
        // Symbol: drake::multibody::LinearBushingRollPitchYaw::GetTorqueDampingConstants
        struct /* GetTorqueDampingConstants */ {
          // Source: drake/multibody/tree/linear_bushing_roll_pitch_yaw.h:421
          const char* doc =
R"""(Returns the torque damping constants ``[d₀ d₁ d₂]`` (units of
N*m*s/rad) stored in ``context``.)""";
        } GetTorqueDampingConstants;
        // Symbol: drake::multibody::LinearBushingRollPitchYaw::GetTorqueStiffnessConstants
        struct /* GetTorqueStiffnessConstants */ {
          // Source: drake/multibody/tree/linear_bushing_roll_pitch_yaw.h:412
          const char* doc =
R"""(Returns the torque stiffness constants ``[k₀ k₁ k₂]`` (units of
N*m/rad) stored in ``context``.)""";
        } GetTorqueStiffnessConstants;
        // Symbol: drake::multibody::LinearBushingRollPitchYaw::LinearBushingRollPitchYaw<T>
        struct /* ctor */ {
          // Source: drake/multibody/tree/linear_bushing_roll_pitch_yaw.h:351
          const char* doc =
R"""(Construct a LinearBushingRollPitchYaw B that connects frames A and C,
where frame A is welded to a link L0 and frame C is welded to a link
L1.

Parameter ``frameA``:
    frame A of link (body) L0 that connects to bushing B.

Parameter ``frameC``:
    frame C of link (body) L1 that connects to bushing B.

Parameter ``torque_stiffness_constants``:
    ``[k₀ k₁ k₂]`` multiply the roll-pitch-yaw angles ``[q₀ q₁ q₂]``
    to produce the spring portion of the "gimbal" torques τ₀, τ₁, τ₂.
    The SI units of ``k₀, k₁, k₂`` are N*m/rad.

Parameter ``torque_damping_constants``:
    ``[d₀ d₁ d₂]`` multiply the roll-pitch-yaw rates ``[q̇₀ q̇₁ q̇₂]``
    to produce the damper portion of the "gimbal" torques τ₀, τ₁, τ₂.
    The SI units of ``d₀, d₁, d₂`` are N*m*s/rad.

Parameter ``force_stiffness_constants``:
    ``[kx ky kz]`` multiply the bushing displacements ``[x y z]`` to
    form 𝐟ᴋ, the spring portion of the force 𝐟 = [fx fy fz]ʙ. The SI
    units of ``kx, ky, kz`` are N/m.

Parameter ``force_damping_constants``:
    ``[dx dy dz]`` multiply the bushing displacement rates ``[ẋ ẏ
    ż]`` to form 𝐟ᴅ, the damper portion of the force 𝐟 = [fx fy fz]ʙ.
    The SI units of ``dx, dy, dz`` are N*s/m.

Note:
    The LinearBushingRollPitchYaw class documentation describes the
    stiffness and damping constants.

Note:
    The net moment on C about Co is affected by both the gimbal torque
    and the moment of 𝐟 about Co. Similarly, for the net moment on A
    about Ao.

Note:
    math::RollPitchYaw describes the roll pitch yaw angles q₀, q₁, q₂.
    The position from Ao to Co is p_AoCo_B = x 𝐁𝐱 + y 𝐁𝐲 + z 𝐁𝐳 = [x y
    z]ʙ.

Note:
    The ModelInstanceIndex assigned to this by the constructor is the
    one assigned to frame C, i.e., frameC.model_instance().

Precondition:
    All the stiffness and damping constants must be non-negative.)""";
        } ctor;
        // Symbol: drake::multibody::LinearBushingRollPitchYaw::SetForceDampingConstants
        struct /* SetForceDampingConstants */ {
          // Source: drake/multibody/tree/linear_bushing_roll_pitch_yaw.h:477
          const char* doc =
R"""(Sets the force damping constants ``[dx dy dz]`` (units of N*s/m) in
``context``.)""";
        } SetForceDampingConstants;
        // Symbol: drake::multibody::LinearBushingRollPitchYaw::SetForceStiffnessConstants
        struct /* SetForceStiffnessConstants */ {
          // Source: drake/multibody/tree/linear_bushing_roll_pitch_yaw.h:467
          const char* doc =
R"""(Sets the force stiffness constants ``[kx ky kz]`` (units of N/m) in
``context``.)""";
        } SetForceStiffnessConstants;
        // Symbol: drake::multibody::LinearBushingRollPitchYaw::SetTorqueDampingConstants
        struct /* SetTorqueDampingConstants */ {
          // Source: drake/multibody/tree/linear_bushing_roll_pitch_yaw.h:458
          const char* doc =
R"""(Sets the torque damping constants ``[d₀ d₁ d₂]`` (units of N*m*s/rad)
in ``context``.)""";
        } SetTorqueDampingConstants;
        // Symbol: drake::multibody::LinearBushingRollPitchYaw::SetTorqueStiffnessConstants
        struct /* SetTorqueStiffnessConstants */ {
          // Source: drake/multibody/tree/linear_bushing_roll_pitch_yaw.h:448
          const char* doc =
R"""(Sets the torque stiffness constants ``[k₀ k₁ k₂]`` (units of N*m/rad)
in ``context``.)""";
        } SetTorqueStiffnessConstants;
        // Symbol: drake::multibody::LinearBushingRollPitchYaw::force_damping_constants
        struct /* force_damping_constants */ {
          // Source: drake/multibody/tree/linear_bushing_roll_pitch_yaw.h:399
          const char* doc =
R"""(Returns the default force damping constants ``[dx dy dz]`` (units of
N*s/m). Refer to Basic_bushing_force_stiffness_and_damping "How to
choose force stiffness and damping constants" for more details.)""";
        } force_damping_constants;
        // Symbol: drake::multibody::LinearBushingRollPitchYaw::force_stiffness_constants
        struct /* force_stiffness_constants */ {
          // Source: drake/multibody/tree/linear_bushing_roll_pitch_yaw.h:392
          const char* doc =
R"""(Returns the default force stiffness constants ``[kx ky kz]`` (units of
N/m). Refer to Basic_bushing_force_stiffness_and_damping "How to
choose force stiffness and damping constants" for more details.)""";
        } force_stiffness_constants;
        // Symbol: drake::multibody::LinearBushingRollPitchYaw::frameA
        struct /* frameA */ {
          // Source: drake/multibody/tree/linear_bushing_roll_pitch_yaw.h:365
          const char* doc =
R"""(Returns frame A, which is the frame that is welded to link (body) L0
and attached to the bushing.)""";
        } frameA;
        // Symbol: drake::multibody::LinearBushingRollPitchYaw::frameC
        struct /* frameC */ {
          // Source: drake/multibody/tree/linear_bushing_roll_pitch_yaw.h:371
          const char* doc =
R"""(Returns frame C, which is the frame that is welded to link (body) L1
and attached to the bushing.)""";
        } frameC;
        // Symbol: drake::multibody::LinearBushingRollPitchYaw::link0
        struct /* link0 */ {
          // Source: drake/multibody/tree/linear_bushing_roll_pitch_yaw.h:358
          const char* doc =
R"""(Returns link (body) L0 (frame A is welded to link L0).)""";
        } link0;
        // Symbol: drake::multibody::LinearBushingRollPitchYaw::link1
        struct /* link1 */ {
          // Source: drake/multibody/tree/linear_bushing_roll_pitch_yaw.h:361
          const char* doc =
R"""(Returns link (body) L1 (frame C is welded to link L1).)""";
        } link1;
        // Symbol: drake::multibody::LinearBushingRollPitchYaw::torque_damping_constants
        struct /* torque_damping_constants */ {
          // Source: drake/multibody/tree/linear_bushing_roll_pitch_yaw.h:385
          const char* doc =
R"""(Returns the default torque damping constants ``[d₀ d₁ d₂]`` (units of
N*m*s/rad). Refer to Basic_bushing_torque_stiffness_and_damping "How
to choose torque stiffness and damping constants" for more details.)""";
        } torque_damping_constants;
        // Symbol: drake::multibody::LinearBushingRollPitchYaw::torque_stiffness_constants
        struct /* torque_stiffness_constants */ {
          // Source: drake/multibody/tree/linear_bushing_roll_pitch_yaw.h:378
          const char* doc =
R"""(Returns the default torque stiffness constants ``[k₀ k₁ k₂]`` (units
of N*m/rad). Refer to Basic_bushing_torque_stiffness_and_damping "How
to choose torque stiffness and damping constants" for more details.)""";
        } torque_stiffness_constants;
      } LinearBushingRollPitchYaw;
      // Symbol: drake::multibody::LinearSpringDamper
      struct /* LinearSpringDamper */ {
        // Source: drake/multibody/tree/linear_spring_damper.h:43
        const char* doc =
R"""(This ForceElement models a spring-damper attached between two points
on two different bodies. Given a point P on a body A and a point Q on
a body B with positions p_AP and p_BQ, respectively, this
spring-damper applies equal and opposite forces on bodies A and B
according to:


::

    f_AP = (k⋅(ℓ - ℓ₀) + c⋅dℓ/dt)⋅r̂
      f_BQ = -f_AP

where ``ℓ = ‖p_WQ - p_WP‖`` is the current length of the spring, dℓ/dt
its rate of change, ``r̂ = (p_WQ - p_WP) / ℓ`` is the normalized
vector from P to Q, ℓ₀ is the free length of the spring and k and c
are the stiffness and damping of the spring-damper, respectively. This
ForceElement is meant to model finite free length springs attached
between two points. In this typical arrangement springs are usually
pre-loaded, meaning they apply a non-zero spring force in the static
configuration of the system. Thus, neither the free length ℓ₀ nor the
current length ℓ of the spring can ever be zero. The length of the
spring approaching zero would incur in a non-physical configuration
and therefore this element throws a RuntimeError exception in that
case. Note that:

- The applied force is always along the line connecting points P and
Q. - Damping always dissipates energy. - Forces on bodies A and B are
equal and opposite according to Newton's third law.)""";
        // Symbol: drake::multibody::LinearSpringDamper::CalcConservativePower
        struct /* CalcConservativePower */ {
          // Source: drake/multibody/tree/linear_spring_damper.h:91
          const char* doc = R"""()""";
        } CalcConservativePower;
        // Symbol: drake::multibody::LinearSpringDamper::CalcNonConservativePower
        struct /* CalcNonConservativePower */ {
          // Source: drake/multibody/tree/linear_spring_damper.h:96
          const char* doc = R"""()""";
        } CalcNonConservativePower;
        // Symbol: drake::multibody::LinearSpringDamper::CalcPotentialEnergy
        struct /* CalcPotentialEnergy */ {
          // Source: drake/multibody/tree/linear_spring_damper.h:87
          const char* doc = R"""()""";
        } CalcPotentialEnergy;
        // Symbol: drake::multibody::LinearSpringDamper::DoCalcAndAddForceContribution
        struct /* DoCalcAndAddForceContribution */ {
          // Source: drake/multibody/tree/linear_spring_damper.h:102
          const char* doc = R"""()""";
        } DoCalcAndAddForceContribution;
        // Symbol: drake::multibody::LinearSpringDamper::DoCloneToScalar
        struct /* DoCloneToScalar */ {
          // Source: drake/multibody/tree/linear_spring_damper.h:108
          const char* doc = R"""()""";
        } DoCloneToScalar;
        // Symbol: drake::multibody::LinearSpringDamper::LinearSpringDamper<T>
        struct /* ctor */ {
          // Source: drake/multibody/tree/linear_spring_damper.h:64
          const char* doc =
R"""(Constructor for a spring-damper between a point P on ``bodyA`` and a
point Q on ``bodyB``. Point P is defined by its position ``p_AP`` as
measured and expressed in the body frame A and similarly, point Q is
defined by its position p_BQ as measured and expressed in body frame
B. The remaining parameters define:

Parameter ``free_length``:
    The free length of the spring ℓ₀, in meters, at which the spring
    applies no forces. Since this force element is meant to model
    finite length springs, ℓ₀ must be strictly positive.

Parameter ``stiffness``:
    The stiffness k of the spring in N/m. It must be non-negative.

Parameter ``damping``:
    The damping c of the damper in N⋅s/m. It must be non-negative.
    Refer to this class's documentation for further details.

Raises:
    RuntimeError if ``free_length`` is negative or zero.

Raises:
    RuntimeError if ``stiffness`` is negative.

Raises:
    RuntimeError if ``damping`` is negative.)""";
        } ctor;
        // Symbol: drake::multibody::LinearSpringDamper::bodyA
        struct /* bodyA */ {
          // Source: drake/multibody/tree/linear_spring_damper.h:69
          const char* doc = R"""()""";
        } bodyA;
        // Symbol: drake::multibody::LinearSpringDamper::bodyB
        struct /* bodyB */ {
          // Source: drake/multibody/tree/linear_spring_damper.h:71
          const char* doc = R"""()""";
        } bodyB;
        // Symbol: drake::multibody::LinearSpringDamper::damping
        struct /* damping */ {
          // Source: drake/multibody/tree/linear_spring_damper.h:85
          const char* doc = R"""()""";
        } damping;
        // Symbol: drake::multibody::LinearSpringDamper::free_length
        struct /* free_length */ {
          // Source: drake/multibody/tree/linear_spring_damper.h:81
          const char* doc = R"""()""";
        } free_length;
        // Symbol: drake::multibody::LinearSpringDamper::p_AP
        struct /* p_AP */ {
          // Source: drake/multibody/tree/linear_spring_damper.h:75
          const char* doc =
R"""(The position p_AP of point P on body A as measured and expressed in
body frame A.)""";
        } p_AP;
        // Symbol: drake::multibody::LinearSpringDamper::p_BQ
        struct /* p_BQ */ {
          // Source: drake/multibody/tree/linear_spring_damper.h:79
          const char* doc =
R"""(The position p_BQ of point Q on body B as measured and expressed in
body frame B.)""";
        } p_BQ;
        // Symbol: drake::multibody::LinearSpringDamper::stiffness
        struct /* stiffness */ {
          // Source: drake/multibody/tree/linear_spring_damper.h:83
          const char* doc = R"""()""";
        } stiffness;
      } LinearSpringDamper;
      // Symbol: drake::multibody::ManipulatorEquationConstraint
      struct /* ManipulatorEquationConstraint */ {
        // Source: drake/multibody/optimization/manipulator_equation_constraint.h:22
        const char* doc =
R"""(A Constraint to impose the manipulator equation: 0 = (Buₙ₊₁ + ∑ᵢ
(Jᵢ_WBᵀ(qₙ₊₁)ᵀ * Fᵢ_AB_W(λᵢ,ₙ₊₁)) + tau_g(qₙ₊₁) - C(qₙ₊₁, Vₙ₊₁)) * dt
- M(qₙ₊₁) * (Vₙ₊₁ - Vₙ))""";
        // Symbol: drake::multibody::ManipulatorEquationConstraint::MakeBinding
        struct /* MakeBinding */ {
          // Source: drake/multibody/optimization/manipulator_equation_constraint.h:52
          const char* doc =
R"""(This constraint depends on the decision variable vector: {vₙ, qₙ₊₁,
vₙ₊₁, uₙ₊₁, λₙ₊₁, dt}.

Parameter ``plant``:
    The plant on which the constraint is imposed.

Parameter ``context``:
    The context for the subsystem ``plant``. This context stores the
    next state {qₙ₊₁, vₙ₊₁}.

Parameter ``contact_wrench_evaluators_and_lambda``:
    For each contact pair, we need to compute the contact wrench
    applied at the point of contact, expressed in the world frame,
    namely Fᵢ_AB_W(λᵢ,ₙ₊₁) at time n+1.
    ``contact_wrench_evaluators_and_lambda.first`` is the evaluator
    for computing this contact wrench from the variables λᵢ[.].
    ``contact_wrench_evaluators_and_lambda.second`` are the decision
    variable λᵢ[n+1] used in computing the contact wrench at time step
    n+1. Notice the generalized position ``q`` is not included in
    variables contact_wrench_evaluators_and_lambda.second.

Parameter ``v_vars``:
    The decision variables for vₙ.

Parameter ``q_next_vars``:
    The decision variables for qₙ₊₁.

Parameter ``v_next_vars``:
    The decision variables for vₙ₊₁.

Parameter ``u_next_vars``:
    The decision variables for uₙ₊₁.

Parameter ``dt_var``:
    The decision variable for dt.

Returns:
    binding The binding between the manipulator equation constraint
    and the variables vₙ, qₙ₊₁, vₙ₊₁, uₙ₊₁, λₙ₊₁, and dt.

Precondition:
    ``plant`` must have been connected to a SceneGraph properly. Refer
    to AddMultibodyPlantSceneGraph for documentation on connecting a
    MultibodyPlant to a SceneGraph.)""";
        } MakeBinding;
        // Symbol: drake::multibody::ManipulatorEquationConstraint::ManipulatorEquationConstraint
        struct /* ctor */ {
          // Source: drake/multibody/optimization/manipulator_equation_constraint.h:24
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::multibody::ManipulatorEquationConstraint::contact_pair_to_wrench_evaluator
        struct /* contact_pair_to_wrench_evaluator */ {
          // Source: drake/multibody/optimization/manipulator_equation_constraint.h:71
          const char* doc =
R"""(Getter for contact_pair_to_wrench_evaluator, passed in the
constructor.)""";
        } contact_pair_to_wrench_evaluator;
      } ManipulatorEquationConstraint;
      // Symbol: drake::multibody::MinimumDistanceConstraint
      struct /* MinimumDistanceConstraint */ {
        // Source: drake/multibody/inverse_kinematics/minimum_distance_constraint.h:67
        const char* doc =
R"""(Constrain the signed distance between all candidate pairs of
geometries (according to the logic of
SceneGraphInspector::GetCollisionCandidates()) to be no smaller than a
specified minimum distance.

The formulation of the constraint is

0 ≤ SmoothMax( φ((dᵢ - d_influence)/(d_influence - dₘᵢₙ)) / φ(-1) ) ≤
1

where dᵢ is the signed distance of the i-th pair, dₘᵢₙ is the minimum
allowable distance, d_influence is the "influence distance" (the
distance below which a pair of geometries influences the constraint),
φ is a multibody::MinimumDistancePenaltyFunction, and SmoothMax(d) is
smooth approximation of max(d). We require that dₘᵢₙ < d_influence.
The input scaling (dᵢ - d_influence)/(d_influence - dₘᵢₙ) ensures that
at the boundary of the feasible set (when dᵢ == dₘᵢₙ), we evaluate the
penalty function at -1, where it is required to have a non-zero
gradient.)""";
        // Symbol: drake::multibody::MinimumDistanceConstraint::MinimumDistanceConstraint
        struct /* ctor */ {
          // Source: drake/multibody/inverse_kinematics/minimum_distance_constraint.h:88
          const char* doc =
R"""(Constructs a MinimumDistanceConstraint.

Parameter ``plant``:
    The multibody system on which the constraint will be evaluated.

Parameter ``minimum_distance``:
    The minimum allowed value, dₘᵢₙ, of the signed distance between
    any candidate pair of geometries.

Parameter ``penalty_function``:
    The penalty function formulation.

*Default:* QuadraticallySmoothedHinge
    $Parameter ``influence_distance_offset``:

The difference (in meters) between the influence distance,
d_influence, and the minimum distance, dₘᵢₙ (see class documentation).
This value must be finite and strictly positive, as it is used to
scale the signed distances between pairs of geometries. Smaller values
may improve performance, as fewer pairs of geometries need to be
considered in each constraint evaluation. $*Default:* 1 meter

Raises:
    ValueError if ``plant`` has not registered its geometry with a
    SceneGraph object.

Raises:
    ValueError if influence_distance_offset = ∞.

Raises:
    ValueError if influence_distance_offset ≤ 0.)""";
        } ctor;
        // Symbol: drake::multibody::MinimumDistanceConstraint::influence_distance
        struct /* influence_distance */ {
          // Source: drake/multibody/inverse_kinematics/minimum_distance_constraint.h:114
          const char* doc = R"""(Getter for the influence distance.)""";
        } influence_distance;
        // Symbol: drake::multibody::MinimumDistanceConstraint::minimum_distance
        struct /* minimum_distance */ {
          // Source: drake/multibody/inverse_kinematics/minimum_distance_constraint.h:109
          const char* doc = R"""(Getter for the minimum distance.)""";
        } minimum_distance;
      } MinimumDistanceConstraint;
      // Symbol: drake::multibody::MinimumDistancePenaltyFunction
      struct /* MinimumDistancePenaltyFunction */ {
        // Source: drake/multibody/inverse_kinematics/minimum_distance_constraint.h:21
        const char* doc =
R"""(Computes the penalty function φ(x) and its derivatives dφ(x)/dx. Valid
penalty functions must meet the following criteria:

1.     φ(x) ≥ 0 ∀ x ∈ ℝ.
2. dφ(x)/dx ≤ 0 ∀ x ∈ ℝ.
3.     φ(x) = 0 ∀ x ≥ 0.
4. dφ(x)/dx < 0 ∀ x < 0.)""";
      } MinimumDistancePenaltyFunction;
      // Symbol: drake::multibody::ModelInstanceIndex
      struct /* ModelInstanceIndex */ {
        // Source: drake/multibody/tree/multibody_tree_indexes.h:39
        const char* doc =
R"""(Type used to identify model instances by index within a multibody tree
system.)""";
      } ModelInstanceIndex;
      // Symbol: drake::multibody::MultibodyElement
      struct /* MultibodyElement */ {
        // Source: drake/multibody/tree/multibody_element.h:52
        const char* doc =
R"""(A class representing an element (subcomponent) of a MultibodyPlant or
(internally) a MultibodyTree. Examples of multibody elements are
bodies, joints, force elements, and actuators. After a Finalize()
call, multibody elements get assigned an type-specific index that
uniquely identifies them. A generic multibody tree element
``MultibodyThing`` is derived from this class as:


::

    template <typename T>
    class MultibodyThing :
        public MultibodyElement<MultibodyThing, T, MultibodyThingIndex> {
     ...
    };

Template parameter ``ElementType``:
    The type of the specific multibody element, for instance, a body
    or a mobilizer. It must be a template class that can be
    templatized by scalar type T. $Template parameter
    ``ElementIndexType``:

The type-safe index used for this element type.

As an example of usage, consider the definition of a ``ForceElement``
class as a multibody element. This is accomplished with:


::

    template <typename T>
      class ForceElement :
          public MultibodyElement<ForceElement, T, ForceElementIndex>;)""";
        // Symbol: drake::multibody::MultibodyElement::DeclareNumericParameter
        struct /* DeclareNumericParameter */ {
          // Source: drake/multibody/tree/multibody_element.h:141
          const char* doc =
R"""(To be used by MultibodyElement-derived objects when declaring
parameters in their implementation of DoDeclareParameters(). For an
example, see RigidBody::DoDeclareParameters().)""";
        } DeclareNumericParameter;
        // Symbol: drake::multibody::MultibodyElement::DeclareParameters
        struct /* DeclareParameters */ {
          // Source: drake/multibody/tree/multibody_element.h:93
          const char* doc =
R"""(Declares MultibodyTreeSystem Parameters at
MultibodyTreeSystem::Finalize() time. NVI to the virtual method
DoDeclareParameters().

Parameter ``tree_system``:
    A mutable copy of the parent MultibodyTreeSystem.

Precondition:
    'tree_system' must be the same as the the parent tree system
    (what's returned from GetParentTreeSystem()).)""";
        } DeclareParameters;
        // Symbol: drake::multibody::MultibodyElement::DoDeclareParameters
        struct /* DoDeclareParameters */ {
          // Source: drake/multibody/tree/multibody_element.h:136
          const char* doc =
R"""(Implementation of the NVI DeclareParameters().
MultibodyElement-derived objects must override to declare their
specific parameters. If an object is not a direct descendent of
MultibodyElement, it must invoke its parent classes'
DoDeclareParameters() before declaring its own parameters.)""";
        } DoDeclareParameters;
        // Symbol: drake::multibody::MultibodyElement::DoSetTopology
        struct /* DoSetTopology */ {
          // Source: drake/multibody/tree/multibody_element.h:130
          const char* doc =
R"""(Implementation of the NVI SetTopology(). For advanced use only for
developers implementing new MultibodyTree components.)""";
        } DoSetTopology;
        // Symbol: drake::multibody::MultibodyElement::GetParentPlant
        struct /* GetParentPlant */ {
          // Source: drake/multibody/tree/multibody_element.h:74
          const char* doc =
R"""(Returns the MultibodyPlant that owns this MultibodyElement.

Note:
    You can only invoke this method if you have a definition of
    MultibodyPlant available. That is, you must include
    ``drake/multibody/plant/multibody_plant.h`` in the translation
    unit that invokes this method; multibody_element.h cannot do that
    for you.

Raises:
    RuntimeError if there is no MultibodyPlant owner.)""";
        } GetParentPlant;
        // Symbol: drake::multibody::MultibodyElement::GetParentTreeSystem
        struct /* GetParentTreeSystem */ {
          // Source: drake/multibody/tree/multibody_element.h:116
          const char* doc =
R"""(Returns a constant reference to the parent MultibodyTreeSystem that
owns the parent MultibodyTree that owns this element.)""";
        } GetParentTreeSystem;
        // Symbol: drake::multibody::MultibodyElement::MultibodyElement<ElementType, T, ElementIndexType>
        struct /* ctor */ {
          // Source: drake/multibody/tree/multibody_element.h:101
          const char* doc_0args =
R"""(Default constructor made protected so that sub-classes can still
declare their default constructors if they need to.)""";
          // Source: drake/multibody/tree/multibody_element.h:104
          const char* doc_1args =
R"""(Constructor which allows specifying a model instance.)""";
        } ctor;
        // Symbol: drake::multibody::MultibodyElement::SetTopology
        struct /* SetTopology */ {
          // Source: drake/multibody/tree/multibody_element.h:124
          const char* doc =
R"""(Gives MultibodyElement-derived objects the opportunity to retrieve
their topology after MultibodyTree::Finalize() is invoked. NVI to pure
virtual method DoSetTopology().)""";
        } SetTopology;
        // Symbol: drake::multibody::MultibodyElement::get_parent_tree
        struct /* get_parent_tree */ {
          // Source: drake/multibody/tree/multibody_element.h:109
          const char* doc =
R"""(Returns a constant reference to the parent MultibodyTree that owns
this element.)""";
        } get_parent_tree;
        // Symbol: drake::multibody::MultibodyElement::index
        struct /* index */ {
          // Source: drake/multibody/tree/multibody_element.h:59
          const char* doc = R"""(Returns this element's unique index.)""";
        } index;
        // Symbol: drake::multibody::MultibodyElement::model_instance
        struct /* model_instance */ {
          // Source: drake/multibody/tree/multibody_element.h:63
          const char* doc =
R"""(Returns the ModelInstanceIndex of the model instance to which this
element belongs.)""";
        } model_instance;
      } MultibodyElement;
      // Symbol: drake::multibody::MultibodyForces
      struct /* MultibodyForces */ {
        // Source: drake/multibody/tree/multibody_forces.h:23
        const char* doc =
R"""(A class to hold a set of forces applied to a MultibodyTree system.
Forces can include generalized forces as well as body spatial forces.)""";
        // Symbol: drake::multibody::MultibodyForces::AddInForces
        struct /* AddInForces */ {
          // Source: drake/multibody/tree/multibody_forces.h:72
          const char* doc =
R"""(Adds into ``this`` the force contribution stored in ``addend``.)""";
        } AddInForces;
        // Symbol: drake::multibody::MultibodyForces::CheckHasRightSizeForModel
        struct /* CheckHasRightSizeForModel */ {
          // Source: drake/multibody/tree/multibody_forces.h:78
          const char* doc_1args_plant =
R"""(Utility that checks that the forces stored by ``this`` object have the
proper sizes to represent the set of forces for the given ``plant``.

Returns:
    true if ``this`` forces object has the proper sizes for the given
    ``plant``.)""";
          // Source: drake/multibody/tree/multibody_forces.h:82
          const char* doc_1args_model = R"""((Advanced) Tree overload.)""";
        } CheckHasRightSizeForModel;
        // Symbol: drake::multibody::MultibodyForces::MultibodyForces<T>
        struct /* ctor */ {
          // Source: drake/multibody/tree/multibody_forces.h:32
          const char* doc_1args_plant =
R"""(Constructs a force object to store a set of forces to be applied to
the multibody model for ``plant``. Forces are initialized to zero,
meaning no forces are applied. ``plant`` must have been already
finalized with MultibodyPlant::Finalize() or this constructor will
abort.)""";
          // Source: drake/multibody/tree/multibody_forces.h:35
          const char* doc_1args_model = R"""((Advanced) Tree overload.)""";
          // Source: drake/multibody/tree/multibody_forces.h:40
          const char* doc_2args_nb_nv =
R"""(Number of bodies and number of generalized velocities overload. This
constructor is useful for constructing the MultibodyForces structure
before a MultibodyPlant has been consructed.)""";
        } ctor;
        // Symbol: drake::multibody::MultibodyForces::SetZero
        struct /* SetZero */ {
          // Source: drake/multibody/tree/multibody_forces.h:43
          const char* doc =
R"""(Sets ``this`` to store zero forces (no applied forces).)""";
        } SetZero;
        // Symbol: drake::multibody::MultibodyForces::body_forces
        struct /* body_forces */ {
          // Source: drake/multibody/tree/multibody_forces.h:66
          const char* doc =
R"""((Advanced) Returns a constant reference to the vector of spatial body
forces ``F_BBo_W`` on each body B in the model, at the body's frame
origin ``Bo``, expressed in the world frame W.

Note:
    Entries are ordered by BodyNodeIndex.)""";
        } body_forces;
        // Symbol: drake::multibody::MultibodyForces::generalized_forces
        struct /* generalized_forces */ {
          // Source: drake/multibody/tree/multibody_forces.h:57
          const char* doc =
R"""((Advanced) Returns a constant reference to the vector of generalized
forces stored by ``this`` forces object.)""";
        } generalized_forces;
        // Symbol: drake::multibody::MultibodyForces::mutable_body_forces
        struct /* mutable_body_forces */ {
          // Source: drake/multibody/tree/multibody_forces.h:69
          const char* doc =
R"""((Advanced) Mutable version of body_forces().)""";
        } mutable_body_forces;
        // Symbol: drake::multibody::MultibodyForces::mutable_generalized_forces
        struct /* mutable_generalized_forces */ {
          // Source: drake/multibody/tree/multibody_forces.h:60
          const char* doc =
R"""((Advanced) Mutable version of generalized_forces().)""";
        } mutable_generalized_forces;
        // Symbol: drake::multibody::MultibodyForces::num_bodies
        struct /* num_bodies */ {
          // Source: drake/multibody/tree/multibody_forces.h:47
          const char* doc =
R"""(Returns the number of bodies for which ``this`` force object applies.
Determined at construction from the given model MultibodyTree object.)""";
        } num_bodies;
        // Symbol: drake::multibody::MultibodyForces::num_velocities
        struct /* num_velocities */ {
          // Source: drake/multibody/tree/multibody_forces.h:53
          const char* doc =
R"""(Returns the number of generalized velocities for the model to which
these forces apply. The number of generalized forces in a multibody
model always equals the number of generalized velocities. Determined
at construction from the given model MultibodyTree object.)""";
        } num_velocities;
      } MultibodyForces;
      // Symbol: drake::multibody::MultibodyPlant
      struct /* MultibodyPlant */ {
        // Source: drake/multibody/plant/multibody_plant.h:526
        const char* doc =
R"""(MultibodyPlant is a Drake system framework representation (see
systems::System) for the model of a physical system consisting of a
collection of interconnected bodies. See multibody for an overview of
concepts/notation.

.. pydrake_system::

    name: MultibodyPlant
    input_ports:
    - applied_generalized_force
    - applied_spatial_force
    - <em style="color:gray">model_instance_name[i]</em>_actuation
    - <span style="color:green">geometry_query</span>
    output_ports:
    - continuous_state
    - body_poses
    - body_spatial_velocities
    - body_spatial_accelerations
    - generalized_acceleration
    - reaction_forces
    - contact_results
    - <em style="color:gray">model_instance_name[i]</em>_continuous_state
    - '<em style="color:gray">
    model_instance_name[i]</em>_generalized_acceleration'
    - '<em style="color:gray">
    model_instance_name[i]</em>_generalized_contact_forces'
    - <span style="color:green">geometry_pose</span>

The ports whose names begin with <em style="color:gray">
model_instance_name[i]</em> represent groups of ports, one for each of
the model_instances "model instances", with i ∈ {0, ..., N-1} for the
N model instances. If a model instance does not contain any data of
the indicated type the port will still be present but its value will
be a zero-length vector. (Model instances ``world_model_instance()``
and ``default_model_instance()`` always exist.)

The ports shown in <span style="color:green"> green</span> are for
communication with Drake's geometry::SceneGraph "SceneGraph" system
for dealing with geometry.

MultibodyPlant provides a user-facing API for:

- mbp_input_and_output_ports "Ports":
Access input and output ports.
- mbp_construction "Construction":
Add bodies, joints, frames, force elements, and actuators.
- mbp_geometry "Geometry":
Register geometries to a provided SceneGraph instance.
- mbp_contact_modeling "Contact modeling":
Select and parameterize contact models.
- mbp_state_accessors_and_mutators "State access and modification":
Obtain and manipulate position and velocity state variables.
- mbp_parameters "Parameters"
Working with system parameters for various multibody elements.
- mbp_working_with_free_bodies "Free bodies":
Work conveniently with free (floating) bodies.
- mbp_kinematic_and_dynamic_computations "Kinematics and dynamics":
Perform systems::Context "Context"-dependent kinematic and dynamic
queries.
- mbp_system_matrix_computations "System matrices":
Explicitly form matrices that appear in the equations of motion.
- mbp_introspection "Introspection":
Perform introspection to find out what's in the MultibodyPlant.

**** Model Instances

A MultiBodyPlant may contain multiple model instances. Each model
instance corresponds to a set of bodies and their connections
(joints). Model instances provide methods to get or set the state of
the set of bodies (e.g., through GetPositionsAndVelocities() and
SetPositionsAndVelocities()), connecting controllers (through
get_state_output_port() and get_actuation_input_port()), and
organizing duplicate models (read through a parser). In fact, many
MultibodyPlant methods are overloaded to allow operating on the entire
plant or just the subset corresponding to the model instance; for
example, one GetPositions() method obtains the generalized positions
for the entire plant while another GetPositions() method obtains the
generalized positions for model instance.

Model instances are frequently defined through SDF files (using the
``model`` tag) and are automatically created when SDF files are parsed
(by Parser). There are two special multibody::ModelInstanceIndex
values. The world body is always multibody::ModelInstanceIndex 0.
multibody::ModelInstanceIndex 1 is reserved for all elements with no
explicit model instance and is generally only relevant for elements
created programmatically (and only when a model instance is not
explicitly specified). Note that Parser creates model instances
(resulting in a multibody::ModelInstanceIndex ≥ 2) as needed.

See num_model_instances(), num_positions(), num_velocities(),
num_actuated_dofs(), AddModelInstance() GetPositionsAndVelocities(),
GetPositions(), GetVelocities(), SetPositionsAndVelocities(),
SetPositions(), SetVelocities(), GetPositionsFromArray(),
GetVelocitiesFromArray(), SetPositionsInArray(),
SetVelocitiesInArray(), SetActuationInArray(),
HasModelInstanceNamed(), GetModelInstanceName(),
get_state_output_port(), get_actuation_input_port().

**** System dynamics

The state of a multibody system ``x = [q; v]`` is given by its
generalized positions vector q, of size ``nq`` (see num_positions()),
and by its generalized velocities vector v, of size ``nv`` (see
num_velocities()). As a Drake systems::System "System", MultibodyPlant
implements the governing equations for a multibody dynamical system in
the form ``ẋ = f(t, x, u)`` with t being time and u the actuation
forces. The governing equations for the dynamics of a multibody system
modeled with MultibodyPlant are [Featherstone 2008, Jain 2010]:


::

    q̇ = N(q)v
    (1)    M(q)v̇ + C(q, v)v = τ

where ``M(q)`` is the mass matrix of the multibody system, ``C(q,
v)v`` contains Coriolis, centripetal, and gyroscopic terms and
``N(q)`` is the kinematic coupling matrix describing the relationship
between q̇ (the time derivatives of the generalized positions) and the
generalized velocities v, [Seth 2010]. ``N(q)`` is an ``nq x nv``
matrix. The vector ``τ ∈ ℝⁿᵛ`` on the right hand side of Eq. (1) is
the system's generalized forces. These incorporate gravity, springs,
externally applied body forces, constraint forces, and contact forces.

**** Loading models from SDF files

Drake has the capability to load multibody models from SDF and URDF
files. Consider the example below which loads an acrobot model:


::

    MultibodyPlant<T> acrobot;
    SceneGraph<T> scene_graph;
    Parser parser(&acrobot, &scene_graph);
    const std::string relative_name =
    "drake/multibody/benchmarks/acrobot/acrobot.sdf";
    const std::string full_name = FindResourceOrThrow(relative_name);
    parser.AddModelFromFile(full_name);

As in the example above, for models including visual geometry,
collision geometry or both, the user must specify a SceneGraph for
geometry handling. You can find a full example of the LQR controlled
acrobot in examples/multibody/acrobot/run_lqr.cc.

AddModelFromFile() can be invoked multiple times on the same plant in
order to load multiple model instances. Other methods are available on
Parser such as AddAllModelsFromFile() which allows creating model
instances per each ``<model>`` tag found in the file. Please refer to
each of these methods' documentation for further details.

**** Working with SceneGraph

** Adding a MultibodyPlant connected to a SceneGraph to your Diagram

Probably the simplest way to add and wire up a MultibodyPlant with a
SceneGraph in your Diagram is using AddMultibodyPlantSceneGraph().

Recommended usages:

Assign to a MultibodyPlant reference (ignoring the SceneGraph):


::

    MultibodyPlant<double>& plant =
    AddMultibodyPlantSceneGraph(&builder, 0.0 /+ time_step +/);
    plant.DoFoo(...);

This flavor is the simplest, when the SceneGraph is not explicitly
needed. (It can always be retrieved later via
GetSubsystemByName("scene_graph").)

Assign to auto, and use the named public fields:


::

    auto items = AddMultibodyPlantSceneGraph(&builder, 0.0 /+ time_step +/);
    items.plant.DoFoo(...);
    items.scene_graph.DoBar(...);

or taking advantage of C++17's structured binding


::

    auto [plant, scene_graph] = AddMultibodyPlantSceneGraph(&builder, 0.0);
    ...
    plant.DoFoo(...);
    scene_graph.DoBar(...);

This is the easiest way to use both the plant and scene_graph.

Assign to already-declared pointer variables:


::

    MultibodyPlant<double>* plant{};
    SceneGraph<double>* scene_graph{};
    std::tie(plant, scene_graph) =
    AddMultibodyPlantSceneGraph(&builder, 0.0 /+ time_step +/);
    plant->DoFoo(...);
    scene_graph->DoBar(...);

This flavor is most useful when the pointers are class member fields
(and so perhaps cannot be references).

** Registering geometry with a SceneGraph

MultibodyPlant users can register geometry with a SceneGraph for
essentially two purposes; a) visualization and, b) contact modeling.

Before any geometry registration takes place, a user **must** first
make a call to RegisterAsSourceForSceneGraph() in order to register
the MultibodyPlant as a client of a SceneGraph instance, point at
which the plant will have assigned a valid geometry::SourceId. At
Finalize(), MultibodyPlant will declare input/output ports as
appropriate to communicate with the SceneGraph instance on which
registrations took place. All geometry registration **must** be
performed pre-finalize.

Multibodyplant declares an input port for geometric queries, see
get_geometry_query_input_port(). If MultibodyPlant registers geometry
with a SceneGraph via calls to RegisterCollisionGeometry(), users may
use this port for geometric queries. Users must connect this input
port to the output port for geometric queries of the SceneGraph used
for registration, which can be obtained with
SceneGraph::get_query_output_port(). In summary, if MultibodyPlant
registers collision geometry, the setup process will include:

1. Call to RegisterAsSourceForSceneGraph().
2. Calls to RegisterCollisionGeometry(), as many as needed.
3. Call to Finalize(), user is done specifying the model.
4. Connect SceneGraph::get_query_output_port() to
get_geometry_query_input_port().

Refer to the documentation provided in each of the methods above for
further details.

** Accessing point contact parameters MultibodyPlant's point contact
model looks for model parameters stored as
geometry::ProximityProperties by geometry::SceneGraph. These
properties can be obtained before or after context creation through
geometry::SceneGraphInspector APIs as outlined below. MultibodyPlant
expects the following properties for point contact modeling:

| Group name | Property Name | Required | Property Type | Property
Description | | :--------: | :--------------: | :------: |
:----------------: | :------------------- | | material |
coulomb_friction | yes¹ | CoulombFriction<T> | Static and Dynamic
friction. | | material | point_contact_stiffness | no² | T | Penalty
method stiffness. | | material | hunt_crossley_dissipation | no² | T |
Penalty method dissipation. |

¹ Collision geometry is required to be registered with a
geometry::ProximityProperties object that contains the ("material",
"coulomb_friction") property. If the property is missing,
MultibodyPlant will throw an exeception.

² If the property is missing, MultibodyPlant will use a heuristic
value as the default. Refer to the section mbp_penalty_method "Penalty
method point contact" for further details.

Accessing and modifying contact properties requires interfacing with
geometry::SceneGraph's model inspector. Interfacing with a model
inspector obtained from geometry::SceneGraph will provide the default
registered values for a given parameter. These are the values that
will initially appear in a systems::Context created by
CreateDefaultContext(). Subsequently, true system parameters can be
accessed and changed through a systems::Context once available. For
both of the above cases, proximity properties are accessed through
geometry::SceneGraphInspector APIs.

Before context creation an inspector can be retrieved directly from
SceneGraph as:


::

    // For a SceneGraph<T> instance called scene_graph.
    const geometry::SceneGraphInspector<T>& inspector =
    scene_graph.model_inspector();

After context creation, an inspector can be retrieved from the state
stored in the context by the plant's geometry query input port:


::

    // For a MultibodyPlant<T> instance called mbp and a
    // Context<T> called context.
    const geometry::QueryObject<T>& query_object =
    mbp.get_geometry_query_input_port()
    .template Eval<geometry::QueryObject<T>>(context);
    const geometry::SceneGraphInspector<T>& inspector =
    query_object.inspector();

Once an inspector is available, proximity properties can be retrieved
as:


::

    // For a body with GeometryId called geometry_id
    const geometry::ProximityProperties* props =
    inspector.GetProximityProperties(geometry_id);
    const CoulombFriction<T>& geometry_friction =
    props->GetProperty<CoulombFriction<T>>("material",
    "coulomb_friction");

**** Working with MultibodyElement parameters Several
MultibodyElements expose parameters, allowing the user flexible
modification of some aspects of the plant's model, post
systems::Context creation. For details, refer to the docmentation for
the MultibodyElement whose parameters you are trying to modify/access
(e.g. RigidBody, FixedOffsetFrame, etc.)

As an example, here is how to access and modify rigid body mass
parameters:


::

    MultibodyPlant<double> plant;
    // ... Code to add bodies, finalize plant, and to obtain a context.
    const RigidBody<double>& body =
    plant.GetRigidBodyByName("BodyName");
    const SpatialInertia<double> M_BBo_B =
    body.GetSpatialInertiaInBodyFrame(context);
    // .. logic to determine a new SpatialInertia parameter for body.
    const SpatialInertia<double>& M_BBo_B_new = ....
    
    // Modify the body parameter for spatial inertia.
    body.SetSpatialInertiaInBodyFrame(&context, M_BBo_B_new);

Another example, working with automatic differentiation in order to
take derivatives with respect to one of the bodies' masses:


::

    MultibodyPlant<double> plant;
    // ... Code to add bodies, finalize plant, and to obtain a
    // context and a body's spatial inertia M_BBo_B.
    
    // Scalar convert the plant.
    unique_ptr<MultibodyPlant<AutoDiffXd>> plant_autodiff =
    systems::System<double>::ToAutoDiffXd(plant);
    unique_ptr<Context<AutoDiffXd>> context_autodiff =
    plant_autodiff->CreateDefaultContext();
    context_autodiff->SetTimeStateAndParametersFrom(context);
    
    const RigidBody<AutoDiffXd>& body =
    plant_autodiff->GetRigidBodyByName("BodyName");
    
    // Modify the body parameter for mass.
    const AutoDiffXd mass_autodiff(mass, Vector1d(1));
    body.SetMass(context_autodiff.get(), mass_autodiff);
    
    // M_autodiff(i, j).derivatives()(0), contains the derivatives of
    // M(i, j) with respect to the body's mass.
    MatrixX<AutoDiffXd> M_autodiff(plant_autodiff->num_velocities(),
    plant_autodiff->num_velocities());
    plant_autodiff->CalcMassMatrix(*context_autodiff, &M_autodiff);

**** Adding modeling elements

Add multibody elements to a MultibodyPlant with methods like:

- Bodies: AddRigidBody()
- Joints: AddJoint()
- see mbp_construction "Construction" for more.

All modeling elements **must** be added before Finalize() is called.
See mbp_finalize_stage "Finalize stage" for a discussion.

**** Modeling contact

Please refer to drake_contacts "Contact Modeling in Drake" for details
on the available approximations, setup, and considerations for a
multibody simulation with frictional contact.

**** Energy and Power

MultibodyPlant implements the System energy and power methods, with
some limitations. - Kinetic energy: fully implemented. - Potential
energy and conservative power: currently include only gravity and
contributions from ForceElement objects; potential energy from
compliant contact and joint limits are not included. - Nonconservative
power: currently includes only contributions from ForceElement
objects; actuation and input port forces, joint damping, and
dissipation from joint limits, friction, and contact dissipation are
not included.

See Drake issue #12942 for more discussion.

**** Finalize() stage

Once the user is done adding modeling elements and registering
geometry, a call to Finalize() must be performed. This call will: -
Build the underlying MultibodyTree topology, see
MultibodyTree::Finalize() for details, - declare the plant's state, -
declare the plant's input and output ports, - declare input and output
ports for communication with a SceneGraph.

**** References

- [Featherstone 2008] Featherstone, R., 2008.
Rigid body dynamics algorithms. Springer.
- [Jain 2010] Jain, A., 2010.
Robot and multibody dynamics: analysis and algorithms.
Springer Science & Business Media.
- [Seth 2010] Seth, A., Sherman, M., Eastman, P. and Delp, S., 2010.
Minimal formulation of joint motion for biomechanisms.
Nonlinear dynamics, 62(1), pp.291-303.)""";
        // Symbol: drake::multibody::MultibodyPlant::AddForceElement
        struct /* AddForceElement */ {
          // Source: drake/multibody/plant/multibody_plant.h:1048
          const char* doc =
R"""(Adds a new force element model of type ``ForceElementType`` to
``this`` MultibodyPlant. The arguments to this method ``args`` are
forwarded to ``ForceElementType`'s constructor.

Parameter ``args``:
    Zero or more parameters provided to the constructor of the new
    force element. It must be the case that
    `ForceElementType<T>(args)`` is a valid constructor.

Template parameter ``ForceElementType``:
    The type of the ForceElement to add. As there is always a
    UniformGravityFieldElement present (accessible through
    gravity_field()), an exception will be thrown if this function is
    called to add another UniformGravityFieldElement.

Returns:
    A constant reference to the new ForceElement just added, of type
    ``ForceElementType<T>`` specialized on the scalar type T of
    ``this`` MultibodyPlant. It will remain valid for the lifetime of
    ``this`` MultibodyPlant.

See also:
    The ForceElement class's documentation for further details on how
    a force element is defined.)""";
        } AddForceElement;
        // Symbol: drake::multibody::MultibodyPlant::AddFrame
        struct /* AddFrame */ {
          // Source: drake/multibody/plant/multibody_plant.h:896
          const char* doc =
R"""(This method adds a Frame of type ``FrameType<T>``. For more
information, please see the corresponding constructor of
``FrameType``.

Template parameter ``FrameType``:
    Template which will be instantiated on ``T``.

Parameter ``frame``:
    Unique pointer frame instance.

Returns:
    A constant reference to the new Frame just added, which will
    remain valid for the lifetime of ``this`` MultibodyPlant.)""";
        } AddFrame;
        // Symbol: drake::multibody::MultibodyPlant::AddJoint
        struct /* AddJoint */ {
          // Source: drake/multibody/plant/multibody_plant.h:903
          const char* doc_1args =
R"""(This method adds a Joint of type ``JointType`` between two bodies. For
more information, see the below overload of ``AddJoint<>``.)""";
          // Source: drake/multibody/plant/multibody_plant.h:986
          const char* doc_6args =
R"""(This method adds a Joint of type ``JointType`` between two bodies. The
two bodies connected by this Joint object are referred to as *parent*
and *child* bodies. The parent/child ordering defines the sign
conventions for the generalized coordinates and the coordinate
ordering for multi-DOF joints. @image html
multibody/plant/images/BodyParentChildJointCM.png width=50% Note: The
previous figure also shows Pcm which is body P's center of mass and
point Bcm which is body B's center of mass.

As explained in the Joint class's documentation, in Drake we define a
frame F attached to the parent body P with pose ``X_PF`` and a frame M
attached to the child body B with pose ``X_BM``. This method helps
creating a joint between two bodies with fixed poses ``X_PF`` and
``X_BM``. Refer to the Joint class's documentation for more details.

Parameter ``name``:
    A string that uniquely identifies the new joint to be added to
    ``this`` model. A RuntimeError is thrown if a joint named ``name``
    already is part of the model. See HasJointNamed(), Joint::name().

Parameter ``parent``:
    The parent body connected by the new joint.

Parameter ``X_PF``:
    The fixed pose of frame F attached to the parent body, measured in
    the frame P of that body. ``X_PF`` is an optional parameter; empty
    curly braces ``{}`` imply that frame F **is** the same body frame
    P. If instead your intention is to make a frame F with pose
    ``X_PF`` equal to the identity pose, provide
    ``RigidTransform<double>::Identity()`` as your input.

Parameter ``child``:
    The child body connected by the new joint.

Parameter ``X_BM``:
    The fixed pose of frame M attached to the child body, measured in
    the frame B of that body. ``X_BM`` is an optional parameter; empty
    curly braces ``{}`` imply that frame M **is** the same body frame
    B. If instead your intention is to make a frame M with pose
    ``X_BM`` equal to the identity pose, provide
    ``RigidTransform<double>::Identity()`` as your input.

Parameter ``args``:
    Zero or more parameters provided to the constructor of the new
    joint. It must be the case that ``JointType<T>( const
    std::string&, const Frame<T>&, const Frame<T>&, args)`` is a valid
    constructor.

Template parameter ``JointType``:
    The type of the Joint to add.

Returns:
    A constant reference to the new joint just added, of type
    ``JointType<T>`` specialized on the scalar type T of ``this``
    MultibodyPlant. It will remain valid for the lifetime of ``this``
    MultibodyPlant.

Example of usage:


::

    MultibodyPlant<T> plant;
      // Code to define bodies serving as the joint's parent and child bodies.
      const RigidBody<double>& body_1 =
        plant.AddRigidBody("Body1", SpatialInertia<double>(...));
      const RigidBody<double>& body_2 =
        plant.AddRigidBody("Body2", SpatialInertia<double>(...));
      // Body 1 serves as parent, Body 2 serves as child.
      // Define the pose X_BM of a frame M rigidly attached to child body B.
      const RevoluteJoint<double>& elbow =
        plant.AddJoint<RevoluteJoint>(
          "Elbow",                /* joint name 
          body_1,                 /* parent body 
          {},                     /* frame F IS the parent body frame P 
          body_2,                 /* child body, the pendulum 
          X_BM,                   /* pose of frame M in the body frame B 
          Vector3d::UnitZ());     /* revolute axis in this case

Raises:
    RuntimeError if ``this`` MultibodyPlant already contains a joint
    with the given ``name``. See HasJointNamed(), Joint::name().

See also:
    The Joint class's documentation for further details on how a Joint
    is defined.)""";
        } AddJoint;
        // Symbol: drake::multibody::MultibodyPlant::AddJointActuator
        struct /* AddJointActuator */ {
          // Source: drake/multibody/plant/multibody_plant.h:1076
          const char* doc =
R"""(Creates and adds a JointActuator model for an actuator acting on a
given ``joint``. This method returns a constant reference to the
actuator just added, which will remain valid for the lifetime of
``this`` plant.

Parameter ``name``:
    A string that uniquely identifies the new actuator to be added to
    ``this`` model. A RuntimeError is thrown if an actuator with the
    same name already exists in the model. See
    HasJointActuatorNamed().

Parameter ``joint``:
    The Joint to be actuated by the new JointActuator.

Parameter ``effort_limit``:
    The maximum effort for the actuator. It must be strictly positive,
    otherwise an RuntimeError is thrown. If +∞, the actuator has no
    limit, which is the default. The effort limit has physical units
    in accordance to the joint type it actuates. For instance, it will
    have units of N⋅m (torque) for revolute joints while it will have
    units of N (force) for prismatic joints.

Returns:
    A constant reference to the new JointActuator just added, which
    will remain valid for the lifetime of ``this`` plant.

Raises:
    RuntimeError if ``joint.num_velocities() > 1`` since for now we
    only support actuators for single dof joints.)""";
        } AddJointActuator;
        // Symbol: drake::multibody::MultibodyPlant::AddModelInstance
        struct /* AddModelInstance */ {
          // Source: drake/multibody/plant/multibody_plant.h:1090
          const char* doc =
R"""(Creates a new model instance. Returns the index for the model
instance.

Parameter ``name``:
    A string that uniquely identifies the new instance to be added to
    ``this`` model. An exception is thrown if an instance with the
    same name already exists in the model. See
    HasModelInstanceNamed().)""";
        } AddModelInstance;
        // Symbol: drake::multibody::MultibodyPlant::AddRigidBody
        struct /* AddRigidBody */ {
          // Source: drake/multibody/plant/multibody_plant.h:827
          const char* doc_3args =
R"""(Creates a rigid body with the provided name and spatial inertia. This
method returns a constant reference to the body just added, which will
remain valid for the lifetime of ``this`` MultibodyPlant.

Example of usage:


::

    MultibodyPlant<T> plant;
      // ... Code to define spatial_inertia, a SpatialInertia<T> object ...
      ModelInstanceIndex model_instance = plant.AddModelInstance("instance");
      const RigidBody<T>& body =
        plant.AddRigidBody("BodyName", model_instance, spatial_inertia);

Parameter ``name``:
    A string that identifies the new body to be added to ``this``
    model. A RuntimeError is thrown if a body named ``name`` already
    is part of ``model_instance``. See HasBodyNamed(), Body::name().

Parameter ``model_instance``:
    A model instance index which this body is part of.

Parameter ``M_BBo_B``:
    The SpatialInertia of the new rigid body to be added to ``this``
    MultibodyPlant, computed about the body frame origin ``Bo`` and
    expressed in the body frame B.

Returns:
    A constant reference to the new RigidBody just added, which will
    remain valid for the lifetime of ``this`` MultibodyPlant.)""";
          // Source: drake/multibody/plant/multibody_plant.h:878
          const char* doc_2args =
R"""(Creates a rigid body with the provided name and spatial inertia. This
method returns a constant reference to the body just added, which will
remain valid for the lifetime of ``this`` MultibodyPlant. The body
will use the default model instance (model_instance "more on model
instances").

Example of usage:


::

    MultibodyPlant<T> plant;
      // ... Code to define spatial_inertia, a SpatialInertia<T> object ...
      const RigidBody<T>& body =
        plant.AddRigidBody("BodyName", spatial_inertia);

Parameter ``name``:
    A string that identifies the new body to be added to ``this``
    model. A RuntimeError is thrown if a body named ``name`` already
    is part of the model in the default model instance. See
    HasBodyNamed(), Body::name().

Parameter ``M_BBo_B``:
    The SpatialInertia of the new rigid body to be added to ``this``
    MultibodyPlant, computed about the body frame origin ``Bo`` and
    expressed in the body frame B.

Returns:
    A constant reference to the new RigidBody just added, which will
    remain valid for the lifetime of ``this`` MultibodyPlant.

Raises:
    RuntimeError if additional model instances have been created
    beyond the world and default instances.)""";
        } AddRigidBody;
        // Symbol: drake::multibody::MultibodyPlant::CalcBiasCenterOfMassTranslationalAcceleration
        struct /* CalcBiasCenterOfMassTranslationalAcceleration */ {
          // Source: drake/multibody/plant/multibody_plant.h:3145
          const char* doc =
R"""(Calculates abias_ACcm_E, point Ccm's translational "bias" acceleration
term in frame A with respect to "speeds" 𝑠, expressed in frame E,
where point Ccm is the composite center of mass of the system of all
bodies (except world_body()) in the MultibodyPlant. abias_ACcm is the
part of a_ACcm (Ccm's translational acceleration) that does not
multiply ṡ, equal to abias_ACcm = J̇𝑠_v_ACcm ⋅ s. This allows a_ACcm
to be written as a_ACcm = J𝑠_v_ACcm ⋅ ṡ + abias_ACcm.

Parameter ``context``:
    The state of the multibody system.

Parameter ``with_respect_to``:
    Enum equal to JacobianWrtVariable::kQDot or
    JacobianWrtVariable::kV, indicating whether the Jacobian
    ``abias_ACcm`` is partial derivatives with respect to 𝑠 = q̇
    (time-derivatives of generalized positions) or with respect to 𝑠 =
    v (generalized velocities).

Parameter ``frame_A``:
    The frame in which abias_ACcm is measured.

Parameter ``frame_E``:
    The frame in which abias_ACcm is expressed on output.

Returns ``abias_ACcm_E``:
    Point Ccm's translational "bias" acceleration term in frame A with
    respect to "speeds" 𝑠, expressed in frame E.

Raises:
    RuntimeError if Ccm does not exist, which occurs if there are no
    massive bodies in MultibodyPlant (except world_body()).

Raises:
    RuntimeError if composite_mass <= 0, where composite_mass is the
    total mass of all bodies except world_body() in MultibodyPlant.

Raises:
    RuntimeError if frame_A is not the world frame.)""";
        } CalcBiasCenterOfMassTranslationalAcceleration;
        // Symbol: drake::multibody::MultibodyPlant::CalcBiasSpatialAcceleration
        struct /* CalcBiasSpatialAcceleration */ {
          // Source: drake/multibody/plant/multibody_plant.h:2932
          const char* doc =
R"""(For one point Bp affixed/welded to a frame B, calculates A𝑠Bias_ABp,
Bp's spatial acceleration bias in frame A with respect to "speeds" 𝑠,
where 𝑠 is either q̇ (time-derivatives of generalized positions) or v
(generalized velocities). A𝑠Bias_ABp is the term in A_ABp (Bp's
spatial acceleration in A) that does not include 𝑠̇, i.e., A𝑠Bias_ABp
is Bi's translational acceleration in A when 𝑠̇ = 0.


::

    A_ABp =  J𝑠_V_ABp ⋅ 𝑠̇  +  J̇𝑠_V_ABp ⋅ 𝑠   (𝑠 = q̇ or 𝑠 = v), hence
      A𝑠Bias_ABp = J̇𝑠_V_ABp ⋅ 𝑠

where J𝑠_V_ABp is Bp's spatial velocity Jacobian in frame A for speeds
s (see CalcJacobianSpatialVelocity() for details on J𝑠_V_ABp).

Parameter ``context``:
    The state of the multibody system.

Parameter ``with_respect_to``:
    Enum equal to JacobianWrtVariable::kQDot or
    JacobianWrtVariable::kV, indicating whether the spatial
    accceleration bias is with respect to 𝑠 = q̇ or 𝑠 = v.

Parameter ``frame_B``:
    The frame on which point Bp is affixed/welded.

Parameter ``p_BoBp_B``:
    Position vector from Bo (frame_B's origin) to point Bp (regarded
    as affixed/welded to B), expressed in frame_B.

Parameter ``frame_A``:
    The frame that measures A𝑠Bias_ABp. Currently, an exception is
    thrown if frame_A is not the World frame.

Parameter ``frame_E``:
    The frame in which A𝑠Bias_ABp is expressed on output.

Returns:
    A𝑠Bias_ABp_E Point Bp's spatial acceleration bias in frame A with
    respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E.

Note:
    Shown below, A𝑠Bias_ABp_E = J̇𝑠_V_ABp ⋅ 𝑠 is quadratic in 𝑠.


::

    V_ABp =  J𝑠_V_ABp ⋅ 𝑠        which upon vector differentiation in A gives
     A_ABp =  J𝑠_V_ABp ⋅ 𝑠̇  +  J̇𝑠_V_ABp ⋅ 𝑠   Since J̇𝑠_V_ABp is linear in 𝑠,
     A𝑠Bias_ABp = J̇𝑠_V_ABp ⋅ 𝑠                             is quadratic in 𝑠.

See also:
    CalcJacobianSpatialVelocity() to compute J𝑠_V_ABp, point Bp's
    translational velocity Jacobian in frame A with respect to 𝑠.

Raises:
    RuntimeError if with_respect_to is not JacobianWrtVariable::kV

Raises:
    RuntimeError if frame_A is not the world frame.)""";
        } CalcBiasSpatialAcceleration;
        // Symbol: drake::multibody::MultibodyPlant::CalcBiasTerm
        struct /* CalcBiasTerm */ {
          // Source: drake/multibody/plant/multibody_plant.h:2844
          const char* doc =
R"""(Computes the bias term ``C(q, v)v`` containing Coriolis, centripetal,
and gyroscopic effects in the multibody equations of motion:


::

    M(q) v̇ + C(q, v) v = tau_app + ∑ (Jv_V_WBᵀ(q) ⋅ Fapp_Bo_W)

where ``M(q)`` is the multibody model's mass matrix and ``tau_app`` is
a vector of generalized forces. The last term is a summation over all
bodies of the dot-product of ``Fapp_Bo_W`` (applied spatial force on
body B at Bo) with ``Jv_V_WB(q)`` (B's spatial Jacobian in world W
with respect to generalized velocities v). Note: B's spatial velocity
in W can be written ``V_WB = Jv_V_WB * v``.

Parameter ``context``:
    The context containing the state of the model. It stores the
    generalized positions q and the generalized velocities v.

Parameter ``Cv``:
    On output, ``Cv`` will contain the product ``C(q, v)v``. It must
    be a valid (non-null) pointer to a column vector in ``ℛⁿ`` with n
    the number of generalized velocities (num_velocities()) of the
    model. This method aborts if Cv is nullptr or if it does not have
    the proper size.)""";
        } CalcBiasTerm;
        // Symbol: drake::multibody::MultibodyPlant::CalcBiasTranslationalAcceleration
        struct /* CalcBiasTranslationalAcceleration */ {
          // Source: drake/multibody/plant/multibody_plant.h:2887
          const char* doc =
R"""(For each point Bi affixed/welded to a frame B, calculates a𝑠Bias_ABi,
Bi's translational acceleration bias in frame A with respect to
"speeds" 𝑠, where 𝑠 is either q̇ (time-derivatives of generalized
positions) or v (generalized velocities). a𝑠Bias_ABi is the term in
a_ABi (Bi's translational acceleration in A) that does not include 𝑠̇,
i.e., a𝑠Bias_ABi is Bi's translational acceleration in A when 𝑠̇ = 0.


::

    a_ABi =  J𝑠_v_ABi ⋅ 𝑠̇  +  J̇𝑠_v_ABi ⋅ 𝑠  (𝑠 = q̇ or 𝑠 = v), hence
      a𝑠Bias_ABi = J̇𝑠_v_ABi ⋅ 𝑠

where J𝑠_v_ABi is Bi's translational velocity Jacobian in frame A for
s (see CalcJacobianTranslationalVelocity() for details on J𝑠_v_ABi).

Parameter ``context``:
    The state of the multibody system.

Parameter ``with_respect_to``:
    Enum equal to JacobianWrtVariable::kQDot or
    JacobianWrtVariable::kV, indicating whether the translational
    accceleration bias is with respect to 𝑠 = q̇ or 𝑠 = v.

Parameter ``frame_B``:
    The frame on which points Bi are affixed/welded.

Parameter ``p_BoBi_B``:
    A position vector or list of p position vectors from Bo (frame_B's
    origin) to points Bi (regarded as affixed to B), where each
    position vector is expressed in frame_B. Each column in the ``3 x
    p`` matrix p_BoBi_B corresponds to a position vector.

Parameter ``frame_A``:
    The frame that measures a𝑠Bias_ABi. Currently, an exception is
    thrown if frame_A is not the World frame.

Parameter ``frame_E``:
    The frame in which a𝑠Bias_ABi is expressed on output.

Returns:
    a𝑠Bias_ABi_E Point Bi's translational acceleration bias in frame A
    with respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E.
    a𝑠Bias_ABi_E is a ``3 x p`` matrix, where p is the number of
    points Bi.

Note:
    Shown below, a𝑠Bias_ABi_E = J̇𝑠_v_ABp ⋅ 𝑠 is quadratic in 𝑠.


::

    v_ABi =  J𝑠_v_ABi ⋅ 𝑠        which upon vector differentiation in A gives
     a_ABi =  J𝑠_v_ABi ⋅ 𝑠̇ + J̇𝑠_v_ABi ⋅ 𝑠     Since J̇𝑠_v_ABi is linear in 𝑠,
     a𝑠Bias_ABi = J̇𝑠_v_ABi ⋅ 𝑠                             is quadratic in 𝑠.

See also:
    CalcJacobianTranslationalVelocity() to compute J𝑠_v_ABi, point
    Bi's translational velocity Jacobian in frame A with respect to 𝑠.

Precondition:
    p_BoBi_B must have 3 rows.

Raises:
    RuntimeError if with_respect_to is not JacobianWrtVariable::kV

Raises:
    RuntimeError if frame_A is not the world frame.)""";
        } CalcBiasTranslationalAcceleration;
        // Symbol: drake::multibody::MultibodyPlant::CalcCenterOfMassPosition
        struct /* CalcCenterOfMassPosition */ {
          // Source: drake/multibody/plant/multibody_plant.h:2447
          const char* doc_deprecated =
R"""((Deprecated.)

Deprecated:
    Use CalcCenterOfMassPositionInWorld() instead of
    CalcCenterOfMassPosition(). This will be removed from Drake on or
    after 2021-04-21.)""";
        } CalcCenterOfMassPosition;
        // Symbol: drake::multibody::MultibodyPlant::CalcCenterOfMassPositionInWorld
        struct /* CalcCenterOfMassPositionInWorld */ {
          // Source: drake/multibody/plant/multibody_plant.h:2439
          const char* doc_1args =
R"""(Calculates the position vector from the world origin Wo to the center
of mass of all bodies in this MultibodyPlant, expressed in the world
frame W.

Parameter ``context``:
    Contains the state of the model.

Returns ``p_WScm_W``:
    position vector from Wo to Scm expressed in world frame W, where
    Scm is the center of mass of the system S stored by ``this``
    plant.

Raises:
    RuntimeError if ``this`` has no body except world_body().

Raises:
    RuntimeError if mₛ ≤ 0 (mₛ is the mass of ``this`` system S).

Note:
    The world_body() is ignored.)""";
          // Source: drake/multibody/plant/multibody_plant.h:2465
          const char* doc_2args =
R"""(Calculates the position vector from the world origin Wo to the center
of mass of all bodies contained in model_instances, expressed in the
world frame W.

Parameter ``context``:
    Contains the state of the model.

Parameter ``model_instances``:
    Vector of selected model instances. This method does not
    distinguish between welded, joint connected, or floating bodies.

Returns ``p_WScm_W``:
    position vector from world origin Wo to Scm expressed in the world
    frame W, where Scm is the center of mass of the system S of bodies
    contained in model_instances.

Raises:
    RuntimeError if model_instance only has world_model_instance(),
    i.e., model_instances has no body except world_body().

Raises:
    RuntimeError if mₛ ≤ 0 (mₛ is the mass of the system S).

Note:
    The world_body() is ignored.)""";
        } CalcCenterOfMassPositionInWorld;
        // Symbol: drake::multibody::MultibodyPlant::CalcCenterOfMassTranslationalVelocityInWorld
        struct /* CalcCenterOfMassTranslationalVelocityInWorld */ {
          // Source: drake/multibody/plant/multibody_plant.h:2488
          const char* doc_1args =
R"""(Calculates system center of mass translational velocity in world frame
W.

Parameter ``context``:
    The context contains the state of the model.

Returns ``v_WScm_W``:
    Scm's translational velocity in frame W, expressed in W, where Scm
    is the center of mass of the system S stored by ``this`` plant.

Raises:
    RuntimeError if ``this`` has no body except world_body().

Raises:
    RuntimeError if mₛ ≤ 0 (mₛ is the mass of ``this`` system S).

Note:
    The world_body() is ignored.)""";
          // Source: drake/multibody/plant/multibody_plant.h:2503
          const char* doc_2args =
R"""(Calculates system center of mass translational velocity in world frame
W.

Parameter ``context``:
    The context contains the state of the model.

Parameter ``model_instances``:
    The vector of selected model instances.

Returns ``v_WScm_W``:
    Scm's translational velocity in frame W, expressed in W, where Scm
    is the center of mass of the system S in model_instances.

Raises:
    RuntimeError if ``this`` has no body except world_body().

Raises:
    RuntimeError if mₛ ≤ 0 (mₛ is the mass of ``this`` system S).

Note:
    This method does not distinguish between welded bodies, joint
    connected bodies, and free bodies. The world_body() is ignored.)""";
        } CalcCenterOfMassTranslationalVelocityInWorld;
        // Symbol: drake::multibody::MultibodyPlant::CalcForceElementsContribution
        struct /* CalcForceElementsContribution */ {
          // Source: drake/multibody/plant/multibody_plant.h:2653
          const char* doc =
R"""(Computes the combined force contribution of ForceElement objects in
the model. A ForceElement can apply forces as a spatial force per body
or as generalized forces, depending on the ForceElement model.
ForceElement contributions are a function of the state and time only.
The output from this method can immediately be used as input to
CalcInverseDynamics() to include the effect of applied forces by force
elements.

Parameter ``context``:
    The context containing the state of this model.

Parameter ``forces``:
    A pointer to a valid, non nullptr, multibody forces object. On
    output ``forces`` will store the forces exerted by all the
    ForceElement objects in the model.

Raises:
    RuntimeError if ``forces`` is null or not compatible with this
    model, per MultibodyForces::CheckInvariants().)""";
        } CalcForceElementsContribution;
        // Symbol: drake::multibody::MultibodyPlant::CalcGravityGeneralizedForces
        struct /* CalcGravityGeneralizedForces */ {
          // Source: drake/multibody/plant/multibody_plant.h:2678
          const char* doc =
R"""(Computes the generalized forces ``tau_g(q)`` due to gravity as a
function of the generalized positions ``q`` stored in the input
``context``. The vector of generalized forces due to gravity
``tau_g(q)`` is defined such that it appears on the right hand side of
the equations of motion together with any other generalized forces,
like so:


::

    Mv̇ + C(q, v)v = tau_g(q) + tau_app

where ``tau_app`` includes any other generalized forces applied on the
system.

Parameter ``context``:
    The context storing the state of the model.

Returns:
    tau_g A vector containing the generalized forces due to gravity.
    The generalized forces are consistent with the vector of
    generalized velocities ``v`` for ``this`` so that the inner
    product ``v⋅tau_g`` corresponds to the power applied by the
    gravity forces on the mechanical system. That is, ``v⋅tau_g > 0``
    corresponds to potential energy going into the system, as either
    mechanical kinetic energy, some other potential energy, or heat,
    and therefore to a decrease of the gravitational potential energy.)""";
        } CalcGravityGeneralizedForces;
        // Symbol: drake::multibody::MultibodyPlant::CalcInverseDynamics
        struct /* CalcInverseDynamics */ {
          // Source: drake/multibody/plant/multibody_plant.h:2628
          const char* doc =
R"""(Given the state of this model in ``context`` and a known vector of
generalized accelerations ``vdot``, this method computes the set of
generalized forces ``tau`` that would need to be applied in order to
attain the specified generalized accelerations. Mathematically, this
method computes:


::

    tau = M(q)v̇ + C(q, v)v - tau_app - ∑ J_WBᵀ(q) Fapp_Bo_W

where ``M(q)`` is the model's mass matrix, ``C(q, v)v`` is the bias
term containing Coriolis and gyroscopic effects and ``tau_app``
consists of a vector applied generalized forces. The last term is a
summation over all bodies in the model where ``Fapp_Bo_W`` is an
applied spatial force on body B at ``Bo`` which gets projected into
the space of generalized forces with the transpose of ``Jv_V_WB(q)``
(where ``Jv_V_WB`` is B's spatial velocity Jacobian in W with respect
to generalized velocities v). Note: B's spatial velocity in W can be
written as ``V_WB = Jv_V_WB * v``. This method does not compute
explicit expressions for the mass matrix nor for the bias term, which
would be of at least ``O(n²)`` complexity, but it implements an
``O(n)`` Newton-Euler recursive algorithm, where n is the number of
bodies in the model. The explicit formation of the mass matrix
``M(q)`` would require the calculation of ``O(n²)`` entries while
explicitly forming the product ``C(q, v) * v`` could require up to
``O(n³)`` operations (see [Featherstone 1987, §4]), depending on the
implementation. The recursive Newton-Euler algorithm is the most
efficient currently known general method for solving inverse dynamics
[Featherstone 2008].

Parameter ``context``:
    The context containing the state of the model.

Parameter ``known_vdot``:
    A vector with the known generalized accelerations ``vdot`` for the
    full model. Use the provided Joint APIs in order to access entries
    into this array.

Parameter ``external_forces``:
    A set of forces to be applied to the system either as body spatial
    forces ``Fapp_Bo_W`` or generalized forces ``tau_app``, see
    MultibodyForces for details.

Returns:
    the vector of generalized forces that would need to be applied to
    the mechanical system in order to achieve the desired acceleration
    given by ``known_vdot``.)""";
        } CalcInverseDynamics;
        // Symbol: drake::multibody::MultibodyPlant::CalcJacobianAngularVelocity
        struct /* CalcJacobianAngularVelocity */ {
          // Source: drake/multibody/plant/multibody_plant.h:3024
          const char* doc =
R"""(Calculates J𝑠_w_AB, a frame B's angular velocity Jacobian in a frame A
with respect to "speeds" 𝑠.


::

    J𝑠_w_AB ≜ [ ∂(w_AB)/∂𝑠₁,  ...  ∂(w_AB)/∂𝑠ₙ ]    (n is j or k)
         w_AB = J𝑠_w_AB ⋅ 𝑠          w_AB is linear in 𝑠 ≜ [𝑠₁ ... 𝑠ₙ]ᵀ

``w_AB`` is B's angular velocity in frame A and "speeds" 𝑠 is either
q̇ ≜ [q̇₁ ... q̇ⱼ]ᵀ (time-derivatives of j generalized positions) or v
≜ [v₁ ... vₖ]ᵀ (k generalized velocities).

Parameter ``context``:
    The state of the multibody system.

Parameter ``with_respect_to``:
    Enum equal to JacobianWrtVariable::kQDot or
    JacobianWrtVariable::kV, indicating whether the Jacobian
    ``J𝑠_w_AB`` is partial derivatives with respect to 𝑠 = q̇
    (time-derivatives of generalized positions) or with respect to 𝑠 =
    v (generalized velocities).

Parameter ``frame_B``:
    The frame B in ``w_AB`` (B's angular velocity in A).

Parameter ``frame_A``:
    The frame A in ``w_AB`` (B's angular velocity in A).

Parameter ``frame_E``:
    The frame in which ``w_AB`` is expressed on input and the frame in
    which the Jacobian ``J𝑠_w_AB`` is expressed on output.

Parameter ``J𝑠_w_AB_E``:
    Frame B's angular velocity Jacobian in frame A with respect to
    speeds 𝑠 (which is either q̇ or v), expressed in frame E. The
    Jacobian is a function of only generalized positions q (which are
    pulled from the context). The previous definition shows
    ``J𝑠_w_AB_E`` is a matrix of size ``3 x n``, where n is the number
    of elements in 𝑠.

Raises:
    RuntimeError if ``J𝑠_w_AB_E`` is nullptr or not of size ``3 x n``.)""";
        } CalcJacobianAngularVelocity;
        // Symbol: drake::multibody::MultibodyPlant::CalcJacobianCenterOfMassTranslationalVelocity
        struct /* CalcJacobianCenterOfMassTranslationalVelocity */ {
          // Source: drake/multibody/plant/multibody_plant.h:3111
          const char* doc =
R"""(This method computes J𝑠_v_ACcm_E, point Ccm's translational velocity
Jacobian in frame A with respect to "speeds" 𝑠, expressed in frame E,
where point Ccm is the composite center of mass of the system of all
bodies in the MultibodyPlant (except world_body()).

Parameter ``context``:
    The state of the multibody system.

Parameter ``with_respect_to``:
    Enum equal to JacobianWrtVariable::kQDot or
    JacobianWrtVariable::kV, indicating whether the Jacobian
    ``J𝑠_v_ACcm_E`` is partial derivatives with respect to 𝑠 = q̇
    (time-derivatives of generalized positions) or with respect to 𝑠 =
    v (generalized velocities).

Parameter ``frame_A``:
    The frame in which the translational velocity v_ACcm and its
    Jacobian J𝑠_v_ACcm are measured.

Parameter ``frame_E``:
    The frame in which the Jacobian J𝑠_v_ACcm is expressed on output.

Parameter ``J𝑠_v_ACcm_E``:
    Point Ccm's translational velocity Jacobian in frame A with
    respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E.
    J𝑠_v_ACcm_E is a 3 x n matrix, where n is the number of elements
    in 𝑠. The Jacobian is a function of only generalized positions q
    (which are pulled from the context).

Raises:
    RuntimeError if CCm does not exist, which occurs if there are no
    massive bodies in MultibodyPlant (except world_body()).

Raises:
    RuntimeError if composite_mass <= 0, where composite_mass is the
    total mass of all bodies except world_body() in MultibodyPlant.)""";
        } CalcJacobianCenterOfMassTranslationalVelocity;
        // Symbol: drake::multibody::MultibodyPlant::CalcJacobianSpatialVelocity
        struct /* CalcJacobianSpatialVelocity */ {
          // Source: drake/multibody/plant/multibody_plant.h:2985
          const char* doc =
R"""(For one point Bp fixed/welded to a frame B, calculates J𝑠_V_ABp, Bp's
spatial velocity Jacobian in frame A with respect to "speeds" 𝑠.


::

    J𝑠_V_ABp ≜ [ ∂(V_ABp)/∂𝑠₁,  ...  ∂(V_ABp)/∂𝑠ₙ ]    (n is j or k)
         V_ABp = J𝑠_V_ABp ⋅ 𝑠          V_ABp is linear in 𝑠 ≜ [𝑠₁ ... 𝑠ₙ]ᵀ

``V_ABp`` is Bp's spatial velocity in frame A and "speeds" 𝑠 is either
q̇ ≜ [q̇₁ ... q̇ⱼ]ᵀ (time-derivatives of j generalized positions) or v
≜ [v₁ ... vₖ]ᵀ (k generalized velocities).

Parameter ``context``:
    The state of the multibody system.

Parameter ``with_respect_to``:
    Enum equal to JacobianWrtVariable::kQDot or
    JacobianWrtVariable::kV, indicating whether the Jacobian
    ``J𝑠_V_ABp`` is partial derivatives with respect to 𝑠 = q̇
    (time-derivatives of generalized positions) or with respect to 𝑠 =
    v (generalized velocities).

Parameter ``frame_B``:
    The frame on which point Bp is fixed/welded.

Parameter ``p_BoBp_B``:
    A position vector from Bo (frame_B's origin) to point Bp (regarded
    as fixed/welded to B), expressed in frame_B.

Parameter ``frame_A``:
    The frame that measures ``v_ABp`` (Bp's velocity in A). Note: It
    is natural to wonder why there is no parameter p_AoAp_A (similar
    to the parameter p_BoBp_B for frame_B). There is no need for
    p_AoAp_A because Bp's velocity in A is defined as the derivative
    in frame A of Bp's position vector from *any* point fixed to A.

Parameter ``frame_E``:
    The frame in which ``v_ABp`` is expressed on input and the frame
    in which the Jacobian ``J𝑠_V_ABp`` is expressed on output.

Parameter ``J𝑠_V_ABp_E``:
    Point Bp's spatial velocity Jacobian in frame A with respect to
    speeds 𝑠 (which is either q̇ or v), expressed in frame E.
    ``J𝑠_V_ABp_E`` is a ``6 x n`` matrix, where n is the number of
    elements in 𝑠. The Jacobian is a function of only generalized
    positions q (which are pulled from the context). Note: The
    returned ``6 x n`` matrix stores frame B's angular velocity
    Jacobian in A in rows 1-3 and stores point Bp's translational
    velocity Jacobian in A in rows 4-6, i.e.,


::

    J𝑠_w_AB_E = J𝑠_V_ABp_E.topRows<3>();
        J𝑠_v_ABp_E = J𝑠_V_ABp_E.bottomRows<3>();

Note: Consider CalcJacobianTranslationalVelocity() for multiple points
fixed to frame B and consider CalcJacobianAngularVelocity() to
calculate frame B's angular velocity Jacobian.

Raises:
    RuntimeError if ``J𝑠_V_ABp_E`` is nullptr or not sized ``6 x n``.)""";
        } CalcJacobianSpatialVelocity;
        // Symbol: drake::multibody::MultibodyPlant::CalcJacobianTranslationalVelocity
        struct /* CalcJacobianTranslationalVelocity */ {
          // Source: drake/multibody/plant/multibody_plant.h:3074
          const char* doc =
R"""(For each point Bi affixed/welded to a frame B, calculates J𝑠_v_ABi,
Bi's translational velocity Jacobian in frame A with respect to
"speeds" 𝑠.


::

    J𝑠_v_ABi ≜ [ ∂(v_ABi)/∂𝑠₁,  ...  ∂(v_ABi)/∂𝑠ₙ ]    (n is j or k)
         v_ABi = J𝑠_v_ABi ⋅ 𝑠          v_ABi is linear in 𝑠 ≜ [𝑠₁ ... 𝑠ₙ]ᵀ

``v_ABi`` is Bi's translational velocity in frame A and "speeds" 𝑠 is
either q̇ ≜ [q̇₁ ... q̇ⱼ]ᵀ (time-derivatives of j generalized
positions) or v ≜ [v₁ ... vₖ]ᵀ (k generalized velocities).

Parameter ``context``:
    The state of the multibody system.

Parameter ``with_respect_to``:
    Enum equal to JacobianWrtVariable::kQDot or
    JacobianWrtVariable::kV, indicating whether the Jacobian
    ``J𝑠_v_ABi`` is partial derivatives with respect to 𝑠 = q̇
    (time-derivatives of generalized positions) or with respect to 𝑠 =
    v (generalized velocities).

Parameter ``frame_B``:
    The frame on which point Bi is affixed/welded.

Parameter ``p_BoBi_B``:
    A position vector or list of p position vectors from Bo (frame_B's
    origin) to points Bi (regarded as affixed to B), where each
    position vector is expressed in frame_B.

Parameter ``frame_A``:
    The frame that measures ``v_ABi`` (Bi's velocity in A). Note: It
    is natural to wonder why there is no parameter p_AoAi_A (similar
    to the parameter p_BoBi_B for frame_B). There is no need for
    p_AoAi_A because Bi's velocity in A is defined as the derivative
    in frame A of Bi's position vector from *any* point affixed to A.

Parameter ``frame_E``:
    The frame in which ``v_ABi`` is expressed on input and the frame
    in which the Jacobian ``J𝑠_v_ABi`` is expressed on output.

Parameter ``J𝑠_v_ABi_E``:
    Point Bi's velocity Jacobian in frame A with respect to speeds 𝑠
    (which is either q̇ or v), expressed in frame E. ``J𝑠_v_ABi_E`` is
    a ``3*p x n`` matrix, where p is the number of points Bi and n is
    the number of elements in 𝑠. The Jacobian is a function of only
    generalized positions q (which are pulled from the context).

Raises:
    RuntimeError if ``J𝑠_v_ABi_E`` is nullptr or not sized ``3*p x
    n``.

Note:
    When 𝑠 = q̇, ``Jq̇_v_ABi = Jq_p_AoBi``. In other words, point Bi's
    velocity Jacobian in frame A with respect to q̇ is equal to point
    Bi's position Jacobian from Ao (A's origin) in frame A with
    respect to q.


::

    [∂(v_ABi)/∂q̇₁,  ...  ∂(v_ABi)/∂q̇ⱼ] = [∂(p_AoBi)/∂q₁,  ...  ∂(p_AoBi)/∂qⱼ]

Note: Each partial derivative of p_AoBi is taken in frame A.)""";
        } CalcJacobianTranslationalVelocity;
        // Symbol: drake::multibody::MultibodyPlant::CalcMassMatrix
        struct /* CalcMassMatrix */ {
          // Source: drake/multibody/plant/multibody_plant.h:2817
          const char* doc =
R"""(Performs the computation of the mass matrix ``M(q)`` of the model, as
a function of the generalized positions q stored in ``context``. This
method employs the Composite Body Algorithm, which is known to be the
fastest O(n²) algorithm to compute the mass matrix of a multibody
system.

Parameter ``context``:
    The context containing the state of the model.

Parameter ``M``:
    A valid (non-null) pointer to a squared matrix in ``ℛⁿˣⁿ`` with n
    the number of generalized velocities (num_velocities()) of the
    model. This method aborts if M is nullptr or if it does not have
    the proper size.

Warning:
    This is an O(n²) algorithm. Avoid the explicit computation of the
    mass matrix whenever possible.)""";
        } CalcMassMatrix;
        // Symbol: drake::multibody::MultibodyPlant::CalcMassMatrixViaInverseDynamics
        struct /* CalcMassMatrixViaInverseDynamics */ {
          // Source: drake/multibody/plant/multibody_plant.h:2795
          const char* doc =
R"""(Performs the computation of the mass matrix ``M(q)`` of the model
using inverse dynamics, where the generalized positions q are stored
in ``context``. See CalcInverseDynamics().

Use CalcMassMatrix() for a faster implementation using the Composite
Body Algorithm.

Parameter ``context``:
    The context containing the state of the model.

Parameter ``M``:
    A valid (non-null) pointer to a squared matrix in ``ℛⁿˣⁿ`` with n
    the number of generalized velocities (num_velocities()) of the
    model. This method aborts if H is nullptr or if it does not have
    the proper size.

The algorithm used to build ``M(q)`` consists in computing one column
of ``M(q)`` at a time using inverse dynamics. The result from inverse
dynamics, with no applied forces, is the vector of generalized forces:


::

    tau = M(q)v̇ + C(q, v)v

where q and v are the generalized positions and velocities,
respectively. When ``v = 0`` the Coriolis and gyroscopic forces term
``C(q, v)v`` is zero. Therefore the ``i-th`` column of ``M(q)`` can be
obtained performing inverse dynamics with an acceleration vector ``v̇
= eᵢ``, with ``eᵢ`` the standard (or natural) basis of ``ℛⁿ`` with n
the number of generalized velocities. We write this as:


::

    M.ᵢ(q) = M(q) * e_i

where ``M.ᵢ(q)`` (notice the dot for the rows index) denotes the
``i-th`` column in M(q).

Warning:
    This is an O(n²) algorithm. Avoid the explicit computation of the
    mass matrix whenever possible.)""";
        } CalcMassMatrixViaInverseDynamics;
        // Symbol: drake::multibody::MultibodyPlant::CalcPointsPositions
        struct /* CalcPointsPositions */ {
          // Source: drake/multibody/plant/multibody_plant.h:2419
          const char* doc =
R"""(Given the positions ``p_BQi`` for a set of points ``Qi`` measured and
expressed in a frame B, this method computes the positions
``p_AQi(q)`` of each point ``Qi`` in the set as measured and expressed
in another frame A, as a function of the generalized positions q of
the model.

Parameter ``context``:
    The context containing the state of the model. It stores the
    generalized positions q of the model.

Parameter ``frame_B``:
    The frame B in which the positions ``p_BQi`` of a set of points
    ``Qi`` are given.

Parameter ``p_BQi``:
    The input positions of each point ``Qi`` in frame B. ``p_BQi ∈
    ℝ³ˣⁿᵖ`` with ``np`` the number of points in the set. Each column
    of ``p_BQi`` corresponds to a vector in ℝ³ holding the position of
    one of the points in the set as measured and expressed in frame B.

Parameter ``frame_A``:
    The frame A in which it is desired to compute the positions
    ``p_AQi`` of each point ``Qi`` in the set.

Parameter ``p_AQi``:
    The output positions of each point ``Qi`` now computed as measured
    and expressed in frame A. The output ``p_AQi`` **must** have the
    same size as the input ``p_BQi`` or otherwise this method aborts.
    That is ``p_AQi`` **must** be in ``ℝ³ˣⁿᵖ``.

Note:
    Both ``p_BQi`` and ``p_AQi`` must have three rows. Otherwise this
    method will throw a RuntimeError exception. This method also
    throws a RuntimeError exception if ``p_BQi`` and ``p_AQi`` differ
    in the number of columns.)""";
        } CalcPointsPositions;
        // Symbol: drake::multibody::MultibodyPlant::CalcRelativeRotationMatrix
        struct /* CalcRelativeRotationMatrix */ {
          // Source: drake/multibody/plant/multibody_plant.h:2381
          const char* doc =
R"""(Calculates the rotation matrix ``R_FG`` relating frame F and frame G.

Parameter ``context``:
    The state of the multibody system, which includes the system's
    generalized positions q. Note: ``R_FG`` is a function of q.

Parameter ``frame_F``:
    The frame F designated in the rigid transform ``R_FG``.

Parameter ``frame_G``:
    The frame G designated in the rigid transform ``R_FG``.

Returns ``R_FG``:
    The RigidTransform relating frame F and frame G.)""";
        } CalcRelativeRotationMatrix;
        // Symbol: drake::multibody::MultibodyPlant::CalcRelativeTransform
        struct /* CalcRelativeTransform */ {
          // Source: drake/multibody/plant/multibody_plant.h:2363
          const char* doc =
R"""(Calculates the rigid transform (pose) ``X_FG`` relating frame F and
frame G.

Parameter ``context``:
    The state of the multibody system, which includes the system's
    generalized positions q. Note: ``X_FG`` is a function of q.

Parameter ``frame_F``:
    The frame F designated in the rigid transform ``X_FG``.

Parameter ``frame_G``:
    The frame G designated in the rigid transform ``X_FG``.

Returns ``X_FG``:
    The RigidTransform relating frame F and frame G.)""";
        } CalcRelativeTransform;
        // Symbol: drake::multibody::MultibodyPlant::CalcSpatialAccelerationsFromVdot
        struct /* CalcSpatialAccelerationsFromVdot */ {
          // Source: drake/multibody/plant/multibody_plant.h:2584
          const char* doc =
R"""(Given the state of this model in ``context`` and a known vector of
generalized accelerations ``known_vdot``, this method computes the
spatial acceleration ``A_WB`` for each body as measured and expressed
in the world frame W.

Parameter ``context``:
    The context containing the state of this model.

Parameter ``known_vdot``:
    A vector with the generalized accelerations for the full model.

Parameter ``A_WB_array``:
    A pointer to a valid, non nullptr, vector of spatial accelerations
    containing the spatial acceleration ``A_WB`` for each body. It
    must be of size equal to the number of bodies in the model. On
    output, entries will be ordered by BodyIndex.

Raises:
    RuntimeError if A_WB_array is not of size ``num_bodies()``.)""";
        } CalcSpatialAccelerationsFromVdot;
        // Symbol: drake::multibody::MultibodyPlant::CalcSpatialMomentumInWorldAboutPoint
        struct /* CalcSpatialMomentumInWorldAboutPoint */ {
          // Source: drake/multibody/plant/multibody_plant.h:2526
          const char* doc_2args =
R"""(This method returns the spatial momentum of ``this`` MultibodyPlant in
the world frame W, about a designated point P, expressed in the world
frame W.

Parameter ``context``:
    Contains the state of the model.

Parameter ``p_WoP_W``:
    Position from Wo (origin of the world frame W) to an arbitrary
    point P, expressed in the world frame W.

Returns ``L_WSP_W``:
    , spatial momentum of the system S represented by ``this`` plant,
    measured in the world frame W, about point P, expressed in W.

Note:
    To calculate the spatial momentum of this system S in W about Scm
    (the system's center of mass), use something like:


::

    MultibodyPlant<T> plant;
      // ... code to load a model ....
      const Vector3<T> p_WoScm_W =
        plant.CalcCenterOfMassPositionInWorld(context);
      const SpatialMomentum<T> L_WScm_W =
        plant.CalcSpatialMomentumInWorldAboutPoint(context, p_WoScm_W);)""";
          // Source: drake/multibody/plant/multibody_plant.h:2560
          const char* doc_3args =
R"""(This method returns the spatial momentum of a set of model instances
in the world frame W, about a designated point P, expressed in frame
W.

Parameter ``context``:
    Contains the state of the model.

Parameter ``model_instances``:
    Set of selected model instances.

Parameter ``p_WoP_W``:
    Position from Wo (origin of the world frame W) to an arbitrary
    point P, expressed in the world frame W.

Returns ``L_WSP_W``:
    , spatial momentum of the system S represented by the
    model_instances, measured in world frame W, about point P,
    expressed in W.

Note:
    To calculate the spatial momentum of this system S in W about Scm
    (the system's center of mass), use something like:


::

    MultibodyPlant<T> plant;
      // ... code to create a set of selected model instances, e.g., ...
      const ModelInstanceIndex gripper_model_instance =
        plant.GetModelInstanceByName("gripper");
      const ModelInstanceIndex robot_model_instance =
        plant.GetBodyByName("end_effector").model_instance();
      const std::vector<ModelInstanceIndex> model_instances{
        gripper_model_instance, robot_model_instance};
      const Vector3<T> p_WoScm_W =
        plant.CalcCenterOfMassPositionInWorld(context, model_instances);
      SpatialMomentum<T> L_WScm_W =
        plant.CalcSpatialMomentumInWorldAboutPoint(context, model_instances,
                                                   p_WoScm_W);

Raises:
    RuntimeError if model_instances contains an invalid
    ModelInstanceIndex.)""";
        } CalcSpatialMomentumInWorldAboutPoint;
        // Symbol: drake::multibody::MultibodyPlant::CollectRegisteredGeometries
        struct /* CollectRegisteredGeometries */ {
          // Source: drake/multibody/plant/multibody_plant.h:1337
          const char* doc =
R"""(For each of the provided ``bodies``, collects up all geometries that
have been registered to that body. Intended to be used in conjunction
with SceneGraph::ExcludeCollisionsWithin() and
SceneGraph::ExcludeCollisionsBetween() to filter collisions between
the geometries registered to the bodies.

For example:


::

    // Don't report on collisions between geometries affixed to ``body1``,
    // ``body2``, or ``body3``.
    std::vector<const RigidBody<T>*> bodies{&body1, &body2, &body3};
    geometry::GeometrySet set = plant.CollectRegisteredGeometries(bodies);
    scene_graph.ExcludeCollisionsWithin(set);

Note:
    There is a *very* specific order of operations:

1. Bodies and geometries must be added to the MultibodyPlant.
2. The MultibodyPlant must be finalized (via Finalize()).
3. Create GeometrySet instances from bodies (via this method).
4. Invoke SceneGraph::ExcludeCollisions*() to filter collisions.
5. Allocate context.

Changing the order will cause exceptions to be thrown.

Raises:
    RuntimeError if called pre-finalize.)""";
        } CollectRegisteredGeometries;
        // Symbol: drake::multibody::MultibodyPlant::EvalBodyPoseInWorld
        struct /* EvalBodyPoseInWorld */ {
          // Source: drake/multibody/plant/multibody_plant.h:2286
          const char* doc =
R"""(Evaluate the pose ``X_WB`` of a body B in the world frame W.

Parameter ``context``:
    The context storing the state of the model.

Parameter ``body_B``:
    The body B for which the pose is requested.

Returns ``X_WB``:
    The pose of body frame B in the world frame W.

Raises:
    RuntimeError if Finalize() was not called on ``this`` model or if
    ``body_B`` does not belong to this model.)""";
        } EvalBodyPoseInWorld;
        // Symbol: drake::multibody::MultibodyPlant::EvalBodySpatialAccelerationInWorld
        struct /* EvalBodySpatialAccelerationInWorld */ {
          // Source: drake/multibody/plant/multibody_plant.h:2317
          const char* doc =
R"""(Evaluates A_WB, body B's spatial acceleration in the world frame W.

Parameter ``context``:
    The context storing the state of the model.

Parameter ``body_B``:
    The body for which spatial acceleration is requested.

Returns ``A_WB_W``:
    Body B's spatial acceleration in the world frame W, expressed in W
    (for point Bo, the body's origin).

Raises:
    RuntimeError if Finalize() was not called on ``this`` model or if
    ``body_B`` does not belong to this model.

Note:
    When cached values are out of sync with the state stored in
    context, this method performs an expensive forward dynamics
    computation, whereas once evaluated, successive calls to this
    method are inexpensive.)""";
        } EvalBodySpatialAccelerationInWorld;
        // Symbol: drake::multibody::MultibodyPlant::EvalBodySpatialVelocityInWorld
        struct /* EvalBodySpatialVelocityInWorld */ {
          // Source: drake/multibody/plant/multibody_plant.h:2300
          const char* doc =
R"""(Evaluates V_WB, body B's spatial velocity in the world frame W.

Parameter ``context``:
    The context storing the state of the model.

Parameter ``body_B``:
    The body B for which the spatial velocity is requested.

Returns ``V_WB_W``:
    Body B's spatial velocity in the world frame W, expressed in W
    (for point Bo, the body's origin).

Raises:
    RuntimeError if Finalize() was not called on ``this`` model or if
    ``body_B`` does not belong to this model.)""";
        } EvalBodySpatialVelocityInWorld;
        // Symbol: drake::multibody::MultibodyPlant::EvalPointPairPenetrations
        struct /* EvalPointPairPenetrations */ {
          // Source: drake/multibody/plant/multibody_plant.h:2331
          const char* doc =
R"""(Evaluates all point pairs of contact for a given state of the model
stored in ``context``. Each entry in the returned vector corresponds
to a single point pair corresponding to two interpenetrating bodies A
and B. The size of the returned vector corresponds to the total number
of contact penetration pairs. If no geometry was registered, the
output vector is empty.

See also:
    mbp_geometry "Geometry" for geometry registration.

See also:
    PenetrationAsPointPair for further details on the returned data.

Raises:
    RuntimeError if called pre-finalize. See Finalize().)""";
        } EvalPointPairPenetrations;
        // Symbol: drake::multibody::MultibodyPlant::ExcludeCollisionGeometriesWithCollisionFilterGroupPair
        struct /* ExcludeCollisionGeometriesWithCollisionFilterGroupPair */ {
          // Source: drake/multibody/plant/multibody_plant.h:1305
          const char* doc =
R"""(Excludes the collision geometries between two given collision filter
groups.

Precondition:
    RegisterAsSourceForSceneGraph() has been called.

Precondition:
    Finalize() has *not* been called.)""";
        } ExcludeCollisionGeometriesWithCollisionFilterGroupPair;
        // Symbol: drake::multibody::MultibodyPlant::Finalize
        struct /* Finalize */ {
          // Source: drake/multibody/plant/multibody_plant.h:1119
          const char* doc =
R"""(This method must be called after all elements in the model (joints,
bodies, force elements, constraints, etc.) are added and before any
computations are performed. It essentially compiles all the necessary
"topological information", i.e. how bodies, joints and, any other
elements connect with each other, and performs all the required
pre-processing to enable computations at a later stage.

If the finalize stage is successful, the topology of this
MultibodyPlant is valid, meaning that the topology is up-to-date after
this call. No more multibody elements can be added after a call to
Finalize().

At Finalize(), state and input/output ports for ``this`` plant are
declared. If ``this`` plant registered geometry with a SceneGraph,
input and output ports to enable communication with that SceneGraph
are declared as well.

If geometry has been registered on a SceneGraph instance, that
instance must be provided to the Finalize() method so that any
geometric implications of the finalization process can be
appropriately handled.

See also:
    is_finalized().

Raises:
    RuntimeError if the MultibodyPlant has already been finalized.)""";
        } Finalize;
        // Symbol: drake::multibody::MultibodyPlant::GetAccelerationLowerLimits
        struct /* GetAccelerationLowerLimits */ {
          // Source: drake/multibody/plant/multibody_plant.h:3746
          const char* doc =
R"""(Returns a vector of size ``num_velocities()`` containing the lower
acceleration limits for every generalized velocity coordinate. These
include joint and free body coordinates. Any unbounded or unspecified
limits will be -infinity.

Raises:
    RuntimeError if called pre-finalize.)""";
        } GetAccelerationLowerLimits;
        // Symbol: drake::multibody::MultibodyPlant::GetAccelerationUpperLimits
        struct /* GetAccelerationUpperLimits */ {
          // Source: drake/multibody/plant/multibody_plant.h:3753
          const char* doc =
R"""(Upper limit analog of GetAccelerationsLowerLimits(), where any
unbounded or unspecified limits will be +infinity.

See also:
    GetAccelerationLowerLimits() for more information.)""";
        } GetAccelerationUpperLimits;
        // Symbol: drake::multibody::MultibodyPlant::GetActuationFromArray
        struct /* GetActuationFromArray */ {
          // Source: drake/multibody/plant/multibody_plant.h:1996
          const char* doc =
R"""(Returns a vector of actuation values for ``model_instance`` from a
vector ``u`` of actuation values for the entire model. This method
throws an exception if ``u`` is not of size
MultibodyPlant::num_actuated_dofs().)""";
        } GetActuationFromArray;
        // Symbol: drake::multibody::MultibodyPlant::GetBodiesWeldedTo
        struct /* GetBodiesWeldedTo */ {
          // Source: drake/multibody/plant/multibody_plant.h:3398
          const char* doc =
R"""(Returns all bodies that are transitively welded, or rigidly affixed,
to ``body``, per these two definitions:

1. A body is always considered welded to itself.
2. Two unique bodies are considered welded together exclusively by the
presence of a weld joint, not by other constructs that prevent mobility
(e.g. constraints).

This method can be called at any time during the lifetime of ``this``
plant, either pre- or post-finalize, see Finalize().

Meant to be used with ``CollectRegisteredGeometries``.

The following example demonstrates filtering collisions between all
bodies rigidly affixed to a door (which could be moving) and all
bodies rigidly affixed to the world:


::

    GeometrySet g_world = plant.CollectRegisteredGeometries(
        plant.GetBodiesWeldedTo(plant.world_body()));
    GeometrySet g_door = plant.CollectRegisteredGeometries(
        plant.GetBodiesWeldedTo(plant.GetBodyByName("door")));
    scene_graph.ExcludeCollisionsBetweeen(g_world, g_door);

Note:
    Usages akin to this example may introduce redundant collision
    filtering; this will not have a functional impact, but may have a
    minor performance impact.

Returns:
    all bodies rigidly fixed to ``body``. This does not return the
    bodies in any prescribed order.

Raises:
    RuntimeError if ``body`` is not part of this plant.)""";
        } GetBodiesWeldedTo;
        // Symbol: drake::multibody::MultibodyPlant::GetBodyByName
        struct /* GetBodyByName */ {
          // Source: drake/multibody/plant/multibody_plant.h:3323
          const char* doc_1args =
R"""(Returns a constant reference to a body that is identified by the
string ``name`` in ``this`` MultibodyPlant.

Raises:
    RuntimeError if there is no body with the requested name.

Raises:
    RuntimeError if the body name occurs in multiple model instances.

See also:
    HasBodyNamed() to query if there exists a body in ``this``
    MultibodyPlant with a given specified name.)""";
          // Source: drake/multibody/plant/multibody_plant.h:3332
          const char* doc_2args =
R"""(Returns a constant reference to the body that is uniquely identified
by the string ``name`` and ``model_instance`` in ``this``
MultibodyPlant.

Raises:
    RuntimeError if there is no body with the requested name.

See also:
    HasBodyNamed() to query if there exists a body in ``this``
    MultibodyPlant with a given specified name.)""";
        } GetBodyByName;
        // Symbol: drake::multibody::MultibodyPlant::GetBodyFrameIdIfExists
        struct /* GetBodyFrameIdIfExists */ {
          // Source: drake/multibody/plant/multibody_plant.h:1350
          const char* doc =
R"""(If the body with ``body_index`` belongs to the called plant, it
returns the geometry::FrameId associated with it. Otherwise, it
returns nullopt.)""";
        } GetBodyFrameIdIfExists;
        // Symbol: drake::multibody::MultibodyPlant::GetBodyFrameIdOrThrow
        struct /* GetBodyFrameIdOrThrow */ {
          // Source: drake/multibody/plant/multibody_plant.h:1364
          const char* doc =
R"""(If the body with ``body_index`` belongs to the called plant, it
returns the geometry::FrameId associated with it. Otherwise this
method throws an exception.

Raises:
    RuntimeError if the called plant does not have the body indicated
    by ``body_index``.)""";
        } GetBodyFrameIdOrThrow;
        // Symbol: drake::multibody::MultibodyPlant::GetBodyFromFrameId
        struct /* GetBodyFromFrameId */ {
          // Source: drake/multibody/plant/multibody_plant.h:1342
          const char* doc =
R"""(Given a geometry frame identifier, returns a pointer to the body
associated with that id (nullptr if there is no such body).)""";
        } GetBodyFromFrameId;
        // Symbol: drake::multibody::MultibodyPlant::GetBodyIndices
        struct /* GetBodyIndices */ {
          // Source: drake/multibody/plant/multibody_plant.h:3338
          const char* doc =
R"""(Returns a list of body indices associated with ``model_instance``.)""";
        } GetBodyIndices;
        // Symbol: drake::multibody::MultibodyPlant::GetCollisionGeometriesForBody
        struct /* GetCollisionGeometriesForBody */ {
          // Source: drake/multibody/plant/multibody_plant.h:1298
          const char* doc =
R"""(Returns an array of GeometryId's identifying the different contact
geometries for ``body`` previously registered with a SceneGraph.

Note:
    This method can be called at any time during the lifetime of
    ``this`` plant, either pre- or post-finalize, see Finalize().
    Post-finalize calls will always return the same value.

See also:
    RegisterCollisionGeometry(), Finalize())""";
        } GetCollisionGeometriesForBody;
        // Symbol: drake::multibody::MultibodyPlant::GetDefaultFreeBodyPose
        struct /* GetDefaultFreeBodyPose */ {
          // Source: drake/multibody/plant/multibody_plant.h:2150
          const char* doc =
R"""(Gets the default pose of ``body`` as set by SetDefaultFreeBodyPose().

Parameter ``body``:
    Body whose default pose will be retrieved.)""";
        } GetDefaultFreeBodyPose;
        // Symbol: drake::multibody::MultibodyPlant::GetFloatingBaseBodies
        struct /* GetFloatingBaseBodies */ {
          // Source: drake/multibody/plant/multibody_plant.h:2092
          const char* doc =
R"""(Returns the set of body indexes corresponding to the free (floating)
bodies in the model, in no particular order.

Raises:
    RuntimeError if called pre-finalize, see Finalize().)""";
        } GetFloatingBaseBodies;
        // Symbol: drake::multibody::MultibodyPlant::GetForceElement
        struct /* GetForceElement */ {
          // Source: drake/multibody/plant/multibody_plant.h:3625
          const char* doc =
R"""(Returns a constant reference to a force element identified by its
unique index in ``this`` MultibodyPlant. If the optional template
argument is supplied, then the returned value is downcast to the
specified ``ForceElementType``.

Template parameter ``ForceElementType``:
    The specific type of the ForceElement to be retrieved. It must be
    a subclass of ForceElement.

Raises:
    RuntimeError if the force element is not of type
    ``ForceElementType`` or if there is no ForceElement with that
    index.)""";
        } GetForceElement;
        // Symbol: drake::multibody::MultibodyPlant::GetFrameByName
        struct /* GetFrameByName */ {
          // Source: drake/multibody/plant/multibody_plant.h:3509
          const char* doc_1args =
R"""(Returns a constant reference to a frame that is identified by the
string ``name`` in ``this`` model.

Raises:
    RuntimeError if there is no frame with the requested name.

Raises:
    RuntimeError if the frame name occurs in multiple model instances.

See also:
    HasFrameNamed() to query if there exists a frame in ``this`` model
    with a given specified name.)""";
          // Source: drake/multibody/plant/multibody_plant.h:3520
          const char* doc_2args =
R"""(Returns a constant reference to the frame that is uniquely identified
by the string ``name`` in ``model_instance``.

Raises:
    RuntimeError if there is no frame with the requested name.

Raises:
    RuntimeError if ``model_instance`` is not valid for this model.

See also:
    HasFrameNamed() to query if there exists a frame in ``this`` model
    with a given specified name.)""";
        } GetFrameByName;
        // Symbol: drake::multibody::MultibodyPlant::GetFreeBodyPose
        struct /* GetFreeBodyPose */ {
          // Source: drake/multibody/plant/multibody_plant.h:2100
          const char* doc =
R"""(Gets the pose of a given ``body`` in the world frame W.

Note:
    In general getting the pose of a body in the model would involve
    solving the kinematics. This method allows us to simplify this
    process when we know the body is free in space.

Raises:
    RuntimeError if ``body`` is not a free body in the model.

Raises:
    RuntimeError if called pre-finalize.)""";
        } GetFreeBodyPose;
        // Symbol: drake::multibody::MultibodyPlant::GetJointActuatorByName
        struct /* GetJointActuatorByName */ {
          // Source: drake/multibody/plant/multibody_plant.h:3585
          const char* doc_1args =
R"""(Returns a constant reference to an actuator that is identified by the
string ``name`` in ``this`` MultibodyPlant.

Raises:
    RuntimeError if there is no actuator with the requested name.

Raises:
    RuntimeError if the actuator name occurs in multiple model
    instances.

See also:
    HasJointActuatorNamed() to query if there exists an actuator in
    ``this`` MultibodyPlant with a given specified name.)""";
          // Source: drake/multibody/plant/multibody_plant.h:3596
          const char* doc_2args =
R"""(Returns a constant reference to the actuator that is uniquely
identified by the string ``name`` and ``model_instance`` in ``this``
MultibodyPlant.

Raises:
    RuntimeError if there is no actuator with the requested name.

Raises:
    RuntimeError if ``model_instance`` is not valid for this model.

See also:
    HasJointActuatorNamed() to query if there exists an actuator in
    ``this`` MultibodyPlant with a given specified name.)""";
        } GetJointActuatorByName;
        // Symbol: drake::multibody::MultibodyPlant::GetJointByName
        struct /* GetJointByName */ {
          // Source: drake/multibody/plant/multibody_plant.h:3454
          const char* doc =
R"""(Returns a constant reference to a joint that is identified by the
string ``name`` in ``this`` MultibodyPlant. If the optional template
argument is supplied, then the returned value is downcast to the
specified ``JointType``.

Template parameter ``JointType``:
    The specific type of the Joint to be retrieved. It must be a
    subclass of Joint.

Raises:
    RuntimeError if the named joint is not of type ``JointType`` or if
    there is no Joint with that name.

Raises:
    RuntimeError if ``model_instance`` is not valid for this model.

See also:
    HasJointNamed() to query if there exists a joint in ``this``
    MultibodyPlant with a given specified name.)""";
        } GetJointByName;
        // Symbol: drake::multibody::MultibodyPlant::GetJointIndices
        struct /* GetJointIndices */ {
          // Source: drake/multibody/plant/multibody_plant.h:3437
          const char* doc =
R"""(Returns a list of joint indices associated with ``model_instance``.)""";
        } GetJointIndices;
        // Symbol: drake::multibody::MultibodyPlant::GetModelInstanceByName
        struct /* GetModelInstanceByName */ {
          // Source: drake/multibody/plant/multibody_plant.h:3666
          const char* doc =
R"""(Returns the index to the model instance that is uniquely identified by
the string ``name`` in ``this`` MultibodyPlant.

Raises:
    RuntimeError if there is no instance with the requested name.

See also:
    HasModelInstanceNamed() to query if there exists an instance in
    ``this`` MultibodyPlant with a given specified name.)""";
        } GetModelInstanceByName;
        // Symbol: drake::multibody::MultibodyPlant::GetModelInstanceName
        struct /* GetModelInstanceName */ {
          // Source: drake/multibody/plant/multibody_plant.h:3650
          const char* doc =
R"""(Returns the name of a ``model_instance``.

Raises:
    RuntimeError when ``model_instance`` does not correspond to a
    model in this model.)""";
        } GetModelInstanceName;
        // Symbol: drake::multibody::MultibodyPlant::GetMutableJointByName
        struct /* GetMutableJointByName */ {
          // Source: drake/multibody/plant/multibody_plant.h:3464
          const char* doc =
R"""(A version of GetJointByName that returns a mutable reference.

See also:
    GetJointByName.)""";
        } GetMutableJointByName;
        // Symbol: drake::multibody::MultibodyPlant::GetMutablePositions
        struct /* GetMutablePositions */ {
          // Source: drake/multibody/plant/multibody_plant.h:1788
          const char* doc_1args =
R"""((Advanced) Returns a mutable vector reference containing the vector of
generalized positions (**see warning**).

Note:
    This method returns a reference to existing data, exhibits
    constant i.e., O(1) time complexity, and runs very quickly.

Warning:
    You should use SetPositions() instead of this method unless you
    are fully aware of the possible interactions with the caching
    mechanism (see dangerous_get_mutable).

Raises:
    RuntimeError if the ``context`` is nullptr or if it does not
    correspond to the context for a multibody model.)""";
          // Source: drake/multibody/plant/multibody_plant.h:1808
          const char* doc_2args =
R"""((Advanced) Returns a mutable vector reference containing the vector of
generalized positions (**see warning**).

Note:
    This method returns a reference to existing data, exhibits
    constant i.e., O(1) time complexity, and runs very quickly.

Warning:
    You should use SetPositions() instead of this method unless you
    are fully aware of the possible interactions with the caching
    mechanism (see dangerous_get_mutable).

Raises:
    RuntimeError if the ``state`` is nullptr or if the context does
    not correspond to the context for a multibody model.

Precondition:
    ``state`` comes from this MultibodyPlant.)""";
        } GetMutablePositions;
        // Symbol: drake::multibody::MultibodyPlant::GetMutablePositionsAndVelocities
        struct /* GetMutablePositionsAndVelocities */ {
          // Source: drake/multibody/plant/multibody_plant.h:1715
          const char* doc =
R"""((Advanced) Returns a mutable vector containing the vector ``[q; v]``
of the model with ``q`` the vector of generalized positions and ``v``
the vector of generalized velocities (**see warning**).

Warning:
    You should use SetPositionsAndVelocities() instead of this method
    unless you are fully aware of the interactions with the caching
    mechanism (see dangerous_get_mutable).

Raises:
    RuntimeError if the ``context`` is nullptr or if it does not
    correspond to the context for a multibody model.)""";
        } GetMutablePositionsAndVelocities;
        // Symbol: drake::multibody::MultibodyPlant::GetMutableVelocities
        struct /* GetMutableVelocities */ {
          // Source: drake/multibody/plant/multibody_plant.h:1898
          const char* doc_2args =
R"""((Advanced) Returns a mutable vector reference containing the vector of
generalized velocities (**see warning**).

Note:
    This method returns a reference to existing data, exhibits
    constant i.e., O(1) time complexity, and runs very quickly.

Warning:
    You should use SetVelocities() instead of this method unless you
    are fully aware of the possible interactions with the caching
    mechanism (see dangerous_get_mutable).

Raises:
    RuntimeError if the ``context`` is nullptr or the context does not
    correspond to the context for a multibody model.

Precondition:
    ``state`` comes from this MultibodyPlant.)""";
          // Source: drake/multibody/plant/multibody_plant.h:1912
          const char* doc_1args =
R"""(See GetMutableVelocities() method above.)""";
        } GetMutableVelocities;
        // Symbol: drake::multibody::MultibodyPlant::GetPositionLowerLimits
        struct /* GetPositionLowerLimits */ {
          // Source: drake/multibody/plant/multibody_plant.h:3714
          const char* doc =
R"""(Returns a vector of size ``num_positions()`` containing the lower
position limits for every generalized position coordinate. These
include joint and free body coordinates. Any unbounded or unspecified
limits will be -infinity.

Raises:
    RuntimeError if called pre-finalize.)""";
        } GetPositionLowerLimits;
        // Symbol: drake::multibody::MultibodyPlant::GetPositionUpperLimits
        struct /* GetPositionUpperLimits */ {
          // Source: drake/multibody/plant/multibody_plant.h:3721
          const char* doc =
R"""(Upper limit analog of GetPositionsLowerLimits(), where any unbounded
or unspecified limits will be +infinity.

See also:
    GetPositionLowerLimits() for more information.)""";
        } GetPositionUpperLimits;
        // Symbol: drake::multibody::MultibodyPlant::GetPositions
        struct /* GetPositions */ {
          // Source: drake/multibody/plant/multibody_plant.h:1755
          const char* doc_1args =
R"""(Returns a const vector reference containing the vector of generalized
positions.

Note:
    This method returns a reference to existing data, exhibits
    constant i.e., O(1) time complexity, and runs very quickly.

Raises:
    RuntimeError if the ``context`` does not correspond to the context
    for a multibody model.)""";
          // Source: drake/multibody/plant/multibody_plant.h:1771
          const char* doc_2args =
R"""(Returns an vector containing the generalized positions (``q``) for the
given model instance.

Raises:
    RuntimeError if the ``context`` does not correspond to the context
    for a multibody model.

Note:
    returns a dense vector of dimension ``q.size()`` associated with
    ``model_instance`` in O(``q.size()``) time.)""";
        } GetPositions;
        // Symbol: drake::multibody::MultibodyPlant::GetPositionsAndVelocities
        struct /* GetPositionsAndVelocities */ {
          // Source: drake/multibody/plant/multibody_plant.h:1687
          const char* doc_1args =
R"""(Returns a const vector reference containing the vector ``[q; v]`` with
``q`` the vector of generalized positions and ``v`` the vector of
generalized velocities.

Note:
    This method returns a reference to existing data, exhibits
    constant i.e., O(1) time complexity, and runs very quickly.

Raises:
    RuntimeError if the ``context`` does not correspond to the context
    for a multibody model.)""";
          // Source: drake/multibody/plant/multibody_plant.h:1700
          const char* doc_2args =
R"""(Returns the vector ``[q; v]`` of the model with ``q`` the vector of
generalized positions and ``v`` the vector of generalized velocities
for model instance ``model_instance``.

Raises:
    RuntimeError if the ``context`` does not correspond to the context
    for a multibody model or ``model_instance`` is invalid.

Note:
    returns a dense vector of dimension ``q.size() + v.size()``
    associated with ``model_instance`` in O(``q.size()``) time.)""";
        } GetPositionsAndVelocities;
        // Symbol: drake::multibody::MultibodyPlant::GetPositionsFromArray
        struct /* GetPositionsFromArray */ {
          // Source: drake/multibody/plant/multibody_plant.h:2024
          const char* doc =
R"""(Returns a vector of generalized positions for ``model_instance`` from
a vector ``q_array`` of generalized positions for the entire model
model. This method throws an exception if ``q`` is not of size
MultibodyPlant::num_positions().)""";
        } GetPositionsFromArray;
        // Symbol: drake::multibody::MultibodyPlant::GetRigidBodyByName
        struct /* GetRigidBodyByName */ {
          // Source: drake/multibody/plant/multibody_plant.h:3351
          const char* doc_1args =
R"""(Returns a constant reference to a rigid body that is identified by the
string ``name`` in ``this`` model.

Raises:
    RuntimeError if there is no body with the requested name.

Raises:
    RuntimeError if the body name occurs in multiple model instances.

Raises:
    RuntimeError if the requested body is not a RigidBody.

See also:
    HasBodyNamed() to query if there exists a body in ``this`` model
    with a given specified name.)""";
          // Source: drake/multibody/plant/multibody_plant.h:3363
          const char* doc_2args =
R"""(Returns a constant reference to the rigid body that is uniquely
identified by the string ``name`` in ``model_instance``.

Raises:
    RuntimeError if there is no body with the requested name.

Raises:
    RuntimeError if the requested body is not a RigidBody.

Raises:
    RuntimeError if ``model_instance`` is not valid for this model.

See also:
    HasBodyNamed() to query if there exists a body in ``this`` model
    with a given specified name.)""";
        } GetRigidBodyByName;
        // Symbol: drake::multibody::MultibodyPlant::GetTopologyGraphvizString
        struct /* GetTopologyGraphvizString */ {
          // Source: drake/multibody/plant/multibody_plant.h:3675
          const char* doc =
R"""(Returns a Graphviz string describing the topology of this plant. To
render the string, use the Graphviz tool, ``dot``.
http://www.graphviz.org/

Note: this method can be called either before or after ``Finalize()``.)""";
        } GetTopologyGraphvizString;
        // Symbol: drake::multibody::MultibodyPlant::GetUniqueFreeBaseBodyOrThrow
        struct /* GetUniqueFreeBaseBodyOrThrow */ {
          // Source: drake/multibody/plant/multibody_plant.h:2249
          const char* doc =
R"""(If there exists a unique base body that belongs to the model given by
``model_instance`` and that unique base body is free (see
HasUniqueBaseBody()), return that free body. Throw an exception
otherwise.

Raises:
    RuntimeError if called pre-finalize.

Raises:
    RuntimeError if ``model_instance`` is not valid.

Raises:
    RuntimeError if HasUniqueFreeBaseBody(model_instance) == false.)""";
        } GetUniqueFreeBaseBodyOrThrow;
        // Symbol: drake::multibody::MultibodyPlant::GetVelocities
        struct /* GetVelocities */ {
          // Source: drake/multibody/plant/multibody_plant.h:1864
          const char* doc_1args =
R"""(Returns a const vector reference containing the generalized
velocities.

Note:
    This method returns a reference to existing data, exhibits
    constant i.e., O(1) time complexity, and runs very quickly.)""";
          // Source: drake/multibody/plant/multibody_plant.h:1880
          const char* doc_2args =
R"""(Returns a vector containing the generalized velocities (``v``) for the
given model instance.

Raises:
    RuntimeError if the ``context`` does not correspond to the context
    for a multibody model.

Note:
    returns a dense vector of dimension ``v.size()`` associated with
    ``model_instance`` in O(``v.size()``) time.)""";
        } GetVelocities;
        // Symbol: drake::multibody::MultibodyPlant::GetVelocitiesFromArray
        struct /* GetVelocitiesFromArray */ {
          // Source: drake/multibody/plant/multibody_plant.h:2047
          const char* doc =
R"""(Returns a vector of generalized velocities for ``model_instance`` from
a vector ``v`` of generalized velocities for the entire MultibodyPlant
model. This method throws an exception if the input array is not of
size MultibodyPlant::num_velocities().)""";
        } GetVelocitiesFromArray;
        // Symbol: drake::multibody::MultibodyPlant::GetVelocityLowerLimits
        struct /* GetVelocityLowerLimits */ {
          // Source: drake/multibody/plant/multibody_plant.h:3730
          const char* doc =
R"""(Returns a vector of size ``num_velocities()`` containing the lower
velocity limits for every generalized velocity coordinate. These
include joint and free body coordinates. Any unbounded or unspecified
limits will be -infinity.

Raises:
    RuntimeError if called pre-finalize.)""";
        } GetVelocityLowerLimits;
        // Symbol: drake::multibody::MultibodyPlant::GetVelocityUpperLimits
        struct /* GetVelocityUpperLimits */ {
          // Source: drake/multibody/plant/multibody_plant.h:3737
          const char* doc =
R"""(Upper limit analog of GetVelocitysLowerLimits(), where any unbounded
or unspecified limits will be +infinity.

See also:
    GetVelocityLowerLimits() for more information.)""";
        } GetVelocityUpperLimits;
        // Symbol: drake::multibody::MultibodyPlant::GetVisualGeometriesForBody
        struct /* GetVisualGeometriesForBody */ {
          // Source: drake/multibody/plant/multibody_plant.h:1258
          const char* doc =
R"""(Returns an array of GeometryId's identifying the different visual
geometries for ``body`` previously registered with a SceneGraph.

Note:
    This method can be called at any time during the lifetime of
    ``this`` plant, either pre- or post-finalize, see Finalize().
    Post-finalize calls will always return the same value.

See also:
    RegisterVisualGeometry(), Finalize())""";
        } GetVisualGeometriesForBody;
        // Symbol: drake::multibody::MultibodyPlant::HasBodyNamed
        struct /* HasBodyNamed */ {
          // Source: drake/multibody/plant/multibody_plant.h:3302
          const char* doc_1args =
R"""(Returns:
    ``True`` if a body named ``name`` was added to the MultibodyPlant.

See also:
    AddRigidBody().

Raises:
    RuntimeError if the body name occurs in multiple model instances.)""";
          // Source: drake/multibody/plant/multibody_plant.h:3311
          const char* doc_2args =
R"""(Returns:
    ``True`` if a body named ``name`` was added to the MultibodyPlant
    in ``model_instance``.

See also:
    AddRigidBody().

Raises:
    RuntimeError if ``model_instance`` is not valid for this model.)""";
        } HasBodyNamed;
        // Symbol: drake::multibody::MultibodyPlant::HasFrameNamed
        struct /* HasFrameNamed */ {
          // Source: drake/multibody/plant/multibody_plant.h:3490
          const char* doc_1args =
R"""(Returns:
    ``True`` if a frame named ``name`` was added to the model.

See also:
    AddFrame().

Raises:
    RuntimeError if the frame name occurs in multiple model instances.)""";
          // Source: drake/multibody/plant/multibody_plant.h:3497
          const char* doc_2args =
R"""(Returns:
    ``True`` if a frame named ``name`` was added to
    ``model_instance``.

See also:
    AddFrame().

Raises:
    RuntimeError if ``model_instance`` is not valid for this model.)""";
        } HasFrameNamed;
        // Symbol: drake::multibody::MultibodyPlant::HasJointActuatorNamed
        struct /* HasJointActuatorNamed */ {
          // Source: drake/multibody/plant/multibody_plant.h:3565
          const char* doc_1args =
R"""(Returns:
    ``True`` if an actuator named ``name`` was added to this model.

See also:
    AddJointActuator().

Raises:
    RuntimeError if the actuator name occurs in multiple model
    instances.)""";
          // Source: drake/multibody/plant/multibody_plant.h:3573
          const char* doc_2args =
R"""(Returns:
    ``True`` if an actuator named ``name`` was added to
    ``model_instance``.

See also:
    AddJointActuator().

Raises:
    RuntimeError if ``model_instance`` is not valid for this model.)""";
        } HasJointActuatorNamed;
        // Symbol: drake::multibody::MultibodyPlant::HasJointNamed
        struct /* HasJointNamed */ {
          // Source: drake/multibody/plant/multibody_plant.h:3417
          const char* doc_1args =
R"""(Returns:
    ``True`` if a joint named ``name`` was added to this model.

See also:
    AddJoint().

Raises:
    RuntimeError if the joint name occurs in multiple model instances.)""";
          // Source: drake/multibody/plant/multibody_plant.h:3424
          const char* doc_2args =
R"""(Returns:
    ``True`` if a joint named ``name`` was added to
    ``model_instance``.

See also:
    AddJoint().

Raises:
    RuntimeError if ``model_instance`` is not valid for this model.)""";
        } HasJointNamed;
        // Symbol: drake::multibody::MultibodyPlant::HasModelInstanceNamed
        struct /* HasModelInstanceNamed */ {
          // Source: drake/multibody/plant/multibody_plant.h:3657
          const char* doc =
R"""(Returns:
    ``True`` if a model instance named ``name`` was added to this
    model.

See also:
    AddModelInstance().)""";
        } HasModelInstanceNamed;
        // Symbol: drake::multibody::MultibodyPlant::HasUniqueFreeBaseBody
        struct /* HasUniqueFreeBaseBody */ {
          // Source: drake/multibody/plant/multibody_plant.h:2259
          const char* doc =
R"""(Return true if there exists a unique base body in the model given by
``model_instance`` and that unique base body is free.

Raises:
    RuntimeError if called pre-finalize.

Raises:
    RuntimeError if ``model_instance`` is not valid.)""";
        } HasUniqueFreeBaseBody;
        // Symbol: drake::multibody::MultibodyPlant::IsAnchored
        struct /* IsAnchored */ {
          // Source: drake/multibody/plant/multibody_plant.h:3292
          const char* doc =
R"""(Returns ``True`` if ``body`` is anchored (i.e. the kinematic path
between ``body`` and the world only contains weld joints.)

Raises:
    RuntimeError if called pre-finalize.)""";
        } IsAnchored;
        // Symbol: drake::multibody::MultibodyPlant::MakeActuationMatrix
        struct /* MakeActuationMatrix */ {
          // Source: drake/multibody/plant/multibody_plant.h:3218
          const char* doc =
R"""(This method creates an actuation matrix B mapping a vector of
actuation values u into generalized forces ``tau_u = B * u``, where B
is a matrix of size ``nv x nu`` with ``nu`` equal to num_actuators()
and ``nv`` equal to num_velocities(). The vector u of actuation values
is of size num_actuators(). For a given JointActuator,
``u[JointActuator::index()]`` stores the value for the external
actuation corresponding to that actuator. ``tau_u`` on the other hand
is indexed by generalized velocity indexes according to
``Joint::velocity_start()``.

Warning:
    B is a permutation matrix. While making a permutation has ``O(n)``
    complexity, making a full B matrix has ``O(n²)`` complexity. For
    most applications this cost can be neglected but it could become
    significant for very large systems.)""";
        } MakeActuationMatrix;
        // Symbol: drake::multibody::MultibodyPlant::MakeActuatorSelectorMatrix
        struct /* MakeActuatorSelectorMatrix */ {
          // Source: drake/multibody/plant/multibody_plant.h:3199
          const char* doc_1args_user_to_actuator_index_map =
R"""(This method allows user to map a vector ``uₛ`` containing the
actuation for a set of selected actuators into the vector u containing
the actuation values for ``this`` full model. The mapping, or
selection, is returned in the form of a selector matrix Su such that
``u = Su⋅uₛ``. The size nₛ of uₛ is always smaller or equal than the
size of the full vector of actuation values u. That is, a user might
be interested in only a given subset of actuators in the model.

This selection matrix is particularly useful when adding PID control
on a portion of the state, see systems::controllers::PidController.

A user specifies the preferred order in uₛ via
``user_to_actuator_index_map``. The actuation values in uₛ are a
concatenation of the values for each actuator in the order they appear
in ``user_to_actuator_index_map``. The full vector of actuation values
u is ordered by JointActuatorIndex.)""";
          // Source: drake/multibody/plant/multibody_plant.h:3230
          const char* doc_1args_user_to_joint_index_map =
R"""(Alternative signature to build an actuation selector matrix ``Su``
such that ``u = Su⋅uₛ``, where u is the vector of actuation values for
the full model (ordered by JointActuatorIndex) and uₛ is a vector of
actuation values for the actuators acting on the joints listed by
``user_to_joint_index_map``. It is assumed that all joints referenced
by ``user_to_joint_index_map`` are actuated. See
MakeActuatorSelectorMatrix(const std::vector<JointActuatorIndex>&) for
details.

Raises:
    RuntimeError if any of the joints in ``user_to_joint_index_map``
    does not have an actuator.)""";
        } MakeActuatorSelectorMatrix;
        // Symbol: drake::multibody::MultibodyPlant::MakeStateSelectorMatrix
        struct /* MakeStateSelectorMatrix */ {
          // Source: drake/multibody/plant/multibody_plant.h:3176
          const char* doc =
R"""(This method allows users to map the state of ``this`` model, x, into a
vector of selected state xₛ with a given preferred ordering. The
mapping, or selection, is returned in the form of a selector matrix Sx
such that ``xₛ = Sx⋅x``. The size nₛ of xₛ is always smaller or equal
than the size of the full state x. That is, a user might be interested
in only a given portion of the full state x.

This selection matrix is particularly useful when adding PID control
on a portion of the state, see systems::controllers::PidController.

A user specifies the preferred order in xₛ via
``user_to_joint_index_map``. The selected state is built such that
selected positions are followed by selected velocities, as in ``xₛ =
[qₛ, vₛ]``. The positions in qₛ are a concatenation of the positions
for each joint in the order they appear in
``user_to_joint_index_map``. That is, the positions for
``user_to_joint_index_map[0]`` are first, followed by the positions
for ``user_to_joint_index_map[1]``, etc. Similarly for the selected
velocities vₛ.

Raises:
    RuntimeError if there are repeated indexes in
    ``user_to_joint_index_map``.)""";
        } MakeStateSelectorMatrix;
        // Symbol: drake::multibody::MultibodyPlant::MapQDotToVelocity
        struct /* MapQDotToVelocity */ {
          // Source: drake/multibody/plant/multibody_plant.h:2740
          const char* doc =
R"""(Transforms the time derivative ``qdot`` of the generalized positions
vector ``q`` (stored in ``context``) to generalized velocities ``v``.
`v` and ``q̇`` are related linearly by ``q̇ = N(q)⋅v``. Although
``N(q)`` is not necessarily square, its left pseudo-inverse ``N⁺(q)``
can be used to invert that relationship without residual error,
provided that ``qdot`` is in the range space of ``N(q)`` (that is, if
it *could* have been produced as ``q̇ = N(q)⋅v`` for some ``v``).
Using the configuration ``q`` stored in the given ``context`` this
method calculates ``v = N⁺(q)⋅q̇``.

Parameter ``context``:
    The context containing the state of the model.

Parameter ``qdot``:
    A vector containing the time derivatives of the generalized
    positions. This method aborts if ``qdot`` is not of size
    num_positions().

Parameter ``v``:
    A valid (non-null) pointer to a vector in ``ℛⁿ`` with n the number
    of generalized velocities. This method aborts if v is nullptr or
    if it is not of size num_velocities().

See also:
    MapVelocityToQDot()

See also:
    Mobilizer::MapQDotToVelocity())""";
        } MapQDotToVelocity;
        // Symbol: drake::multibody::MultibodyPlant::MapVelocityToQDot
        struct /* MapVelocityToQDot */ {
          // Source: drake/multibody/plant/multibody_plant.h:2706
          const char* doc =
R"""(Transforms generalized velocities v to time derivatives ``qdot`` of
the generalized positions vector ``q`` (stored in ``context``). `v`
and ``qdot`` are related linearly by ``q̇ = N(q)⋅v``. Using the
configuration ``q`` stored in the given ``context`` this method
calculates ``q̇ = N(q)⋅v``.

Parameter ``context``:
    The context containing the state of the model.

Parameter ``v``:
    A vector of of generalized velocities for this model. This method
    aborts if v is not of size num_velocities().

Parameter ``qdot``:
    A valid (non-null) pointer to a vector in ``ℝⁿ`` with n being the
    number of generalized positions in this model, given by
    ``num_positions()``. This method aborts if ``qdot`` is nullptr or
    if it is not of size num_positions().

See also:
    MapQDotToVelocity()

See also:
    Mobilizer::MapVelocityToQDot())""";
        } MapVelocityToQDot;
        // Symbol: drake::multibody::MultibodyPlant::MultibodyPlant<T>
        struct /* ctor */ {
          // Source: drake/multibody/plant/multibody_plant.h:759
          const char* doc =
R"""(This constructor creates a plant with a single "world" body.
Therefore, right after creation, num_bodies() returns one.

MultibodyPlant offers two different modalities to model mechanical
systems in time. These are: 1. As a discrete system with periodic
updates, ``time_step`` is strictly greater than zero. 2. As a
continuous system, ``time_step`` equals exactly zero.

Currently the discrete model is preferred for simulation given its
robustness and speed in problems with frictional contact. However this
might change as we work towards developing better strategies to model
contact. See time_advancement_strategy "Choice of Time Advancement
Strategy" for further details.

Warning:
    Users should be aware of current limitations in either modeling
    modality. While the discrete model is often the preferred option
    for problems with frictional contact given its robustness and
    speed, it might become unstable when using large feedback gains,
    high damping or large external forcing. MultibodyPlant will throw
    an exception whenever the discrete solver is detected to fail.
    Conversely, the continuous modality has the potential to leverage
    the robustness and accuracy control provide by Drake's
    integrators. However thus far this has proved difficult in
    practice and especially due to poor performance.

Parameter ``time_step``:
    Indicates whether ``this`` plant is modeled as a continuous system
    (``time_step = 0``) or as a discrete system with periodic updates
    of period ``time_step > 0``. See time_advancement_strategy "Choice
    of Time Advancement Strategy" for further details.

Warning:
    Currently the continuous modality with ``time_step = 0`` does not
    support joint limits for simulation, these are ignored.
    MultibodyPlant prints a warning to console if joint limits are
    provided. If your simulation requires joint limits currently you
    must use a discrete MultibodyPlant model.

Raises:
    RuntimeError if ``time_step`` is negative.)""";
          // Source: drake/multibody/plant/multibody_plant.h:763
          const char* doc_copyconvert =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";
        } ctor;
        // Symbol: drake::multibody::MultibodyPlant::RegisterAsSourceForSceneGraph
        struct /* RegisterAsSourceForSceneGraph */ {
          // Source: drake/multibody/plant/multibody_plant.h:1203
          const char* doc =
R"""(Registers ``this`` plant to serve as a source for an instance of
SceneGraph. This registration allows MultibodyPlant to register
geometry with ``scene_graph`` for visualization and/or collision
queries. The string returned by ``this->get_name()`` is passed to
SceneGraph's RegisterSource, so it is highly recommended that you give
the plant a recognizable name before calling this. Successive
registration calls with SceneGraph **must** be performed on the same
instance to which the pointer argument ``scene_graph`` points to.
Failure to do so will result in runtime exceptions.

Parameter ``scene_graph``:
    A valid non nullptr to the SceneGraph instance for which ``this``
    plant will sever as a source, see SceneGraph documentation for
    further details.

Returns:
    the SourceId of ``this`` plant in ``scene_graph``. It can also
    later on be retrieved with get_source_id().

Raises:
    RuntimeError if called post-finalize.

Raises:
    RuntimeError if ``scene_graph`` is the nullptr.

Raises:
    RuntimeError if called more than once.)""";
        } RegisterAsSourceForSceneGraph;
        // Symbol: drake::multibody::MultibodyPlant::RegisterCollisionGeometry
        struct /* RegisterCollisionGeometry */ {
          // Source: drake/multibody/plant/multibody_plant.h:1280
          const char* doc_5args_body_X_BG_shape_name_properties =
R"""(Registers geometry in a SceneGraph with a given geometry::Shape to be
used for the contact modeling of a given ``body``. More than one
geometry can be registered with a body, in which case the body's
contact geometry is the union of all geometries registered to that
body.

Parameter ``body``:
    The body for which geometry is being registered.

Parameter ``X_BG``:
    The fixed pose of the geometry frame G in the body frame B.

Parameter ``shape``:
    The geometry::Shape used for visualization. E.g.:
    geometry::Sphere, geometry::Cylinder, etc.

Parameter ``properties``:
    The proximity properties associated with the collision geometry.
    They *must* include the (``material``, `coulomb_friction`)
    property of type CoulombFriction<double>.

Raises:
    RuntimeError if called post-finalize or if the properties are
    missing the coulomb friction property (or if it is of the wrong
    type).)""";
          // Source: drake/multibody/plant/multibody_plant.h:1287
          const char* doc_5args_body_X_BG_shape_name_coulomb_friction =
R"""(Overload which specifies a single property: coulomb_friction.)""";
        } RegisterCollisionGeometry;
        // Symbol: drake::multibody::MultibodyPlant::RegisterVisualGeometry
        struct /* RegisterVisualGeometry */ {
          // Source: drake/multibody/plant/multibody_plant.h:1231
          const char* doc_5args_body_X_BG_shape_name_properties =
R"""(Registers geometry in a SceneGraph with a given geometry::Shape to be
used for visualization of a given ``body``.

Note:
    Currently, the visual geometry will *also* be assigned a
    perception role. Its render label's value will be equal to the
    body's index and its perception color will be the same as its
    illustration color (defaulting to gray if no color is provided).
    This behavior will change in the near future and code that
    directly relies on this behavior will break.

Parameter ``body``:
    The body for which geometry is being registered.

Parameter ``X_BG``:
    The fixed pose of the geometry frame G in the body frame B.

Parameter ``shape``:
    The geometry::Shape used for visualization. E.g.:
    geometry::Sphere, geometry::Cylinder, etc.

Parameter ``name``:
    The name for the geometry. It must satisfy the requirements
    defined in drake::geometry::GeometryInstance.

Parameter ``properties``:
    The illustration properties for this geometry.

Raises:
    RuntimeError if called post-finalize.

Raises:
    RuntimeError if ``scene_graph`` does not correspond to the same
    instance with which RegisterAsSourceForSceneGraph() was called.

Returns:
    the id for the registered geometry.)""";
          // Source: drake/multibody/plant/multibody_plant.h:1240
          const char* doc_5args_body_X_BG_shape_name_diffuse_color =
R"""(Overload for visual geometry registration; it converts the
``diffuse_color`` (RGBA with values in the range [0, 1]) into a
geometry::DrakeVisualizer-compatible set of
geometry::IllustrationProperties.)""";
          // Source: drake/multibody/plant/multibody_plant.h:1248
          const char* doc_4args_body_X_BG_shape_name =
R"""(Overload for visual geometry registration; it relies on the downstream
geometry::IllustrationProperties *consumer* to provide default
parameter values (see geometry_roles for details).)""";
        } RegisterVisualGeometry;
        // Symbol: drake::multibody::MultibodyPlant::SetActuationInArray
        struct /* SetActuationInArray */ {
          // Source: drake/multibody/plant/multibody_plant.h:2012
          const char* doc =
R"""(Given the actuation values ``u_instance`` for all actuators in
``model_instance``, this method sets the actuation vector u for the
entire model to which this actuator belongs to. This method throws an
exception if the size of ``u_instance`` is not equal to the number of
degrees of freedom of all of the actuated joints in
``model_instance``.

Parameter ``u_instance``:
    Actuation values for the actuators. It must be of size equal to
    the number of degrees of freedom of all of the actuated joints in
    ``model_instance``.

Parameter ``u``:
    The vector containing the actuation values for the entire model.)""";
        } SetActuationInArray;
        // Symbol: drake::multibody::MultibodyPlant::SetDefaultFreeBodyPose
        struct /* SetDefaultFreeBodyPose */ {
          // Source: drake/multibody/plant/multibody_plant.h:2142
          const char* doc =
R"""(Sets the default pose of ``body``. If ``body.is_floating()`` is true,
this will affect subsequent calls to SetDefaultState(); otherwise,
this value is effectively ignored.

Parameter ``body``:
    Body whose default pose will be set.

Parameter ``X_WB``:
    Default pose of the body.)""";
        } SetDefaultFreeBodyPose;
        // Symbol: drake::multibody::MultibodyPlant::SetDefaultState
        struct /* SetDefaultState */ {
          // Source: drake/multibody/plant/multibody_plant.h:1965
          const char* doc =
R"""(Sets ``state`` according to defaults set by the user for joints (e.g.
RevoluteJoint::set_default_angle()) and free bodies
(SetDefaultFreeBodyPose()). If the user does not specify defaults, the
state corresponds to zero generalized positions and velocities.

Raises:
    RuntimeError if called pre-finalize. See Finalize().)""";
        } SetDefaultState;
        // Symbol: drake::multibody::MultibodyPlant::SetFreeBodyPose
        struct /* SetFreeBodyPose */ {
          // Source: drake/multibody/plant/multibody_plant.h:2113
          const char* doc_3args =
R"""(Sets ``context`` to store the pose ``X_WB`` of a given ``body`` B in
the world frame W.

Note:
    In general setting the pose and/or velocity of a body in the model
    would involve a complex inverse kinematics problem. This method
    allows us to simplify this process when we know the body is free
    in space.

Raises:
    RuntimeError if ``body`` is not a free body in the model.

Raises:
    RuntimeError if called pre-finalize.)""";
          // Source: drake/multibody/plant/multibody_plant.h:2127
          const char* doc_4args =
R"""(Sets ``state`` to store the pose ``X_WB`` of a given ``body`` B in the
world frame W, for a given ``context`` of ``this`` model.

Note:
    In general setting the pose and/or velocity of a body in the model
    would involve a complex inverse kinematics problem. This method
    allows us to simplify this process when we know the body is free
    in space.

Raises:
    RuntimeError if ``body`` is not a free body in the model.

Raises:
    RuntimeError if called pre-finalize.

Precondition:
    ``state`` comes from this MultibodyPlant.)""";
        } SetFreeBodyPose;
        // Symbol: drake::multibody::MultibodyPlant::SetFreeBodyPoseInAnchoredFrame
        struct /* SetFreeBodyPoseInAnchoredFrame */ {
          // Source: drake/multibody/plant/multibody_plant.h:2237
          const char* doc =
R"""(Updates ``context`` to store the pose ``X_FB`` of a given ``body`` B
in a frame F. Frame F must be anchored, meaning that it is either
directly welded to the world frame W or, more generally, that there is
a kinematic path between frame F and the world frame W that only
includes weld joints.

Raises:
    RuntimeError if called pre-finalize.

Raises:
    RuntimeError if frame F is not anchored to the world.)""";
        } SetFreeBodyPoseInAnchoredFrame;
        // Symbol: drake::multibody::MultibodyPlant::SetFreeBodyPoseInWorldFrame
        struct /* SetFreeBodyPoseInWorldFrame */ {
          // Source: drake/multibody/plant/multibody_plant.h:2226
          const char* doc =
R"""(Sets ``context`` to store the pose ``X_WB`` of a given ``body`` B in
the world frame W.

Parameter ``context``:
    The context to store the pose ``X_WB`` of ``body_B``.

Parameter ``body_B``:
    The body B corresponding to the pose ``X_WB`` to be stored in
    ``context``.

Returns ``X_WB``:
    The pose of body frame B in the world frame W.

Note:
    In general setting the pose and/or velocity of a body in the model
    would involve a complex inverse kinematics problem. This method
    allows us to simplify this process when we know the body is free
    in space.

Raises:
    RuntimeError if ``body`` is not a free body in the model.

Raises:
    RuntimeError if called pre-finalize.)""";
        } SetFreeBodyPoseInWorldFrame;
        // Symbol: drake::multibody::MultibodyPlant::SetFreeBodyRandomPositionDistribution
        struct /* SetFreeBodyRandomPositionDistribution */ {
          // Source: drake/multibody/plant/multibody_plant.h:2190
          const char* doc =
R"""(Sets the distribution used by SetRandomState() to populate the free
body's x-y-z ``position`` with respect to World.

Raises:
    RuntimeError if ``body`` is not a free body in the model.

Raises:
    RuntimeError if called pre-finalize.)""";
        } SetFreeBodyRandomPositionDistribution;
        // Symbol: drake::multibody::MultibodyPlant::SetFreeBodyRandomRotationDistribution
        struct /* SetFreeBodyRandomRotationDistribution */ {
          // Source: drake/multibody/plant/multibody_plant.h:2200
          const char* doc =
R"""(Sets the distribution used by SetRandomState() to populate the free
body's ``rotation`` with respect to World.

Raises:
    RuntimeError if ``body`` is not a free body in the model.

Raises:
    RuntimeError if called pre-finalize.)""";
        } SetFreeBodyRandomRotationDistribution;
        // Symbol: drake::multibody::MultibodyPlant::SetFreeBodyRandomRotationDistributionToUniform
        struct /* SetFreeBodyRandomRotationDistributionToUniform */ {
          // Source: drake/multibody/plant/multibody_plant.h:2211
          const char* doc =
R"""(Sets the distribution used by SetRandomState() to populate the free
body's rotation with respect to World using uniformly random
rotations.

Raises:
    RuntimeError if ``body`` is not a free body in the model.

Raises:
    RuntimeError if called pre-finalize.)""";
        } SetFreeBodyRandomRotationDistributionToUniform;
        // Symbol: drake::multibody::MultibodyPlant::SetFreeBodySpatialVelocity
        struct /* SetFreeBodySpatialVelocity */ {
          // Source: drake/multibody/plant/multibody_plant.h:2162
          const char* doc_3args =
R"""(Sets ``context`` to store the spatial velocity ``V_WB`` of a given
``body`` B in the world frame W.

Note:
    In general setting the pose and/or velocity of a body in the model
    would involve a complex inverse kinematics problem. This method
    allows us to simplify this process when we know the body is free
    in space.

Raises:
    RuntimeError if ``body`` is not a free body in the model.

Raises:
    RuntimeError if called pre-finalize.)""";
          // Source: drake/multibody/plant/multibody_plant.h:2177
          const char* doc_4args =
R"""(Sets ``state`` to store the spatial velocity ``V_WB`` of a given
``body`` B in the world frame W, for a given ``context`` of ``this``
model.

Note:
    In general setting the pose and/or velocity of a body in the model
    would involve a complex inverse kinematics problem. This method
    allows us to simplify this process when we know the body is free
    in space.

Raises:
    RuntimeError if ``body`` is not a free body in the model.

Raises:
    RuntimeError if called pre-finalize.

Precondition:
    ``state`` comes from this MultibodyPlant.)""";
        } SetFreeBodySpatialVelocity;
        // Symbol: drake::multibody::MultibodyPlant::SetPositions
        struct /* SetPositions */ {
          // Source: drake/multibody/plant/multibody_plant.h:1825
          const char* doc_2args =
R"""(Sets all generalized positions from the given vector.

Raises:
    RuntimeError if the ``context`` is nullptr, if the context does
    not correspond to the context for a multibody model, or if the
    length of ``q`` is not equal to ``num_positions()``.)""";
          // Source: drake/multibody/plant/multibody_plant.h:1836
          const char* doc_3args =
R"""(Sets the positions for a particular model instance from the given
vector.

Raises:
    RuntimeError if the ``context`` is nullptr, if the context does
    not correspond to the context for a multibody model, if the model
    instance index is invalid, or if the length of ``q_instance`` is
    not equal to ``num_positions(model_instance)``.)""";
          // Source: drake/multibody/plant/multibody_plant.h:1851
          const char* doc_4args =
R"""(Sets the positions for a particular model instance from the given
vector.

Raises:
    RuntimeError if the ``state`` is nullptr, if the context does not
    correspond to the context for a multibody model, if the model
    instance index is invalid, or if the length of ``q_instance`` is
    not equal to ``num_positions(model_instance)``.

Precondition:
    ``state`` comes from this MultibodyPlant.)""";
        } SetPositions;
        // Symbol: drake::multibody::MultibodyPlant::SetPositionsAndVelocities
        struct /* SetPositionsAndVelocities */ {
          // Source: drake/multibody/plant/multibody_plant.h:1726
          const char* doc_2args =
R"""(Sets all generalized positions and velocities from the given vector
[q; v].

Raises:
    RuntimeError if the ``context`` is nullptr, if the context does
    not correspond to the context for a multibody model, or if the
    length of ``q_v`` is not equal to ``num_positions() +
    num_velocities()``.)""";
          // Source: drake/multibody/plant/multibody_plant.h:1739
          const char* doc_3args =
R"""(Sets generalized positions and velocities from the given vector [q; v]
for the specified model instance.

Raises:
    RuntimeError if the ``context`` is nullptr, if the context does
    not correspond to the context for a multibody model, if the model
    instance index is invalid, or if the length of ``q_v`` is not
    equal to ``num_positions(model_instance) +
    num_velocities(model_instance)``.)""";
        } SetPositionsAndVelocities;
        // Symbol: drake::multibody::MultibodyPlant::SetPositionsInArray
        struct /* SetPositionsInArray */ {
          // Source: drake/multibody/plant/multibody_plant.h:2035
          const char* doc =
R"""(Sets the vector of generalized positions for ``model_instance`` in
``q`` using ``q_instance``, leaving all other elements in the array
untouched. This method throws an exception if ``q`` is not of size
MultibodyPlant::num_positions() or ``q_instance`` is not of size
``MultibodyPlant::num_positions(model_instance)``.)""";
        } SetPositionsInArray;
        // Symbol: drake::multibody::MultibodyPlant::SetRandomState
        struct /* SetRandomState */ {
          // Source: drake/multibody/plant/multibody_plant.h:1984
          const char* doc =
R"""(Assigns random values to all elements of the state, by drawing samples
independently for each joint/free body (coming soon: and then solving
a mathematical program to "project" these samples onto the registered
system constraints).

See also:
    stochastic_systems)""";
        } SetRandomState;
        // Symbol: drake::multibody::MultibodyPlant::SetVelocities
        struct /* SetVelocities */ {
          // Source: drake/multibody/plant/multibody_plant.h:1922
          const char* doc_2args =
R"""(Sets all generalized velocities from the given vector.

Raises:
    RuntimeError if the ``context`` is nullptr, if the context does
    not correspond to the context for a multibody model, or if the
    length of ``v`` is not equal to ``num_velocities()``.)""";
          // Source: drake/multibody/plant/multibody_plant.h:1935
          const char* doc_4args =
R"""(Sets the generalized velocities for a particular model instance from
the given vector.

Raises:
    RuntimeError if the ``context`` is nullptr, if the context does
    not correspond to the context for a multibody model, if the model
    instance index is invalid, or if the length of ``v_instance`` is
    not equal to ``num_velocities(model_instance)``.

Precondition:
    ``state`` comes from this MultibodyPlant.)""";
          // Source: drake/multibody/plant/multibody_plant.h:1951
          const char* doc_3args =
R"""(Sets the generalized velocities for a particular model instance from
the given vector.

Raises:
    RuntimeError if the ``context`` is nullptr, if the context does
    not correspond to the context for a multibody model, if the model
    instance index is invalid, or if the length of ``v_instance`` is
    not equal to ``num_velocities(model_instance)``.)""";
        } SetVelocities;
        // Symbol: drake::multibody::MultibodyPlant::SetVelocitiesInArray
        struct /* SetVelocitiesInArray */ {
          // Source: drake/multibody/plant/multibody_plant.h:2058
          const char* doc =
R"""(Sets the vector of generalized velocities for ``model_instance`` in
``v`` using ``v_instance``, leaving all other elements in the array
untouched. This method throws an exception if ``v`` is not of size
MultibodyPlant::num_velocities() or ``v_instance`` is not of size
``MultibodyPlant::num_positions(model_instance)``.)""";
        } SetVelocitiesInArray;
        // Symbol: drake::multibody::MultibodyPlant::WeldFrames
        struct /* WeldFrames */ {
          // Source: drake/multibody/plant/multibody_plant.h:1025
          const char* doc =
R"""(Welds frames A and B with relative pose ``X_AB``. That is, the pose of
frame B in frame A is fixed, with value ``X_AB``. The call to this
method creates and adds a new WeldJoint to the model. The new
WeldJoint is named as: A.name() + "_welds_to_" + B.name().

Returns:
    a constant reference to the WeldJoint welding frames A and B.)""";
        } WeldFrames;
        // Symbol: drake::multibody::MultibodyPlant::geometry_source_is_registered
        struct /* geometry_source_is_registered */ {
          // Source: drake/multibody/plant/multibody_plant.h:3794
          const char* doc =
R"""(Returns ``True`` if ``this`` MultibodyPlant was registered with a
SceneGraph. This method can be called at any time during the lifetime
of ``this`` plant to query if ``this`` plant has been registered with
a SceneGraph, either pre- or post-finalize, see Finalize().)""";
        } geometry_source_is_registered;
        // Symbol: drake::multibody::MultibodyPlant::get_actuation_input_port
        struct /* get_actuation_input_port */ {
          // Source: drake/multibody/plant/multibody_plant.h:601
          const char* doc_1args =
R"""(Returns a constant reference to the input port for external actuation
for a specific model instance. This input port is a vector valued
port, which can be set with JointActuator::set_actuation_vector().

Precondition:
    Finalize() was already called on ``this`` plant.

Raises:
    RuntimeError if called before Finalize().

Raises:
    RuntimeError if the model instance does not exist.)""";
          // Source: drake/multibody/plant/multibody_plant.h:611
          const char* doc_0args =
R"""(Returns a constant reference to the input port for external actuation
for the case where only one model instance has actuated dofs. This
input port is a vector valued port, which can be set with
JointActuator::set_actuation_vector().

Precondition:
    Finalize() was already called on ``this`` plant.

Raises:
    RuntimeError if called before Finalize(), if the model does not
    contain any actuators, or if multiple model instances have
    actuated dofs.)""";
        } get_actuation_input_port;
        // Symbol: drake::multibody::MultibodyPlant::get_applied_generalized_force_input_port
        struct /* get_applied_generalized_force_input_port */ {
          // Source: drake/multibody/plant/multibody_plant.h:620
          const char* doc =
R"""(Returns a constant reference to the vector-valued input port for
applied generalized forces, and the vector will be added directly into
``tau`` (see mbp_equations_of_motion "System dynamics"). This vector
is ordered using the same convention as the plant velocities: you can
set the generalized forces that will be applied to model instance i
using, e.g., ``SetVelocitiesInArray(i, model_forces, &force_array)``.

Raises:
    RuntimeError if called before Finalize().)""";
        } get_applied_generalized_force_input_port;
        // Symbol: drake::multibody::MultibodyPlant::get_applied_spatial_force_input_port
        struct /* get_applied_spatial_force_input_port */ {
          // Source: drake/multibody/plant/multibody_plant.h:626
          const char* doc =
R"""(Returns a constant reference to the input port for applying spatial
forces to bodies in the plant. The data type for the port is an
std::vector of ExternallyAppliedSpatialForce; any number of spatial
forces can be applied to any number of bodies in the plant.)""";
        } get_applied_spatial_force_input_port;
        // Symbol: drake::multibody::MultibodyPlant::get_body
        struct /* get_body */ {
          // Source: drake/multibody/plant/multibody_plant.h:3285
          const char* doc =
R"""(Returns a constant reference to the body with unique index
``body_index``.

Raises:
    RuntimeError if ``body_index`` does not correspond to a body in
    this model.)""";
        } get_body;
        // Symbol: drake::multibody::MultibodyPlant::get_body_poses_output_port
        struct /* get_body_poses_output_port */ {
          // Source: drake/multibody/plant/multibody_plant.h:559
          const char* doc =
R"""(Returns the output port of all body poses in the world frame. You can
obtain the pose ``X_WB`` of a body B in the world frame W with:


::

    const auto& X_WB_all = plant.get_body_poses_output_port().
          .Eval<std::vector<math::RigidTransform<double>>>(plant_context);
      const BodyIndex arm_body_index = plant.GetBodyByName("arm").index();
      const math::RigidTransform<double>& X_WArm = X_WB_all[arm_body_index];

As shown in the example above, the resulting ``std::vector`` of body
poses is indexed by BodyIndex, and it has size num_bodies(). BodyIndex
"zero" (0) always corresponds to the world body, with pose equal to
the identity at all times.

Raises:
    RuntimeError if called pre-finalize.)""";
        } get_body_poses_output_port;
        // Symbol: drake::multibody::MultibodyPlant::get_body_spatial_accelerations_output_port
        struct /* get_body_spatial_accelerations_output_port */ {
          // Source: drake/multibody/plant/multibody_plant.h:592
          const char* doc =
R"""(Returns the output port of all body spatial accelerations in the world
frame. You can obtain the spatial acceleration ``A_WB`` of a body B in
the world frame W with:


::

    const auto& A_WB_all =
      plant.get_body_spatial_accelerations_output_port().
          .Eval<std::vector<SpatialAcceleration<double>>>(plant_context);
      const BodyIndex arm_body_index = plant.GetBodyByName("arm").index();
      const SpatialVelocity<double>& A_WArm = A_WB_all[arm_body_index];

As shown in the example above, the resulting ``std::vector`` of body
spatial accelerations is indexed by BodyIndex, and it has size
num_bodies(). BodyIndex "zero" (0) always corresponds to the world
body, with zero spatial acceleration at all times.

Raises:
    RuntimeError if called pre-finalize.)""";
        } get_body_spatial_accelerations_output_port;
        // Symbol: drake::multibody::MultibodyPlant::get_body_spatial_velocities_output_port
        struct /* get_body_spatial_velocities_output_port */ {
          // Source: drake/multibody/plant/multibody_plant.h:575
          const char* doc =
R"""(Returns the output port of all body spatial velocities in the world
frame. You can obtain the spatial velocity ``V_WB`` of a body B in the
world frame W with:


::

    const auto& V_WB_all = plant.get_body_spatial_velocities_output_port().
          .Eval<std::vector<SpatialVelocity<double>>>(plant_context);
      const BodyIndex arm_body_index = plant.GetBodyByName("arm").index();
      const SpatialVelocity<double>& V_WArm = V_WB_all[arm_body_index];

As shown in the example above, the resulting ``std::vector`` of body
spatial velocities is indexed by BodyIndex, and it has size
num_bodies(). BodyIndex "zero" (0) always corresponds to the world
body, with zero spatial velocity at all times.

Raises:
    RuntimeError if called pre-finalize.)""";
        } get_body_spatial_velocities_output_port;
        // Symbol: drake::multibody::MultibodyPlant::get_contact_model
        struct /* get_contact_model */ {
          // Source: drake/multibody/plant/multibody_plant.h:3758
          const char* doc =
R"""(Returns the model used for contact. See documentation for
ContactModel.)""";
        } get_contact_model;
        // Symbol: drake::multibody::MultibodyPlant::get_contact_penalty_method_time_scale
        struct /* get_contact_penalty_method_time_scale */ {
          // Source: drake/multibody/plant/multibody_plant.h:1611
          const char* doc =
R"""(Returns a time-scale estimate ``tc`` based on the requested
penetration allowance δ set with set_penetration_allowance(). For the
penalty method in use to enforce non-penetration, this time scale
relates to the time it takes the relative normal velocity between two
bodies to go to zero. This time scale ``tc`` is artificially
introduced by the penalty method and goes to zero in the limit to
ideal rigid contact. Since numerical integration methods for continuum
systems must be able to resolve a system's dynamics, the time step
used by an integrator must in general be much smaller than the time
scale ``tc``. How much smaller will depend on the details of the
problem and the convergence characteristics of the integrator and
should be tuned appropriately. Another factor to take into account for
setting up the simulation's time step is the speed of the objects in
your simulation. If ``vn`` represents a reference velocity scale for
the normal relative velocity between bodies, the new time scale ``tn =
δ / vn`` represents the time it would take for the distance between
two bodies approaching with relative normal velocity ``vn`` to
decrease by the penetration_allowance δ. In this case a user should
choose a time step for simulation that can resolve the smallest of the
two time scales ``tc`` and ``tn``.)""";
        } get_contact_penalty_method_time_scale;
        // Symbol: drake::multibody::MultibodyPlant::get_contact_results_output_port
        struct /* get_contact_results_output_port */ {
          // Source: drake/multibody/plant/multibody_plant.h:698
          const char* doc =
R"""(Returns a constant reference to the port that outputs ContactResults.

Raises:
    RuntimeError if called pre-finalize, see Finalize().)""";
        } get_contact_results_output_port;
        // Symbol: drake::multibody::MultibodyPlant::get_force_element
        struct /* get_force_element */ {
          // Source: drake/multibody/plant/multibody_plant.h:3611
          const char* doc =
R"""(Returns a constant reference to the force element with unique index
``force_element_index``.

Raises:
    RuntimeError when ``force_element_index`` does not correspond to a
    force element in this model.)""";
        } get_force_element;
        // Symbol: drake::multibody::MultibodyPlant::get_frame
        struct /* get_frame */ {
          // Source: drake/multibody/plant/multibody_plant.h:3482
          const char* doc =
R"""(Returns a constant reference to the frame with unique index
``frame_index``.

Raises:
    RuntimeError if ``frame_index`` does not correspond to a frame in
    this plant.)""";
        } get_frame;
        // Symbol: drake::multibody::MultibodyPlant::get_generalized_acceleration_output_port
        struct /* get_generalized_acceleration_output_port */ {
          // Source: drake/multibody/plant/multibody_plant.h:653
          const char* doc_0args =
R"""(Returns a constant reference to the output port for generalized
accelerations v̇ of the model.

Precondition:
    Finalize() was already called on ``this`` plant.

Raises:
    RuntimeError if called before Finalize().)""";
          // Source: drake/multibody/plant/multibody_plant.h:661
          const char* doc_1args =
R"""(Returns a constant reference to the output port for the generalized
accelerations v̇ᵢ ⊆ v̇ for model instance i.

Precondition:
    Finalize() was already called on ``this`` plant.

Raises:
    RuntimeError if called before Finalize().

Raises:
    RuntimeError if the model instance does not exist.)""";
        } get_generalized_acceleration_output_port;
        // Symbol: drake::multibody::MultibodyPlant::get_generalized_contact_forces_output_port
        struct /* get_generalized_contact_forces_output_port */ {
          // Source: drake/multibody/plant/multibody_plant.h:670
          const char* doc =
R"""(Returns a constant reference to the output port of generalized contact
forces for a specific model instance.

Precondition:
    Finalize() was already called on ``this`` plant.

Raises:
    RuntimeError if called before Finalize().

Raises:
    RuntimeError if the model instance does not exist.)""";
        } get_generalized_contact_forces_output_port;
        // Symbol: drake::multibody::MultibodyPlant::get_geometry_poses_output_port
        struct /* get_geometry_poses_output_port */ {
          // Source: drake/multibody/plant/multibody_plant.h:702
          const char* doc =
R"""(Returns the output port of frames' poses to communicate with a
SceneGraph.)""";
        } get_geometry_poses_output_port;
        // Symbol: drake::multibody::MultibodyPlant::get_geometry_query_input_port
        struct /* get_geometry_query_input_port */ {
          // Source: drake/multibody/plant/multibody_plant.h:633
          const char* doc =
R"""(Returns a constant reference to the input port used to perform
geometric queries on a SceneGraph. See
SceneGraph::get_query_output_port(). Refer to section mbp_geometry
"Geometry" of this class's documentation for further details on
collision geometry registration and connection with a SceneGraph.)""";
        } get_geometry_query_input_port;
        // Symbol: drake::multibody::MultibodyPlant::get_joint
        struct /* get_joint */ {
          // Source: drake/multibody/plant/multibody_plant.h:3409
          const char* doc =
R"""(Returns a constant reference to the joint with unique index
``joint_index``.

Raises:
    RuntimeError when ``joint_index`` does not correspond to a joint
    in this model.)""";
        } get_joint;
        // Symbol: drake::multibody::MultibodyPlant::get_joint_actuator
        struct /* get_joint_actuator */ {
          // Source: drake/multibody/plant/multibody_plant.h:3547
          const char* doc =
R"""(Returns a constant reference to the joint actuator with unique index
``actuator_index``.

Raises:
    RuntimeError if ``actuator_index`` does not correspond to a joint
    actuator in this tree.)""";
        } get_joint_actuator;
        // Symbol: drake::multibody::MultibodyPlant::get_mutable_joint
        struct /* get_mutable_joint */ {
          // Source: drake/multibody/plant/multibody_plant.h:3432
          const char* doc =
R"""(Returns a mutable reference to the joint with unique index
``joint_index``.

Raises:
    RuntimeError when ``joint_index`` does not correspond to a joint
    in this model.)""";
        } get_mutable_joint;
        // Symbol: drake::multibody::MultibodyPlant::get_mutable_joint_actuator
        struct /* get_mutable_joint_actuator */ {
          // Source: drake/multibody/plant/multibody_plant.h:3556
          const char* doc =
R"""(Returns a mutable reference to the joint actuator with unique index
``actuator_index``.

Raises:
    RuntimeError if ``actuator_index`` does not correspond to a joint
    actuator in this tree.)""";
        } get_mutable_joint_actuator;
        // Symbol: drake::multibody::MultibodyPlant::get_reaction_forces_output_port
        struct /* get_reaction_forces_output_port */ {
          // Source: drake/multibody/plant/multibody_plant.h:694
          const char* doc =
R"""(Returns the port for joint reaction forces. A Joint models the
kinematical relationship which characterizes the possible relative
motion between two bodies. In Drake, a joint connects a frame ``Jp``
on *parent* body P with a frame ``Jc`` on a *child* body C. This usage
of the terms *parent* and *child* is just a convention and implies
nothing about the inboard-outboard relationship between the bodies.
Since a Joint imposes a kinematical relationship which characterizes
the possible relative motion between frames Jp and Jc, reaction forces
on each body are established. That is, we could cut the model at the
joint and replace it with equivalent forces equal to these reaction
forces in order to attain the same motions of the mechanical system.

This output port allows to evaluate the reaction force ``F_CJc_Jc`` on
the *child* body C, at ``Jc``, and expressed in Jc for all joints in
the model. This port evaluates to a vector of type
std::vector<SpatialForce<T>> and size num_joints() indexed by
JointIndex, see Joint::index(). Each entry corresponds to the spatial
force ``F_CJc_Jc`` applied on the joint's child body C
(Joint::child_body()), at the joint's child frame ``Jc``
(Joint::frame_on_child()) and expressed in frame ``Jc``.

Raises:
    RuntimeError if called pre-finalize.)""";
        } get_reaction_forces_output_port;
        // Symbol: drake::multibody::MultibodyPlant::get_source_id
        struct /* get_source_id */ {
          // Source: drake/multibody/plant/multibody_plant.h:3785
          const char* doc =
R"""(Returns the unique id identifying ``this`` plant as a source for a
SceneGraph. Returns ``nullopt`` if ``this`` plant did not register any
geometry. This method can be called at any time during the lifetime of
``this`` plant to query if ``this`` plant has been registered with a
SceneGraph, either pre- or post-finalize, see Finalize(). However, a
geometry::SourceId is only assigned once at the first call of any of
this plant's geometry registration methods, and it does not change
after that. Post-finalize calls will always return the same value.)""";
        } get_source_id;
        // Symbol: drake::multibody::MultibodyPlant::get_state_output_port
        struct /* get_state_output_port */ {
          // Source: drake/multibody/plant/multibody_plant.h:639
          const char* doc_0args =
R"""(Returns a constant reference to the output port for the multibody
state x = [q, v] of the model.

Precondition:
    Finalize() was already called on ``this`` plant.

Raises:
    RuntimeError if called before Finalize().)""";
          // Source: drake/multibody/plant/multibody_plant.h:646
          const char* doc_1args =
R"""(Returns a constant reference to the output port for the state xᵢ = [qᵢ
vᵢ] of model instance i. (Here qᵢ ⊆ q and vᵢ ⊆ v.)

Precondition:
    Finalize() was already called on ``this`` plant.

Raises:
    RuntimeError if called before Finalize().

Raises:
    RuntimeError if the model instance does not exist.)""";
        } get_state_output_port;
        // Symbol: drake::multibody::MultibodyPlant::gravity_field
        struct /* gravity_field */ {
          // Source: drake/multibody/plant/multibody_plant.h:3632
          const char* doc =
R"""(An accessor to the current gravity field.)""";
        } gravity_field;
        // Symbol: drake::multibody::MultibodyPlant::is_finalized
        struct /* is_finalized */ {
          // Source: drake/multibody/plant/multibody_plant.h:3263
          const char* doc =
R"""(Returns ``True`` if this MultibodyPlant was finalized with a call to
Finalize().

See also:
    Finalize().)""";
        } is_finalized;
        // Symbol: drake::multibody::MultibodyPlant::mutable_gravity_field
        struct /* mutable_gravity_field */ {
          // Source: drake/multibody/plant/multibody_plant.h:3637
          const char* doc =
R"""(A mutable accessor to the current gravity field.)""";
        } mutable_gravity_field;
        // Symbol: drake::multibody::MultibodyPlant::num_actuated_dofs
        struct /* num_actuated_dofs */ {
          // Source: drake/multibody/plant/multibody_plant.h:3534
          const char* doc_0args =
R"""(Returns the total number of actuated degrees of freedom. That is, the
vector of actuation values u has this size. See AddJointActuator().)""";
          // Source: drake/multibody/plant/multibody_plant.h:3539
          const char* doc_1args =
R"""(Returns the total number of actuated degrees of freedom for a specific
model instance. That is, the vector of actuation values u has this
size. See AddJointActuator().)""";
        } num_actuated_dofs;
        // Symbol: drake::multibody::MultibodyPlant::num_actuators
        struct /* num_actuators */ {
          // Source: drake/multibody/plant/multibody_plant.h:3527
          const char* doc =
R"""(Returns the number of joint actuators in the model.

See also:
    AddJointActuator().)""";
        } num_actuators;
        // Symbol: drake::multibody::MultibodyPlant::num_bodies
        struct /* num_bodies */ {
          // Source: drake/multibody/plant/multibody_plant.h:3278
          const char* doc =
R"""(Returns the number of bodies in the model, including the "world" body,
which is always part of the model.

See also:
    AddRigidBody().)""";
        } num_bodies;
        // Symbol: drake::multibody::MultibodyPlant::num_collision_geometries
        struct /* num_collision_geometries */ {
          // Source: drake/multibody/plant/multibody_plant.h:3772
          const char* doc =
R"""(Returns the number of geometries registered for contact modeling. This
method can be called at any time during the lifetime of ``this``
plant, either pre- or post-finalize, see Finalize(). Post-finalize
calls will always return the same value.)""";
        } num_collision_geometries;
        // Symbol: drake::multibody::MultibodyPlant::num_force_elements
        struct /* num_force_elements */ {
          // Source: drake/multibody/plant/multibody_plant.h:3603
          const char* doc =
R"""(Returns the number of ForceElement objects.

See also:
    AddForceElement().)""";
        } num_force_elements;
        // Symbol: drake::multibody::MultibodyPlant::num_frames
        struct /* num_frames */ {
          // Source: drake/multibody/plant/multibody_plant.h:3475
          const char* doc =
R"""(Returns the number of Frame objects in this model. Frames include body
frames associated with each of the bodies, including the *world* body.
This means the minimum number of frames is one.)""";
        } num_frames;
        // Symbol: drake::multibody::MultibodyPlant::num_joints
        struct /* num_joints */ {
          // Source: drake/multibody/plant/multibody_plant.h:3402
          const char* doc =
R"""(Returns the number of joints in the model.

See also:
    AddJoint().)""";
        } num_joints;
        // Symbol: drake::multibody::MultibodyPlant::num_model_instances
        struct /* num_model_instances */ {
          // Source: drake/multibody/plant/multibody_plant.h:3643
          const char* doc =
R"""(Returns the number of model instances in the model.

See also:
    AddModelInstance().)""";
        } num_model_instances;
        // Symbol: drake::multibody::MultibodyPlant::num_multibody_states
        struct /* num_multibody_states */ {
          // Source: drake/multibody/plant/multibody_plant.h:3699
          const char* doc_0args =
R"""(Returns the size of the multibody system state vector x = [q v]. This
will be ``num_positions()`` plus ``num_velocities()``.)""";
          // Source: drake/multibody/plant/multibody_plant.h:3705
          const char* doc_1args =
R"""(Returns the size of the multibody system state vector xᵢ = [qᵢ vᵢ] for
model instance i. (Here qᵢ ⊆ q and vᵢ ⊆ v.) will be
``num_positions(model_instance)`` plus
``num_velocities(model_instance)``.)""";
        } num_multibody_states;
        // Symbol: drake::multibody::MultibodyPlant::num_positions
        struct /* num_positions */ {
          // Source: drake/multibody/plant/multibody_plant.h:3678
          const char* doc_0args =
R"""(Returns the size of the generalized position vector q for this model.)""";
          // Source: drake/multibody/plant/multibody_plant.h:3682
          const char* doc_1args =
R"""(Returns the size of the generalized position vector qᵢ for model
instance i.)""";
        } num_positions;
        // Symbol: drake::multibody::MultibodyPlant::num_velocities
        struct /* num_velocities */ {
          // Source: drake/multibody/plant/multibody_plant.h:3687
          const char* doc_0args =
R"""(Returns the size of the generalized velocity vector v for this model.)""";
          // Source: drake/multibody/plant/multibody_plant.h:3691
          const char* doc_1args =
R"""(Returns the size of the generalized velocity vector vᵢ for model
instance i.)""";
        } num_velocities;
        // Symbol: drake::multibody::MultibodyPlant::num_visual_geometries
        struct /* num_visual_geometries */ {
          // Source: drake/multibody/plant/multibody_plant.h:3764
          const char* doc =
R"""(Returns the number of geometries registered for visualization. This
method can be called at any time during the lifetime of ``this``
plant, either pre- or post-finalize, see Finalize(). Post-finalize
calls will always return the same value.)""";
        } num_visual_geometries;
        // Symbol: drake::multibody::MultibodyPlant::set_contact_model
        struct /* set_contact_model */ {
          // Source: drake/multibody/plant/multibody_plant.h:1554
          const char* doc =
R"""(Sets the contact model to be used by ``this`` MultibodyPlant, see
ContactModel for available options. The default contact model is
ContactModel::kPointContactOnly.

Raises:
    RuntimeError iff called post-finalize.)""";
        } set_contact_model;
        // Symbol: drake::multibody::MultibodyPlant::set_contact_solver
        struct /* set_contact_solver */ {
          // Source: drake/multibody/plant/multibody_plant.h:1570
          const char* doc = R"""()""";
        } set_contact_solver;
        // Symbol: drake::multibody::MultibodyPlant::set_penetration_allowance
        struct /* set_penetration_allowance */ {
          // Source: drake/multibody/plant/multibody_plant.h:1590
          const char* doc =
R"""(Sets the penetration allowance used to estimate the coefficients in
the penalty method used to impose non-penetration among bodies. Refer
to the section mbp_penalty_method "Contact by penalty method" for
further details.

Raises:
    RuntimeError if penetration_allowance is not positive.)""";
        } set_penetration_allowance;
        // Symbol: drake::multibody::MultibodyPlant::set_stiction_tolerance
        struct /* set_stiction_tolerance */ {
          // Source: drake/multibody/plant/multibody_plant.h:1652
          const char* doc =
R"""(**** Stribeck model of friction

Currently MultibodyPlant uses the Stribeck approximation to model dry
friction. The Stribeck model of friction is an approximation to
Coulomb's law of friction that allows using continuous time
integration without the need to specify complementarity constraints.
While this results in a simpler model immediately tractable with
standard numerical methods for integration of ODE's, it often leads to
stiff dynamics that require an explicit integrator to take very small
time steps. It is therefore recommended to use error controlled
integrators when using this model or the discrete time stepping (see
time_advancement_strategy "Choice of Time Advancement Strategy"). See
stribeck_approximation for a detailed discussion of the Stribeck
model.

Sets the stiction tolerance ``v_stiction`` for the Stribeck model,
where ``v_stiction`` must be specified in m/s (meters per second.)
``v_stiction`` defaults to a value of 1 millimeter per second. In
selecting a value for ``v_stiction``, you must ask yourself the
question, "When two objects are ostensibly in stiction, how much slip
am I willing to allow?" There are two opposing design issues in
picking a value for vₛ. On the one hand, small values of vₛ make the
problem numerically stiff during stiction, potentially increasing the
integration cost. On the other hand, it should be picked to be
appropriate for the scale of the problem. For example, a car
simulation could allow a "large" value for vₛ of 1 cm/s (1×10⁻² m/s),
but reasonable stiction for grasping a 10 cm box might require
limiting residual slip to 1×10⁻³ m/s or less. Ultimately, picking the
largest viable value will allow your simulation to run faster and more
robustly. Note that ``v_stiction`` is the slip velocity that we'd have
when we are at edge of the friction cone. For cases when the friction
force is well within the friction cone the slip velocity will always
be smaller than this value. See also stribeck_approximation.

Raises:
    RuntimeError if ``v_stiction`` is non-positive.)""";
        } set_stiction_tolerance;
        // Symbol: drake::multibody::MultibodyPlant::time_step
        struct /* time_step */ {
          // Source: drake/multibody/plant/multibody_plant.h:3258
          const char* doc =
R"""(The time step (or period) used to model ``this`` plant as a discrete
system with periodic updates. Returns 0 (zero) if the plant is modeled
as a continuous system. This property of the plant is specified at
construction and therefore this query can be performed either pre- or
post-finalize, see Finalize().

See also:
    MultibodyPlant::MultibodyPlant(double))""";
        } time_step;
        // Symbol: drake::multibody::MultibodyPlant::world_body
        struct /* world_body */ {
          // Source: drake/multibody/plant/multibody_plant.h:3266
          const char* doc =
R"""(Returns a constant reference to the *world* body.)""";
        } world_body;
        // Symbol: drake::multibody::MultibodyPlant::world_frame
        struct /* world_frame */ {
          // Source: drake/multibody/plant/multibody_plant.h:3271
          const char* doc =
R"""(Returns a constant reference to the *world* frame.)""";
        } world_frame;
      } MultibodyPlant;
      // Symbol: drake::multibody::OrientationConstraint
      struct /* OrientationConstraint */ {
        // Source: drake/multibody/inverse_kinematics/orientation_constraint.h:31
        const char* doc =
R"""(Constrains that the angle difference θ between the orientation of
frame A and the orientation of frame B to satisfy θ ≤ θ_bound. The
angle difference between frame A's orientation R_WA and B's
orientation R_WB is θ (θ ∈ [0, π]), if there exists a rotation axis a,
such that rotating frame A by angle θ about axis a aligns it with
frame B. Namely R_AB = I + sinθ â + (1-cosθ)â² (1) where R_AB is the
orientation of frame B expressed in frame A. â is the skew symmetric
matrix of the rotation axis a. Equation (1) is the Rodrigues formula
that computes the rotation matrix froma rotation axis a and an angle
θ, https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula If the
users want frame A and frame B to align perfectly, they can set
θ_bound = 0. Mathematically, this constraint is imposed as trace(R_AB)
≥ 2cos(θ_bound) + 1 (1) To derive (1), using Rodrigues formula R_AB =
I + sinθ â + (1-cosθ)â² where trace(R_AB) = 2cos(θ) + 1 ≥
2cos(θ_bound) + 1)""";
        // Symbol: drake::multibody::OrientationConstraint::OrientationConstraint
        struct /* ctor */ {
          // Source: drake/multibody/inverse_kinematics/orientation_constraint.h:59
          const char* doc =
R"""(Constructs an OrientationConstraint object. The frame A is fixed to a
frame A̅, with orientatation ``R_AbarA`` measured in frame A̅. The
frame B is fixed to a frame B̅, with orientation ``R_BbarB`` measured
in frame B. We constrain the angle between frame A and B to be less
than ``theta_bound``.

Parameter ``plant``:
    The MultibodyPlant on which the constraint is imposed. ``plant``
    should be alive during the lifetime of this constraint.

Parameter ``frameAbar``:
    The frame A̅ in the model to which frame A is fixed.

Parameter ``R_AbarA``:
    The orientation of frame A measured in frame A̅.

Parameter ``frameBbar``:
    The frame B̅ in the model to which frame B is fixed.

Parameter ``R_BbarB``:
    The orientation of frame B measured in frame B̅.

Parameter ``theta_bound``:
    The bound on the angle difference between frame A's orientation
    and frame B's orientation. It is denoted as θ_bound in the class
    documentation. ``theta_bound`` is in radians.

Parameter ``plant_context``:
    The Context that has been allocated for this ``tree``. We will
    update the context when evaluating the constraint.
    ``plant_context`` should be alive during the lifetime of this
    constraint.

Raises:
    ValueError if ``plant`` is nullptr.

Raises:
    RuntimeError if ``frameAbar`` or ``frameBbar`` does not belong to
    ``plant``.

Raises:
    ValueError if angle_bound < 0.

Raises:
    ValueError if ``plant_context`` is nullptr.)""";
        } ctor;
      } OrientationConstraint;
      // Symbol: drake::multibody::PackageMap
      struct /* PackageMap */ {
        // Source: drake/multibody/parsing/package_map.h:14
        const char* doc =
R"""(Maps ROS package names to their full path on the local file system. It
is used by the SDF and URDF parsers when parsing files that reference
ROS packages for resources like mesh files.)""";
        // Symbol: drake::multibody::PackageMap::Add
        struct /* Add */ {
          // Source: drake/multibody/parsing/package_map.h:24
          const char* doc =
R"""(Adds package ``package_name`` and its path, ``package_path``. Throws
if ``package_name`` is already present in this PackageMap, or if
``package_path`` does not exist.)""";
        } Add;
        // Symbol: drake::multibody::PackageMap::AddPackageXml
        struct /* AddPackageXml */ {
          // Source: drake/multibody/parsing/package_map.h:43
          const char* doc =
R"""(Adds an entry into this PackageMap for the given ``package.xml``
filename. Throws if ``filename`` does not exist or its embedded name
already exists in this map.)""";
        } AddPackageXml;
        // Symbol: drake::multibody::PackageMap::Contains
        struct /* Contains */ {
          // Source: drake/multibody/parsing/package_map.h:27
          const char* doc =
R"""(Returns true if and only if this PackageMap contains ``package_name``.)""";
        } Contains;
        // Symbol: drake::multibody::PackageMap::GetPath
        struct /* GetPath */ {
          // Source: drake/multibody/parsing/package_map.h:38
          const char* doc =
R"""(Obtains the path associated with package ``package_name``. Aborts if
no package named ``package_name`` exists in this PackageMap.)""";
        } GetPath;
        // Symbol: drake::multibody::PackageMap::PackageMap
        struct /* ctor */ {
          // Source: drake/multibody/parsing/package_map.h:19
          const char* doc =
R"""(A constructor that initializes an empty map.)""";
        } ctor;
        // Symbol: drake::multibody::PackageMap::PopulateFromEnvironment
        struct /* PopulateFromEnvironment */ {
          // Source: drake/multibody/parsing/package_map.h:61
          const char* doc =
R"""(Obtains one or more paths from environment variable
``environment_variable``. Crawls downward through the directory
tree(s) starting from the path(s) searching for ``package.xml`` files.
For each of these files, this method adds a new entry into this
PackageMap where the key is the package name as specified within
``package.xml`` and the value is the path to the ``package.xml`` file.
Multiple paths can be specified by separating them using the ':'
symbol. For example, the environment variable can contain [path
1]:[path 2]:[path 3] to search three different paths.)""";
        } PopulateFromEnvironment;
        // Symbol: drake::multibody::PackageMap::PopulateFromFolder
        struct /* PopulateFromFolder */ {
          // Source: drake/multibody/parsing/package_map.h:50
          const char* doc =
R"""(Crawls down the directory tree starting at ``path`` searching for
directories containing the file ``package.xml``. For each of these
directories, this method adds a new entry into this PackageMap where
the key is the package name as specified within ``package.xml`` and
the directory's path is the value.)""";
        } PopulateFromFolder;
        // Symbol: drake::multibody::PackageMap::PopulateUpstreamToDrake
        struct /* PopulateUpstreamToDrake */ {
          // Source: drake/multibody/parsing/package_map.h:70
          const char* doc =
R"""(Crawls up the directory tree from ``model_file`` to ``drake``
searching for ``package.xml`` files. Adds the packages described by
these ``package.xml`` files. If ``model_file`` is not in ``drake``,
this method returns without doing anything.

Parameter ``model_file``:
    The model file whose directory is the start of the search for
    ``package.xml`` files. This file must be an SDF or URDF file.)""";
        } PopulateUpstreamToDrake;
        // Symbol: drake::multibody::PackageMap::Remove
        struct /* Remove */ {
          // Source: drake/multibody/parsing/package_map.h:31
          const char* doc =
R"""(Removes package ``package_name`` and its previously added path. Throws
if ``package_name`` is not present in this PackageMap.)""";
        } Remove;
        // Symbol: drake::multibody::PackageMap::size
        struct /* size */ {
          // Source: drake/multibody/parsing/package_map.h:34
          const char* doc =
R"""(Returns the number of entries in this PackageMap.)""";
        } size;
      } PackageMap;
      // Symbol: drake::multibody::Parser
      struct /* Parser */ {
        // Source: drake/multibody/parsing/parser.h:16
        const char* doc =
R"""(Parses SDF and URDF input files into a MultibodyPlant and (optionally)
a SceneGraph.)""";
        // Symbol: drake::multibody::Parser::AddAllModelsFromFile
        struct /* AddAllModelsFromFile */ {
          // Source: drake/multibody/parsing/parser.h:49
          const char* doc =
R"""(Parses the SDF or URDF file named in ``file_name`` and adds all of its
model(s) to ``plant``.

SDF files may contain multiple ``<model>`` elements. New model
instances will be added to ``plant`` for each ``<model>`` tag in the
file.

URDF files contain a single ``<robot>`` element. Only a single model
instance will be added to ``plant``.

Parameter ``file_name``:
    The name of the SDF or URDF file to be parsed. The file type will
    be inferred from the extension.

Returns:
    The set of model instance indices for the newly added models.

Raises:
    RuntimeError in case of errors.)""";
        } AddAllModelsFromFile;
        // Symbol: drake::multibody::Parser::AddModelFromFile
        struct /* AddModelFromFile */ {
          // Source: drake/multibody/parsing/parser.h:63
          const char* doc =
R"""(Parses the SDF or URDF file named in ``file_name`` and adds one model
to ``plant``. It is an error to call this using an SDF file with more
than one ``<model>`` element.

Parameter ``file_name``:
    The name of the SDF or URDF file to be parsed. The file type will
    be inferred from the extension.

Parameter ``model_name``:
    The name given to the newly created instance of this model. If
    empty, the "name" attribute from the ``<model>`` or ``<robot>``
    tag will be used.

Returns:
    The instance index for the newly added model.

Raises:
    RuntimeError in case of errors.)""";
        } AddModelFromFile;
        // Symbol: drake::multibody::Parser::AddModelFromString
        struct /* AddModelFromString */ {
          // Source: drake/multibody/parsing/parser.h:78
          const char* doc =
R"""(Parses the SDF or URDF XML data passed given in ``file_contents`` and
adds one model to ``plant``. It is an error to call this using an SDF
with more than one ``<model>`` element.

Parameter ``file_contents``:
    The XML data to be parsed.

Parameter ``file_type``:
    The data format; must be either "sdf" or "urdf".

Parameter ``model_name``:
    The name given to the newly created instance of this model. If
    empty, the "name" attribute from the ``<model>`` or ``<robot>``
    tag will be used.

Returns:
    The instance index for the newly added model.

Raises:
    RuntimeError in case of errors.)""";
        } AddModelFromString;
        // Symbol: drake::multibody::Parser::Parser
        struct /* ctor */ {
          // Source: drake/multibody/parsing/parser.h:29
          const char* doc =
R"""(Creates a Parser that adds models to the given plant and (optionally)
scene_graph.

Parameter ``plant``:
    A pointer to a mutable MultibodyPlant object to which parsed
    model(s) will be added; ``plant->is_finalized()`` must remain
    ``False`` for as long as the ``plant`` is in used by ``this``.

Parameter ``scene_graph``:
    A pointer to a mutable SceneGraph object used for geometry
    registration (either to model visual or contact geometry). May be
    nullptr.)""";
        } ctor;
        // Symbol: drake::multibody::Parser::package_map
        struct /* package_map */ {
          // Source: drake/multibody/parsing/parser.h:34
          const char* doc =
R"""(Gets a mutable reference to the PackageMap used by this parser.)""";
        } package_map;
      } Parser;
      // Symbol: drake::multibody::PlanarJoint
      struct /* PlanarJoint */ {
        // Source: drake/multibody/tree/planar_joint.h:33
        const char* doc =
R"""(This joint models a planar joint allowing two bodies to translate and
rotate relative to one another in a plane with three degrees of
freedom. That is, given a frame F attached to the parent body P and a
frame M attached to the child body B (see the Joint class's
documentation), this joint allows frame M to translate within the x-y
plane of frame F and to rotate about the z-axis, with M's z-axis Mz
and F's z-axis Fz coincident at all times. The translations along the
x- and y-axes of F, the rotation about the z-axis and their rates
specify the state of the joint. Zero (x, y, θ) corresponds to frames F
and M being coincident and aligned. Translation (x, y) is defined to
be positive in the direction of the respective axes and the rotation θ
is defined to be positive according to the right-hand-rule with the
thumb aligned in the direction of frame F's z-axis.)""";
        // Symbol: drake::multibody::PlanarJoint::PlanarJoint<T>
        struct /* ctor */ {
          // Source: drake/multibody/tree/planar_joint.h:58
          const char* doc =
R"""(Constructor to create a planar joint between two bodies so that frame
F attached to the parent body P and frame M attached to the child body
B translate and rotate as described in the class's documentation. This
constructor signature creates a joint with no joint limits, i.e. the
joint position, velocity and acceleration limits are the pair ``(-∞,
∞)``. These can be set using the Joint methods set_position_limits(),
set_velocity_limits() and set_acceleration_limits(). The first three
arguments to this constructor are those of the Joint class
constructor. See the Joint class's documentation for details. The
additional parameters are:

Parameter ``damping``:
    Viscous damping coefficient, in N⋅s/m for translation and N⋅m⋅s
    for rotation, used to model losses within the joint. See
    documentation of damping() for details on modelling of the damping
    force and torque.

Raises:
    RuntimeError if any element of damping is negative.)""";
        } ctor;
        // Symbol: drake::multibody::PlanarJoint::damping
        struct /* damping */ {
          // Source: drake/multibody/tree/planar_joint.h:91
          const char* doc =
R"""(Returns ``this`` joint's damping constant in N⋅s/m for the
translational degrees and N⋅m⋅s for the rotational degree. The damping
force (in N) is modeled as ``fᵢ = -dampingᵢ⋅vᵢ, i = 1, 2`` i.e.
opposing motion, with vᵢ the translation rates along the i-th axis for
``this`` joint (see get_translational_velocity()) and fᵢ the force on
child body B at Mo and expressed in F. That is, f_BMo_F = (f₁, f₂).
The damping torque (in N⋅m) is modeled as ``τ = -damping₃⋅ω`` i.e.
opposing motion, with ω the angular rate for ``this`` joint (see
get_angular_velocity()) and τ the torque on child body B expressed in
frame F as t_B_F = τ⋅Fz_F.)""";
        } damping;
        // Symbol: drake::multibody::PlanarJoint::get_angular_velocity
        struct /* get_angular_velocity */ {
          // Source: drake/multibody/tree/planar_joint.h:187
          const char* doc =
R"""(Gets the rate of change, in radians per second, of ``this`` joint's
angle θ from ``context``. See class documentation for the definition
of this angle.

Parameter ``context``:
    The context of the model this joint belongs to.

Returns ``theta_dot``:
    The rate of change of ``this`` joint's angle θ as stored in the
    ``context``.)""";
        } get_angular_velocity;
        // Symbol: drake::multibody::PlanarJoint::get_default_rotation
        struct /* get_default_rotation */ {
          // Source: drake/multibody/tree/planar_joint.h:223
          const char* doc =
R"""(Gets the default angle for ``this`` joint.

Returns ``theta``:
    The default angle of ``this`` joint.)""";
        } get_default_rotation;
        // Symbol: drake::multibody::PlanarJoint::get_default_translation
        struct /* get_default_translation */ {
          // Source: drake/multibody/tree/planar_joint.h:209
          const char* doc =
R"""(Gets the default position for ``this`` joint.

Returns ``p_FoMo_F``:
    The default position of ``this`` joint.)""";
        } get_default_translation;
        // Symbol: drake::multibody::PlanarJoint::get_rotation
        struct /* get_rotation */ {
          // Source: drake/multibody/tree/planar_joint.h:123
          const char* doc =
R"""(Gets the angle θ of ``this`` joint from ``context``.

Parameter ``context``:
    The context of the model this joint belongs to.

Returns ``theta``:
    The angle of ``this`` joint stored in the ``context``. See class
    documentation for details.)""";
        } get_rotation;
        // Symbol: drake::multibody::PlanarJoint::get_translation
        struct /* get_translation */ {
          // Source: drake/multibody/tree/planar_joint.h:101
          const char* doc =
R"""(Gets the position of ``this`` joint from ``context``.

Parameter ``context``:
    The context of the model this joint belongs to.

Returns ``p_FoMo_F``:
    The position of ``this`` joint stored in the ``context`` ordered
    as (x, y). See class documentation for details.)""";
        } get_translation;
        // Symbol: drake::multibody::PlanarJoint::get_translational_velocity
        struct /* get_translational_velocity */ {
          // Source: drake/multibody/tree/planar_joint.h:162
          const char* doc =
R"""(Gets the translational velocity v_FoMo_F, in meters per second, of
``this`` joint's Mo measured and expressed in frame F from
``context``.

Parameter ``context``:
    The context of the model this joint belongs to.

Returns ``v_FoMo_F``:
    The translational velocity of ``this`` joint as stored in the
    ``context``.)""";
        } get_translational_velocity;
        // Symbol: drake::multibody::PlanarJoint::set_angular_velocity
        struct /* set_angular_velocity */ {
          // Source: drake/multibody/tree/planar_joint.h:199
          const char* doc =
R"""(Sets the rate of change, in radians per second, of ``this`` joint's
angle θ (see class documentation) to ``theta_dot``. The new rate of
change gets stored in ``context``.

Parameter ``context``:
    The context of the model this joint belongs to.

Parameter ``theta_dot``:
    The desired rates of change of ``this`` joint's angle in radians
    per second.

Returns:
    a constant reference to ``this`` joint.)""";
        } set_angular_velocity;
        // Symbol: drake::multibody::PlanarJoint::set_default_pose
        struct /* set_default_pose */ {
          // Source: drake/multibody/tree/planar_joint.h:236
          const char* doc =
R"""(Sets the default position and angle of this joint.

Parameter ``p_FoMo_F``:
    The desired default position of the joint

Parameter ``theta``:
    The desired default angle of the joint)""";
        } set_default_pose;
        // Symbol: drake::multibody::PlanarJoint::set_default_rotation
        struct /* set_default_rotation */ {
          // Source: drake/multibody/tree/planar_joint.h:227
          const char* doc =
R"""(Sets the default angle of this joint.

Parameter ``theta``:
    The desired default angle of the joint)""";
        } set_default_rotation;
        // Symbol: drake::multibody::PlanarJoint::set_default_translation
        struct /* set_default_translation */ {
          // Source: drake/multibody/tree/planar_joint.h:215
          const char* doc =
R"""(Sets the default position of this joint.

Parameter ``p_FoMo_F``:
    The desired default position of the joint)""";
        } set_default_translation;
        // Symbol: drake::multibody::PlanarJoint::set_pose
        struct /* set_pose */ {
          // Source: drake/multibody/tree/planar_joint.h:149
          const char* doc =
R"""(Sets the ``context`` so that the position of ``this`` joint equals
``p_FoMo_F`` and its angle equals ``theta``.

Parameter ``context``:
    The context of the model this joint belongs to.

Parameter ``p_FoMo_F``:
    The desired position in meters to be stored in ``context`` ordered
    as (x, y). See class documentation for details.

Parameter ``theta``:
    The desired angle in radians to be stored in ``context``. See
    class documentation for details.

Returns:
    a constant reference to ``this`` joint.)""";
        } set_pose;
        // Symbol: drake::multibody::PlanarJoint::set_random_pose_distribution
        struct /* set_random_pose_distribution */ {
          // Source: drake/multibody/tree/planar_joint.h:244
          const char* doc =
R"""(Sets the random distribution that the position and angle of this joint
will be randomly sampled from. See class documentation for details on
the definition of the position and angle.)""";
        } set_random_pose_distribution;
        // Symbol: drake::multibody::PlanarJoint::set_rotation
        struct /* set_rotation */ {
          // Source: drake/multibody/tree/planar_joint.h:133
          const char* doc =
R"""(Sets the ``context`` so that the angle θ of ``this`` joint equals
``theta``.

Parameter ``context``:
    The context of the model this joint belongs to.

Parameter ``theta``:
    The desired angle in radians to be stored in ``context``. See
    class documentation for details.

Returns:
    a constant reference to ``this`` joint.)""";
        } set_rotation;
        // Symbol: drake::multibody::PlanarJoint::set_translation
        struct /* set_translation */ {
          // Source: drake/multibody/tree/planar_joint.h:112
          const char* doc =
R"""(Sets the ``context`` so that the position of ``this`` joint equals
``p_FoMo_F``.

Parameter ``context``:
    The context of the model this joint belongs to.

Parameter ``p_FoMo_F``:
    The desired position in meters to be stored in ``context`` ordered
    as (x, y). See class documentation for details.

Returns:
    a constant reference to ``this`` joint.)""";
        } set_translation;
        // Symbol: drake::multibody::PlanarJoint::set_translational_velocity
        struct /* set_translational_velocity */ {
          // Source: drake/multibody/tree/planar_joint.h:174
          const char* doc =
R"""(Sets the translational velocity, in meters per second, of this
``this`` joint's Mo measured and expressed in frame F to ``v_FoMo_F``.
The new translational velocity gets stored in ``context``.

Parameter ``context``:
    The context of the model this joint belongs to.

Parameter ``v_FoMo_F``:
    The desired translational velocity of ``this`` joint in meters per
    second.

Returns:
    a constant reference to ``this`` joint.)""";
        } set_translational_velocity;
        // Symbol: drake::multibody::PlanarJoint::type_name
        struct /* type_name */ {
          // Source: drake/multibody/tree/planar_joint.h:77
          const char* doc = R"""()""";
        } type_name;
      } PlanarJoint;
      // Symbol: drake::multibody::PointPairContactInfo
      struct /* PointPairContactInfo */ {
        // Source: drake/multibody/plant/point_pair_contact_info.h:29
        const char* doc =
R"""(A class containing information regarding contact response between two
bodies including:

- The pair of bodies that are contacting, referenced by their BodyIndex.
- A resultant contact force.
- A contact point.
- Separation speed.
- Slip speed.)""";
        // Symbol: drake::multibody::PointPairContactInfo::PointPairContactInfo<T>
        struct /* ctor */ {
          // Source: drake/multibody/plant/point_pair_contact_info.h:55
          const char* doc =
R"""(Constructs the contact information for a given pair of two colliding
bodies.

Parameter ``bodyA_index``:
    Index that references body A in ``this`` contact pair.

Parameter ``bodyB_index``:
    Index that references body B in ``this`` contact pair.

Parameter ``f_Bc_W``:
    Force on body B applied at contact point C, expressed in the world
    frame W.

Parameter ``p_WC``:
    Position of the contact point C in the world frame W.

Parameter ``separation_speed``:
    Separation speed along the normal direction between body A and
    body B, in meters per second. A positive value indicates bodies
    are moving apart. A negative value indicates bodies are moving
    towards each other.

Parameter ``slip_speed``:
    Slip speed, that is, the magnitude of the relative tangential
    velocity at the contact point in meters per second. A non-negative
    value always.

Parameter ``point_pair``:
    Additional point pair information for ``this`` contact info. Refer
    to the documentation for PenetrationAsPointPair for further
    details.

Precondition:
    The two body indexes must reference bodies from the same
    MultibodyPlant. Contact values should likewise be generated by the
    same MultibodyPlant.)""";
        } ctor;
        // Symbol: drake::multibody::PointPairContactInfo::bodyA_index
        struct /* bodyA_index */ {
          // Source: drake/multibody/plant/point_pair_contact_info.h:62
          const char* doc =
R"""(Returns the index of body A in the contact pair.)""";
        } bodyA_index;
        // Symbol: drake::multibody::PointPairContactInfo::bodyB_index
        struct /* bodyB_index */ {
          // Source: drake/multibody/plant/point_pair_contact_info.h:65
          const char* doc =
R"""(Returns the index of body B in the contact pair.)""";
        } bodyB_index;
        // Symbol: drake::multibody::PointPairContactInfo::contact_force
        struct /* contact_force */ {
          // Source: drake/multibody/plant/point_pair_contact_info.h:69
          const char* doc =
R"""(Returns the contact force ``f_Bc_W`` on B at contact point C expressed
in the world frame W.)""";
        } contact_force;
        // Symbol: drake::multibody::PointPairContactInfo::contact_point
        struct /* contact_point */ {
          // Source: drake/multibody/plant/point_pair_contact_info.h:72
          const char* doc =
R"""(Returns the position ``p_WC`` of the contact point C in the world
frame W.)""";
        } contact_point;
        // Symbol: drake::multibody::PointPairContactInfo::point_pair
        struct /* point_pair */ {
          // Source: drake/multibody/plant/point_pair_contact_info.h:84
          const char* doc =
R"""(Returns additional information for the geometric contact query for
``this`` pair as a PenetrationAsPointPair.)""";
        } point_pair;
        // Symbol: drake::multibody::PointPairContactInfo::separation_speed
        struct /* separation_speed */ {
          // Source: drake/multibody/plant/point_pair_contact_info.h:80
          const char* doc =
R"""(Returns the separation speed between body A and B along the normal
direction (see PenetrationAsPointPair::nhat_BA_W) at the contact
point. It is defined positive for bodies moving apart in the normal
direction.)""";
        } separation_speed;
        // Symbol: drake::multibody::PointPairContactInfo::slip_speed
        struct /* slip_speed */ {
          // Source: drake/multibody/plant/point_pair_contact_info.h:75
          const char* doc =
R"""(Returns the slip speed between body A and B at contact point C.)""";
        } slip_speed;
      } PointPairContactInfo;
      // Symbol: drake::multibody::PointToPointDistanceConstraint
      struct /* PointToPointDistanceConstraint */ {
        // Source: drake/multibody/inverse_kinematics/point_to_point_distance_constraint.h:15
        const char* doc =
R"""(Constrain that the distance between a point P1 on frame B1 and another
point P2 on frame B2 is within a range [distance_lower,
distance_upper].)""";
        // Symbol: drake::multibody::PointToPointDistanceConstraint::PointToPointDistanceConstraint
        struct /* ctor */ {
          // Source: drake/multibody/inverse_kinematics/point_to_point_distance_constraint.h:43
          const char* doc =
R"""(Constrain that the distance between a point P1 attached to frame B1
and another point P2 attached to frame B2 is within the range
[distance_lower, distance_upper]. Mathematically, we impose the
constraint distance_lower² <= distance(P1, P2)² <= distance_upper². We
impose the constraint on the distance square instead of distance
directly, because the gradient of distance is not well defined at
distance=0, the the gradient of the distance square is well defined
everywhere.

Parameter ``plant``:
    The MultibodyPlant on which the constraint is imposed. ``plant``
    should be alive during the lifetime of this constraint.

Parameter ``frame1``:
    The frame in which P1 is attached to.

Parameter ``p_B1P1``:
    The position of P1 measured and expressed in B1.

Parameter ``frame2``:
    The frame in which P2 is attached to.

Parameter ``p_B2P2``:
    The position of P2 measured and expressed in B2.

Parameter ``distance_lower``:
    The lower bound on the distance, must be non-negative.

Parameter ``distance_upper``:
    The upper bound on the distance, must be non-negative.

Parameter ``plant_context``:
    The Context that has been allocated for this ``plant``. We will
    update the context when evaluating the constraint.
    ``plant_context`` should be alive during the lifetime of this
    constraint.)""";
        } ctor;
      } PointToPointDistanceConstraint;
      // Symbol: drake::multibody::PositionConstraint
      struct /* PositionConstraint */ {
        // Source: drake/multibody/inverse_kinematics/position_constraint.h:16
        const char* doc =
R"""(Constrains the position of a point Q, rigidly attached to a frame B,
to be within a bounding box measured and expressed in frame A. Namely
p_AQ_lower <= p_AQ <= p_AQ_upper.)""";
        // Symbol: drake::multibody::PositionConstraint::PositionConstraint
        struct /* ctor */ {
          // Source: drake/multibody/inverse_kinematics/position_constraint.h:40
          const char* doc =
R"""(Constructs PositionConstraint object.

Parameter ``plant``:
    The MultibodyPlant on which the constraint is imposed. ``plant``
    should be alive during the lifetime of this constraint.

Parameter ``frameA``:
    The frame in which point Q's position is measured.

Parameter ``p_AQ_lower``:
    The lower bound on the position of point Q, measured and expressed
    in frame A.

Parameter ``p_AQ_upper``:
    The upper bound on the position of point Q, measured and expressed
    in frame A.

Parameter ``frameB``:
    The frame to which point Q is rigidly attached.

Parameter ``p_BQ``:
    The position of the point Q, rigidly attached to frame B, measured
    and expressed in frame B.

Parameter ``plant_context``:
    The Context that has been allocated for this ``plant``. We will
    update the context when evaluating the constraint.
    ``plant_context`` should be alive during the lifetime of this
    constraint.

Precondition:
    ``frameA`` and ``frameB`` must belong to ``plant``.

Precondition:
    p_AQ_lower(i) <= p_AQ_upper(i) for i = 1, 2, 3.

Raises:
    ValueError if ``plant`` is nullptr.

Raises:
    ValueError if ``plant_context`` is nullptr.)""";
        } ctor;
      } PositionConstraint;
      // Symbol: drake::multibody::PrismaticJoint
      struct /* PrismaticJoint */ {
        // Source: drake/multibody/tree/prismatic_joint.h:29
        const char* doc =
R"""(This Joint allows two bodies to translate relative to one another
along a common axis. That is, given a frame F attached to the parent
body P and a frame M attached to the child body B (see the Joint
class's documentation), this Joint allows frames F and M to translate
with respect to each other along an axis â. The translation distance
is defined positive when child body B translates along the direction
of â. Axis â is constant and has the same measures in both frames F
and M, that is, ``â_F = â_M``.)""";
        // Symbol: drake::multibody::PrismaticJoint::AddInForce
        struct /* AddInForce */ {
          // Source: drake/multibody/tree/prismatic_joint.h:216
          const char* doc =
R"""(Adds into ``multibody_forces`` a given ``force``, in Newtons, for
``this`` joint that is to be applied along the joint's axis. The force
is defined to be positive in the direction along this joint's axis.
That is, a positive force causes a positive translational acceleration
along the joint's axis.)""";
        } AddInForce;
        // Symbol: drake::multibody::PrismaticJoint::DoAddInDamping
        struct /* DoAddInDamping */ {
          // Source: drake/multibody/tree/prismatic_joint.h:252
          const char* doc =
R"""(Joint<T> override called through public NVI, Joint::AddInDamping().
Therefore arguments were already checked to be valid. This method adds
into ``forces`` a dissipative force according to the viscous law ``f =
-d⋅v``, with d the damping coefficient (see damping()).)""";
        } DoAddInDamping;
        // Symbol: drake::multibody::PrismaticJoint::DoAddInOneForce
        struct /* DoAddInOneForce */ {
          // Source: drake/multibody/tree/prismatic_joint.h:235
          const char* doc =
R"""(Joint<T> virtual override called through public NVI,
Joint::AddInForce(). Therefore arguments were already checked to be
valid. For a PrismaticJoint, we must always have ``joint_dof = 0``
since there is only a single degree of freedom (num_velocities() ==
1). ``joint_tau`` is the linear force applied along the joint's axis,
on the body declared as child (according to the prismatic joint's
constructor) at the origin of the child frame (which is coincident
with the origin of the parent frame at all times).)""";
        } DoAddInOneForce;
        // Symbol: drake::multibody::PrismaticJoint::PrismaticJoint<T>
        struct /* ctor */ {
          // Source: drake/multibody/tree/prismatic_joint.h:67
          const char* doc =
R"""(Constructor to create a prismatic joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B, translate relatively to one another along a common axis.
See this class's documentation for further details on the definition
of these frames and translation distance. The first three arguments to
this constructor are those of the Joint class constructor. See the
Joint class's documentation for details. The additional parameter
``axis`` is:

Parameter ``axis``:
    A vector in ℝ³ specifying the translation axis for this joint.
    Given that frame M only translates with respect to F and there is
    no relative rotation, the measures of ``axis`` in either frame F
    or M are exactly the same, that is, ``axis_F = axis_M``. This
    vector can have any length, only the direction is used.

Parameter ``pos_lower_limit``:
    Lower position limit, in meters, for the translation coordinate
    (see get_translation()).

Parameter ``pos_upper_limit``:
    Upper position limit, in meters, for the translation coordinate
    (see get_translation()).

Parameter ``damping``:
    Viscous damping coefficient, in N⋅s/m, used to model losses within
    the joint. The damping force (in N) is modeled as ``f =
    -damping⋅v``, i.e. opposing motion, with v the translational speed
    for ``this`` joint (see get_translation_rate()).

Raises:
    RuntimeError if the L2 norm of ``axis`` is less than the square
    root of machine epsilon.

Raises:
    RuntimeError if damping is negative.

Raises:
    RuntimeError if pos_lower_limit > pos_upper_limit.)""";
        } ctor;
        // Symbol: drake::multibody::PrismaticJoint::acceleration_lower_limit
        struct /* acceleration_lower_limit */ {
          // Source: drake/multibody/tree/prismatic_joint.h:129
          const char* doc =
R"""(Returns the acceleration lower limit for ``this`` joint in meters per
second squared.)""";
        } acceleration_lower_limit;
        // Symbol: drake::multibody::PrismaticJoint::acceleration_upper_limit
        struct /* acceleration_upper_limit */ {
          // Source: drake/multibody/tree/prismatic_joint.h:135
          const char* doc =
R"""(Returns the acceleration upper limit for ``this`` joint in meters per
second squared.)""";
        } acceleration_upper_limit;
        // Symbol: drake::multibody::PrismaticJoint::damping
        struct /* damping */ {
          // Source: drake/multibody/tree/prismatic_joint.h:105
          const char* doc =
R"""(Returns ``this`` joint's damping constant in N⋅s/m.)""";
        } damping;
        // Symbol: drake::multibody::PrismaticJoint::get_default_translation
        struct /* get_default_translation */ {
          // Source: drake/multibody/tree/prismatic_joint.h:193
          const char* doc =
R"""(Gets the default translation. Wrapper for the more general
``Joint::default_positions()``.

Returns:
    The default translation of ``this`` stored in
    ``default_positions_``.)""";
        } get_default_translation;
        // Symbol: drake::multibody::PrismaticJoint::get_translation
        struct /* get_translation */ {
          // Source: drake/multibody/tree/prismatic_joint.h:146
          const char* doc =
R"""(Gets the translation distance of ``this`` mobilizer from ``context``.

Parameter ``context``:
    The context of the MultibodyTree this joint belongs to.

Returns:
    The translation coordinate of ``this`` joint read from
    ``context``.)""";
        } get_translation;
        // Symbol: drake::multibody::PrismaticJoint::get_translation_rate
        struct /* get_translation_rate */ {
          // Source: drake/multibody/tree/prismatic_joint.h:169
          const char* doc =
R"""(Gets the rate of change, in meters per second, of ``this`` joint's
translation distance (see get_translation()) from ``context``.

Parameter ``context``:
    The context of the MultibodyTree this joint belongs to.

Returns:
    The rate of change of ``this`` joint's translation read from
    ``context``.)""";
        } get_translation_rate;
        // Symbol: drake::multibody::PrismaticJoint::position_lower_limit
        struct /* position_lower_limit */ {
          // Source: drake/multibody/tree/prismatic_joint.h:108
          const char* doc =
R"""(Returns the position lower limit for ``this`` joint in meters.)""";
        } position_lower_limit;
        // Symbol: drake::multibody::PrismaticJoint::position_upper_limit
        struct /* position_upper_limit */ {
          // Source: drake/multibody/tree/prismatic_joint.h:113
          const char* doc =
R"""(Returns the position upper limit for ``this`` joint in meters.)""";
        } position_upper_limit;
        // Symbol: drake::multibody::PrismaticJoint::set_default_translation
        struct /* set_default_translation */ {
          // Source: drake/multibody/tree/prismatic_joint.h:201
          const char* doc =
R"""(Sets the ``default_positions`` of this joint (in this case a single
translation)

Parameter ``translation``:
    The desired default translation of the joint)""";
        } set_default_translation;
        // Symbol: drake::multibody::PrismaticJoint::set_random_translation_distribution
        struct /* set_random_translation_distribution */ {
          // Source: drake/multibody/tree/prismatic_joint.h:205
          const char* doc = R"""()""";
        } set_random_translation_distribution;
        // Symbol: drake::multibody::PrismaticJoint::set_translation
        struct /* set_translation */ {
          // Source: drake/multibody/tree/prismatic_joint.h:157
          const char* doc =
R"""(Sets ``context`` so that the generalized coordinate corresponding to
the translation distance of ``this`` joint equals ``translation``.

Parameter ``context``:
    The context of the MultibodyTree this joint belongs to.

Parameter ``translation``:
    The desired translation in meters to be stored in ``context``.

Returns:
    a constant reference to ``this`` joint.)""";
        } set_translation;
        // Symbol: drake::multibody::PrismaticJoint::set_translation_rate
        struct /* set_translation_rate */ {
          // Source: drake/multibody/tree/prismatic_joint.h:182
          const char* doc =
R"""(Sets the rate of change, in meters per second, of ``this`` joint's
translation distance to ``translation_dot``. The new rate of change
``translation_dot`` gets stored in ``context``.

Parameter ``context``:
    The context of the MultibodyTree this joint belongs to.

Parameter ``translation_dot``:
    The desired rate of change of ``this`` joints's translation in
    meters per second.

Returns:
    a constant reference to ``this`` joint.)""";
        } set_translation_rate;
        // Symbol: drake::multibody::PrismaticJoint::translation_axis
        struct /* translation_axis */ {
          // Source: drake/multibody/tree/prismatic_joint.h:100
          const char* doc =
R"""(Returns the axis of translation for ``this`` joint as a unit vector.
Since the measures of this axis in either frame F or M are the same
(see this class's documentation for frames's definitions) then, ``axis
= axis_F = axis_M``.)""";
        } translation_axis;
        // Symbol: drake::multibody::PrismaticJoint::type_name
        struct /* type_name */ {
          // Source: drake/multibody/tree/prismatic_joint.h:91
          const char* doc = R"""()""";
        } type_name;
        // Symbol: drake::multibody::PrismaticJoint::velocity_lower_limit
        struct /* velocity_lower_limit */ {
          // Source: drake/multibody/tree/prismatic_joint.h:118
          const char* doc =
R"""(Returns the velocity lower limit for ``this`` joint in meters per
second.)""";
        } velocity_lower_limit;
        // Symbol: drake::multibody::PrismaticJoint::velocity_upper_limit
        struct /* velocity_upper_limit */ {
          // Source: drake/multibody/tree/prismatic_joint.h:123
          const char* doc =
R"""(Returns the velocity upper limit for ``this`` joint in meters per
second.)""";
        } velocity_upper_limit;
      } PrismaticJoint;
      // Symbol: drake::multibody::Propeller
      struct /* Propeller */ {
        // Source: drake/multibody/plant/propeller.h:82
        const char* doc =
R"""(A System that connects to the MultibodyPlant in order to model the
effects of one or more controlled propellers acting on a Body.

.. pydrake_system::

    name: Propeller
    input_ports:
    - command
    - body_poses
    output_ports:
    - spatial_forces

- The command input is a BasicVector<T> with one element per propeller.
- It is expected that the body_poses input should be connected to the
MultibodyPlant::get_body_poses_output_port() "MultibodyPlant body_poses
output port".
- The output is of type std::vector<ExternallyAppliedSpatialForce<T>>; it is
expected that this output will be connected to the MultibodyPlant::get_applied_spatial_force_input_port()
"externally_applied_spatial_force input port" of the MultibodyPlant.
- This system does not have any state.

The resulting iᵗʰ spatial force will have a force component in the
z-axis of the iᵗʰ propeller frame with magnitude ``thrust_ratio *
command`` Newtons, and a moment around the z-axis with magnitude
``moment_ratio * command`` Newton-meters. (Including these moments
tends to be important -- a quadrotor does not have a stabilizable
linearization around a hovering fixed point in 3D without them).

Note:
    Set PropellerInfo::moment_ratio to zero if you want a simple
    thruster which applies only a force (no moment) in the Propeller
    coordinates.)""";
        // Symbol: drake::multibody::Propeller::Propeller<T>
        struct /* ctor */ {
          // Source: drake/multibody/plant/propeller.h:88
          const char* doc_4args =
R"""(Constructs a system describing a single propeller.

See also:
    PropellerInfo for details on the arguments.)""";
          // Source: drake/multibody/plant/propeller.h:95
          const char* doc_1args =
R"""(Constructs a system describing multiple propellers.

See also:
    PropellerInfo.)""";
          // Source: drake/multibody/plant/propeller.h:99
          const char* doc_copyconvert =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";
        } ctor;
        // Symbol: drake::multibody::Propeller::get_body_poses_input_port
        struct /* get_body_poses_input_port */ {
          // Source: drake/multibody/plant/propeller.h:115
          const char* doc =
R"""(Returns a reference to the body_poses input port. It is anticipated
that this port will be connected the body_poses output port of a
MultibodyPlant.)""";
        } get_body_poses_input_port;
        // Symbol: drake::multibody::Propeller::get_command_input_port
        struct /* get_command_input_port */ {
          // Source: drake/multibody/plant/propeller.h:108
          const char* doc =
R"""(Returns a reference to the vector-valued input port for the propeller
commands. It has size ``num_propellers()``.)""";
        } get_command_input_port;
        // Symbol: drake::multibody::Propeller::get_spatial_forces_output_port
        struct /* get_spatial_forces_output_port */ {
          // Source: drake/multibody/plant/propeller.h:123
          const char* doc =
R"""(Returns a reference to the spatial_forces output port. It is
anticipated that this port will be connected to the
MultibodyPlant::get_applied_spatial_force_input_port()
"applied_spatial_force" input port of a MultibodyPlant.)""";
        } get_spatial_forces_output_port;
        // Symbol: drake::multibody::Propeller::num_propellers
        struct /* num_propellers */ {
          // Source: drake/multibody/plant/propeller.h:104
          const char* doc =
R"""(Returns the number of propellers modeled by this system.)""";
        } num_propellers;
      } Propeller;
      // Symbol: drake::multibody::PropellerInfo
      struct /* PropellerInfo */ {
        // Source: drake/multibody/plant/propeller.h:16
        const char* doc =
R"""(Parameters that describe the kinematic frame and force-production
properties of a single propeller.)""";
        // Symbol: drake::multibody::PropellerInfo::PropellerInfo
        struct /* ctor */ {
          // Source: drake/multibody/plant/propeller.h:17
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::multibody::PropellerInfo::X_BP
        struct /* X_BP */ {
          // Source: drake/multibody/plant/propeller.h:34
          const char* doc =
R"""(Pose of the propeller frame P measured in the body frame B.
$*Default:* is the identity matrix.)""";
        } X_BP;
        // Symbol: drake::multibody::PropellerInfo::body_index
        struct /* body_index */ {
          // Source: drake/multibody/plant/propeller.h:30
          const char* doc =
R"""(The BodyIndex of a Body in the MultibodyPlant to which the propeller
is attached. The spatial forces will be applied to this body.)""";
        } body_index;
        // Symbol: drake::multibody::PropellerInfo::moment_ratio
        struct /* moment_ratio */ {
          // Source: drake/multibody/plant/propeller.h:44
          const char* doc =
R"""(The moment about the z axis (in frame P) of the spatial force will
have magnitude ``moment_ratio*command`` in Newton-meters. The default
is 0, which makes the propeller a simple Cartesian force generator.)""";
        } moment_ratio;
        // Symbol: drake::multibody::PropellerInfo::thrust_ratio
        struct /* thrust_ratio */ {
          // Source: drake/multibody/plant/propeller.h:39
          const char* doc =
R"""(The z component (in frame P) of the spatial force will have magnitude
``thrust_ratio*command`` in Newtons. The default is 1 (command in
Newtons), but this can also be used to scale an actuator command to
the resulting force.)""";
        } thrust_ratio;
      } PropellerInfo;
      // Symbol: drake::multibody::RevoluteJoint
      struct /* RevoluteJoint */ {
        // Source: drake/multibody/tree/revolute_joint.h:30
        const char* doc =
R"""(This Joint allows two bodies to rotate relatively to one another
around a common axis. That is, given a frame F attached to the parent
body P and a frame M attached to the child body B (see the Joint
class's documentation), this Joint allows frames F and M to rotate
with respect to each other about an axis â. The rotation angle's sign
is defined such that child body B rotates about axis â according to
the right hand rule, with thumb aligned in the axis direction. Axis â
is constant and has the same measures in both frames F and M, that is,
``â_F = â_M``.)""";
        // Symbol: drake::multibody::RevoluteJoint::AddInTorque
        struct /* AddInTorque */ {
          // Source: drake/multibody/tree/revolute_joint.h:245
          const char* doc =
R"""(Adds into ``forces`` a given ``torque`` for ``this`` joint that is to
be applied about the joint's axis. The torque is defined to be
positive according to the right-hand-rule with the thumb aligned in
the direction of ``this`` joint's axis. That is, a positive torque
causes a positive rotational acceleration according to the
right-hand-rule around the joint's axis.

Note:
    A torque is the moment of a set of forces whose resultant is zero.)""";
        } AddInTorque;
        // Symbol: drake::multibody::RevoluteJoint::DoAddInDamping
        struct /* DoAddInDamping */ {
          // Source: drake/multibody/tree/revolute_joint.h:285
          const char* doc =
R"""(Joint<T> override called through public NVI, Joint::AddInDamping().
Therefore arguments were already checked to be valid. This method adds
into ``forces`` a dissipative torque according to the viscous law ``τ
= -d⋅ω``, with d the damping coefficient (see damping()).)""";
        } DoAddInDamping;
        // Symbol: drake::multibody::RevoluteJoint::DoAddInOneForce
        struct /* DoAddInOneForce */ {
          // Source: drake/multibody/tree/revolute_joint.h:267
          const char* doc =
R"""(Joint<T> override called through public NVI, Joint::AddInForce().
Therefore arguments were already checked to be valid. For a
RevoluteJoint, we must always have ``joint_dof = 0`` since there is
only a single degree of freedom (num_velocities() == 1). ``joint_tau``
is the torque applied about the joint's axis, on the body declared as
child (according to the revolute joint's constructor) at the origin of
the child frame (which is coincident with the origin of the parent
frame at all times). The torque is defined to be positive according to
the right-hand-rule with the thumb aligned in the direction of
``this`` joint's axis. That is, a positive torque causes a positive
rotational acceleration (of the child body frame) according to the
right-hand-rule around the joint's axis.)""";
        } DoAddInOneForce;
        // Symbol: drake::multibody::RevoluteJoint::RevoluteJoint<T>
        struct /* ctor */ {
          // Source: drake/multibody/tree/revolute_joint.h:64
          const char* doc_5args =
R"""(Constructor to create a revolute joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B, rotate relatively to one another about a common axis.
See this class's documentation for further details on the definition
of these frames and rotation angle. This constructor signature creates
a joint with no joint limits, i.e. the joint position, velocity and
acceleration limits are the pair ``(-∞, ∞)``. The first three
arguments to this constructor are those of the Joint class
constructor. See the Joint class's documentation for details. The
additional parameters are:

Parameter ``axis``:
    A vector in ℝ³ specifying the axis of revolution for this joint.
    Given that frame M only rotates with respect to F and their
    origins are coincident at all times, the measures of ``axis`` in
    either frame F or M are exactly the same, that is, ``axis_F =
    axis_M``. In other words, ``axis_F`` (or ``axis_M``) is the
    eigenvector of ``R_FM`` with eigenvalue equal to one. This vector
    can have any length, only the direction is used. This method
    aborts if ``axis`` is the zero vector.

Parameter ``damping``:
    Viscous damping coefficient, in N⋅m⋅s, used to model losses within
    the joint. The damping torque (in N⋅m) is modeled as ``τ =
    -damping⋅ω``, i.e. opposing motion, with ω the angular rate for
    ``this`` joint (see get_angular_rate()).

Raises:
    RuntimeError if damping is negative.)""";
          // Source: drake/multibody/tree/revolute_joint.h:102
          const char* doc_7args =
R"""(Constructor to create a revolute joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B, rotate relatively to one another about a common axis.
See this class's documentation for further details on the definition
of these frames and rotation angle. The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class's documentation for details. The additional parameters are:

Parameter ``axis``:
    A vector in ℝ³ specifying the axis of revolution for this joint.
    Given that frame M only rotates with respect to F and their
    origins are coincident at all times, the measures of ``axis`` in
    either frame F or M are exactly the same, that is, ``axis_F =
    axis_M``. In other words, ``axis_F`` (or ``axis_M``) is the
    eigenvector of ``R_FM`` with eigenvalue equal to one. This vector
    can have any length, only the direction is used. This method
    aborts if ``axis`` is the zero vector.

Parameter ``pos_lower_limit``:
    Lower position limit, in radians, for the rotation coordinate (see
    get_angle()).

Parameter ``pos_upper_limit``:
    Upper position limit, in radians, for the rotation coordinate (see
    get_angle()).

Parameter ``damping``:
    Viscous damping coefficient, in N⋅m⋅s, used to model losses within
    the joint. The damping torque (in N⋅m) is modeled as ``τ =
    -damping⋅ω``, i.e. opposing motion, with ω the angular rate for
    ``this`` joint (see get_angular_rate()).

Raises:
    RuntimeError if damping is negative.

Raises:
    RuntimeError if pos_lower_limit > pos_upper_limit.)""";
        } ctor;
        // Symbol: drake::multibody::RevoluteJoint::acceleration_lower_limit
        struct /* acceleration_lower_limit */ {
          // Source: drake/multibody/tree/revolute_joint.h:161
          const char* doc =
R"""(Returns the acceleration lower limit for ``this`` joint in radians /
s².)""";
        } acceleration_lower_limit;
        // Symbol: drake::multibody::RevoluteJoint::acceleration_upper_limit
        struct /* acceleration_upper_limit */ {
          // Source: drake/multibody/tree/revolute_joint.h:166
          const char* doc =
R"""(Returns the acceleration upper limit for ``this`` joint in radians /
s².)""";
        } acceleration_upper_limit;
        // Symbol: drake::multibody::RevoluteJoint::damping
        struct /* damping */ {
          // Source: drake/multibody/tree/revolute_joint.h:138
          const char* doc =
R"""(Returns ``this`` joint's damping constant in N⋅m⋅s.)""";
        } damping;
        // Symbol: drake::multibody::RevoluteJoint::get_angle
        struct /* get_angle */ {
          // Source: drake/multibody/tree/revolute_joint.h:177
          const char* doc =
R"""(Gets the rotation angle of ``this`` mobilizer from ``context``.

Parameter ``context``:
    The context of the MultibodyTree this joint belongs to.

Returns:
    The angle coordinate of ``this`` joint stored in the ``context``.)""";
        } get_angle;
        // Symbol: drake::multibody::RevoluteJoint::get_angular_rate
        struct /* get_angular_rate */ {
          // Source: drake/multibody/tree/revolute_joint.h:205
          const char* doc =
R"""(Gets the rate of change, in radians per second, of ``this`` joint's
angle (see get_angle()) from ``context``.

Parameter ``context``:
    The context of the MultibodyTree this joint belongs to.

Returns:
    The rate of change of ``this`` joint's angle as stored in the
    ``context``.)""";
        } get_angular_rate;
        // Symbol: drake::multibody::RevoluteJoint::get_default_angle
        struct /* get_default_angle */ {
          // Source: drake/multibody/tree/revolute_joint.h:229
          const char* doc =
R"""(Gets the default rotation angle. Wrapper for the more general
``Joint::default_positions()``.

Returns:
    The default angle of ``this`` stored in ``default_positions_``)""";
        } get_default_angle;
        // Symbol: drake::multibody::RevoluteJoint::position_lower_limit
        struct /* position_lower_limit */ {
          // Source: drake/multibody/tree/revolute_joint.h:141
          const char* doc =
R"""(Returns the position lower limit for ``this`` joint in radians.)""";
        } position_lower_limit;
        // Symbol: drake::multibody::RevoluteJoint::position_upper_limit
        struct /* position_upper_limit */ {
          // Source: drake/multibody/tree/revolute_joint.h:146
          const char* doc =
R"""(Returns the position upper limit for ``this`` joint in radians.)""";
        } position_upper_limit;
        // Symbol: drake::multibody::RevoluteJoint::revolute_axis
        struct /* revolute_axis */ {
          // Source: drake/multibody/tree/revolute_joint.h:133
          const char* doc =
R"""(Returns the axis of revolution of ``this`` joint as a unit vector.
Since the measures of this axis in either frame F or M are the same
(see this class's documentation for frames's definitions) then, ``axis
= axis_F = axis_M``.)""";
        } revolute_axis;
        // Symbol: drake::multibody::RevoluteJoint::set_angle
        struct /* set_angle */ {
          // Source: drake/multibody/tree/revolute_joint.h:188
          const char* doc =
R"""(Sets the ``context`` so that the generalized coordinate corresponding
to the rotation angle of ``this`` joint equals ``angle``.

Parameter ``context``:
    The context of the MultibodyTree this joint belongs to.

Parameter ``angle``:
    The desired angle in radians to be stored in ``context``.

Returns:
    a constant reference to ``this`` joint.)""";
        } set_angle;
        // Symbol: drake::multibody::RevoluteJoint::set_angular_rate
        struct /* set_angular_rate */ {
          // Source: drake/multibody/tree/revolute_joint.h:218
          const char* doc =
R"""(Sets the rate of change, in radians per second, of this ``this``
joint's angle to ``theta_dot``. The new rate of change ``theta_dot``
gets stored in ``context``.

Parameter ``context``:
    The context of the MultibodyTree this joint belongs to.

Parameter ``theta_dot``:
    The desired rate of change of ``this`` joints's angle in radians
    per second.

Returns:
    a constant reference to ``this`` joint.)""";
        } set_angular_rate;
        // Symbol: drake::multibody::RevoluteJoint::set_default_angle
        struct /* set_default_angle */ {
          // Source: drake/multibody/tree/revolute_joint.h:234
          const char* doc =
R"""(Sets the ``default_positions`` of this joint (in this case a single
angle).

Parameter ``angle``:
    The desired default angle of the joint)""";
        } set_default_angle;
        // Symbol: drake::multibody::RevoluteJoint::set_random_angle_distribution
        struct /* set_random_angle_distribution */ {
          // Source: drake/multibody/tree/revolute_joint.h:194
          const char* doc = R"""()""";
        } set_random_angle_distribution;
        // Symbol: drake::multibody::RevoluteJoint::type_name
        struct /* type_name */ {
          // Source: drake/multibody/tree/revolute_joint.h:124
          const char* doc = R"""()""";
        } type_name;
        // Symbol: drake::multibody::RevoluteJoint::velocity_lower_limit
        struct /* velocity_lower_limit */ {
          // Source: drake/multibody/tree/revolute_joint.h:151
          const char* doc =
R"""(Returns the velocity lower limit for ``this`` joint in radians / s.)""";
        } velocity_lower_limit;
        // Symbol: drake::multibody::RevoluteJoint::velocity_upper_limit
        struct /* velocity_upper_limit */ {
          // Source: drake/multibody/tree/revolute_joint.h:156
          const char* doc =
R"""(Returns the velocity upper limit for ``this`` joint in radians / s.)""";
        } velocity_upper_limit;
      } RevoluteJoint;
      // Symbol: drake::multibody::RevoluteSpring
      struct /* RevoluteSpring */ {
        // Source: drake/multibody/tree/revolute_spring.h:27
        const char* doc =
R"""(This ForceElement models a torsional spring attached to a
RevoluteJoint and applies a torque to that joint


::

    τ = -k⋅(θ - θ₀)

where θ₀ is the nominal joint position. Note that joint damping exists
within the RevoluteJoint itself, and so is not included here.)""";
        // Symbol: drake::multibody::RevoluteSpring::CalcConservativePower
        struct /* CalcConservativePower */ {
          // Source: drake/multibody/tree/revolute_spring.h:51
          const char* doc = R"""()""";
        } CalcConservativePower;
        // Symbol: drake::multibody::RevoluteSpring::CalcNonConservativePower
        struct /* CalcNonConservativePower */ {
          // Source: drake/multibody/tree/revolute_spring.h:56
          const char* doc = R"""()""";
        } CalcNonConservativePower;
        // Symbol: drake::multibody::RevoluteSpring::CalcPotentialEnergy
        struct /* CalcPotentialEnergy */ {
          // Source: drake/multibody/tree/revolute_spring.h:47
          const char* doc = R"""()""";
        } CalcPotentialEnergy;
        // Symbol: drake::multibody::RevoluteSpring::DoCalcAndAddForceContribution
        struct /* DoCalcAndAddForceContribution */ {
          // Source: drake/multibody/tree/revolute_spring.h:62
          const char* doc = R"""()""";
        } DoCalcAndAddForceContribution;
        // Symbol: drake::multibody::RevoluteSpring::DoCloneToScalar
        struct /* DoCloneToScalar */ {
          // Source: drake/multibody/tree/revolute_spring.h:68
          const char* doc = R"""()""";
        } DoCloneToScalar;
        // Symbol: drake::multibody::RevoluteSpring::RevoluteSpring<T>
        struct /* ctor */ {
          // Source: drake/multibody/tree/revolute_spring.h:38
          const char* doc =
R"""(Constructor for a spring attached to the given joint

Parameter ``nominal_angle``:
    The nominal angle of the spring θ₀, in radians, at which the
    spring applies no moment.

Parameter ``stiffness``:
    The stiffness k of the spring in N⋅m/rad.

Raises:
    RuntimeError if ``stiffness`` is negative.)""";
        } ctor;
        // Symbol: drake::multibody::RevoluteSpring::joint
        struct /* joint */ {
          // Source: drake/multibody/tree/revolute_spring.h:41
          const char* doc = R"""()""";
        } joint;
        // Symbol: drake::multibody::RevoluteSpring::nominal_angle
        struct /* nominal_angle */ {
          // Source: drake/multibody/tree/revolute_spring.h:43
          const char* doc = R"""()""";
        } nominal_angle;
        // Symbol: drake::multibody::RevoluteSpring::stiffness
        struct /* stiffness */ {
          // Source: drake/multibody/tree/revolute_spring.h:45
          const char* doc = R"""()""";
        } stiffness;
      } RevoluteSpring;
      // Symbol: drake::multibody::RigidBody
      struct /* RigidBody */ {
        // Source: drake/multibody/tree/rigid_body.h:45
        const char* doc =
R"""(The term **rigid body** implies that the deformations of the body
under consideration are so small that they have no significant effect
on the overall motions of the body and therefore deformations can be
neglected. If deformations are neglected, the distance between any two
points on the rigid body remains constant at all times. This
invariance of the distance between two arbitrary points is often taken
as the definition of a rigid body in classical treatments of multibody
mechanics [Goldstein 2001]. It can be demonstrated that the
unconstrained three-dimensional motions of a rigid body can be
described by six coordinates and thus it is often said that a free
body in space has six **degrees of freedom**. These degrees of freedom
obey the Newton-Euler equations of motion. However, within a
MultibodyTree, a RigidBody is *not* free in space; instead, it is
assigned a limited number of degrees of freedom (0-6) with respect to
its parent body in the multibody tree by its Mobilizer (also called a
"tree joint" or "inboard joint"). Additional constraints on
permissible motion can be added using Constraint objects to remove
more degrees of freedom.

- [Goldstein 2001] H Goldstein, CP Poole, JL Safko, Classical Mechanics
                   (3rd Edition), Addison-Wesley, 2001.)""";
        // Symbol: drake::multibody::RigidBody::CalcCenterOfMassInBodyFrame
        struct /* CalcCenterOfMassInBodyFrame */ {
          // Source: drake/multibody/tree/rigid_body.h:148
          const char* doc =
R"""(Gets the center of mass stored in ``context``

Raises:
    RuntimeError if ``this`` RigidBody is not owned by a
    MultibodyPlant)""";
        } CalcCenterOfMassInBodyFrame;
        // Symbol: drake::multibody::RigidBody::CalcCenterOfMassTranslationalVelocityInWorld
        struct /* CalcCenterOfMassTranslationalVelocityInWorld */ {
          // Source: drake/multibody/tree/rigid_body.h:160
          const char* doc =
R"""(Calculates Bcm's translational velocity in the world frame W.

Parameter ``context``:
    The context contains the state of the model.

Returns ``v_WBcm_W``:
    The translational velocity of Bcm (``this`` rigid body's center of
    mass) in the world frame W, expressed in W.)""";
        } CalcCenterOfMassTranslationalVelocityInWorld;
        // Symbol: drake::multibody::RigidBody::CalcSpatialInertiaInBodyFrame
        struct /* CalcSpatialInertiaInBodyFrame */ {
          // Source: drake/multibody/tree/rigid_body.h:184
          const char* doc =
R"""(Gets the spatial inertia stored in ``context``

Raises:
    RuntimeError if ``this`` RigidBody is not owned by a
    MultibodyPlant.)""";
        } CalcSpatialInertiaInBodyFrame;
        // Symbol: drake::multibody::RigidBody::DoCloneToScalar
        struct /* DoCloneToScalar */ {
          // Source: drake/multibody/tree/rigid_body.h:343
          const char* doc = R"""()""";
        } DoCloneToScalar;
        // Symbol: drake::multibody::RigidBody::DoDeclareParameters
        struct /* DoDeclareParameters */ {
          // Source: drake/multibody/tree/rigid_body.h:361
          const char* doc = R"""()""";
        } DoDeclareParameters;
        // Symbol: drake::multibody::RigidBody::RigidBody<T>
        struct /* ctor */ {
          // Source: drake/multibody/tree/rigid_body.h:55
          const char* doc_1args =
R"""(Constructs a RigidBody with the given default SpatialInertia.

Parameter ``M_BBo_B``:
    Spatial inertia of ``this`` body B about the frame's origin ``Bo``
    and expressed in the body frame B.

Note:
    See multibody_spatial_inertia for details on the monogram notation
    used for spatial inertia quantities.)""";
          // Source: drake/multibody/tree/rigid_body.h:67
          const char* doc_2args =
R"""(Constructs a RigidBody named ``body_name`` with the given default
SpatialInertia.

Parameter ``body_name``:
    A name associated with ``this`` body.

Parameter ``M_BBo_B``:
    Spatial inertia of ``this`` body B about the frame's origin ``Bo``
    and expressed in the body frame B.

Note:
    See multibody_spatial_inertia for details on the monogram notation
    used for spatial inertia quantities.)""";
          // Source: drake/multibody/tree/rigid_body.h:82
          const char* doc_3args =
R"""(Constructs a RigidBody named ``body_name`` with the given default
SpatialInertia.

Parameter ``body_name``:
    A name associated with ``this`` body.

Parameter ``model_instance``:
    The model instance associated with ``this`` body.

Parameter ``M_BBo_B``:
    Spatial inertia of ``this`` body B about the frame's origin ``Bo``
    and expressed in the body frame B.

Note:
    See multibody_spatial_inertia for details on the monogram notation
    used for spatial inertia quantities.)""";
        } ctor;
        // Symbol: drake::multibody::RigidBody::SetCenterOfMassInBodyFrame
        struct /* SetCenterOfMassInBodyFrame */ {
          // Source: drake/multibody/tree/rigid_body.h:206
          const char* doc =
R"""(Sets the center of mass stored in ``context`` to ``center_of_mass``

Raises:
    RuntimeError if ``this`` RigidBody is not owned by a
    MultibodyPlant)""";
        } SetCenterOfMassInBodyFrame;
        // Symbol: drake::multibody::RigidBody::SetMass
        struct /* SetMass */ {
          // Source: drake/multibody/tree/rigid_body.h:195
          const char* doc =
R"""(Sets the mass stored in ``context`` to ``mass``

Raises:
    RuntimeError if ``this`` RigidBody is not owned by a
    MultibodyPlant)""";
        } SetMass;
        // Symbol: drake::multibody::RigidBody::SetSpatialInertiaInBodyFrame
        struct /* SetSpatialInertiaInBodyFrame */ {
          // Source: drake/multibody/tree/rigid_body.h:222
          const char* doc =
R"""(Sets the spatial inertia stored in ``context`` to ``M_Bo_B``

Raises:
    RuntimeError if ``this`` RigidBody is not owned by a
    MultibodyPlant)""";
        } SetSpatialInertiaInBodyFrame;
        // Symbol: drake::multibody::RigidBody::default_com
        struct /* default_com */ {
          // Source: drake/multibody/tree/rigid_body.h:108
          const char* doc =
R"""(Returns the default value of this rigid body's center of mass as
measured and expressed in this body's frame. This value is initially
supplied at construction when specifying this body's SpatialInertia.

Returns ``p_BoBcm_B``:
    The position of this rigid body B's center of mass ``Bcm``
    measured from Bo (B's frame origin) and expressed in B (body B's
    frame).)""";
        } default_com;
        // Symbol: drake::multibody::RigidBody::default_mass
        struct /* default_mass */ {
          // Source: drake/multibody/tree/rigid_body.h:99
          const char* doc =
R"""(Returns the default value of this body's mass. This value is initially
supplied at construction when specifying this body's SpatialInertia.

Returns:
    This body's default mass.)""";
        } default_mass;
        // Symbol: drake::multibody::RigidBody::default_rotational_inertia
        struct /* default_rotational_inertia */ {
          // Source: drake/multibody/tree/rigid_body.h:124
          const char* doc =
R"""(Gets the default value of this body B's rotational inertia about Bo
(B's origin), expressed in B (this body's frame). This value is
calculated from the SpatialInertia supplied at construction of this
body.

Returns ``I_BBo_B``:
    body B's rotational inertia about Bo, expressed in B.)""";
        } default_rotational_inertia;
        // Symbol: drake::multibody::RigidBody::default_spatial_inertia
        struct /* default_spatial_inertia */ {
          // Source: drake/multibody/tree/rigid_body.h:132
          const char* doc =
R"""(Gets the default value of this body B's spatial inertia about Bo (B's
origin) and expressed in B (this body's frame).

Returns ``M_BBo_B``:
    body B's spatial inertia about Bo, expressed in B.)""";
        } default_spatial_inertia;
        // Symbol: drake::multibody::RigidBody::default_unit_inertia
        struct /* default_unit_inertia */ {
          // Source: drake/multibody/tree/rigid_body.h:116
          const char* doc =
R"""(Returns the default value of this body B's unit inertia about Bo (body
B's origin), expressed in B (this body's frame). This value is
initially supplied at construction when specifying this body's
SpatialInertia.

Returns ``G_BBo_B``:
    rigid body B's unit inertia about Bo, expressed in B.)""";
        } default_unit_inertia;
        // Symbol: drake::multibody::RigidBody::get_angular_acceleration_in_world
        struct /* get_angular_acceleration_in_world */ {
          // Source: drake/multibody/tree/rigid_body.h:327
          const char* doc =
R"""((Advanced) Extract this body's angular acceleration in world,
expressed in world.

Parameter ``ac``:
    velocity kinematics cache.

Returns ``alpha_WB_W``:
    B's angular acceleration in world W, expressed in W.)""";
        } get_angular_acceleration_in_world;
        // Symbol: drake::multibody::RigidBody::get_angular_velocity_in_world
        struct /* get_angular_velocity_in_world */ {
          // Source: drake/multibody/tree/rigid_body.h:290
          const char* doc =
R"""((Advanced) Extract this body angular velocity in world, expressed in
world.

Parameter ``vc``:
    velocity kinematics cache.

Returns ``w_WB_W``:
    rigid body B's angular velocity in world W, expressed in W.)""";
        } get_angular_velocity_in_world;
        // Symbol: drake::multibody::RigidBody::get_mass
        struct /* get_mass */ {
          // Source: drake/multibody/tree/rigid_body.h:139
          const char* doc =
R"""(Gets the mass stored in ``context``

Raises:
    RuntimeError if ``this`` RigidBody is not owned by a
    MultibodyPlant)""";
        } get_mass;
        // Symbol: drake::multibody::RigidBody::get_num_flexible_positions
        struct /* get_num_flexible_positions */ {
          // Source: drake/multibody/tree/rigid_body.h:89
          const char* doc =
R"""(There are no flexible degrees of freedom associated with a rigid body
and therefore this method returns zero. By definition, a rigid body
has no state associated with flexible deformations.)""";
        } get_num_flexible_positions;
        // Symbol: drake::multibody::RigidBody::get_num_flexible_velocities
        struct /* get_num_flexible_velocities */ {
          // Source: drake/multibody/tree/rigid_body.h:94
          const char* doc =
R"""(There are no flexible degrees of freedom associated with a rigid body
and therefore this method returns zero. By definition, a rigid body
has no state associated with flexible deformations.)""";
        } get_num_flexible_velocities;
        // Symbol: drake::multibody::RigidBody::get_origin_acceleration_in_world
        struct /* get_origin_acceleration_in_world */ {
          // Source: drake/multibody/tree/rigid_body.h:336
          const char* doc =
R"""((Advanced) Extract acceleration of this body's origin in world,
expressed in world.

Parameter ``vc``:
    velocity kinematics cache.

Returns ``a_WBo_W``:
    acceleration of body origin Bo in world W, expressed in W.)""";
        } get_origin_acceleration_in_world;
        // Symbol: drake::multibody::RigidBody::get_origin_position_in_world
        struct /* get_origin_position_in_world */ {
          // Source: drake/multibody/tree/rigid_body.h:262
          const char* doc =
R"""((Advanced) Extract the position vector from world origin to this
body's origin, expressed in world.

Parameter ``pc``:
    position kinematics cache.

Returns ``p_WoBo_W``:
    position vector from Wo (world origin) to Bo (this body's origin)
    expressed in W (world).)""";
        } get_origin_position_in_world;
        // Symbol: drake::multibody::RigidBody::get_origin_velocity_in_world
        struct /* get_origin_velocity_in_world */ {
          // Source: drake/multibody/tree/rigid_body.h:299
          const char* doc =
R"""((Advanced) Extract the velocity of this body's origin in world,
expressed in world.

Parameter ``vc``:
    velocity kinematics cache.

Returns ``v_WBo_W``:
    velocity of Bo (body origin) in world W, expressed in W.)""";
        } get_origin_velocity_in_world;
        // Symbol: drake::multibody::RigidBody::get_pose_in_world
        struct /* get_pose_in_world */ {
          // Source: drake/multibody/tree/rigid_body.h:243
          const char* doc =
R"""((Advanced) Extract this body's pose in world (from the position
kinematics).

Parameter ``pc``:
    position kinematics cache.

Returns ``X_WB``:
    pose of rigid body B in world frame W.)""";
        } get_pose_in_world;
        // Symbol: drake::multibody::RigidBody::get_rotation_matrix_in_world
        struct /* get_rotation_matrix_in_world */ {
          // Source: drake/multibody/tree/rigid_body.h:252
          const char* doc =
R"""((Advanced) Extract the rotation matrix relating the world frame to
this body's frame.

Parameter ``pc``:
    position kinematics cache.

Returns ``R_WB``:
    rotation matrix relating rigid body B in world frame W.)""";
        } get_rotation_matrix_in_world;
        // Symbol: drake::multibody::RigidBody::get_spatial_acceleration_in_world
        struct /* get_spatial_acceleration_in_world */ {
          // Source: drake/multibody/tree/rigid_body.h:318
          const char* doc =
R"""((Advanced) Returns A_WB, ``this`` rigid body B's spatial acceleration
in the world frame W.

Parameter ``ac``:
    acceleration kinematics cache.

Returns ``A_WB_W``:
    ``this`` rigid body B's spatial acceleration in the world frame W,
    expressed in W (for point Bo, the body frame's origin).)""";
        } get_spatial_acceleration_in_world;
        // Symbol: drake::multibody::RigidBody::get_spatial_velocity_in_world
        struct /* get_spatial_velocity_in_world */ {
          // Source: drake/multibody/tree/rigid_body.h:281
          const char* doc =
R"""((Advanced) Returns V_WB, ``this`` rigid body B's spatial velocity in
the world frame W.

Parameter ``vc``:
    velocity kinematics cache.

Returns ``V_WB_W``:
    ``this`` rigid body B's spatial velocity in the world frame W,
    expressed in W (for point Bo, the body frame's origin).)""";
        } get_spatial_velocity_in_world;
      } RigidBody;
      // Symbol: drake::multibody::RotationalInertia
      struct /* RotationalInertia */ {
        // Source: drake/multibody/tree/rotational_inertia.h:164
        const char* doc =
R"""(This class describes the mass distribution (inertia properties) of a
body or composite body about a particular point. Herein, "composite
body" means one body or a collection of bodies that are welded
together. In this documentation, "body" and "composite body" are used
interchangeably.

A **rigid** body's mass distribution is described by three quantities:
the body's mass; the body's center of mass; and the body's rotational
inertia about a particular point. The term **rotational inertia** is
used here and by [Jain 2010] to distinguish from a body's **spatial
inertia**. In this class, a 3x3 **inertia matrix** I represents a
body's rotational inertia about a point and expressed in a frame. More
specifically, ``I_BP_E`` is the inertia matrix of a body B about-point
P and expressed-in frame E (herein frame E's orthogonal unit vectors
Ex, Ey, Ez are denoted 𝐱̂, 𝐲̂, 𝐳̂).


::

    | Ixx Ixy Ixz |
    I = | Ixy Iyy Iyz |
        | Ixz Iyz Izz |

The moments of inertia Ixx, Iyy, Izz and products of inertia Ixy, Ixz,
Iyz are defined in terms of the mass dm of a differential volume of
the body. The position of dm from about-point P is xx̂ + yŷ + zẑ =
[x, y, z]_E.


::

    Ixx = ∫ (y² + z²) dm
    Iyy = ∫ (x² + z²) dm
    Izz = ∫ (x² + y²) dm
    Ixy = - ∫ x y dm
    Ixz = - ∫ x z dm
    Iyz = - ∫ y z dm

We use the negated convention for products of inertia, so that I
serves to relate angular velocity ω and angular momentum h via ``h = I
⋅ ω``. Ensure your products of inertia follow this negative sign
convention.

The 3x3 inertia matrix is symmetric and its diagonal elements (moments
of inertia) and off-diagonal elements (products of inertia) are
associated with a body (or composite body) S, an about-point P, and an
expressed-in frame E (𝐱̂, 𝐲̂, 𝐳̂̂). A rotational inertia is
ill-defined unless there is a body S, about-point P, and expressed-in
frame E. The user of this class is responsible for tracking the body
S, about-point P and expressed-in frame E (none of these are stored in
this class).

Note:
    This class does not store the about-point nor the expressed-in
    frame, nor does this class help enforce consistency of the
    about-point or expressed-in frame. To help users of this class
    track the about-point and expressed-in frame, we strongly
    recommend the following notation.

Note:
    In typeset material, use the symbol :math:`[I^{S/P}]_E` to
    represent the rotational inertia (inertia matrix) of a body (or
    composite body) S about-point P, expressed in frame E. In code and
    comments, use the monogram notation ``I_SP_E`` (e.g., as described
    in multibody_spatial_inertia). If the about-point P is fixed to a
    body B, the point is named :math:`B_P` and this appears in
    code/comments as ``Bp``. Examples: ``I_BBp_E`` is rigid body B's
    rotational inertia about-point Bp expressed-in frame E; I_BBo_E is
    B's rotational inertia about-point ``Bo`` (body B's origin)
    expressed-in frame E; and I_BBcm_E is B's inertia matrix
    about-point ``Bcm`` (B's center of mass) expressed-in frame E.

Note:
    The rotational inertia (inertia matrix) can be re-expressed in
    terms of a special frame whose orthogonal unit vectors are
    parallel to **principal axes of inertia** so that the inertia
    matrix is diagonalized with elements called **principal moments of
    inertia**.

Note:
    The formal definition of the inertia matrix :math:`I^{S/P}` of a
    system S about a point P follows the definition of the inertia
    dyadic 𝐈 of S about P, which begins by modeling S with n particles
    S₁ ... Sₙ (e.g., 12 grams of carbon can be modeled with n = 6.02 *
    10²³ molecules/particles). The inertia dyadic 𝐈₁ of one particle
    S₁ about point P is defined [Kane, 1985] in terms of m₁ (mass of
    S₁), ᴾ𝐩ˢ¹ (position vector from P to S₁), and the unit dyadic 𝐔
    which is defined by the property 𝐔 ⋅ 𝐯 = 𝐯 where 𝐯 is is any
    vector (this definition of 𝐔 is analogous to defining the identity
    matrix by the property 𝑰𝒅𝒆𝒏𝒕𝒊𝒕𝒚𝑴𝒂𝒕𝒓𝒊𝒙 * 𝒂𝒏𝒚𝑴𝒂𝒕𝒓𝒊𝒙 = 𝒂𝒏𝒚𝑴𝒂𝒕𝒓𝒊𝒙).


::

    𝐈₁ = m₁ * [𝐔 * (ᴾ𝐩ˢ¹ ⋅ ᴾ𝐩ˢ¹)  -  ᴾ𝐩ˢ¹ * ᴾ𝐩ˢ¹]

Note: The vector dot-product (⋅) above produces a scalar whereas the
vector multiply (*) produces a dyadic which is a 2nd-order tensor
(ᴾ𝐩ˢ¹ * ᴾ𝐩ˢ¹ is similar to the matrix outer-product of a 3x1 matrix
multiplied by a 1x3 matrix). An example inertia dyadic for a single
particle is shown further below. The inertia dyadic 𝐈 of the entire
system S is defined by summing the inertia dyadic of each particle Sᵢ
about P (i = 1, ... n), i.e.,


::

    𝐈 = 𝐈₁ + 𝐈₂ + ... 𝐈ₙ

The elements of the inertia matrix :math:`[I^{S/P}]_E` expressed in
frame E (in terms of orthogonal unit vectors 𝐱̂, 𝐲̂, 𝐳̂̂) are found by
pre-dot multiplying and post-dot multiplying 𝐈 with appropriate unit
vectors.


::

    Ixx = 𝐱̂ ⋅ 𝐈 ⋅ 𝐱̂     Ixy = 𝐱̂ ⋅ 𝐈 ⋅ 𝐲̂      Ixz = 𝐱̂ ⋅ 𝐈 ⋅ 𝐳̂̂
       Iyx = 𝐲̂ ⋅ 𝐈 ⋅ 𝐱̂     Iyy = 𝐲̂ ⋅ 𝐈 ⋅ 𝐲̂      Iyz = 𝐲̂ ⋅ 𝐈 ⋅ 𝐳̂̂
       Izx = 𝐳̂̂ ⋅ 𝐈 ⋅ 𝐱̂     Izy = 𝐳̂̂ ⋅ 𝐈 ⋅ 𝐲̂      Izz = 𝐳̂̂ ⋅ 𝐈 ⋅ 𝐳̂̂

The inertia dyadic 𝐈ᴮ of a rigid body B about Bcm (B's center of mass)
is related to various dynamic quantities. For example, B's angular
momentum 𝐇 about Bcm in a frame N and B's kinetic energy KE in N
relate to 𝐈ᴮ by


::

    𝐇 = 𝐈ᴮ ⋅ 𝛚
       KE = 1/2 𝛚 ⋅ 𝐈ᴮ ⋅ 𝛚  +  1/2 mᴮ 𝐯 ⋅ 𝐯

where 𝛚 is B's angular velocity in N, 𝐯 is Bcm's translational
velocity in N, and mᴮ is B's mass. When frame N happens to be a
Newtonian frame (also called an inertial frame or
non-rotating/non-accelerating frame), the moment 𝐓 of all forces on B
about Bcm relates to 𝐈ᴮ and 𝛂 (B's angular acceleration in N) by
Euler's rigid body equation as


::

    𝐓 = 𝐈ᴮ ⋅ 𝛂  +  𝛚 × 𝐈ᴮ ⋅ 𝛚

Example: For a particle Q of mass m whose position vector from a point
O is written in terms of right-handed orthogonal unit vectors 𝐱̂, 𝐲̂,
𝐳̂ (below), the inertia dyadic 𝐈 of particle Q about point O is
defined and calculated


::

    𝐩 = x 𝐱̂  +  y 𝐲̂                               (given)
        𝐈 = m * [𝐔 * (𝐩 ⋅ 𝐩)  -  𝐩 * 𝐩]              (definition)
          = m * [𝐔 * (x² + y²)  -  (x𝐱̂ + y𝐲̂̂) * (x𝐱̂ + y𝐲̂)
          = m * [(𝐱̂𝐱̂ + 𝐲̂𝐲̂ + 𝐳̂𝐳̂) * (x² + y²) - (x²𝐱̂𝐱̂ + xy𝐱̂𝐲̂̂ + xy𝐲̂̂𝐱̂ + y²𝐲̂̂𝐲̂̂)]
          = m * [y²𝐱̂𝐱̂ + x²𝐲̂𝐲̂ + (x² + y²)𝐳̂𝐳̂ - xy𝐱̂𝐲̂̂ - xy𝐲̂̂𝐱̂]

which means the inertia matrix for particle Q about point O for 𝐱̂,
𝐲̂, 𝐳̂ is


::

    |  m y²     -m x y         0     |
    I = | -m x y     m x²          0     |
        |    0         0     m (x² + y²) |

[Kane, 1985] pg. 68. "Dynamics: Theory and Applications," McGraw-Hill
Co., New York, 1985 (with D. A. Levinson). Available for free .pdf
download: https://ecommons.cornell.edu/handle/1813/637

Note:
    Several methods in this class throw a RuntimeError for invalid
    rotational inertia operations in debug releases only. This
    provides speed in a release build while facilitating debugging in
    debug builds. In addition, these validity tests are only performed
    for scalar types for which drake::scalar_predicate<T>::is_bool is
    ``True``. For instance, validity checks are not performed when T
    is symbolic::Expression.

Various methods in this class require numerical (not symbolic) data
types.)""";
        // Symbol: drake::multibody::RotationalInertia::CalcMaximumPossibleMomentOfInertia
        struct /* CalcMaximumPossibleMomentOfInertia */ {
          // Source: drake/multibody/tree/rotational_inertia.h:241
          const char* doc =
R"""(Returns the maximum possible moment of inertia for ``this`` rotational
inertia about-point P for any expressed-in frame E.

Remark:
    The maximum moment Imax has range: trace / 3 <= Imax <= trace / 2.

See also:
    Trace())""";
        } CalcMaximumPossibleMomentOfInertia;
        // Symbol: drake::multibody::RotationalInertia::CalcPrincipalMomentsOfInertia
        struct /* CalcPrincipalMomentsOfInertia */ {
          // Source: drake/multibody/tree/rotational_inertia.h:487
          const char* doc =
R"""(This method takes ``this`` rotational inertia about-point P,
expressed-in frame E, and computes its principal moments of inertia
about-point P, but expressed-in a frame aligned with the principal
axes.

Note:
    : This method only works for a rotational inertia with scalar type
    T that can be converted to a double (discarding any supplemental
    scalar data such as derivatives of an AutoDiffScalar).

Returns ``principal_moments``:
    The vector of principal moments of inertia ``[Ixx Iyy Izz]``
    sorted in ascending order.

Raises:
    RuntimeError if eigenvalue solver fails or if scalar type T cannot
    be converted to a double.)""";
        } CalcPrincipalMomentsOfInertia;
        // Symbol: drake::multibody::RotationalInertia::CopyToFullMatrix3
        struct /* CopyToFullMatrix3 */ {
          // Source: drake/multibody/tree/rotational_inertia.h:259
          const char* doc =
R"""(Gets a full 3x3 matrix copy of this rotational inertia. The returned
copy is symmetric and includes both lower and upper parts of the
matrix.)""";
        } CopyToFullMatrix3;
        // Symbol: drake::multibody::RotationalInertia::CouldBePhysicallyValid
        struct /* CouldBePhysicallyValid */ {
          // Source: drake/multibody/tree/rotational_inertia.h:547
          const char* doc =
R"""(Performs several necessary checks to verify whether ``this``
rotational inertia *could* be physically valid, including:

- No NaN moments or products of inertia.
- Ixx, Iyy, Izz and principal moments are all non-negative.
- Ixx, Iyy  Izz and principal moments satisfy the triangle inequality:
  - ``Ixx + Iyy >= Izz``
  - `Ixx + Izz >= Iyy`
  - ``Iyy + Izz >= Ixx``

Warning:
    These checks are necessary (but NOT sufficient) conditions for a
    rotational inertia to be physically valid. The sufficient
    condition requires a rotational inertia to satisfy the above
    checks *after* ``this`` is shifted to the center of mass, i.e.,
    the sufficient condition requires calling CouldBePhysicallyValid()
    when the about-point is Bcm (the body's center of mass). Note:
    this class does not know its about-point or its center of mass
    location.

Returns:
    ``True`` for a plausible rotational inertia passing the above
    necessary but insufficient checks and ``False`` otherwise.

Raises:
    RuntimeError if principal moments of inertia cannot be calculated
    (eigenvalue solver) or if scalar type T cannot be converted to a
    double.)""";
        } CouldBePhysicallyValid;
        // Symbol: drake::multibody::RotationalInertia::IsNaN
        struct /* IsNaN */ {
          // Source: drake/multibody/tree/rotational_inertia.h:442
          const char* doc =
R"""(Returns ``True`` if any moment/product in ``this`` rotational inertia
is NaN. Otherwise returns ``False``.)""";
        } IsNaN;
        // Symbol: drake::multibody::RotationalInertia::IsNearlyEqualTo
        struct /* IsNearlyEqualTo */ {
          // Source: drake/multibody/tree/rotational_inertia.h:282
          const char* doc =
R"""(Compares ``this`` rotational inertia to ``other`` rotional inertia
within the specified ``precision`` (which is a dimensionless number
specifying the relative precision to which the comparison is
performed). Denoting ``I_maxA`` as the largest element value that can
appear in a valid ``this`` rotational inertia (independent of the
expressed-in frame E) and denoting ``I_maxB`` as the largest element
value that can appear in a valid ``other`` rotational inertia
(independent of the expressed-in frame E), ``this`` and ``other`` are
considered nearly equal to each other, if: ‖this - other‖∞ < precision
* min(I_maxA, I_maxB)

Parameter ``other``:
    Rotational inertia to compare with ``this`` rotational inertia.

Parameter ``precision``:
    is a dimensionless real positive number that is usually based on
    two factors, namely expected accuracy of moments/products of
    inertia (e.g., from end-user or CAD) and/or machine-precision.

Returns:
    ``True`` if the absolute value of each moment/product of inertia
    in ``this`` is within ``epsilon`` of the corresponding moment/
    product absolute value in ``other``. Otherwise returns ``False``.

Note:
    : This method only works if all moments of inertia with scalar
    type T in ``this`` and ``other`` can be converted to a double
    (discarding supplemental scalar data such as derivatives of an
    AutoDiffScalar). It fails at runtime if type T cannot be converted
    to ``double``.)""";
        } IsNearlyEqualTo;
        // Symbol: drake::multibody::RotationalInertia::MinusEqualsUnchecked
        struct /* MinusEqualsUnchecked */ {
          // Source: drake/multibody/tree/rotational_inertia.h:748
          const char* doc =
R"""(Subtracts a rotational inertia ``I_BP_E`` from ``this`` rotational
inertia. No check is done to determine if the result is physically
valid.

Parameter ``I_BP_E``:
    Rotational inertia of a body (or composite body) B to be
    subtracted from ``this`` rotational inertia.

Returns:
    A reference to ``this`` rotational inertia. ``this`` changes since
    rotational inertia ``I_BP_E`` has been subtracted from it.

See also:
    operator-().

Warning:
    This operator may produce an invalid rotational inertia. Use
    operator-=() to perform necessary (but insufficient) checks on the
    physical validity of the resulting rotational inertia.

Note:
    : Although this method is mathematically useful, it may result in
    a rotational inertia that is physically invalid. This method helps
    perform intermediate calculations which do not necessarily
    represent a real rotational inertia. For example, an efficient way
    to shift a rotational inertia from an arbitrary point P to an
    arbitrary point Q is mathematical equivalent to a + (b - c).
    Although ``a`` must be physically valid and the result ``a + (b -
    c)`` must be physically valid, the intermediate quantity (b - c)
    is not necessarily physically valid. This method allows (b - c) to
    be calculated without requiring (b - c) to be physically valid.

See also:
    operator-=().)""";
        } MinusEqualsUnchecked;
        // Symbol: drake::multibody::RotationalInertia::ReExpress
        struct /* ReExpress */ {
          // Source: drake/multibody/tree/rotational_inertia.h:591
          const char* doc =
R"""(Re-expresses ``this`` rotational inertia ``I_BP_E`` to ``I_BP_A``
i.e., re-expresses body B's rotational inertia from frame E to frame
A.

Parameter ``R_AE``:
    RotationMatrix relating frames A and E.

Returns ``I_BP_A``:
    Rotational inertia of B about-point P expressed-in frame A.

Raises:
    RuntimeError for Debug builds if the rotational inertia that is
    re-expressed-in frame A violates CouldBePhysicallyValid().

See also:
    ReExpressInPlace())""";
        } ReExpress;
        // Symbol: drake::multibody::RotationalInertia::ReExpressInPlace
        struct /* ReExpressInPlace */ {
          // Source: drake/multibody/tree/rotational_inertia.h:582
          const char* doc =
R"""(Re-expresses ``this`` rotational inertia ``I_BP_E`` in place to
``I_BP_A``. In other words, starts with ``this`` rotational inertia of
a body (or composite body) B about-point P expressed-in frame E and
re-expresses to B's rotational inertia about-point P expressed-in
frame A. More concisely, we compute ``I_BP_A = R_AE * I_BP_E *
(R_AE)ᵀ``.

Parameter ``R_AE``:
    RotationMatrix relating frames A and E.

Returns:
    A reference to ``this`` rotational inertia about-point P, but with
    ``this`` now expressed in frame A (instead of frame E).

Raises:
    RuntimeError for Debug builds if the rotational inertia that is
    re-expressed-in frame A violates CouldBePhysicallyValid().

See also:
    ReExpress().)""";
        } ReExpressInPlace;
        // Symbol: drake::multibody::RotationalInertia::RotationalInertia<T>
        struct /* ctor */ {
          // Source: drake/multibody/tree/rotational_inertia.h:170
          const char* doc_0args =
R"""(Constructs a rotational inertia that has all its moments/products of
inertia equal to NaN (helps quickly detect uninitialized values).)""";
          // Source: drake/multibody/tree/rotational_inertia.h:175
          const char* doc_3args =
R"""(Creates a rotational inertia with moments of inertia ``Ixx``, `Iyy`,
``Izz``, and with each product of inertia set to zero.

Raises:
    RuntimeError for Debug builds if not CouldBePhysicallyValid().)""";
          // Source: drake/multibody/tree/rotational_inertia.h:181
          const char* doc_6args =
R"""(Creates a rotational inertia with moments of inertia ``Ixx``, `Iyy`,
``Izz``, and with products of inertia ``Ixy``, `Ixz`, ``Iyz``.

Raises:
    RuntimeError for Debug builds if not CouldBePhysicallyValid().)""";
          // Source: drake/multibody/tree/rotational_inertia.h:196
          const char* doc_2args =
R"""(Constructs a rotational inertia for a particle Q of mass ``mass``,
whose position vector from about-point P is p_PQ_E (E is expressed-in
frame). This RuntimeError exception only occurs if ``mass`` < 0.

Parameter ``mass``:
    The mass of particle Q.

Parameter ``p_PQ_E``:
    Position from about-point P to Q, expressed-in frame E.

Returns ``I_QP_E``:
    , Q's rotational inertia about-point P expressed-in frame E.

Remark:
    Negating the position vector p_PQ_E has no affect on the result.

Raises:
    RuntimeError for Debug builds if not CouldBePhysicallyValid().)""";
        } ctor;
        // Symbol: drake::multibody::RotationalInertia::SetToNaN
        struct /* SetToNaN */ {
          // Source: drake/multibody/tree/rotational_inertia.h:425
          const char* doc =
R"""(Sets ``this`` rotational inertia so all its elements are equal to NaN.
This helps quickly detect uninitialized moments/products of inertia.)""";
        } SetToNaN;
        // Symbol: drake::multibody::RotationalInertia::SetZero
        struct /* SetZero */ {
          // Source: drake/multibody/tree/rotational_inertia.h:434
          const char* doc =
R"""(Sets ``this`` rotational inertia so all its moments/products of
inertia are zero, e.g., for convenient initialization before a
computation or for inertia calculations involving a particle
(point-mass). Note: Real 3D massive physical objects have non-zero
moments of inertia.)""";
        } SetZero;
        // Symbol: drake::multibody::RotationalInertia::ShiftFromCenterOfMass
        struct /* ShiftFromCenterOfMass */ {
          // Source: drake/multibody/tree/rotational_inertia.h:636
          const char* doc =
R"""(Calculates the rotational inertia that results from shifting ``this``
rotational inertia for a body (or composite body) B from about-point
Bcm (B's center of mass) to about-point Q. I.e., shifts ``I_BBcm_E``
to ``I_BQ_E`` (both are expressed-in frame E).

Parameter ``mass``:
    The mass of body (or composite body) B.

Parameter ``p_BcmQ_E``:
    Position vector from Bcm to Q, expressed-in frame E.

Returns ``I_BQ_E``:
    B's rotational inertia about-point Q expressed-in frame E.

Raises:
    RuntimeError for Debug builds if the rotational inertia that is
    shifted to about-point Q violates CouldBePhysicallyValid().

Remark:
    Negating the position vector p_BcmQ_E has no affect on the result.)""";
        } ShiftFromCenterOfMass;
        // Symbol: drake::multibody::RotationalInertia::ShiftFromCenterOfMassInPlace
        struct /* ShiftFromCenterOfMassInPlace */ {
          // Source: drake/multibody/tree/rotational_inertia.h:619
          const char* doc =
R"""(Shifts ``this`` rotational inertia for a body (or composite body) B
from about-point Bcm (B's center of mass) to about-point Q. I.e.,
shifts ``I_BBcm_E`` to ``I_BQ_E`` (both are expressed-in frame E).

Parameter ``mass``:
    The mass of body (or composite body) B.

Parameter ``p_BcmQ_E``:
    Position vector from Bcm to Q, expressed-in frame E.

Returns:
    A reference to ``this`` rotational inertia expressed-in frame E,
    but with ``this`` shifted from about-point Bcm to about-point Q.
    i.e., returns I_BQ_E, B's rotational inertia about-point Bcm
    expressed-in frame E.

Raises:
    RuntimeError for Debug builds if the rotational inertia that is
    shifted to about-point Q violates CouldBePhysicallyValid().

Remark:
    Negating the position vector p_BcmQ_E has no affect on the result.)""";
        } ShiftFromCenterOfMassInPlace;
        // Symbol: drake::multibody::RotationalInertia::ShiftToCenterOfMass
        struct /* ShiftToCenterOfMass */ {
          // Source: drake/multibody/tree/rotational_inertia.h:674
          const char* doc =
R"""(Calculates the rotational inertia that results from shifting ``this``
rotational inertia for a body (or composite body) B from about-point Q
to about-point ``Bcm`` (B's center of mass). I.e., shifts ``I_BQ_E``
to ``I_BBcm_E`` (both are expressed-in frame E).

Parameter ``mass``:
    The mass of body (or composite body) B.

Parameter ``p_QBcm_E``:
    Position vector from Q to ``Bcm``, expressed-in frame E.

Returns ``I_BBcm_E``:
    B's rotational inertia about-point ``Bcm`` expressed-in frame E.

Raises:
    RuntimeError for Debug builds if the rotational inertia that is
    shifted to about-point ``Bcm`` violates CouldBePhysicallyValid().

Remark:
    Negating the position vector ``p_QBcm_E`` has no affect on the
    result.)""";
        } ShiftToCenterOfMass;
        // Symbol: drake::multibody::RotationalInertia::ShiftToCenterOfMassInPlace
        struct /* ShiftToCenterOfMassInPlace */ {
          // Source: drake/multibody/tree/rotational_inertia.h:656
          const char* doc =
R"""(Shifts ``this`` rotational inertia for a body (or composite body) B
from about-point Q to about-point ``Bcm`` (B's center of mass). I.e.,
shifts ``I_BQ_E`` to ``I_BBcm_E`` (both are expressed-in frame E).

Parameter ``mass``:
    The mass of body (or composite body) B.

Parameter ``p_QBcm_E``:
    Position vector from Q to ``Bcm``, expressed-in frame E.

Returns:
    A reference to ``this`` rotational inertia expressed-in frame E,
    but with ``this`` shifted from about-point Q to about-point
    ``Bcm``, i.e., returns ``I_BBcm_E``, B's rotational inertia
    about-point ``Bcm`` expressed-in frame E.

Raises:
    RuntimeError for Debug builds if the rotational inertia that is
    shifted to about-point ``Bcm`` violates CouldBePhysicallyValid().

Remark:
    Negating the position vector ``p_QBcm_E`` has no affect on the
    result.)""";
        } ShiftToCenterOfMassInPlace;
        // Symbol: drake::multibody::RotationalInertia::ShiftToThenAwayFromCenterOfMass
        struct /* ShiftToThenAwayFromCenterOfMass */ {
          // Source: drake/multibody/tree/rotational_inertia.h:718
          const char* doc =
R"""(Calculates the rotational inertia that results from shifting ``this``
rotational inertia for a body (or composite body) B from about-point P
to about-point Q via Bcm (B's center of mass). I.e., shifts ``I_BP_E``
to ``I_BQ_E`` (both are expressed-in frame E).

Parameter ``mass``:
    The mass of body (or composite body) B.

Parameter ``p_PBcm_E``:
    Position vector from P to Bcm, expressed-in frame E.

Parameter ``p_QBcm_E``:
    Position vector from Q to Bcm, expressed-in frame E.

Returns ``I_BQ_E``:
    , B's rotational inertia about-point Q expressed-in frame E.

Raises:
    RuntimeError for Debug builds if the rotational inertia that is
    shifted to about-point Q violates CouldBePhysicallyValid().

Remark:
    Negating either (or both) position vectors p_PBcm_E and p_QBcm_E
    has no affect on the result.)""";
        } ShiftToThenAwayFromCenterOfMass;
        // Symbol: drake::multibody::RotationalInertia::ShiftToThenAwayFromCenterOfMassInPlace
        struct /* ShiftToThenAwayFromCenterOfMassInPlace */ {
          // Source: drake/multibody/tree/rotational_inertia.h:697
          const char* doc =
R"""(Shifts ``this`` rotational inertia for a body (or composite body) B
from about-point P to about-point Q via Bcm (B's center of mass).
I.e., shifts ``I_BP_E`` to ``I_BQ_E`` (both are expressed-in frame E).

Parameter ``mass``:
    The mass of body (or composite body) B.

Parameter ``p_PBcm_E``:
    Position vector from P to Bcm, expressed-in frame E.

Parameter ``p_QBcm_E``:
    Position vector from Q to Bcm, expressed-in frame E.

Returns:
    A reference to ``this`` rotational inertia expressed-in frame E,
    but with ``this`` shifted from about-point P to about-point Q,
    i.e., returns I_BQ_E, B's rotational inertia about-point Q
    expressed-in frame E.

Raises:
    RuntimeError for Debug builds if the rotational inertia that is
    shifted to about-point Q violates CouldBePhysicallyValid().

Remark:
    Negating either (or both) position vectors p_PBcm_E and p_QBcm_E
    has no affect on the result.

Remark:
    This method is more efficient (by 6 multiplications) than first
    shifting to the center of mass, then shifting away, e.g., as
    (ShiftToCenterOfMassInPlace()).ShiftFromCenterOfMassInPlace();)""";
        } ShiftToThenAwayFromCenterOfMassInPlace;
        // Symbol: drake::multibody::RotationalInertia::Trace
        struct /* Trace */ {
          // Source: drake/multibody/tree/rotational_inertia.h:235
          const char* doc =
R"""(Returns a rotational inertia's trace (i.e., Ixx + Iyy + Izz, the sum
of the diagonal elements of the inertia matrix). The trace happens to
be invariant to its expressed-in frame (i.e., the trace does not
depend on the frame in which it is expressed). The trace is useful
because the largest moment of inertia Imax has range: trace / 3 <=
Imax <= trace / 2, and the largest possible product of inertia must be
<= Imax / 2. Hence, trace / 3 and trace / 2 give a lower and upper
bound on the largest possible element that can be in a valid
rotational inertia.)""";
        } Trace;
        // Symbol: drake::multibody::RotationalInertia::TriaxiallySymmetric
        struct /* TriaxiallySymmetric */ {
          // Source: drake/multibody/tree/rotational_inertia.h:204
          const char* doc = R"""()""";
        } TriaxiallySymmetric;
        // Symbol: drake::multibody::RotationalInertia::cast
        struct /* cast */ {
          // Source: drake/multibody/tree/rotational_inertia.h:470
          const char* doc =
R"""(Returns a new RotationalInertia object templated on ``Scalar``
initialized from the values of ``this`` rotational inertia's entries.

Template parameter ``Scalar``:
    The scalar type on which the new rotational inertia will be
    templated.

Note:
    ``RotationalInertia<From>::cast<To>()`` creates a new
    ``RotationalInertia<To>`` from a ``RotationalInertia<From>`` but
    only if type ``To`` is constructible from type ``From``. This cast
    method works in accordance with Eigen's cast method for Eigen's
    Matrix3 that underlies this RotationalInertia. For example, Eigen
    currently allows cast from type double to AutoDiffXd, but not
    vice-versa.)""";
        } cast;
        // Symbol: drake::multibody::RotationalInertia::cols
        struct /* cols */ {
          // Source: drake/multibody/tree/rotational_inertia.h:212
          const char* doc =
R"""(For consistency with Eigen's API, the cols() method returns 3.)""";
        } cols;
        // Symbol: drake::multibody::RotationalInertia::get_moments
        struct /* get_moments */ {
          // Source: drake/multibody/tree/rotational_inertia.h:215
          const char* doc =
R"""(Returns 3-element vector with moments of inertia [Ixx, Iyy, Izz].)""";
        } get_moments;
        // Symbol: drake::multibody::RotationalInertia::get_products
        struct /* get_products */ {
          // Source: drake/multibody/tree/rotational_inertia.h:218
          const char* doc =
R"""(Returns 3-element vector with products of inertia [Ixy, Ixz, Iyz].)""";
        } get_products;
        // Symbol: drake::multibody::RotationalInertia::operator()
        struct /* operator_call */ {
          // Source: drake/multibody/tree/rotational_inertia.h:250
          const char* doc =
R"""(Const access to the ``(i, j)`` element of this rotational inertia.

Remark:
    A mutable version of operator() is intentionally absent so as to
    prevent an end-user from directly setting elements. This prevents
    the creation of a non-physical (or non-symmetric) rotational
    inertia.)""";
        } operator_call;
        // Symbol: drake::multibody::RotationalInertia::operator*
        struct /* operator_mul */ {
          // Source: drake/multibody/tree/rotational_inertia.h:375
          const char* doc =
R"""(Multiplies ``this`` rotational inertia by a nonnegative scalar (>= 0).
In debug builds, throws RuntimeError if ``nonnegative_scalar`` < 0.

Parameter ``nonnegative_scalar``:
    Nonnegative scalar which multiplies ``this``.

Returns:
    ``this`` rotational inertia multiplied by ``nonnegative_scalar``.

See also:
    operator*=(), operator*(const T&, const RotationalInertia<T>&))""";
        } operator_mul;
        // Symbol: drake::multibody::RotationalInertia::operator*=
        struct /* operator_imul */ {
          // Source: drake/multibody/tree/rotational_inertia.h:363
          const char* doc =
R"""(Multiplies ``this`` rotational inertia by a nonnegative scalar (>= 0).
In debug builds, throws RuntimeError if ``nonnegative_scalar`` < 0.

Parameter ``nonnegative_scalar``:
    Nonnegative scalar which multiplies ``this``.

Returns:
    A reference to ``this`` rotational inertia. ``this`` changes since
    ``this`` has been multiplied by ``nonnegative_scalar``.

See also:
    operator*(), operator*(const T&, const RotationalInertia<T>&).)""";
        } operator_imul;
        // Symbol: drake::multibody::RotationalInertia::operator+
        struct /* operator_add */ {
          // Source: drake/multibody/tree/rotational_inertia.h:316
          const char* doc =
R"""(Adds a rotational inertia ``I_BP_E`` to ``this`` rotational inertia.
This method requires both rotational inertias (``I_BP_E`` and
``this``) to have the same about-point P and the same expressed-in
frame E.

Parameter ``I_BP_E``:
    Rotational inertia of a body (or composite body) B to be added to
    ``this`` rotational inertia. ``I_BP_E`` and ``this`` must have the
    same about-point P and expressed-in frame E.

Returns:
    The sum of ``this`` rotational inertia and ``I_BP_E``.

See also:
    operator+=().)""";
        } operator_add;
        // Symbol: drake::multibody::RotationalInertia::operator+=
        struct /* operator_iadd */ {
          // Source: drake/multibody/tree/rotational_inertia.h:303
          const char* doc = R"""()""";
        } operator_iadd;
        // Symbol: drake::multibody::RotationalInertia::operator-
        struct /* operator_sub */ {
          // Source: drake/multibody/tree/rotational_inertia.h:353
          const char* doc =
R"""(Subtracts a rotational inertia ``I_BP_E`` from ``this`` rotational
inertia. This method requires both rotational inertias (``I_BP_E`` and
``this``) to have the same about-point P and the same expressed-in
frame E.

Parameter ``I_BP_E``:
    Rotational inertia of a body (or composite body) B to be
    subtracted from ``this`` rotational inertia. ``I_BP_E`` and
    ``this`` must have the same about-point P and expressed-in frame
    E.

Returns:
    The subtraction of ``I_BP_E`` from ``this`` rotational inertia.

Raises:
    RuntimeError for Debug builds if not CouldBePhysicallyValid().

See also:
    operator-=().

Warning:
    See warning and documentation for operator-=().)""";
        } operator_sub;
        // Symbol: drake::multibody::RotationalInertia::operator-=
        struct /* operator_isub */ {
          // Source: drake/multibody/tree/rotational_inertia.h:337
          const char* doc =
R"""(Subtracts a rotational inertia ``I_BP_E`` from ``this`` rotational
inertia. This method requires both rotational inertias (``I_BP_E`` and
``this``) to have the same about-point P and the same expressed-in
frame E. The -= operator updates ``this`` so ``I_BP_E`` is subtracted
from ``this``.

Parameter ``I_BP_E``:
    Rotational inertia of a body (or composite body) B to be
    subtracted from ``this`` rotational inertia. ``I_BP_E`` and
    ``this`` must have the same about-point P and expressed-in frame
    E.

Returns:
    A reference to ``this`` rotational inertia. ``this`` changes since
    rotational inertia ``I_BP_E`` has been subtracted from it.

Raises:
    RuntimeError for Debug builds if not CouldBePhysicallyValid().

See also:
    operator-().

Note:
    This subtract operator is useful for computing rotational inertia
    of a body with a hole. First the rotational inertia of a fully
    solid body S (without the hole) is calculated, then the rotational
    inertia of the hole (treated as a massive solid body B) is
    calculated. The rotational inertia of a composite body C
    (comprised of S and -B) is computed by subtracting B's rotational
    inertia from S's rotational inertia.)""";
        } operator_isub;
        // Symbol: drake::multibody::RotationalInertia::operator/
        struct /* operator_div */ {
          // Source: drake/multibody/tree/rotational_inertia.h:419
          const char* doc = R"""()""";
        } operator_div;
        // Symbol: drake::multibody::RotationalInertia::operator/=
        struct /* operator_idiv */ {
          // Source: drake/multibody/tree/rotational_inertia.h:407
          const char* doc =
R"""(Divides ``this`` rotational inertia by a positive scalar (> 0). In
debug builds, throws RuntimeError if ``positive_scalar`` <= 0.

Parameter ``positive_scalar``:
    Positive scalar (> 0) which divides ``this``.

Returns:
    A reference to ``this`` rotational inertia. ``this`` changes since
    ``this`` has been divided by ``positive_scalar``.

See also:
    operator/().)""";
        } operator_idiv;
        // Symbol: drake::multibody::RotationalInertia::rows
        struct /* rows */ {
          // Source: drake/multibody/tree/rotational_inertia.h:209
          const char* doc =
R"""(For consistency with Eigen's API, the rows() method returns 3.)""";
        } rows;
      } RotationalInertia;
      // Symbol: drake::multibody::SignedDistanceWithTimeDerivative
      struct /* SignedDistanceWithTimeDerivative */ {
        // Source: drake/multibody/plant/calc_distance_and_time_derivative.h:14
        const char* doc =
R"""(The struct containing the signed distance and its time derivative
between a pair of geometries.)""";
        // Symbol: drake::multibody::SignedDistanceWithTimeDerivative::distance
        struct /* distance */ {
          // Source: drake/multibody/plant/calc_distance_and_time_derivative.h:15
          const char* doc = R"""()""";
        } distance;
        // Symbol: drake::multibody::SignedDistanceWithTimeDerivative::distance_time_derivative
        struct /* distance_time_derivative */ {
          // Source: drake/multibody/plant/calc_distance_and_time_derivative.h:16
          const char* doc = R"""()""";
        } distance_time_derivative;
      } SignedDistanceWithTimeDerivative;
      // Symbol: drake::multibody::SpatialAcceleration
      struct /* SpatialAcceleration */ {
        // Source: drake/multibody/math/spatial_acceleration.h:57
        const char* doc =
R"""(This class is used to represent a *spatial acceleration* that combines
rotational (angular acceleration) and translational (linear
acceleration) components. While a SpatialVelocity ``V_XY`` represents
the motion of a "moving frame" Y measured with respect to a
"measured-in" frame X, the SpatialAcceleration ``A_XY`` represents the
rate of change of this spatial velocity ``V_XY`` in frame X. That is
:math:`^XA^Y = \frac{^Xd}{dt}\,{^XV^Y}` where :math:`\frac{^Xd}{dt}`
denotes the time derivative taken in frame X. That is, to compute an
acceleration we need to specify in what frame the time derivative is
taken, see [Mitiguy 2016, §6.1] for a more in depth discussion on
this. Time derivatives can be taken in different frames, and they
transform according to the "Transport Theorem", which in Drake is
implemented in drake::math::ConvertTimeDerivativeToOtherFrame(). In
source code comments we write ``A_XY = DtX(V_XY)``, where ``DtX()`` is
the operator that takes the time derivative in the X frame. By
convention, and unless otherwise stated, we assume that the frame in
which the time derivative is taken is the "measured-in" frame, i.e.
the time derivative used in ``A_XY`` is in frame X by default (i.e.
DtX()). To perform numerical computations, we need to specify an
"expressed-in" frame E (which may be distinct from either X or Y), so
that components can be expressed as real numbers. Only the vector
values are stored in a SpatialAcceleration object; the frames must be
understood from context and it is the responsibility of the user to
keep track of them. That is best accomplished through disciplined
notation. In source code we use monogram notation where capital A is
used to designate a spatial acceleration quantity. The same monogram
notation rules for SpatialVelocity are also used for
SpatialAcceleration. That is, the spatial acceleration of a frame Y
measured in X and expressed in E is denoted with ``A_XY_E``. For a
more detailed introduction on spatial vectors and the monogram
notation please refer to section multibody_spatial_vectors.

[Mitiguy 2016] Mitiguy, P., 2016. Advanced Dynamics & Motion
Simulation.)""";
        // Symbol: drake::multibody::SpatialAcceleration::ComposeWithMovingFrameAcceleration
        struct /* ComposeWithMovingFrameAcceleration */ {
          // Source: drake/multibody/math/spatial_acceleration.h:406
          const char* doc =
R"""(This method composes ``this`` spatial acceleration ``A_WP`` of a frame
P measured in a frame W, with that of a third frame B moving in P with
spatial acceleration ``A_PB``. The result is the spatial acceleration
``A_WB`` of frame B measured in W. At the instant in which the
accelerations are composed, frame B is located with its origin Bo at
``p_PB`` from P's origin Po.

This operation can be written in a more compact form in terms of the
rigid shift operator ``Φᵀ(p_PB)`` (see SpatialVelocity::Shift()) as:


::

    A_WB = Φᵀ(p_PB) A_WP + Ac_WB(w_WP, V_PB) + A_PB_W

where ``Φᵀ(p_PB) A_WP`` denotes the application of the rigid shift
operation as in SpatialVelocity::Shift() and ``Ac_WB(w_WP, V_PB)``
contains the centrifugal and Coriolis terms:


::

    Ac_WB(w_WP, V_PB) = | w_WP x w_PB_W                          |
                          | w_WP x w_WP x p_PB_W + 2 w_WP x v_PB_W |
                                      ^^^                ^^^
                                  centrifugal         Coriolis

The equation above shows that composing spatial accelerations cannot
be simply accomplished by adding ``A_WP`` with ``A_PB``. Moreover, we
see that, unlike with angular velocities, angular accelerations cannot
be added in order to compose them. That is ``w_AC = w_AB + w_BC`` but
``alpha_AC ≠ alpha_AB + alpha_BC`` due to the cross term ``w_AC x
w_BC``. See the derivation below for more details.

See also:
    SpatialVelocity::ComposeWithMovingFrameVelocity() for the
    composition of SpatialVelocity quantities.

Note:
    This method is the extension to the Shift() operator, which
    computes the spatial acceleration frame P shifted to B as if frame
    B moved rigidly with P, that is, for when ``V_PB`` and ``A_PB``
    are both zero. In other words the results from Shift() equal the
    results from this method when ``V_PB`` and ``A_PB`` are both zero.

Parameter ``p_PB_E``:
    Shift vector from P's origin to B's origin, expressed in frame E.
    The "from" point ``Po`` must be the point whose acceleration is
    currently represented in ``this`` spatial acceleration, and E must
    be the same expressed-in frame as for ``this`` spatial
    acceleration.

Parameter ``w_WP_E``:
    Angular velocity of frame P measured in frame W and expressed in
    frame E.

Parameter ``V_PB_E``:
    The spatial velocity of a third frame B in motion with respect to
    P, expressed in the same frame E as ``this`` spatial acceleration.

Parameter ``A_PB_E``:
    The spatial acceleration of a third frame B in motion with respect
    to P, expressed in the same frame E as ``this`` spatial
    acceleration.

Returns ``A_WB_E``:
    The spatial acceleration of frame B in W, expressed in frame E.

** Derivation **

The spatial velocity of frame B in W can be obtained by composing
``V_WP`` with ``V_PB``:


::

    V_WB = V_WPb + V_PB = Φᵀ(p_PB) V_WP + V_PB                        (1)

This operation can be performed with the method
SpatialVelocity::ComposeWithMovingFrameVelocity().

* Translational acceleration component *

The translational velocity ``v_WB`` of point B in W corresponds to the
translational component in Eq. (1):


::

    v_WB = v_WP + w_WP x p_PB + v_PB                                  (2)

Therefore, for the translational acceleration we have:


::

    a_WB = DtW(v_WB)
            = DtW(v_WP + w_WP x p_PB + v_PB)
            = DtW(v_WP) + DtW(w_WP x p_PB) + DtW(v_PB)
            = a_WP + DtW(w_WP) x p_PB + w_WP x DtW(p_PB) + DtW(v_PB)
            = a_WP + alpha_WP x p_PB + w_WP x DtW(p_PB) + DtW(v_PB)     (3)

with ``a_WP = DtW(v_WP)`` and ``alpha_WP = DtW(w_WP)`` by definition.
The term DtW(p_PB) in Eq. (3) is obtained by converting the vector
time derivative from ``DtW()`` to ``DtP()``, see
drake::math::ConvertTimeDerivativeToOtherFrame():


::

    DtW(p_PB) = DtP(p_PB) + w_WP x p_PB
                = v_PB + w_WP x p_PB                                    (4)

since ``v_PB = DtP(p_PB)`` by definition. Similarly, the term
``DtW(v_PB)`` in Eq. (3) is also obtained by converting the time
derivative from ``DtW()`` to ``DtP()``:


::

    DtW(v_PB) = DtP(v_PB) + w_WP x v_PB
                = a_PB + w_WP x v_PB                                    (5)

with ``a_PB = DtP(v_PB)`` by definition. Using Eqs. (4) and (5) in Eq.
(3) yields for the translational acceleration:


::

    a_WB = a_WP + alpha_WP x p_PB + a_PB + ac_WB
      ac_WB = w_WP x (v_PB + w_WP x p_PB) + w_WP x v_PB                 (6)

where finally the term ``ac_WB`` can be written as:


::

    ac_WB = w_WP x w_WP x p_PB + 2 * w_WP x v_PB                      (7)

which includes the effect of angular acceleration of P in W ``alpha_WP
x p_PB``, the centrifugal acceleration ``w_WP x w_WP x p_PB``, the
Coriolis acceleration ``2 * w_WP x v_PB`` due to the motion of B in P
and, the additional acceleration of B in P ``a_PB``.

Note:
    Alternatively, we can write an efficient version of the
    centrifugal term ``ac_WB`` in Eq. (6) for when the velocities of P
    and B are available (e.g. from velocity kinematics). This is
    accomplished by adding and subtracting v_WP within the
    parenthesized term in Eq. (6) and grouping together v_WB = v_WPb +
    v_PB = v_WP + w_WP x p_PB + v_PB:


::

    ac_WB = w_WP x (v_WB - v_WP) + w_WP x v_PB
            = w_WP x (v_WB - v_WP + v_PB)                               (6b)

which simplifies the expression from three cross products to one.

* Rotational acceleration component *

The rotational velocity ``w_WB`` of frame B in W corresponds to the
rotational component in Eq. (1):


::

    w_WB = w_WP + w_PB                                                (8)

Therefore, the rotational acceleration of B in W corresponds to:


::

    alpha_WB = DtW(w_WB) = DtW(w_WP) + DtW(w_PB)
               = alpha_WP + DtW(w_PB)                                   (9)

where the last term in Eq. (9) can be converted to a time derivative
in P as:


::

    DtW(w_PB) = DtP(w_PB) + w_WP x w_PB = alpha_PB + w_WP x w_PB      (10)

where ``alpha_PB = DtP(w_PB)`` by definition. Thus, the final
expression for ``alpha_WB`` is obtained by using Eq. (10) into Eq.
(9):


::

    alpha_WB = alpha_WP + alpha_PB + w_WP x w_PB                      (11)

Equation (11) shows that angular accelerations cannot be simply added
as angular velocities can but there exists an additional term ``w_WP x
w_PB``.

* The spatial acceleration *

The rotational and translational components of the spatial
acceleration are given by Eqs. (11) and (6) respectively:


::

    A_WB.rotational() = alpha_WB
                        = {alpha_WP} + alpha_PB + w_WP x w_PB           (12)
      A_WB.translational() = a_WB
                           = {a_WP + alpha_WP x p_PB + w_WP x w_WP x p_PB}
                           + 2 * w_WP x v_PB + a_PB                     (13)

where we have placed within curly brackets ``{}`` all the terms that
also appear in the Shift() operation, which is equivalent to this
method when ``V_PB`` and ``A_PB`` are both zero. In the equations
above ``alpha_WP = A_WP.rotational()`` and ``a_WP =
A_WP.translational()``. The above expression can be written in a more
compact form in terms of the rigid shift operator ``Φᵀ(p_PB)`` (see
SpatialVelocity::Shift()) as presented in the main body of this
documentation:


::

    A_WB = Φᵀ(p_PB)A_WP + Ac_WB(w_WP, V_PB) + A_PB_W                  (14)

where ``Ac_WB(w_WP, V_PB)`` contains the centrifugal and Coriolis
terms:


::

    Ac_WB(w_WP, V_PB) = | w_WP x w_PB_W                          |
                          | w_WP x w_WP x p_PB_W + 2 w_WP x v_PB_W |
                                      ^^^                ^^^
                                  centrifugal         Coriolis

As usual, for computation, all quantities above must be expressed in a
common frame E; we add an ``_E`` suffix to each symbol to indicate
that.)""";
        } ComposeWithMovingFrameAcceleration;
        // Symbol: drake::multibody::SpatialAcceleration::Shift
        struct /* Shift */ {
          // Source: drake/multibody/math/spatial_acceleration.h:221
          const char* doc_2args =
R"""(Shifts ``this`` spatial acceleration ``A_WP`` of a frame P into the
spatial acceleration ``A_WPq`` of a frame ``Pq`` which is an offset
frame rigidly aligned with P, but with its origin shifted to a point Q
by an offset p_PoQ. Frame ``Pq`` is instantaneously moving together
with frame P as if rigidly attached to it. As an example of
application, this operation can be used to compute ``A_WPq`` where P
is a frame on a rigid body and Q is another point on that same body.
Therefore P and ``Pq`` move together with the spatial velocity
``V_PPq`` being zero at all times. This is an alternate signature for
shifting a spatial acceleration that does not change the original
object. See ShiftInPlace() for more information and a description of
the arguments.)""";
          // Source: drake/multibody/math/spatial_acceleration.h:237
          const char* doc_1args =
R"""((Advanced) Given ``this`` spatial acceleration ``A_WP`` of a frame P
in a second frame W, this operation is only valid when the angular
velocity ``w_WP`` of P in W is zero. Refer to Shift(const Vector3<T>&,
const Vector3<T>&) for the full version that includes velocity terms.
This method can be used to avoid unnecessary computation when shifting
``this`` spatial acceleration of a frame P into the spatial
acceleration of the shifted frame ``Pq``. The shift position vector is
given by ``p_PoQ_E``, expresssed in the same frame E as ``this``
spatial` acceleration. Mathematically, this returns ``A_WPq =
Φᵀ(p_PoQ)A_WP``, where ``Φ(p_PoQ)`` is the rigid shift operator, see
SpatialVelocity::Shift().)""";
        } Shift;
        // Symbol: drake::multibody::SpatialAcceleration::ShiftInPlace
        struct /* ShiftInPlace */ {
          // Source: drake/multibody/math/spatial_acceleration.h:197
          const char* doc =
R"""(In-place shift of ``this`` spatial acceleration ``A_WP`` of a frame P
into the spatial acceleration ``A_WPq`` of a frame ``Pq`` which is an
offset frame rigidly aligned with P, but with its origin shifted to a
point Q by an offset ``p_PoQ``. Frame ``Pq`` is instantaneously moving
together with frame P as if rigidly attached to it. As an example of
application, this operation can be used to compute ``A_WPq`` where P
is a frame on a rigid body and Q is another point on that same body.
Therefore P and ``Pq`` move together with the spatial velocity
``V_PPq`` being zero at all times.

The shift operation modifies ``this`` spatial acceleration ``A_WP_E``
of a frame P measured in a frame W and expressed in a frame E, to
become ``A_WPq_E``, representing the acceleration of a frame ``Pq``
result of shifting frame P to point Q which instantaneously moves
together with frame P. This requires adjusting the linear acceleration
component to account for:

1. the angular acceleration ``alpha_WP`` of frame P in W. 2. the
centrifugal acceleration due to the angular velocity ``w_WP`` of frame
P in W.

We are given the vector from the origin ``Po`` of frame P to point Q,
which becomes the origin of the shifted frame ``Pq``, as the position
vector ``p_PoQ_E`` expressed in the same frame E as ``this`` spatial
acceleration. The operation performed, in coordinate-free form, is:


::

    alpha_WPq  = alpha_WP,  i.e. the angular acceleration is unchanged.
      a_WQ = a_WPo + alpha_WP x p_PoQ + w_WP x w_WP x p_PoQ

where ``alpha`` and ``a`` represent the angular and linear
acceleration components respectively. See notes at the end of this
documentation for a detailed derivation.

For computation, all quantities above must be expressed in a common
frame E; we add an ``_E`` suffix to each symbol to indicate that.

This operation is performed in-place modifying the original object.

Parameter ``p_PoQ_E``:
    Shift vector from the origin ``Po`` of frame P to point Q,
    expressed in frame E. The "from" frame P must be the frame whose
    acceleration is currently represented in ``this`` spatial
    acceleration, and E must be the same expressed-in frame as for
    this spatial acceleration.

Parameter ``w_WP_E``:
    Angular velocity of frame P measured in frame W and expressed in
    frame E.

Returns:
    A reference to ``this`` spatial acceleration which is now
    ``A_WPq_E``, that is, the spatial acceleration of frame ``Pq``,
    still measured in frame W and expressed in frame E.

See also:
    Shift() to compute the shifted spatial acceleration without
    modifying this original object.

** Derivation **

* Translational acceleration component *

Recall that frame ``Pq`` is an offset frame rigidly aligned with P,
but with its origin shifted to a point Q by an offset ``p_PoQ``. Frame
``Pq`` is instantaneously moving together with frame P as if rigidly
attached to it. The translational velocity ``v_WPq`` of frame ``Pq`'s
origin, point Q, in W can be obtained by the shift operation as:


::

    v_WPq = v_WPo + w_WP x p_PoQ                                       (1)

Therefore, for the translational acceleration we have:


::

    a_WQ = DtW(v_WPq)
            = DtW(v_WPo + w_WP x p_PoQ)
            = DtW(v_WPo) + DtW(w_WP x p_PoQ)
            = a_WPo + DtW(w_WP) x p_PoQ + w_WP x DtW(p_PoQ)
            = a_WPo + alpha_WP x p_PoQ + w_WP x DtW(p_PoQ)              (2)

with `a_WPo = DtW(v_WPo)`` and ``alpha_WP = DtW(w_WP)`` by definition.
The last term in Eq. (2) is obtained by converting the vector time
derivative from ``DtW()`` to ``DtP()``, see
drake::math::ConvertTimeDerivativeToOtherFrame():


::

    DtW(p_PoQ) = DtP(p_PoQ) + w_WP x p_PoQ
                  = w_WP x p_PoQ                                         (3)

since ``v_PQ = DtP(p_PoQ) = 0`` because the position of point Q is
fixed in frame P. Using Eq. (3) in Eq. (2) finally yields for the
translational acceleration:


::

    a_WQ = a_WPo + alpha_WP x p_PoQ + w_WP x w_WP x p_PoQ            (4)

* Rotational acceleration component *

The rotational velocity of frame ``Pq`` simply equals that of frame P
since they are moving together in rigid motion, therefore ``w_WPq =
w_WP``. From this, the rotational acceleration of frame ``Pq`` in W is
obtained as:


::

    alpha_WPq = DtW(w_WPq) = DtW(w_WP) = alpha_WP                       (5)

which should be immediately obvious considering that frame ``Pq``
rotates together with frame P.

With the rotational, Eq. (5), and translational, Eq. (4), components
of acceleration derived above, we can write for ``A_WPq``:


::

    A_WPq.rotational() = alpha_WPq = alpha_WP
      A_WPq.translational() = a_WQ
                            = a_WPo + alpha_WP x p_PoQ + w_WP x w_WP x p_PoQ

with ``alpha_WP = A_WP.rotational()`` and ``a_WPo =
A_WP.translational()``. As usual, for computation, all quantities
above must be expressed in a common frame E; we add an ``_E`` suffix
to each symbol to indicate that.)""";
        } ShiftInPlace;
        // Symbol: drake::multibody::SpatialAcceleration::SpatialAcceleration<T>
        struct /* ctor */ {
          // Source: drake/multibody/math/spatial_acceleration.h:72
          const char* doc_0args =
R"""(Default constructor. In Release builds the elements of the newly
constructed spatial acceleration are left uninitialized resulting in a
zero cost operation. However in Debug builds those entries are set to
NaN so that operations using this uninitialized spatial acceleration
fail fast, allowing fast bug detection.)""";
          // Source: drake/multibody/math/spatial_acceleration.h:76
          const char* doc_2args =
R"""(SpatialAcceleration constructor from an angular acceleration ``alpha``
and a linear acceleration ``a``.)""";
          // Source: drake/multibody/math/spatial_acceleration.h:91
          const char* doc_1args =
R"""(SpatialAcceleration constructor from an Eigen expression that
represents a six-dimensional vector. Under the hood, spatial
accelerations are 6-element quantities that are pairs of ordinary
3-vectors. Elements 0-2 constitute the angular acceleration component
while elements 3-5 constitute the translational acceleration. The
argument ``A`` in this constructor is the concatenation of the
rotational 3D component followed by the translational 3D component.
This constructor will assert the size of ``A`` is six (6) at
compile-time for fixed sized Eigen expressions and at run-time for
dynamic sized Eigen expressions.)""";
        } ctor;
      } SpatialAcceleration;
      // Symbol: drake::multibody::SpatialForce
      struct /* SpatialForce */ {
        // Source: drake/multibody/math/spatial_force.h:45
        const char* doc =
R"""(This class is used to represent a *spatial force* (also called a
*wrench*) that combines both rotational (torque) and translational
force components. Spatial forces are 6-element quantities that are
pairs of ordinary 3-vectors. Elements 0-2 are the torque component
while elements 3-5 are the force component. Both vectors must be
expressed in the same frame, and the translational force is applied to
a particular point of a body, but neither the frame nor the point are
stored with a SpatialForce object; they must be understood from
context. It is the responsibility of the user to keep track of the
application point and the expressed-in frame. That is best
accomplished through disciplined notation. In source code we use
monogram notation where capital F is used to designate a spatial force
quantity. We write a point P fixed to body (or frame) B as :math:`B_P`
which appears in code and comments as ``Bp``. Then we write a
particular spatial force as ``F_Bp_E`` where the ``_E`` suffix
indicates that the expressed-in frame is E. This symbol represents a
torque applied to body B, and a force applied to point P on B, with
both vectors expressed in E. Very often the application point will be
the body origin ``Bo``; if no point is shown the origin is understood,
so ``F_B_E`` means ``F_Bo_E``. For a more detailed introduction on
spatial vectors and the monogram notation please refer to section
multibody_spatial_vectors.)""";
        // Symbol: drake::multibody::SpatialForce::Shift
        struct /* Shift */ {
          // Source: drake/multibody/math/spatial_force.h:178
          const char* doc_1args =
R"""(Shift of a SpatialForce from one application point to another. This is
an alternate signature for shifting a spatial force's application
point that does not change the original object. See ShiftInPlace() for
more information.

Parameter ``p_BpBq_E``:
    Shift vector from point P of body B to point Q of B, expressed in
    frame E. The "from" point ``Bp`` must be the current application
    point of ``this`` spatial force, and E must be the same
    expressed-in frame as for this spatial force.

Returns ``F_Bq_E``:
    The equivalent shifted spatial force, now applied at point Q
    rather than P.

See also:
    ShiftInPlace() to compute the shifted spatial force in-place
    modifying the original object.)""";
          // Source: drake/multibody/math/spatial_force.h:206
          const char* doc_3args =
R"""(Performs a rigid shift of each column of 6 x n matrix ``F_Bp_E_all``
into ``F_Bq_E_all`` as if each column were a SpatialForce. The spatial
forces are assumed to be applied at point P of a body B, and we shift
them to point Q of that body by modifying the moment appropriately
(translational forces are unchanged). The first three elements of each
column must store the torque (rotational) component while the last
three elements store the force (translational) component. All
quantities are expressed in the same common frame E.

Parameter ``F_Bp_E_all``:
    A 6 x n matrix of spatial forces at point Bp on input, shifted to
    point Bq on output.

Parameter ``p_BpBq_E``:
    The vector from point Bp to point Bq.

Parameter ``F_Bq_E_all``:
    A 6 x n matrix of spatial forces shifted from Bp to Bq.

Precondition:
    Columns are spatial forces with torque first, then force.

Precondition:
    F_Bq_E_all must be non-null and point to a 6 x n matrix (same size
    as the input matrix).

Note:
    Although this method will function if the input and output are the
    same matrix, it is faster to use ShiftInPlace() in that case since
    the translational components don't need to be copied.

See also:
    ShiftInPlace(const Vector3<T>&) for details.)""";
        } Shift;
        // Symbol: drake::multibody::SpatialForce::ShiftInPlace
        struct /* ShiftInPlace */ {
          // Source: drake/multibody/math/spatial_force.h:124
          const char* doc_1args =
R"""(In-place shift of a SpatialForce from one application point to
another. ``this`` spatial force ``F_Bp_E``, which applies its
translational force component to point P of body B, is modified to
become the equivalent spatial force ``F_Bq_E`` that considers the
force to be applied to point Q of body B instead (see class comment
for more about this notation). This requires adjusting the torque
component to account for the change in moment caused by the force
shift.

We are given the vector from point P to point Q, as a position vector
``p_BpBq_E`` (or ``p_PQ_E``) expressed in the same frame E as the
spatial force. The operation performed, in coordinate-free form, is:


::

    τ_B  = τ_B -  p_BpBq x f_Bp
      f_Bq = f_Bp,  i.e. the force as applied to body B at Q is the
                    same as was applied to B at P.

where τ and f represent the torque and force components respectively.

Notice this operation is linear. [Jain 2010], (§1.5, page 15) uses the
"rigid body transformation operator" to write this as:


::

    F_Bq = Φ(p_BqBp)F_Bp = Φ(-p_BpBq)F_Bp

where ``Φ(p_PQ)`` is the linear operator:


::

    Φ(p_PQ) = | I₃ p_PQx |
                | 0     I₃ |

where ``p_PQx`` denotes the cross product, skew-symmetric, matrix such
that ``p_PQx v = p_PQ x v``. The transpose of this operator allow us
to shift spatial velocities, see SpatialVelocity::Shift().

- [Jain 2010] Jain, A., 2010. Robot and multibody dynamics: analysis and
              algorithms. Springer Science & Business Media, pp. 123-130.

For computation, all quantities above must be expressed in a common
frame E; we add an ``_E`` suffix to each symbol to indicate that.

This operation is performed in-place modifying the original object.

Parameter ``p_BpBq_E``:
    Shift vector from point P of body B to point Q of B, expressed in
    frame E. The "from" point ``Bp`` must be the current application
    point of ``this`` spatial force, and E must be the same
    expressed-in frame as for this spatial force.

Returns:
    A reference to ``this`` spatial force which is now ``F_Bq_E``,
    that is, the force is now applied at point Q rather than P.

See also:
    Shift() to compute the shifted spatial force without modifying
    this original object.)""";
          // Source: drake/multibody/math/spatial_force.h:147
          const char* doc_2args =
R"""(Performs a rigid in-place shift of each column of 6 x n matrix
``F_Bp_E_all`` as if each column were a SpatialForce. The spatial
forces are assumed to be applied at point P of a body B, and we shift
them to point Q of that body by modifying the moment appropriately
(translational forces are unchanged). Hence on output the matrix
should be renamed F_Bq_E_all (conceptually). The first three elements
of each column must store the torque (rotational) component while the
last three elements store the force (translational) component. All
quantities are expressed in the same common frame E.

Parameter ``F_Bp_E_all``:
    A 6 x n matrix of spatial forces at point Bp on input, shifted to
    point Bq on output.

Parameter ``p_BpBq_E``:
    The vector from point Bp to point Bq.

Precondition:
    Columns are spatial forces with torque first, then force.

See also:
    ShiftInPlace(const Vector3<T>&) for details.)""";
        } ShiftInPlace;
        // Symbol: drake::multibody::SpatialForce::SpatialForce<T>
        struct /* ctor */ {
          // Source: drake/multibody/math/spatial_force.h:60
          const char* doc_0args =
R"""(Default constructor. In Release builds the elements of the newly
constructed spatial force are left uninitialized resulting in a zero
cost operation. However in Debug builds those entries are set to NaN
so that operations using this uninitialized spatial force fail fast,
allowing fast bug detection.)""";
          // Source: drake/multibody/math/spatial_force.h:63
          const char* doc_2args =
R"""(SpatialForce constructor from a torque ``tau`` and a force ``f``.)""";
          // Source: drake/multibody/math/spatial_force.h:72
          const char* doc_1args =
R"""(SpatialForce constructor from an Eigen expression that represents a
six-dimensional vector. This constructor will assert the size of F is
six (6) at compile-time for fixed sized Eigen expressions and at
run-time for dynamic sized Eigen expressions.)""";
        } ctor;
        // Symbol: drake::multibody::SpatialForce::dot
        struct /* dot */ {
          // Source: drake/multibody/math/spatial_force.h:227
          const char* doc =
R"""(Given ``this`` spatial force ``F_Bp_E`` applied at point P of body B
and expressed in a frame E, this method computes the 6-dimensional dot
product with the spatial velocity ``V_IBp_E`` of body B at point P,
measured in an inertial frame I and expressed in the same frame E in
which the spatial force is expressed. This dot-product represents the
power generated by ``this`` spatial force when its body and
application point have the given spatial velocity. Although the two
spatial vectors must be expressed in the same frame, the result is
independent of that frame.

Warning:
    The result of this method cannot be interpreted as power unless
    the spatial velocity is measured in an inertial frame I.)""";
        } dot;
      } SpatialForce;
      // Symbol: drake::multibody::SpatialInertia
      struct /* SpatialInertia */ {
        // Source: drake/multibody/tree/spatial_inertia.h:92
        const char* doc =
R"""(This class represents the physical concept of a *Spatial Inertia*. A
spatial inertia (or spatial mass matrix) encapsulates the mass, center
of mass, and rotational inertia of the mass distribution of a body or
composite body S, where with "composite body" we mean a collection of
bodies welded together containing at least one body (throughout this
documentation "body" is many times used instead of "composite body"
but the same concepts apply to a collection of bodies as well.) A
spatial inertia is an element of ℝ⁶ˣ⁶ that is symmetric, and positive
semi-definite. It logically consists of ``3x3`` sub-matrices arranged
like so, [Jain 2010]:


::

    Spatial mass matrix
              ------------ ------------
           0 |            |            |
           1 |    I_SP    | m p_PScm×  |
           2 |            |            |
              ------------ ------------
           3 |            |            |
           4 | -m p_PScm× |     m Id   |
           5 |            |            |
              ------------ ------------
                   Symbol: M

where, with the monogram notation described in
multibody_spatial_inertia, ``I_SP`` is the rotational inertia of body
or composite body S computed about a point P, m is the mass of this
composite body, ``p_PScm`` is the position vector from point P to the
center of mass ``Scm`` of the composite body S with ``p_PScm×``
denoting its skew-symmetric cross product matrix (defined such that
``a× b = a.cross(b)``), and ``Id`` is the identity matrix in ℝ³ˣ³. See
Section 2.1, p. 17 of [Jain 2010]. The logical arrangement as shown
above is chosen to be consistent with our logical arrangement for
spatial vectors as documented in multibody_spatial_algebra for which
the rotational component comes first followed by the translational
component.

In typeset material we use the symbol :math:`[M^{S/P}]_E` to represent
the spatial inertia of a body or composite body S about point P,
expressed in frame E. For this inertia, the monogram notation reads
``M_SP_E``. If the point P is fixed to a body B, we write that point
as :math:`B_P` which appears in code and comments as ``Bp``. So if the
body or composite body is B and the about point is ``Bp``, the
monogram notation reads ``M_BBp_E``, which can be abbreviated to
``M_Bp_E`` since the about point ``Bp`` also identifies the body.
Common cases are that the about point is the origin ``Bo`` of the
body, or it's the center of mass ``Bcm`` for which the rotational
inertia in monogram notation would read as ``I_Bo_E`` and ``I_Bcm_E``,
respectively. Given ``M_BP_E`` (:math:`[M^{B/P}]_E`), the rotational
inertia of this spatial inertia is ``I_BP_E`` (:math:`[I^{B/P}]_E`)
and the position vector of the center of mass measured from point P
and expressed in E is ``p_PBcm_E`` (:math:`[^Pp^{B_{cm}}]_E`).

Note:
    This class does not implement any mechanism to track the frame E
    in which a spatial inertia is expressed or about what point is
    computed. Methods and operators on this class have no means to
    determine frame consistency through operations. It is therefore
    the responsibility of users of this class to keep track of frames
    in which operations are performed. We suggest doing that using
    disciplined notation, as described above.

Note:
    Several methods in this class throw a RuntimeError for invalid
    rotational inertia operations in debug releases only. This
    provides speed in a release build while facilitating debugging in
    debug builds. In addition, these validity tests are only performed
    for scalar types for which drake::scalar_predicate<T>::is_bool is
    ``True``. For instance, validity checks are not performed when T
    is symbolic::Expression.

- [Jain 2010]  Jain, A., 2010. Robot and multibody dynamics: analysis and
               algorithms. Springer Science & Business Media.)""";
        // Symbol: drake::multibody::SpatialInertia::CalcComMoment
        struct /* CalcComMoment */ {
          // Source: drake/multibody/tree/spatial_inertia.h:194
          const char* doc =
R"""(Computes the center of mass moment vector ``mass * p_PScm_E`` given
the position vector ``p_PScm_E`` from the *about point* P to the
center of mass ``Scm`` of the body or composite body S, expressed in
frame E. See the documentation of this class for details.)""";
        } CalcComMoment;
        // Symbol: drake::multibody::SpatialInertia::CalcRotationalInertia
        struct /* CalcRotationalInertia */ {
          // Source: drake/multibody/tree/spatial_inertia.h:204
          const char* doc =
R"""(Computes the rotational inertia ``I_SP_E = mass * G_SP_E`` of this
spatial inertia, computed about point P and expressed in frame E. See
the documentation of this class for details.)""";
        } CalcRotationalInertia;
        // Symbol: drake::multibody::SpatialInertia::CopyToFullMatrix6
        struct /* CopyToFullMatrix6 */ {
          // Source: drake/multibody/tree/spatial_inertia.h:240
          const char* doc =
R"""(Copy to a full 6x6 matrix representation.)""";
        } CopyToFullMatrix6;
        // Symbol: drake::multibody::SpatialInertia::IsNaN
        struct /* IsNaN */ {
          // Source: drake/multibody/tree/spatial_inertia.h:208
          const char* doc =
R"""(Returns ``True`` if any of the elements in this spatial inertia is NaN
and ``False`` otherwise.)""";
        } IsNaN;
        // Symbol: drake::multibody::SpatialInertia::IsPhysicallyValid
        struct /* IsPhysicallyValid */ {
          // Source: drake/multibody/tree/spatial_inertia.h:232
          const char* doc =
R"""(Performs a number of checks to verify that this is a physically valid
spatial inertia. The checks performed are:

- No NaN entries.
- Non-negative mass.
- Non-negative principal moments about the center of mass.
- Principal moments about the center of mass must satisfy the triangle
  inequality:
  - ``Ixx + Iyy >= Izz``
  - `Ixx + Izz >= Iyy`
  - ``Iyy + Izz >= Ixx``

These are the tests performed by
RotationalInertia::CouldBePhysicallyValid() which become a sufficient
condition when performed on a rotational inertia about a body's center
of mass.

See also:
    RotationalInertia::CouldBePhysicallyValid().)""";
        } IsPhysicallyValid;
        // Symbol: drake::multibody::SpatialInertia::MakeFromCentralInertia
        struct /* MakeFromCentralInertia */ {
          // Source: drake/multibody/tree/spatial_inertia.h:112
          const char* doc =
R"""(Creates a spatial inertia for a physical body or composite body S
about a point P from a given mass, center of mass, and central
rotational inertia. For example, this method creates a body's
SpatialInertia about its body origin Bo from the body's mass, position
vector from Bo to the body's center of mass, and rotational inertia
about the body's center of mass.

This method checks for the physical validity of the resulting
SpatialInertia with IsPhysicallyValid() and throws a RuntimeError
exception in the event the provided input parameters lead to a
non-physically viable spatial inertia.

Parameter ``mass``:
    The mass of the body or composite body S.

Parameter ``p_PScm_E``:
    The position vector from point P to point ``Scm`` (S's center of
    mass), expressed in a frame E.

Parameter ``I_SScm_E``:
    S's RotationalInertia about Scm, expressed in frame E.

Returns ``M_SP_E``:
    S's spatial inertia about point P, expressed in frame E.)""";
        } MakeFromCentralInertia;
        // Symbol: drake::multibody::SpatialInertia::ReExpress
        struct /* ReExpress */ {
          // Source: drake/multibody/tree/spatial_inertia.h:319
          const char* doc =
R"""(Given ``this`` spatial inertia ``M_SP_E`` for some body or composite
body S, taken about a point P and expressed in frame E, this method
computes the same inertia re-expressed in another frame A.

Parameter ``R_AE``:
    RotationMatrix relating frames A and E.

Returns ``M_SP_A``:
    The same spatial inertia of S about P but now re-expressed in
    frame A.

See also:
    ReExpressInPlace() for details.)""";
        } ReExpress;
        // Symbol: drake::multibody::SpatialInertia::ReExpressInPlace
        struct /* ReExpressInPlace */ {
          // Source: drake/multibody/tree/spatial_inertia.h:306
          const char* doc =
R"""(Given ``this`` spatial inertia ``M_SP_E`` for some body or composite
body S, taken about a point P and expressed in frame E, this method
computes the same inertia re-expressed in another frame A. This
operation is performed in-place modifying the original object.

Parameter ``R_AE``:
    Rotation matrix from frame E to frame A.

Returns:
    A reference to ``this`` rotational inertia about the same point P
    but now re-expressed in frame A, that is, ``M_SP_A``.)""";
        } ReExpressInPlace;
        // Symbol: drake::multibody::SpatialInertia::SetNaN
        struct /* SetNaN */ {
          // Source: drake/multibody/tree/spatial_inertia.h:252
          const char* doc =
R"""(Sets ``this`` spatial inertia to have NaN entries. Typically used for
quick detection of uninitialized values.)""";
        } SetNaN;
        // Symbol: drake::multibody::SpatialInertia::Shift
        struct /* Shift */ {
          // Source: drake/multibody/tree/spatial_inertia.h:364
          const char* doc =
R"""(Given ``this`` spatial inertia ``M_SP_E`` for some body or composite
body S, computed about point P, and expressed in frame E, this method
uses the *Parallel Axis Theorem* for spatial inertias to compute the
same spatial inertia about a new point Q. The result still is
expressed in frame E.

See also:
    ShiftInPlace() for more details.

Parameter ``p_PQ_E``:
    Vector from the original about point P to the new about point Q,
    expressed in the same frame E ``this`` spatial inertia is
    expressed in.

Returns ``M_SQ_E``:
    This same spatial inertia for body or composite body S but
    computed about about a new point Q.)""";
        } Shift;
        // Symbol: drake::multibody::SpatialInertia::ShiftInPlace
        struct /* ShiftInPlace */ {
          // Source: drake/multibody/tree/spatial_inertia.h:338
          const char* doc =
R"""(Given ``this`` spatial inertia ``M_SP_E`` for some body or composite
body S, computed about point P, and expressed in frame E, this method
uses the *Parallel Axis Theorem* for spatial inertias to compute the
same spatial inertia about a new point Q. The result still is
expressed in frame E. This operation is performed in-place modifying
the original object.

See also:
    Shift() which does not modify this object.

For details see Section 2.1.2, p. 20 of [Jain 2010].

Parameter ``p_PQ_E``:
    Vector from the original about point P to the new about point Q,
    expressed in the same frame E ``this`` spatial inertia is
    expressed in.

Returns:
    A reference to ``this`` spatial inertia for body or composite body
    S but now computed about about a new point Q.)""";
        } ShiftInPlace;
        // Symbol: drake::multibody::SpatialInertia::SpatialInertia<T>
        struct /* ctor */ {
          // Source: drake/multibody/tree/spatial_inertia.h:124
          const char* doc_0args =
R"""(Default SpatialInertia constructor initializes mass, center of mass
and rotational inertia to invalid NaN's for a quick detection of
uninitialized values.)""";
          // Source: drake/multibody/tree/spatial_inertia.h:152
          const char* doc_4args =
R"""(Constructs a spatial inertia for a physical body or composite body S
about a point P from a given mass, center of mass and rotational
inertia. The center of mass is specified by the position vector
``p_PScm_E`` from point P to the center of mass point ``Scm``,
expressed in a frame E. The rotational inertia is provided as the
UnitInertia ``G_SP_E`` of the body or composite body S computed about
point P and expressed in frame E.

Note:
    The third argument of this constructor is unusual in that it is an
    UnitInertia (not a traditional RotationalInertia) and its inertia
    is about the arbitrary point P (not Scm -- S's center of mass).

See also:
    MakeFromCentralInertia a factory method with traditional utility.

This constructor checks for the physical validity of the resulting
SpatialInertia with IsPhysicallyValid() and throws a RuntimeError
exception in the event the provided input parameters lead to
non-physically viable spatial inertia. Since this check has
non-negligable runtime costs, it can be disabled by setting the
optional argument ``skip_validity_check`` to ``True``.

Parameter ``mass``:
    The mass of the body or composite body S.

Parameter ``p_PScm_E``:
    The position vector from point P to the center of mass of body or
    composite body S expressed in frame E.

Parameter ``G_SP_E``:
    UnitInertia of the body or composite body S computed about origin
    point P and expressed in frame E.

Parameter ``skip_validity_check``:
    If true, skips the validity check described above. Defaults to
    false.)""";
        } ctor;
        // Symbol: drake::multibody::SpatialInertia::cast
        struct /* cast */ {
          // Source: drake/multibody/tree/spatial_inertia.h:174
          const char* doc =
R"""(Returns a new SpatialInertia object templated on ``Scalar``
initialized from the value of ``this`` spatial inertia.

Template parameter ``Scalar``:
    The scalar type on which the new spatial inertia will be
    templated.

Note:
    ``SpatialInertia<From>::cast<To>()`` creates a new
    ``SpatialInertia<To>`` from a ``SpatialInertia<From>`` but only if
    type ``To`` is constructible from type ``From``. This cast method
    works in accordance with Eigen's cast method for Eigen's objects
    that underlie this SpatialInertia. For example, Eigen currently
    allows cast from type double to AutoDiffXd, but not vice-versa.)""";
        } cast;
        // Symbol: drake::multibody::SpatialInertia::get_com
        struct /* get_com */ {
          // Source: drake/multibody/tree/spatial_inertia.h:188
          const char* doc =
R"""(Get a constant reference to the position vector ``p_PScm_E`` from the
*about point* P to the center of mass ``Scm`` of the body or composite
body S, expressed in frame E. See the documentation of this class for
details.)""";
        } get_com;
        // Symbol: drake::multibody::SpatialInertia::get_mass
        struct /* get_mass */ {
          // Source: drake/multibody/tree/spatial_inertia.h:183
          const char* doc =
R"""(Get a constant reference to the mass of this spatial inertia.)""";
        } get_mass;
        // Symbol: drake::multibody::SpatialInertia::get_unit_inertia
        struct /* get_unit_inertia */ {
          // Source: drake/multibody/tree/spatial_inertia.h:199
          const char* doc =
R"""(Get a constant reference to the unit inertia ``G_SP_E`` of this
spatial inertia, computed about point P and expressed in frame E. See
the documentation of this class for details.)""";
        } get_unit_inertia;
        // Symbol: drake::multibody::SpatialInertia::operator*
        struct /* operator_mul */ {
          // Source: drake/multibody/tree/spatial_inertia.h:392
          const char* doc_1args_A_WB_E =
R"""(Multiplies ``this`` spatial inertia ``M_Bo_E`` of a body B about its
frame origin ``Bo`` by the spatial acceleration of the body frame B in
a frame W. Mathematically:


::

    F_Bo_E = M_Bo_E * A_WB_E

or, in terms of its rotational and translational components (see this
class's documentation for the block form of a rotational inertia):


::

    t_Bo = I_Bo * alpha_WB + m * p_BoBcm x a_WBo
      f_Bo = -m * p_BoBcm x alpha_WB + m * a_WBo

where ``alpha_WB`` and ``a_WBo`` are the rotational and translational
components of the spatial acceleration ``A_WB``, respectively.

Note:
    The term ``F_Bo_E`` computed by this operator appears in the
    equations of motion for a rigid body which, when written about the
    origin ``Bo`` of the body frame B (which does not necessarily need
    to coincide with the body's center of mass), read as:


::

    Ftot_BBo = M_Bo_W * A_WB + b_Bo

where ``Ftot_BBo`` is the total spatial force applied on body B at at
``Bo`` that corresponds to the body spatial acceleration ``A_WB`` and
``b_Bo`` contains the velocity dependent gyroscopic terms (see Eq.
2.26, p. 27, in A. Jain's book).)""";
          // Source: drake/multibody/tree/spatial_inertia.h:426
          const char* doc_1args_V_WBp_E =
R"""(Multiplies ``this`` spatial inertia ``M_BP_E`` of a body B about a
point P by the spatial velocity ``V_WBp``, in a frame W, of the body
frame B shifted to point P. Mathematically:


::

    L_WBp_E = M_BP_E * V_WBp_E

or, in terms of its rotational and translational components (see this
class's documentation for the block form of a rotational inertia):


::

    h_WB  = I_Bp * w_WB + m * p_BoBcm x v_WP
      l_WBp = -m * p_BoBcm x w_WB + m * v_WP

where ``w_WB`` and ``v_WP`` are the rotational and translational
components of the spatial velocity ``V_WBp``, respectively and,
``h_WB`` and ``l_WBp`` are the angular and linear components of the
spatial momentum ``L_WBp``, respectively.

Note:
    It is possible to show that ``M_BP_E.Shift(p_PQ_E) *
    V_WBp_E.Shift(p_PQ_E)`` exactly equals ``L_WBp_E.Shift(p_PQ_E)``.)""";
          // Source: drake/multibody/tree/spatial_inertia.h:452
          const char* doc_1args_constEigenMatrixBase =
R"""(Multiplies ``this`` spatial inertia by a set of spatial vectors in M⁶
stored as columns of input matrix ``Mmatrix``. The top three rows of
Mmatrix are expected to store the rotational components while the
bottom three rows are expected to store the translational components.
The output matrix is of the same size as ``Mmatrix`` and each j-th
column stores the spatial vector in F⁶ result of multiplying ``this``
spatial inertia with the j-th column of ``Mmatrix``.)""";
        } operator_mul;
        // Symbol: drake::multibody::SpatialInertia::operator+=
        struct /* operator_iadd */ {
          // Source: drake/multibody/tree/spatial_inertia.h:281
          const char* doc =
R"""(Adds in a spatial inertia to ``this`` spatial inertia.

Parameter ``M_BP_E``:
    A spatial inertia of some body B to be added to ``this`` spatial
    inertia. It must be defined about the same point P as ``this``
    inertia, and expressed in the same frame E.

Returns:
    A reference to ``this`` spatial inertia, which has been updated to
    include the given spatial inertia ``M_BP_E``.

Note:
    Given that the composition of spatial inertias is not well defined
    for massless bodies, this composition of the spatial inertias
    performs the arithmetic average of the center of mass position
    vector (get_com()) and unit inertia (get_unit_inertia()) when the
    two spatial inertias have zero mass (get_mass()). This is only
    valid in the limit to zero mass for two bodies with the same mass.
    This special case allows the composition of spatial inertias in
    the common case of a kinematic chain of massless bodies.

Warning:
    This operation is only valid if both spatial inertias are computed
    about the same point P and expressed in the same frame E.
    Considering ``this`` spatial inertia to be ``M_SP_E`` for some
    body or composite body S, about some point P, the supplied spatial
    inertia ``M_BP_E`` must be for some other body or composite body B
    about the *same* point P; B's inertia is then included in S.)""";
        } operator_iadd;
      } SpatialInertia;
      // Symbol: drake::multibody::SpatialMomentum
      struct /* SpatialMomentum */ {
        // Source: drake/multibody/math/spatial_momentum.h:70
        const char* doc =
R"""(This class is used to represent the *spatial momentum* of a particle,
system of particles or body (whether rigid or soft.) The linear
momentum ``l_NS`` of a system of particles S in a reference frame N is
defined by:


::

    l_NS = ∑l_NQi = ∑mᵢv_NQi

where ``mᵢ`` and ``v_NQi`` are the mass and linear velocity (in frame
N) of the i-th particle in the system, respectively. Their product
``l_NQi = mᵢv_NQi`` is the linear momentum of the i-th particle in the
N reference frame. The angular momentum ``h_NSp`` of a system of
particles S in a reference frame N about an arbitrary point P is
defined by:


::

    h_NSp = ∑ p_PQi x l_NQi

where ``p_PQi`` is the position vector from point P to the i-th
particle position ``Qi``. The definitions above extend to a continuum
of particles as:


::

    h_NSp = ∫p_PQ(r) x v_NQ(r) ρ(r)d³r
      l_NS = ∫v_NQ(r) ρ(r)d³r

where ``ρ(r)`` is the density of the body at each material location
``r``. In particular, the continuum version above also applies to
rigid bodies.

Spatial momenta are elements of F⁶ (see [Featherstone 2008]) that
combine both rotational (angular momentum) and translational (linear
momentum) components. Spatial momenta are 6-element quantities that
are pairs of ordinary 3-vectors. Elements 0-2 are the angular momentum
component while elements 3-5 are the linear momentum component. As
with any other spatial vector, both vector components must be
expressed in the same frame.

Neither the expressed-in frame nor the about-point are stored with a
SpatialMomentum object; they must be understood from context. It is
the responsibility of the user to keep track of the about-point and
the expressed-in frame. That is best accomplished through disciplined
notation. In source code we use monogram notation where L designates a
spatial momentum quantity. The spatial momentum of a system S in a
frame N about an arbitrary point P, expressed in a frame E is typeset
as :math:`[^NL^{S/P}]_E`, which appears in code as ``L_NSP_E``. The
spatial momentum of a body B in a frame N about the body origin Bo is
explicitly typeset as L_NBBo_E, but we abbreviate it as L_NBo_E.
Similarly, the spatial momentum of a system S in a frame N about Scm
(the system center of mass), expressed in a frame E is explicitly
typeset as L_NSScm_E, but we abbreviate it as L_NScm_E. For a more
detailed introduction on spatial vectors and the monogram notation
please refer to section multibody_spatial_vectors.

- [Featherstone 2008] Featherstone, R., 2008. Rigid body dynamics
                      algorithms. Springer.)""";
        // Symbol: drake::multibody::SpatialMomentum::Shift
        struct /* Shift */ {
          // Source: drake/multibody/math/spatial_momentum.h:165
          const char* doc =
R"""(Shift of a SpatialMomentum from one application point to another. This
is an alternate signature for shifting a spatial momentum's
about-point that does not change the original object. See
ShiftInPlace() for more information.

Parameter ``p_PQ_E``:
    Shift vector from point P to point Q.

Returns ``L_NSq_E``:
    The equivalent shifted spatial momentum, now applied at point Q
    rather than P.

See also:
    ShiftInPlace() to compute the shifted spatial momentum in-place
    modifying the original object.)""";
        } Shift;
        // Symbol: drake::multibody::SpatialMomentum::ShiftInPlace
        struct /* ShiftInPlace */ {
          // Source: drake/multibody/math/spatial_momentum.h:147
          const char* doc =
R"""(In-place shift of a SpatialMomentum from one "about-point" to another.
``this`` spatial momentum ``L_NSp_E`` for a system S in a reference
frame N about a point P, and expressed in frame E, is modified to
become the equivalent spatial momentum ``L_NSq_E`` of the same system
about another point Q.

We are given the vector from point P to point Q, as a position vector
``p_PQ_E`` expressed in the same frame E as the spatial momentum. The
operation performed, in coordinate-free form, is:


::

    h_NSq  = h_NSp -  p_PQ x l_NSp
      l_NSq = l_NSp,  i.e. the linear momentum about point Q is the
                      same as the linear momentum about point P.

where h and l represent the angular and linear momentum components
respectively. Notice that spatial momenta shift in the same way as
spatial forces (see SpatialForce.)

The operation is linear, which [Jain 2010], (§2.1, page 22) writes
using the "rigid body transformation operator" as:


::

    L_NSq = Φ(p_QP)L_NSp = Φ(-p_PQ)L_NSp

where ``Φ(p_PQ)`` is the linear operator:


::

    Φ(p_PQ) = | I₃ p_PQx |
                | 0     I₃ |

where ``p_PQx`` denotes the cross product, skew-symmetric, matrix such
that ``p_PQx v = p_PQ x v``. This same operator shifts spatial forces
in analogous way (see SpatialForce::Shift()) while the transpose of
this operator allow us to shift spatial velocities, see
SpatialVelocity::Shift().

- [Jain 2010] Jain, A., 2010. Robot and multibody dynamics: analysis and
              algorithms. Springer Science & Business Media, pp. 123-130.

For computation, all quantities above must be expressed in a common
frame E; we add an ``_E`` suffix to each symbol to indicate that.

This operation is performed in-place modifying the original object.

Parameter ``p_PQ_E``:
    Shift vector from point P to point Q, expressed in frame E.

Returns:
    A reference to ``this`` spatial momentum which is now ``L_NSq_E``,
    that is, the spatial momentum about point Q rather than P.

See also:
    Shift() to compute the shifted spatial momentum without modifying
    this original object.)""";
        } ShiftInPlace;
        // Symbol: drake::multibody::SpatialMomentum::SpatialMomentum<T>
        struct /* ctor */ {
          // Source: drake/multibody/math/spatial_momentum.h:85
          const char* doc_0args =
R"""(Default constructor. In Release builds the elements of the newly
constructed spatial momentum are left uninitialized resulting in a
zero cost operation. However in Debug builds those entries are set to
NaN so that operations using this uninitialized spatial momentum fail
fast, allowing fast bug detection.)""";
          // Source: drake/multibody/math/spatial_momentum.h:89
          const char* doc_2args =
R"""(SpatialMomentum constructor from an angular momentum h and a linear
momentum l.)""";
          // Source: drake/multibody/math/spatial_momentum.h:98
          const char* doc_1args =
R"""(SpatialMomentum constructor from an Eigen expression that represents a
six-dimensional vector. This constructor will assert the size of L is
six (6) at compile-time for fixed sized Eigen expressions and at
run-time for dynamic sized Eigen expressions.)""";
        } ctor;
        // Symbol: drake::multibody::SpatialMomentum::dot
        struct /* dot */ {
          // Source: drake/multibody/math/spatial_momentum.h:185
          const char* doc =
R"""(Given ``this`` spatial momentum ``L_NBp_E`` of a rigid body B, about
point P and, expressed in a frame E, this method computes the dot
product with the spatial velocity ``V_NBp_E`` of body B frame shifted
to point P, measured in an inertial (or Newtonian) frame N and
expressed in the same frame E in which the spatial momentum is
expressed. This dot-product is twice the kinetic energy ``ke_NB`` of
body B in reference frame N. The kinetic energy ``ke_NB`` is
independent of the about-point P and so is this dot product. Therefore
it is always true that:


::

    ke_NB = 1/2 (L_NBp⋅V_NBp) = 1/2 (L_NBcm⋅V_NBcm)

where ``L_NBcm`` is the spatial momentum about the center of mass of
body B and ``V_NBcm`` is the spatial velocity of frame B shifted to
its center of mass. The above is true due to how spatial momentum and
velocity shift when changing point P, see SpatialMomentum::Shift() and
SpatialVelocity::Shift().)""";
        } dot;
      } SpatialMomentum;
      // Symbol: drake::multibody::SpatialVector
      struct /* SpatialVector */ {
        // Source: drake/multibody/math/spatial_vector.h:30
        const char* doc =
R"""(This class is used to represent physical quantities that correspond to
spatial vectors such as spatial velocities, spatial accelerations and
spatial forces. Spatial vectors are 6-element quantities that are
pairs of ordinary 3-vectors. Elements 0-2 are always the rotational
component while elements 3-5 are always the translational component.
For a more detailed introduction on spatial vectors please refer to
section multibody_spatial_vectors.

Template parameter ``SV``:
    The type of the more specialized spatial vector class. It must be
    a template on the scalar type T.)""";
        // Symbol: drake::multibody::SpatialVector::CoeffsEigenType
        struct /* CoeffsEigenType */ {
          // Source: drake/multibody/math/spatial_vector.h:46
          const char* doc =
R"""(The type of the underlying in-memory representation using an Eigen
vector.)""";
        } CoeffsEigenType;
        // Symbol: drake::multibody::SpatialVector::GetMaximumAbsoluteDifferences
        struct /* GetMaximumAbsoluteDifferences */ {
          // Source: drake/multibody/math/spatial_vector.h:141
          const char* doc =
R"""(Returns the maximum absolute values of the differences in the
rotational and translational components of ``this`` and ``other``
(i.e., the infinity norms of the difference in rotational and
translational components). These quantities are returned in a tuple,
in the order below. std::tuple | Description
-----------------|-------------------------------------------------
w_max_difference | Maximum absolute difference in rotation components
v_max_difference | Maximum absolute difference in translation
components)""";
        } GetMaximumAbsoluteDifferences;
        // Symbol: drake::multibody::SpatialVector::IsApprox
        struct /* IsApprox */ {
          // Source: drake/multibody/math/spatial_vector.h:178
          const char* doc =
R"""(Compares ``this`` spatial vector to the provided spatial vector
``other`` within a specified tolerance. Mathematically, if ``this`` is
the spatial vector U and ``other`` is the spatial vector V, then this
method returns ``True`` if ``‖U-V‖∞ < ε`` and ``False`` otherwise.)""";
        } IsApprox;
        // Symbol: drake::multibody::SpatialVector::IsNearlyEqualWithinAbsoluteTolerance
        struct /* IsNearlyEqualWithinAbsoluteTolerance */ {
          // Source: drake/multibody/math/spatial_vector.h:163
          const char* doc =
R"""(Compares the rotational and translational parts of ``this`` and
``other`` to check if they are the same to within specified absolute
differences.

Parameter ``rotational_tolerance``:
    maximum allowable absolute difference between the rotational parts
    of ``this`` and ``other``. The units depend on the underlying
    class. For example, spatial velocity, acceleration, and force have
    units of rad/sec, rad/sec^2, and N*m, respectively.

Parameter ``translational_tolerance``:
    maximum allowable absolute difference between the translational
    parts of ``this`` and ``other``. The units depend on the
    underlying class. For example, spatial velocity, acceleration, and
    force have units of meter/sec, meter/sec^2, and Newton,
    respectively.

Returns:
    ``True`` if the rotational part of ``this`` and ``other`` are
    equal within ``rotational_tolerance`` and the translational part
    of ``this`` and ``other`` are equal within
    ``translational_tolerance``.)""";
        } IsNearlyEqualWithinAbsoluteTolerance;
        // Symbol: drake::multibody::SpatialVector::SetNaN
        struct /* SetNaN */ {
          // Source: drake/multibody/math/spatial_vector.h:187
          const char* doc =
R"""(Sets all entries in ``this`` SpatialVector to NaN. Typically used to
quickly detect uninitialized values since NaN will trigger a chain of
invalid computations that can then be tracked back to the source.)""";
        } SetNaN;
        // Symbol: drake::multibody::SpatialVector::SetZero
        struct /* SetZero */ {
          // Source: drake/multibody/math/spatial_vector.h:194
          const char* doc =
R"""(Sets both rotational and translational components of ``this``
SpatialVector to zero.)""";
        } SetZero;
        // Symbol: drake::multibody::SpatialVector::SpatialQuantity
        struct /* SpatialQuantity */ {
          // Source: drake/multibody/math/spatial_vector.h:36
          const char* doc =
R"""(The more specialized spatial vector class templated on the scalar type
T.)""";
        } SpatialQuantity;
        // Symbol: drake::multibody::SpatialVector::SpatialVector<SV, T>
        struct /* ctor */ {
          // Source: drake/multibody/math/spatial_vector.h:53
          const char* doc_0args =
R"""(Default constructor. In Release builds the elements of the newly
constructed spatial vector are left uninitialized resulting in a zero
cost operation. However in Debug builds those entries are set to NaN
so that operations using this uninitialized spatial vector fail fast,
allowing fast bug detection.)""";
          // Source: drake/multibody/math/spatial_vector.h:59
          const char* doc_2args =
R"""(SpatialVector constructor from an rotational component ``w`` and a
linear component ``v``.)""";
          // Source: drake/multibody/math/spatial_vector.h:71
          const char* doc_1args =
R"""(SpatialVector constructor from an Eigen expression that represents a
six-dimensional vector. This constructor will assert the size of V is
six (6) at compile-time for fixed sized Eigen expressions and at
run-time for dynamic sized Eigen expressions.)""";
        } ctor;
        // Symbol: drake::multibody::SpatialVector::Zero
        struct /* Zero */ {
          // Source: drake/multibody/math/spatial_vector.h:275
          const char* doc =
R"""(Factory to create a *zero* SpatialVector, i.e. rotational and
translational components are both zero.)""";
        } Zero;
        // Symbol: drake::multibody::SpatialVector::data
        struct /* data */ {
          // Source: drake/multibody/math/spatial_vector.h:126
          const char* doc =
R"""(Returns a (const) bare pointer to the underlying data. It is
guaranteed that there will be six (6) T's densely packed at data[0],
data[1], etc.)""";
        } data;
        // Symbol: drake::multibody::SpatialVector::get_coeffs
        struct /* get_coeffs */ {
          // Source: drake/multibody/math/spatial_vector.h:200
          const char* doc_0args_nonconst =
R"""(Returns a reference to the underlying storage.)""";
          // Source: drake/multibody/math/spatial_vector.h:203
          const char* doc_0args_const =
R"""(Returns a constant reference to the underlying storage.)""";
        } get_coeffs;
        // Symbol: drake::multibody::SpatialVector::kRotationSize
        struct /* kRotationSize */ {
          // Source: drake/multibody/math/spatial_vector.h:41
          const char* doc = R"""()""";
        } kRotationSize;
        // Symbol: drake::multibody::SpatialVector::kSpatialVectorSize
        struct /* kSpatialVectorSize */ {
          // Source: drake/multibody/math/spatial_vector.h:40
          const char* doc = R"""()""";
        } kSpatialVectorSize;
        // Symbol: drake::multibody::SpatialVector::kTranslationSize
        struct /* kTranslationSize */ {
          // Source: drake/multibody/math/spatial_vector.h:42
          const char* doc = R"""()""";
        } kTranslationSize;
        // Symbol: drake::multibody::SpatialVector::mutable_data
        struct /* mutable_data */ {
          // Source: drake/multibody/math/spatial_vector.h:131
          const char* doc =
R"""(Returns a (mutable) bare pointer to the underlying data. It is
guaranteed that there will be six (6) T's densely packed at data[0],
data[1], etc.)""";
        } mutable_data;
        // Symbol: drake::multibody::SpatialVector::operator*=
        struct /* operator_imul */ {
          // Source: drake/multibody/math/spatial_vector.h:223
          const char* doc = R"""(Multiplication assignment operator.)""";
        } operator_imul;
        // Symbol: drake::multibody::SpatialVector::operator+=
        struct /* operator_iadd */ {
          // Source: drake/multibody/math/spatial_vector.h:211
          const char* doc = R"""(Addition assignment operator.)""";
        } operator_iadd;
        // Symbol: drake::multibody::SpatialVector::operator-
        struct /* operator_sub */ {
          // Source: drake/multibody/math/spatial_vector.h:206
          const char* doc = R"""(Unary minus operator.)""";
        } operator_sub;
        // Symbol: drake::multibody::SpatialVector::operator-=
        struct /* operator_isub */ {
          // Source: drake/multibody/math/spatial_vector.h:217
          const char* doc = R"""(Subtraction assignment operator.)""";
        } operator_isub;
        // Symbol: drake::multibody::SpatialVector::operator[]
        struct /* operator_array */ {
          // Source: drake/multibody/math/spatial_vector.h:80
          const char* doc_1args_i_const =
R"""(Const access to the i-th component of this spatial vector. Bounds are
only checked in Debug builds for a zero overhead implementation in
Release builds.)""";
          // Source: drake/multibody/math/spatial_vector.h:88
          const char* doc_1args_i_nonconst =
R"""(Mutable access to the i-th component of this spatial vector. Bounds
are only checked in Debug builds for a zero overhead implementation in
Release builds.)""";
        } operator_array;
        // Symbol: drake::multibody::SpatialVector::rotational
        struct /* rotational */ {
          // Source: drake/multibody/math/spatial_vector.h:94
          const char* doc_0args_const =
R"""(Const access to the rotational component of this spatial vector.)""";
          // Source: drake/multibody/math/spatial_vector.h:101
          const char* doc_0args_nonconst =
R"""(Mutable access to the rotational component of this spatial vector.)""";
        } rotational;
        // Symbol: drake::multibody::SpatialVector::size
        struct /* size */ {
          // Source: drake/multibody/math/spatial_vector.h:75
          const char* doc =
R"""(The total size of the concatenation of the angular and linear
components. In three dimensions this is six (6) and it is known at
compile time.)""";
        } size;
        // Symbol: drake::multibody::SpatialVector::translational
        struct /* translational */ {
          // Source: drake/multibody/math/spatial_vector.h:108
          const char* doc_0args_const =
R"""(Const access to the translational component of this spatial vector.)""";
          // Source: drake/multibody/math/spatial_vector.h:116
          const char* doc_0args_nonconst =
R"""(Mutable access to the translational component of this spatial vector.)""";
        } translational;
      } SpatialVector;
      // Symbol: drake::multibody::SpatialVelocity
      struct /* SpatialVelocity */ {
        // Source: drake/multibody/math/spatial_velocity.h:50
        const char* doc =
R"""(This class is used to represent a *spatial velocity* (also called a
*twist*) that combines rotational (angular) and translational (linear)
velocity components. Spatial velocities are 6-element quantities that
are pairs of ordinary 3-vectors. Elements 0-2 are the angular velocity
component while elements 3-5 are the translational velocity. Spatial
velocities represent the motion of a "moving frame" B measured with
respect to a "measured-in" frame A. In addition, the two contained
vectors must be expressed in the same "expressed-in" frame E, which
may be distinct from either A or B. Finally, while angular velocity is
identical for any frame fixed to a rigid body, translational velocity
refers to a particular point. Only the vector values are stored in a
SpatialVelocity object; the three frames and the point must be
understood from context. It is the responsibility of the user to keep
track of them. That is best accomplished through disciplined notation.
In source code we use monogram notation where capital V is used to
designate a spatial velocity quantity. We write a point P fixed to
body (or frame) B as :math:`B_P` which appears in code and comments as
``Bp``. Then we write a particular spatial velocity as ``V_ABp_E``
where the ``_E`` suffix indicates that the expressed-in frame is E.
This symbol represents the angular velocity of frame B in frame A, and
the translational velocity of point P in A, where P is fixed to frame
B, with both vectors expressed in E. Very often the point of interest
will be the body origin ``Bo``; if no point is shown the origin is
understood, so ``V_AB_E`` means ``V_ABo_E``. For a more detailed
introduction on spatial vectors and the monogram notation please refer
to section multibody_spatial_vectors.)""";
        // Symbol: drake::multibody::SpatialVelocity::ComposeWithMovingFrameVelocity
        struct /* ComposeWithMovingFrameVelocity */ {
          // Source: drake/multibody/math/spatial_velocity.h:197
          const char* doc =
R"""(This method composes ``this`` spatial velocity ``V_WP`` of a frame P
measured in a frame W, with that of a third frame B moving in P with
spatial velocity ``V_PB``. The result is the spatial velocity ``V_WB``
of frame B measured in W. At the instant in which the velocities are
composed, frame B is located with its origin ``Bo`` at ``p_PoBo`` from
P's origin Po.

The composition cannot be performed directly since frames P and B do
not have the same origins. To perform the composition ``V_WB``, the
velocity of P needs to be shifted to point ``Bo``:


::

    V_WB_E = V_WPb_E + V_PB_E = V_WP_E.Shift(p_PoBo_E) + V_PB_E

where p_PoBo is the position vector from P's origin to B's origin and
``V_WPb`` is the spatial velocity of a new frame ``Pb`` which is an
offset frame rigidly aligned with P, but with its origin shifted to
B's origin. The key is that in the expression above, the two spatial
velocities being added must be for frames with the same origin point,
in this case Bo.

For computation, all quantities above must be expressed in a common
frame E; we add an ``_E`` suffix to each symbol to indicate that.

Note:
    If frame B moves rigidly together with frame P, as in a rigid
    body, ``V_PB = 0`` and the result of this method equals that of
    the Shift() operation.

Parameter ``p_PoBo_E``:
    Shift vector from P's origin to B's origin, expressed in frame E.
    The "from" point ``Po`` must be the point whose velocity is
    currently represented in ``this`` spatial velocity, and E must be
    the same expressed-in frame as for ``this`` spatial velocity.

Parameter ``V_PB_E``:
    The spatial velocity of a third frame B in motion with respect to
    P, expressed in the same frame E as ``this`` spatial velocity.

Returns ``V_WB_E``:
    The spatial velocity of frame B in W resulting from the
    composition of ``this`` spatial velocity ``V_WP`` and B's velocity
    in P, ``V_PB``. The result is expressed in the same frame E as
    ``this`` spatial velocity.)""";
        } ComposeWithMovingFrameVelocity;
        // Symbol: drake::multibody::SpatialVelocity::Shift
        struct /* Shift */ {
          // Source: drake/multibody/math/spatial_velocity.h:157
          const char* doc =
R"""(Shift of a SpatialVelocity from one point on a rigid body or frame to
another point on the same body or frame. This is an alternate
signature for shifting a spatial velocity's point that does not change
the original object. See ShiftInPlace() for more information.

Parameter ``p_BpBq_E``:
    Shift vector from point P of body B to point Q of B, expressed in
    frame E. The "from" point ``Bp`` must be the point whose velocity
    is currently represented in this spatial velocity, and E must be
    the same expressed-in frame as for this spatial velocity.

Returns ``V_ABq_E``:
    The spatial velocity of frame B at point Q, measured in frame A
    and expressed in frame E.

See also:
    ShiftInPlace() to compute the shifted spatial velocity in-place
    modifying the original object.)""";
        } Shift;
        // Symbol: drake::multibody::SpatialVelocity::ShiftInPlace
        struct /* ShiftInPlace */ {
          // Source: drake/multibody/math/spatial_velocity.h:133
          const char* doc =
R"""(In-place shift of a SpatialVelocity from one point on a rigid body or
frame to another point on the same body or frame. ``this`` spatial
velocity ``V_ABp_E`` of a frame B at a point P fixed on B, measured in
a frame A, and expressed in a frame E, is modified to become
``V_ABq_E``, representing the velocity of another point Q on B instead
(see class comment for more about this notation). This requires
adjusting the translational (linear) velocity component to account for
the velocity difference between P and Q due to the angular velocity of
B in A.

We are given the vector from point P to point Q, as a position vector
``p_BpBq_E`` (or ``p_PQ_E``) expressed in the same frame E as the
spatial velocity. The operation performed, in coordinate-free form,
is:


::

    w_AB  = w_AB,  i.e. the angular velocity is unchanged.
      v_ABq = v_ABp + w_AB x p_BpBq

where w and v represent the angular and linear velocity components
respectively. Notice this operation is linear. [Jain 2010], (§1.4,
page 12) uses the "rigid body transformation operator" to write this
as:


::

    V_ABq = Φᵀ(p_BpBq)V_ABp

where ``Φᵀ(p_PQ)`` is the linear operator:


::

    Φᵀ(p_PQ) = |  I₃    0  |
                 | -p_PQx I₃ |

where ``p_PQx`` denotes the cross product, skew-symmetric, matrix such
that ``p_PQx v = p_PQ x v``. This same operator (not its transpose as
for spatial velocities) allow us to shift spatial forces, see
SpatialForce::Shift().

- [Jain 2010] Jain, A., 2010. Robot and multibody dynamics: analysis and
              algorithms. Springer Science & Business Media, pp. 123-130.

For computation, all quantities above must be expressed in a common
frame E; we add an ``_E`` suffix to each symbol to indicate that.

This operation is performed in-place modifying the original object.

Parameter ``p_BpBq_E``:
    Shift vector from point P of body B to point Q of B, expressed in
    frame E. The "from" point ``Bp`` must be the point whose velocity
    is currently represented in this spatial velocity, and E must be
    the same expressed-in frame as for this spatial velocity.

Returns:
    A reference to ``this`` spatial velocity which is now ``V_ABq_E``,
    that is, the spatial velocity of frame B at point Q, still
    measured in frame A and expressed in frame E.

See also:
    Shift() to compute the shifted spatial velocity without modifying
    this original object.)""";
        } ShiftInPlace;
        // Symbol: drake::multibody::SpatialVelocity::SpatialVelocity<T>
        struct /* ctor */ {
          // Source: drake/multibody/math/spatial_velocity.h:65
          const char* doc_0args =
R"""(Default constructor. In Release builds the elements of the newly
constructed spatial velocity are left uninitialized resulting in a
zero cost operation. However in Debug builds those entries are set to
NaN so that operations using this uninitialized spatial velocity fail
fast, allowing fast bug detection.)""";
          // Source: drake/multibody/math/spatial_velocity.h:69
          const char* doc_2args =
R"""(SpatialVelocity constructor from an angular velocity ``w`` and a
linear velocity ``v``.)""";
          // Source: drake/multibody/math/spatial_velocity.h:78
          const char* doc_1args =
R"""(SpatialVelocity constructor from an Eigen expression that represents a
six-dimensional vector. This constructor will assert the size of V is
six (6) at compile-time for fixed sized Eigen expressions and at
run-time for dynamic sized Eigen expressions.)""";
        } ctor;
        // Symbol: drake::multibody::SpatialVelocity::dot
        struct /* dot */ {
          // Source: drake/multibody/math/spatial_velocity.h:216
          const char* doc_1args_F_Q_E =
R"""(Given ``this`` spatial velocity ``V_IBp_E`` of point P of body B,
measured in an inertial frame I and expressed in a frame E, this
method computes the 6-dimensional dot product with the spatial force
``F_Bp_E`` applied to point P, and expressed in the same frame E in
which the spatial velocity is expressed. This dot-product represents
the power generated by the spatial force when its body and application
point have ``this`` spatial velocity. Although the two spatial vectors
must be expressed in the same frame, the result is independent of that
frame.

Warning:
    The result of this method cannot be interpreted as power unless
    ``this`` spatial velocity is measured in an inertial frame I,
    which cannot be enforced by this class.)""";
          // Source: drake/multibody/math/spatial_velocity.h:237
          const char* doc_1args_L_NBp_E =
R"""(Given ``this`` spatial velocity ``V_NBp_E`` of rigid body B frame
shifted to point P, measured in an inertial (or Newtonian) frame N
and, expressed in a frame E this method computes the dot product with
the spatial momentum ``L_NBp_E`` of rigid body B, about point P, and
expressed in the same frame E. This dot-product is twice the kinetic
energy ``ke_NB`` of body B in reference frame N. The kinetic energy
``ke_NB`` is independent of the about-point P and so is this dot
product. Therefore it is always true that:


::

    ke_NB = 1/2 (L_NBp⋅V_NBp) = 1/2 (L_NBcm⋅V_NBcm)

where ``L_NBcm`` is the spatial momentum about the center of mass of
body B and ``V_NBcm`` is the spatial velocity of frame B shifted to
its center of mass. The above is true due to how spatial momentum and
velocity shift when changing point P, see SpatialMomentum::Shift() and
SpatialVelocity::Shift().)""";
        } dot;
      } SpatialVelocity;
      // Symbol: drake::multibody::StaticEquilibriumConstraint
      struct /* StaticEquilibriumConstraint */ {
        // Source: drake/multibody/optimization/static_equilibrium_constraint.h:20
        const char* doc =
R"""(Impose the static equilibrium constraint 0 = τ_g + Bu + ∑J_WBᵀ(q) *
Fapp_B_W)""";
        // Symbol: drake::multibody::StaticEquilibriumConstraint::MakeBinding
        struct /* MakeBinding */ {
          // Source: drake/multibody/optimization/static_equilibrium_constraint.h:46
          const char* doc =
R"""(Create a static equilibrium constraint 0 = g(q) + Bu + ∑ᵢ
JᵢᵀFᵢ_AB_W(λᵢ) This constraint depends on the variables q, u and λ.

Parameter ``plant``:
    The plant on which the constraint is imposed.

Parameter ``context``:
    The context for the subsystem ``plant``.

Parameter ``contact_wrench_evaluators_and_lambda``:
    For each contact pair, we need to compute the contact wrench
    applied at the point of contact, expressed in the world frame,
    namely Fᵢ_AB_W(λᵢ). ``contact_wrench_evaluators_and_lambda.first``
    is the evaluator for computing this contact wrench from the
    variables λᵢ. ``contact_wrench_evaluators_and_lambda.second`` are
    the decision variable λᵢ used in computing the contact wrench.
    Notice the generalized position ``q`` is not included in variables
    contact_wrench_evaluators_and_lambda.second.

Parameter ``q_vars``:
    The decision variables for q (the generalized position).

Parameter ``u_vars``:
    The decision variables for u (the input).

Returns:
    binding The binding between the static equilibrium constraint and
    the variables q, u and λ.

Precondition:
    ``plant`` must have been connected to a SceneGraph properly. You
    could refer to AddMultibodyPlantSceneGraph on how to connect a
    MultibodyPlant to a SceneGraph.)""";
        } MakeBinding;
        // Symbol: drake::multibody::StaticEquilibriumConstraint::StaticEquilibriumConstraint
        struct /* ctor */ {
          // Source: drake/multibody/optimization/static_equilibrium_constraint.h:22
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::multibody::StaticEquilibriumConstraint::contact_pair_to_wrench_evaluator
        struct /* contact_pair_to_wrench_evaluator */ {
          // Source: drake/multibody/optimization/static_equilibrium_constraint.h:62
          const char* doc =
R"""(Getter for contact_pair_to_wrench_evaluator, passed in the
constructor.)""";
        } contact_pair_to_wrench_evaluator;
      } StaticEquilibriumConstraint;
      // Symbol: drake::multibody::StaticEquilibriumProblem
      struct /* StaticEquilibriumProblem */ {
        // Source: drake/multibody/optimization/static_equilibrium_problem.h:31
        const char* doc =
R"""(Finds the static equilibrium pose of a multibody system through
optimization. The constraints are 1. 0 = g(q) + Bu + ∑ᵢ JᵢᵀFᵢ_AB_W(λᵢ)
(generalized force equals to 0). 2. Fᵢ_AB_W(λᵢ) is within the
admissible contact wrench (for example, contact force is in the
friction cone). 3. sdf(q) >= 0 (signed distance function is no smaller
than 0, hence no penetration). 4. complementarity condition between
the contact force and the signed distance. 5. q within the joint
limit. TODO(hongkai.dai): add the bounds on the input u, and other
position constraint (such as unit length constraint on quaternion).)""";
        // Symbol: drake::multibody::StaticEquilibriumProblem::GetContactWrenchSolution
        struct /* GetContactWrenchSolution */ {
          // Source: drake/multibody/optimization/static_equilibrium_problem.h:69
          const char* doc =
R"""(Retrieve the solution to all contact wrenches.

Parameter ``result``:
    The result of solving prog().)""";
        } GetContactWrenchSolution;
        // Symbol: drake::multibody::StaticEquilibriumProblem::StaticEquilibriumProblem
        struct /* ctor */ {
          // Source: drake/multibody/optimization/static_equilibrium_problem.h:46
          const char* doc =
R"""(Parameter ``plant``:
    The plant for which the static equilibrium posture is computed.
    ``plant`` should remain alive as long as this
    StaticEquilibriumProblem exists.

Parameter ``context``:
    The context for ``plant``. ``context`` should remain alive as long
    as this StaticEquilibriumProblem exists.

Parameter ``ignored_collision_pairs``:
    The contact between the pair of geometry in
    ``ignored_collision_pairs`` will be ignored. We will not impose
    non-penetration constraint between these pairs, and no contact
    wrench will be applied between these pairs.)""";
        } ctor;
        // Symbol: drake::multibody::StaticEquilibriumProblem::UpdateComplementarityTolerance
        struct /* UpdateComplementarityTolerance */ {
          // Source: drake/multibody/optimization/static_equilibrium_problem.h:77
          const char* doc =
R"""(Updates the tolerance on all the complementarity constraints α * β =
0. The complementarity constraint is relaxed as 0 ≤ α * β ≤ tol. See
AddStaticFrictionConeComplementarityConstraint() for more details.)""";
        } UpdateComplementarityTolerance;
        // Symbol: drake::multibody::StaticEquilibriumProblem::get_mutable_prog
        struct /* get_mutable_prog */ {
          // Source: drake/multibody/optimization/static_equilibrium_problem.h:54
          const char* doc = R"""()""";
        } get_mutable_prog;
        // Symbol: drake::multibody::StaticEquilibriumProblem::prog
        struct /* prog */ {
          // Source: drake/multibody/optimization/static_equilibrium_problem.h:57
          const char* doc =
R"""(Getter for the immutable optimization program.)""";
        } prog;
        // Symbol: drake::multibody::StaticEquilibriumProblem::q_vars
        struct /* q_vars */ {
          // Source: drake/multibody/optimization/static_equilibrium_problem.h:60
          const char* doc =
R"""(Getter for q, the decision variable for the generalized position.)""";
        } q_vars;
        // Symbol: drake::multibody::StaticEquilibriumProblem::u_vars
        struct /* u_vars */ {
          // Source: drake/multibody/optimization/static_equilibrium_problem.h:63
          const char* doc =
R"""(Getter for u, the decision variable for the input.)""";
        } u_vars;
      } StaticEquilibriumProblem;
      // Symbol: drake::multibody::StaticFrictionConeConstraint
      struct /* StaticFrictionConeConstraint */ {
        // Source: drake/multibody/optimization/static_friction_cone_constraint.h:27
        const char* doc =
R"""(Formulates the nonlinear friction cone constraint |fₜ| ≤ μ*fₙ, where
fₜ is the tangential contact force, fₙ is the normal contact force,
and μ is the friction coefficient.

The mathematical formulation of this constraint is

0 ≤ μ*fᵀn fᵀ((1+μ²)nnᵀ - I)f ≥ 0 where n is the unit length normal
vector. This formulation is equivalent to |fₜ| ≤ μ*fₙ, but the
constraint is differentiable everywhere (while |fₜ| ≤ μ*fₙ is not
differentiable at fₜ = 0.)

The bound variables for this constraint is x = [q;λ], where q is the
generalized position, and λ is the parameterization of the contact
wrench.)""";
        // Symbol: drake::multibody::StaticFrictionConeConstraint::DecomposeX
        struct /* DecomposeX */ {
          // Source: drake/multibody/optimization/static_friction_cone_constraint.h:53
          const char* doc =
R"""(Given the bound variable ``x``, decompose it into the generalized
position q, and λ as a parameterization of the contact wrench. x = [q;
λ].)""";
        } DecomposeX;
        // Symbol: drake::multibody::StaticFrictionConeConstraint::StaticFrictionConeConstraint
        struct /* ctor */ {
          // Source: drake/multibody/optimization/static_friction_cone_constraint.h:43
          const char* doc =
R"""(Parameter ``contact_wrench_evaluator``:
    . The evaluator takes in the generalized position q, and a
    parameterization of the contact wrench λ, and evaluates the
    contact wrench from body A to body B applied at the witness point
    of geometry B expressed in the world frame, i.e., computes the
    contact wrench F_Cb_W at the witness point p_WCb_W (see
    SignedDistancePair for the definition of witness point), and
    F_Ca_W = -F_Cb_W (assuming Ca and Cb are at the same spatial
    location).

Note:
    although contact_wrench_evaluator computes both the contact force
    and torque in the wrench, we only constrain the contact force to
    be within the friction cone, and leave the torque unconstrained.)""";
        } ctor;
      } StaticFrictionConeConstraint;
      // Symbol: drake::multibody::TamsiSolver
      struct /* TamsiSolver */ {
        // Source: drake/multibody/plant/tamsi_solver.h:506
        const char* doc =
R"""(TamsiSolver uses the Transition-Aware Modified Semi-Implicit (TAMSI)
method, castro_etal_2019 "[Castro et al., 2019]", to solve the
equations below for mechanical systems in contact with regularized
friction:


::

    q̇ = N(q) v
    (1)  M(q) v̇ = τ + Jₙᵀ(q) fₙ(q, v) + Jₜᵀ(q) fₜ(q, v)

where ``v ∈ ℝⁿᵛ`` is the vector of generalized velocities, ``M(q) ∈
ℝⁿᵛˣⁿᵛ`` is the mass matrix, ``Jₙ(q) ∈ ℝⁿᶜˣⁿᵛ`` is the Jacobian of
normal separation velocities, ``Jₜ(q) ∈ ℝ²ⁿᶜˣⁿᵛ`` is the Jacobian of
tangent velocities, ``fₙ ∈ ℝⁿᶜ`` is the vector of normal contact
forces, ``fₜ ∈ ℝ²ⁿᶜ`` is the vector of tangent friction forces and τ ∈
ℝⁿᵛ is a vector of generalized forces containing all other applied
forces (e.g., Coriolis, gyroscopic terms, actuator forces, etc.) but
contact forces. This solver assumes a compliant law for the normal
forces ``fₙ(q, v)`` and therefore the functional dependence of ``fₙ(q,
v)`` with q and v is stated explicitly.

Since TamsiSolver uses regularized friction, we explicitly emphasize
the functional dependence of ``fₜ(q, v)`` with the generalized
velocities. The functional dependence of ``fₜ(q, v)`` with the
generalized positions stems from its direct dependence with the normal
forces ``fₙ(q, v)``.

TamsiSolver implements two different schemes. A "one-way coupling
scheme" which solves for the friction forces given the normal forces
are known. That is, normal forces affect the computation of the
friction forces however, the normal forces are kept constant during
the solution procedure.

A "two-way coupling scheme" treats both the normal and friction forces
implicitly in the generalized velocities resulting in a numerical
strategy in which normal forces affect friction forces and,
conversely, friction forces couple back to the computation of the
normal forces.

The two-way coupled scheme provides a more stable and therefore robust
solution to the problem stated in Eq. (1) with just a small increase
of the computational cost compared to the one-way coupled scheme. The
one-way coupled scheme is however very useful for testing and analysis
of the solver.

One-Way Coupling Scheme
-----------------------

Equation (1) is discretized in time using a variation of the first
order semi-implicit Euler scheme from step s to step s+1 with time
step ``δt`` as:


::

    qˢ⁺¹ = qˢ + δt N(qˢ) vˢ⁺¹
    (2)  M(qˢ) vˢ⁺¹ =
    M(qˢ) vˢ + δt [τˢ + Jₙᵀ(qˢ) fₙ(qˢ,vˢ) + Jₜᵀ(qˢ) fₜ(qˢ,vˢ⁺¹)]

(We are using s for step counter rather than n to avoid
Unicode-induced confusion with the "normal direction" subscript n.)

Please see details in the one_way_coupling_derivation "Derivation of
the one-way coupling scheme" section. The equation for the generalized
velocities in Eq. (2) is rewritten as:


::

    (3)  M vˢ⁺¹ = p* + δt [Jₙᵀ fₙ + Jₜᵀ fₜ(vˢ⁺¹)]

where ``p* = M vˢ + δt τˢ`` is the generalized momentum that the
system would have in the absence of contact forces and, for
simplicity, we have only kept the functional dependencies in
generalized velocities. Notice that TamsiSolver uses a precomputed
value of the normal forces. These normal forces could be available for
instance if using a compliant contact approach, for which normal
forces are a function of the state.

Two-Way Coupling Scheme
-----------------------

Equation (1) is discretized in time using a variation on the
semi-implicit Euler scheme with time step ``δt`` as:


::

    qˢ⁺¹ = qˢ + δt N(qˢ) vˢ⁺¹
    (4)  M(qˢ) vˢ⁺¹ = M(qˢ) vˢ +
    δt [τˢ + Jₙᵀ(qˢ) fₙˢ⁺¹ + Jₜᵀ(qˢ) fₜ(fₙˢ⁺¹,vₜˢ⁺¹)]

This implicit scheme variation evaluates Jacobian matrices Jₙ and Jₜ
as well as the kinematic mapping N(q) at the previous time step. In
Eq. (4) we have fₙˢ⁺¹ = fₙ(xˢ⁺¹, vₙˢ⁺¹) with xˢ⁺¹ = x(qˢ⁺¹), the
signed *penetration* distance (defined positive when bodies overlap)
between contact point pairs and the *separation* velocities vₙˢ⁺¹ =
Jₙ(qˢ) vˢ⁺¹ (= −ẋˢ⁺¹). Also the functional dependence of fₜ with fₙ
and vₜ is highlighted in Eq. (4). More precisely, the two-way coupling
scheme uses a normal force law for each contact pair of the form:


::

    (5)  fₙ(x, vₙ) = k(vₙ)₊ x₊
    (6)      k(vₙ) = k (1 − d vₙ)₊

where ``x₊`` is the positive part of x (x₊ = x if x ≥ 0 and x₊ = 0
otherwise) and ``k`` and d are the stiffness and dissipation
coefficients for a given contact point, respectively.

The two-way coupling scheme uses a first order approximation to the
signed distance functions vector:


::

    (7)  xˢ⁺¹ ≈ xˢ − δt vₙˢ⁺¹ =  xˢ − δt Jₙ(qˢ) vˢ⁺¹

where the minus sign is needed given that ẋ = dx/dt = −vₙ. This
approximation is used in Eq. (5) to obtain a numerical scheme that
implicitly couples normal forces through their functional dependence
on the signed penetration distance. Notice that, according to Eq. (5),
normal forces at each contact point are decoupled from each other.
However their values are coupled given the choice of a common
variable, the generalized velocity v.

Equation (7) is used into Eq. (5) to obtain an expression of the
normal force in terms of the generalized velocity vˢ⁺¹ at the next
time step:


::

    (8) fₙ(xˢ⁺¹, vₙˢ⁺¹) = k (1 − d vₙˢ⁺¹)₊ xˢ⁺¹₊
    = k (1 − d Jₙ(qˢ) vˢ⁺¹)₊ (xˢ − δt Jₙ(qˢ) vˢ⁺¹)₊
    = fₙ(vˢ⁺¹)

Similarly, the friction forces fₜ can be written in terms of the next
time step generalized velocities using vₜˢ⁺¹ = Jₜ(qˢ) vˢ⁺¹ and using
Eq. (8) to substitute an expression for the normal force in terms of
vˢ⁺¹. This allows to re-write the tangential forces as a function of
the generalized velocities as:


::

    (9)  fₜ(fₙˢ⁺¹, vₜˢ⁺¹) = fₜ(fₙ(x(vˢ⁺¹), vₙ(vˢ⁺¹)), vₜ((vˢ⁺¹)))
    = fₜ(vˢ⁺¹)

where we write x(vˢ⁺¹) = xˢ − δt Jₙ(qˢ) vˢ⁺¹. Finally, Eqs. (8) and
(9) are used into Eq. (4) to obtain an expression in vˢ⁺¹:


::

    (10)  M(qˢ) vˢ⁺¹ = p* + δt [Jₙᵀ(qˢ) fₙ(vˢ⁺¹) + Jₜᵀ(qˢ) fₜ(vˢ⁺¹)]

with p* = ``p* = M vˢ + δt τˢ`` the generalized momentum that the
system would have in the absence of contact forces.

TamsiSolver uses a Newton-Raphson strategy to solve Eq. (10) in the
generalized velocities, limiting the iteration update with the scheme
described in iteration_limiter.

Limits in the Iteration Updates
-------------------------------

TamsiSolver solves for the generalized velocity at the next time step
``vˢ⁺¹`` with either a one-way or two-way coupled scheme as described
in the previous sections. The solver uses a Newton-Raphson iteration
to compute an update ``Δvᵏ`` at the k-th Newton-Raphson iteration.
Once ``Δvᵏ`` is computed, the solver limits the change in the
tangential velocities ``Δvₜᵏ = Jₜᵀ Δvᵏ`` using the approach described
in uchida_etal_2015 "[Uchida et al., 2015]". This approach limits the
maximum angle change θ between two successive iterations in the
tangential velocity. Details of our implementation are provided in
castro_etal_2019 "[Castro et al., 2019]".

Derivation of the one-way coupling scheme
-----------------------------------------

In this section we provide a detailed derivation of the first order
time stepping approach in Eq. (2). We start from the continuous Eq.
(1):


::

    (1)  M(q) v̇ = τ + Jₙᵀ(q) fₙ(q,v) + Jₜᵀ(q) fₜ(q,v)

we can discretize Eq. (1) in time using a first order semi-implicit
Euler scheme in velocities:


::

    (11)  M(qˢ) vˢ⁺¹ = M(qˢ) vˢ +
    δt [τˢ⁺¹ + Jₙᵀ(qˢ) fₙ(qˢ,vˢ⁺¹) + Jₜᵀ(qˢ) fₜ(vˢ⁺¹)] + O₁(δt²)

where the equality holds strictly since we included the leading terms
in ``O(δt²)``. We use ``τˢ⁺¹ = τ(tˢ, qˢ, vˢ⁺¹)`` for brevity in Eq.
(11). When moving from the continuous Eq. (1) to the discrete version
Eq. (11), we lost the nice property that our compliant normal forces
are decoupled from the friction forces (both depend on the same
unknown vˢ⁺¹ in Eq (11)). The reason is that Eq. (11) includes an
integration over a small interval of size δt. To solve the discrete
system in Eq. (11), we'd like to decouple the normal forces from the
tangential forces again, which will require a new (though still valid)
approximation. To do so we will expand in Taylor series the term
``fₙ(qˢ, vˢ⁺¹)``:


::

    (12)  fₙ(qˢ, vˢ⁺¹) = fₙ(qˢ,vˢ) + ∇ᵥfₙ(qˢ,vˢ) (vˢ⁺¹ − vˢ) + O₂(‖vˢ⁺¹ − vˢ‖²)

The difference between ``vˢ`` and ``vˢ⁺¹`` can be written as:


::

    (13)  vˢ⁺¹ − vˢ = δtv̇ˢ + δtO₃(δt²) = O₄(δt)

Substituting ``vˢ⁺¹ − vˢ`` from Eq. (13) into Eq. (12) we arrive to:


::

    (14)  fₙ(qˢ, vˢ⁺¹) = fₙ(qˢ,vˢ) + ∇ᵥfₙ(qˢ,vˢ) O₄(δt) + O₅(δt²)
    = fₙ(qˢ,vˢ) + O₆(δt)

where ``O₅(δt²) = O₂(‖vˢ⁺¹ − vˢ‖²) = O₂(‖O₄(δt)‖²)``. A similar
argument for τˢ⁺¹ shows it also differs in O(δt) from τˢ = τ(tˢ, qˢ,
vˢ). We can now use Eq. (14) into Eq. (11) to arrive to:


::

    (15)  M(qˢ) vˢ⁺¹ = M(qˢ) vˢ +
    δt [τˢ + Jₙᵀ(qˢ) (fₙ(qˢ,vˢ) + O₆(δt)] + Jₜᵀ(qˢ) fₜ(vˢ⁺¹)) +
    O₁(δt²)

which we can rewrite as:


::

    (16)  M(qˢ) vˢ⁺¹ = M(qˢ) vˢ +
    δt [τˢ + Jₙᵀ(qˢ) fₙ(qˢ, vˢ) + Jₜᵀ(qˢ) fₜ(vˢ⁺¹)] + O₇(δt²)

with ``O₇(δt²) = δt Jₙᵀ(qˢ) O₆(δt) + O₁(δt²)``. That is, Eq. (16)
introduces the same order of approximation as in the semi-implicit
method in Eq. (11). Up to this point we have made no approximations
but we instead propagated the ``O(⋅)`` leading terms. Therefore the
equalities in the equations above are exact. To obtain an approximate
time stepping scheme, we drop ``O₇(δt²)`` (we neglect it) in Eq. (16)
to arrive to a first order scheme:


::

    (17)  M(qˢ) vˢ⁺¹ = M(qˢ) vˢ +
    δt [τˢ + Jₙᵀ(qˢ) fₙ(qˢ,vˢ) + Jₜᵀ(qˢ) fₜ(vˢ⁺¹)]

Therefore, with the scheme in Eq. (17) we are able to decouple the
computation of (compliant) normal forces from that of friction forces.
A very important feature of this scheme however, is the explicit
nature (in the velocities v) of the term associated with the normal
forces (usually including dissipation in the normal direction), which
will become unstable for a sufficiently large time step. However, for
most applications in practice, the stability of the scheme is mostly
determined by the explicit update of normal forces with positions,
that is, Eq. (17) is explicit in positions through the normal forces
``fₙ(qˢ, vˢ)``. For many common applications, the explicit dependence
of ``τˢ(tˢ, qˢ, vˢ)`` on the previous time step velocities ``vˢ``
determines the overall stability of the scheme, since this term can
include velocity dependent contributions such as control forces and
dampers. Notice that Eq. (12) introduces an expansion of ``fₙ`` with
an order of approximation consistent with the first order scheme as
needed. Therefore, it propagates into a ``O(δt²)`` term exactly as
needed in Eq. (16).

References
----------

- [Castro et al., 2019] Castro, A.M, Qu, A.,
Kuppuswamy, N., Alspach, A., Sherman, M.A., 2019. A Transition-Aware Method
for the Simulation of Compliant Contact with Regularized Friction.
arXiv:1909.05700 [cs.RO].
- Uchida, T.K., Sherman, M.A. and Delp, S.L., 2015.
Making a meaningful impact: modelling simultaneous frictional collisions
in spatial multibody systems. Proc. R. Soc. A, 471(2177), p.20140859.

Authors:
    Alejandro Castro (2018) Original author.

Authors:
    Michael Sherman, Evan Drumwright (2018) Original PR #8925
    reviewers.

Authors:
    Drake team (see https://drake.mit.edu/credits).)""";
        // Symbol: drake::multibody::TamsiSolver::SetOneWayCoupledProblemData
        struct /* SetOneWayCoupledProblemData */ {
          // Source: drake/multibody/plant/tamsi_solver.h:553
          const char* doc =
R"""(Sets data for the problem to be solved as outlined by Eq. (3) in this
class's documentation:


::

    (3)  M v = p* + δt Jₙᵀ fₙ +  δt Jₜᵀ fₜ(v)

Refer to this class's documentation for further details on the
structure of the problem and the solution strategy. In the documented
parameters below, ``nv`` is the number of generalized velocities and
``nc`` is the number of contact points.

Parameter ``M``:
    The mass matrix of the system, of size ``nv x nv``.

Parameter ``Jn``:
    The normal separation velocities Jacobian, of size ``nc x nv``.

Parameter ``Jt``:
    The tangential velocities Jacobian, of size ``2nc x nv``.

Parameter ``p_star``:
    The generalized momentum the system would have at ``s + 1`` if
    contact forces were zero.

Parameter ``fn``:
    A vector of size ``nc`` containing the normal force at each
    contact point.

Parameter ``mu``:
    A vector of size ``nc`` containing the friction coefficient at
    each contact point. The solver makes no distinction between static
    and dynamic coefficients of friction or, similarly, the solver
    assumes the static and dynamic coefficients of friction are the
    same.

Warning:
    This method stores constant references to the matrices and vectors
    passed as arguments. Therefore 1. they must outlive this class
    and, 2. changes to the problem data invalidate any solution
    performed by this solver. In such a case,
    SetOneWayCoupledProblemData() and SolveWithGuess() must be invoked
    again.

Raises:
    RuntimeError if any of the data pointers are nullptr.

Raises:
    RuntimeError if the problem data sizes are not consistent as
    described above.

Raises:
    RuntimeError if SetTwoWayCoupledProblemData() was ever called on
    ``this`` solver.)""";
        } SetOneWayCoupledProblemData;
        // Symbol: drake::multibody::TamsiSolver::SetTwoWayCoupledProblemData
        struct /* SetTwoWayCoupledProblemData */ {
          // Source: drake/multibody/plant/tamsi_solver.h:606
          const char* doc =
R"""(Sets the problem data to solve the problem outlined in Eq. (10) in
this class's documentation using a two-way coupled approach:


::

    (10)  M(qˢ) vˢ⁺¹ = p* + δt [Jₙᵀ(qˢ) fₙ(vˢ⁺¹) + Jₜᵀ(qˢ) fₜ(vˢ⁺¹)]

Refer to this class's documentation for further details on the
structure of the problem and the solution strategy. In the documented
parameters below, ``nv`` is the number of generalized velocities and
``nc`` is the number of contact points.

Parameter ``M``:
    The mass matrix of the system, of size ``nv x nv``.

Parameter ``Jn``:
    The normal separation velocities Jacobian, of size ``nc x nv``.

Parameter ``Jt``:
    The tangential velocities Jacobian, of size ``2nc x nv``.

Parameter ``p_star``:
    The generalized momentum the system would have at ``n + 1`` if
    contact forces were zero.

Parameter ``fn0``:
    Normal force at the previous time step. Always positive since
    bodies cannot attract each other.

Parameter ``stiffness``:
    A vector of size ``nc`` storing at each ith entry the stiffness
    coefficient for the ith contact pair.

Parameter ``dissipation``:
    A vector of size ``nc`` storing at each ith entry the dissipation
    coefficient for the ith contact pair.

Parameter ``mu``:
    A vector of size ``nc`` containing the friction coefficient at
    each contact point. The solver makes no distinction between static
    and dynamic coefficients of friction or, similarly, the solver
    assumes the static and dynamic coefficients of friction are the
    same.

Warning:
    This method stores constant references to the matrices and vectors
    passed as arguments. Therefore 1. they must outlive this class
    and, 2. changes to the problem data invalidate any solution
    performed by this solver. In such a case,
    SetOneWayCoupledProblemData() and SolveWithGuess() must be invoked
    again.

Raises:
    RuntimeError if any of the data pointers are nullptr.

Raises:
    RuntimeError if the problem data sizes are not consistent as
    described above.

Raises:
    RuntimeError if SetOneWayCoupledProblemData() was ever called on
    ``this`` solver.)""";
        } SetTwoWayCoupledProblemData;
        // Symbol: drake::multibody::TamsiSolver::SolveWithGuess
        struct /* SolveWithGuess */ {
          // Source: drake/multibody/plant/tamsi_solver.h:629
          const char* doc =
R"""(Given an initial guess ``v_guess``, this method uses a Newton-Raphson
iteration to find a solution for the generalized velocities satisfying
either Eq. (3) when one-way coupling is used or Eq. (10) when two-way
coupling is used. See this class's documentation for further details.
To retrieve the solution, please refer to retrieving_the_solution.

Returns:
    kSuccess if the iteration converges. All other values of
    TamsiSolverResult report different failure modes. Uses ``this``
    solver accessors to retrieve the last computed solution.

Warning:
    Always verify that the return value indicates success before
    retrieving the computed solution.

Parameter ``dt``:
    The time step used advance the solution in time.

Parameter ``v_guess``:
    The initial guess used in by the Newton-Raphson iteration.
    Typically, the previous time step velocities.

Raises:
    RuntimeError if ``v_guess`` is not of size ``nv``, the number of
    generalized velocities specified at construction.)""";
        } SolveWithGuess;
        // Symbol: drake::multibody::TamsiSolver::TamsiSolver<T>
        struct /* ctor */ {
          // Source: drake/multibody/plant/tamsi_solver.h:512
          const char* doc =
R"""(Instantiates a solver for a problem with ``nv`` generalized
velocities.

Raises:
    RuntimeError if nv is non-positive.)""";
        } ctor;
        // Symbol: drake::multibody::TamsiSolver::get_friction_forces
        struct /* get_friction_forces */ {
          // Source: drake/multibody/plant/tamsi_solver.h:682
          const char* doc =
R"""(Returns a constant reference to the most recent vector of friction
forces. These friction forces are defined in accordance to the
tangential velocities Jacobian Jₜ as documented in tamsi_class_intro
"this class's documentation".)""";
        } get_friction_forces;
        // Symbol: drake::multibody::TamsiSolver::get_generalized_contact_forces
        struct /* get_generalized_contact_forces */ {
          // Source: drake/multibody/plant/tamsi_solver.h:653
          const char* doc =
R"""(Returns a constant reference to the most recent vector of generalized
contact forces, including both friction and normal forces.)""";
        } get_generalized_contact_forces;
        // Symbol: drake::multibody::TamsiSolver::get_generalized_friction_forces
        struct /* get_generalized_friction_forces */ {
          // Source: drake/multibody/plant/tamsi_solver.h:640
          const char* doc =
R"""(Returns a constant reference to the most recent vector of generalized
friction forces.)""";
        } get_generalized_friction_forces;
        // Symbol: drake::multibody::TamsiSolver::get_generalized_velocities
        struct /* get_generalized_velocities */ {
          // Source: drake/multibody/plant/tamsi_solver.h:666
          const char* doc =
R"""(Returns a constant reference to the most recent vector of generalized
velocities.)""";
        } get_generalized_velocities;
        // Symbol: drake::multibody::TamsiSolver::get_iteration_statistics
        struct /* get_iteration_statistics */ {
          // Source: drake/multibody/plant/tamsi_solver.h:690
          const char* doc =
R"""(Returns statistics recorded during the last call to SolveWithGuess().
See IterationStats for details.)""";
        } get_iteration_statistics;
        // Symbol: drake::multibody::TamsiSolver::get_normal_forces
        struct /* get_normal_forces */ {
          // Source: drake/multibody/plant/tamsi_solver.h:674
          const char* doc =
R"""(Returns a constant reference to the most recent vector of (repulsive)
forces in the normal direction. That is, the normal force is positive
when the bodies push each other apart. Otherwise the normal force is
zero, since contact forces can only be repulsive.)""";
        } get_normal_forces;
        // Symbol: drake::multibody::TamsiSolver::get_normal_velocities
        struct /* get_normal_velocities */ {
          // Source: drake/multibody/plant/tamsi_solver.h:647
          const char* doc =
R"""(Returns a constant reference to the most recent solution vector for
normal separation velocities. This method returns an
``Eigen::VectorBlock`` referencing a vector of size ``nc``.)""";
        } get_normal_velocities;
        // Symbol: drake::multibody::TamsiSolver::get_solver_parameters
        struct /* get_solver_parameters */ {
          // Source: drake/multibody/plant/tamsi_solver.h:696
          const char* doc =
R"""(Returns the current set of parameters controlling the iteration
process. See Parameters for details.)""";
        } get_solver_parameters;
        // Symbol: drake::multibody::TamsiSolver::get_tangential_velocities
        struct /* get_tangential_velocities */ {
          // Source: drake/multibody/plant/tamsi_solver.h:660
          const char* doc =
R"""(Returns a constant reference to the most recent vector of tangential
forces. This method returns an ``Eigen::VectorBlock`` referencing a
vector of size ``nc``.)""";
        } get_tangential_velocities;
        // Symbol: drake::multibody::TamsiSolver::set_solver_parameters
        struct /* set_solver_parameters */ {
          // Source: drake/multibody/plant/tamsi_solver.h:702
          const char* doc =
R"""(Sets the parameters to be used by the solver. See Parameters for
details.)""";
        } set_solver_parameters;
      } TamsiSolver;
      // Symbol: drake::multibody::TamsiSolverIterationStats
      struct /* TamsiSolverIterationStats */ {
        // Source: drake/multibody/plant/tamsi_solver.h:230
        const char* doc =
R"""(Struct used to store information about the iteration process performed
by TamsiSolver.)""";
        // Symbol: drake::multibody::TamsiSolverIterationStats::Reset
        struct /* Reset */ {
          // Source: drake/multibody/plant/tamsi_solver.h:232
          const char* doc =
R"""((Internal) Used by TamsiSolver to reset statistics.)""";
        } Reset;
        // Symbol: drake::multibody::TamsiSolverIterationStats::Update
        struct /* Update */ {
          // Source: drake/multibody/plant/tamsi_solver.h:240
          const char* doc =
R"""((Internal) Used by TamsiSolver to update statistics.)""";
        } Update;
        // Symbol: drake::multibody::TamsiSolverIterationStats::num_iterations
        struct /* num_iterations */ {
          // Source: drake/multibody/plant/tamsi_solver.h:247
          const char* doc =
R"""(The number of iterations performed by the last TamsiSolver solve.)""";
        } num_iterations;
        // Symbol: drake::multibody::TamsiSolverIterationStats::residuals
        struct /* residuals */ {
          // Source: drake/multibody/plant/tamsi_solver.h:261
          const char* doc =
R"""((Advanced) Residual in the tangential velocities, in m/s. The k-th
entry in this vector corresponds to the residual for the k-th
Newton-Raphson iteration performed by the solver. After TamsiSolver
solved a problem, this vector will have size num_iterations. The last
entry in this vector, ``residuals[num_iterations-1]``, corresponds to
the residual upon completion of the solver, i.e. vt_residual.)""";
        } residuals;
        // Symbol: drake::multibody::TamsiSolverIterationStats::vt_residual
        struct /* vt_residual */ {
          // Source: drake/multibody/plant/tamsi_solver.h:252
          const char* doc =
R"""(Returns the residual in the tangential velocities, in m/s. Upon
convergence of the solver this value should be smaller than
Parameters::tolerance times Parameters::stiction_tolerance.)""";
        } vt_residual;
      } TamsiSolverIterationStats;
      // Symbol: drake::multibody::TamsiSolverParameters
      struct /* TamsiSolverParameters */ {
        // Source: drake/multibody/plant/tamsi_solver.h:181
        const char* doc =
R"""(These are the parameters controlling the iteration process of the
TamsiSolver solver.)""";
        // Symbol: drake::multibody::TamsiSolverParameters::max_iterations
        struct /* max_iterations */ {
          // Source: drake/multibody/plant/tamsi_solver.h:195
          const char* doc =
R"""(The maximum number of iterations allowed for the Newton-Raphson
iterative solver.)""";
        } max_iterations;
        // Symbol: drake::multibody::TamsiSolverParameters::relative_tolerance
        struct /* relative_tolerance */ {
          // Source: drake/multibody/plant/tamsi_solver.h:209
          const char* doc =
R"""(The tolerance to monitor the convergence of the tangential velocities.
This number specifies a tolerance relative to the value of the
stiction_tolerance and thus it is dimensionless. Using a tolerance
relative to the value of the stiction_tolerance is necessary in order
to capture transitions to stiction that would require an accuracy in
the value of the tangential velocities smaller than that of the
"stiction region" (the circle around the origin with radius
stiction_tolerance). A value close to one could cause the solver to
miss transitions from/to stiction. Small values approaching zero will
result in a higher number of iterations needed to attain the desired
level of convergence. Typical values lie within the 10⁻³ - 10⁻² range.)""";
        } relative_tolerance;
        // Symbol: drake::multibody::TamsiSolverParameters::stiction_tolerance
        struct /* stiction_tolerance */ {
          // Source: drake/multibody/plant/tamsi_solver.h:191
          const char* doc =
R"""(The stiction tolerance vₛ for the slip velocity in the regularized
friction function, in m/s. Roughly, for an externally applied
tangential forcing fₜ and normal force fₙ, under "stiction", the slip
velocity will be approximately vₜ ≈ vₛ fₜ/(μfₙ). In other words, the
maximum slip error of the regularized friction approximation occurs at
the edge of the friction cone when fₜ = μfₙ and vₜ = vₛ. The default
of 0.1 mm/s is a very tight value that for most problems of interest
in robotics will result in simulation results with negligible slip
velocities introduced by regularizing friction when in stiction.)""";
        } stiction_tolerance;
        // Symbol: drake::multibody::TamsiSolverParameters::theta_max
        struct /* theta_max */ {
          // Source: drake/multibody/plant/tamsi_solver.h:225
          const char* doc =
R"""((Advanced) TamsiSolver limits large angular changes between tangential
velocities at two successive iterations vₜᵏ⁺¹ and vₜᵏ. This change is
measured by the angle θ = acos(vₜᵏ⁺¹⋅vₜᵏ/(‖vₜᵏ⁺¹‖‖vₜᵏ‖)). To aid
convergence, TamsiSolver, limits this angular change to ``theta_max``.
Please refer to the documentation for TamsiSolver for further details.

Small values of ``theta_max`` will result in a larger number of
iterations of the solver for situations in which large angular changes
occur (sudden transients or impacts). Values of ``theta_max`` close to
π/2 allow for a faster convergence for problems with sudden
transitions to/from stiction. Large values of ``theta_max`` however
might lead to non-convergence of the solver. We choose a conservative
number by default that we found to work well in most practical
problems of interest.)""";
        } theta_max;
      } TamsiSolverParameters;
      // Symbol: drake::multibody::TamsiSolverResult
      struct /* TamsiSolverResult */ {
        // Source: drake/multibody/plant/tamsi_solver.h:166
        const char* doc =
R"""(The result from TamsiSolver::SolveWithGuess() used to report the
success or failure of the solver.)""";
        // Symbol: drake::multibody::TamsiSolverResult::kLinearSolverFailed
        struct /* kLinearSolverFailed */ {
          // Source: drake/multibody/plant/tamsi_solver.h:176
          const char* doc =
R"""(The linear solver used within the Newton-Raphson loop failed. This
might be caused by a divergent iteration that led to an invalid
Jacobian matrix.)""";
        } kLinearSolverFailed;
        // Symbol: drake::multibody::TamsiSolverResult::kMaxIterationsReached
        struct /* kMaxIterationsReached */ {
          // Source: drake/multibody/plant/tamsi_solver.h:171
          const char* doc =
R"""(The maximum number of iterations was reached.)""";
        } kMaxIterationsReached;
        // Symbol: drake::multibody::TamsiSolverResult::kSuccess
        struct /* kSuccess */ {
          // Source: drake/multibody/plant/tamsi_solver.h:168
          const char* doc = R"""(Successful computation.)""";
        } kSuccess;
      } TamsiSolverResult;
      // Symbol: drake::multibody::TriangleQuadrature
      struct /* TriangleQuadrature */ {
        // Source: drake/multibody/triangle_quadrature/triangle_quadrature.h:25
        const char* doc =
R"""(A class for integrating a function using numerical quadrature over
triangular domains.

Template parameter ``NumericReturnType``:
    the output type of the function being integrated. Commonly will be
    a IEEE floating point scalar (e.g., ``double``), but could be an
    Eigen::VectorXd, a multibody::SpatialForce, or any other numeric
    type that supports both scalar multiplication (i.e.,
    operator*(const NumericReturnType&, double) and addition with
    another of the same type (i.e., operator+(const
    NumericReturnType&, const NumericReturnType&)).

Template parameter ``T``:
    the scalar type of the function being integrated over. Supported
    types are currently only IEEE floating point scalars.)""";
        // Symbol: drake::multibody::TriangleQuadrature::Integrate
        struct /* Integrate */ {
          // Source: drake/multibody/triangle_quadrature/triangle_quadrature.h:34
          const char* doc_was_unable_to_choose_unambiguous_names =
R"""(Numerically integrates the function f over a triangle using the given
quadrature rule and the initial value.

Parameter ``f(p)``:
    a function that returns a numerical value for point p in the
    domain of the triangle, specified in barycentric coordinates. The
    barycentric coordinates are given by (p[0], p[1], 1 - p[0] -
    p[1]).

Parameter ``area``:
    the area of the triangle.)""";
        } Integrate;
      } TriangleQuadrature;
      // Symbol: drake::multibody::TriangleQuadratureRule
      struct /* TriangleQuadratureRule */ {
        // Source: drake/multibody/triangle_quadrature/triangle_quadrature_rule.h:12
        const char* doc =
R"""(A "rule" (weights and quadrature points) for computing quadrature over
triangular domains.)""";
        // Symbol: drake::multibody::TriangleQuadratureRule::TriangleQuadratureRule
        struct /* ctor */ {
          // Source: drake/multibody/triangle_quadrature/triangle_quadrature_rule.h:14
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::multibody::TriangleQuadratureRule::do_order
        struct /* do_order */ {
          // Source: drake/multibody/triangle_quadrature/triangle_quadrature_rule.h:40
          const char* doc =
R"""(Derived classes shall return the order (>= 1) of this rule.)""";
        } do_order;
        // Symbol: drake::multibody::TriangleQuadratureRule::do_quadrature_points
        struct /* do_quadrature_points */ {
          // Source: drake/multibody/triangle_quadrature/triangle_quadrature_rule.h:46
          const char* doc =
R"""(Derived classes shall return the vector of quadrature points. Each of
these Vector2 objects represents the barycentric coordinates of a
triangle (the third barycentric coordinate is implicit: it is the
difference between unity and the sum of the other two coordinates).)""";
        } do_quadrature_points;
        // Symbol: drake::multibody::TriangleQuadratureRule::do_weights
        struct /* do_weights */ {
          // Source: drake/multibody/triangle_quadrature/triangle_quadrature_rule.h:50
          const char* doc =
R"""(Derived classes shall return the vector of weights. The sum of all
weights must equal 1.0.)""";
        } do_weights;
        // Symbol: drake::multibody::TriangleQuadratureRule::order
        struct /* order */ {
          // Source: drake/multibody/triangle_quadrature/triangle_quadrature_rule.h:19
          const char* doc = R"""(Returns the order of this rule.)""";
        } order;
        // Symbol: drake::multibody::TriangleQuadratureRule::quadrature_points
        struct /* quadrature_points */ {
          // Source: drake/multibody/triangle_quadrature/triangle_quadrature_rule.h:28
          const char* doc =
R"""(Returns the vector of quadrature points. These are returned as the
first two barycentric coordinates b0 b1; the third is just b2 = 1 - b0
- b1. Each of these has a corresponding weight returned by weights().)""";
        } quadrature_points;
        // Symbol: drake::multibody::TriangleQuadratureRule::weights
        struct /* weights */ {
          // Source: drake/multibody/triangle_quadrature/triangle_quadrature_rule.h:34
          const char* doc =
R"""(Returns the vector of weights. These sum to 1 and there is one weight
for each point returned by quadrature_points().)""";
        } weights;
      } TriangleQuadratureRule;
      // Symbol: drake::multibody::UniformGravityFieldElement
      struct /* UniformGravityFieldElement */ {
        // Source: drake/multibody/tree/uniform_gravity_field_element.h:19
        const char* doc =
R"""(This ForceElement allows modeling the effect of a uniform gravity
field as felt by bodies on the surface of the Earth. This gravity
field acts on all bodies in the MultibodyTree model.)""";
        // Symbol: drake::multibody::UniformGravityFieldElement::CalcConservativePower
        struct /* CalcConservativePower */ {
          // Source: drake/multibody/tree/uniform_gravity_field_element.h:83
          const char* doc = R"""()""";
        } CalcConservativePower;
        // Symbol: drake::multibody::UniformGravityFieldElement::CalcGravityGeneralizedForces
        struct /* CalcGravityGeneralizedForces */ {
          // Source: drake/multibody/tree/uniform_gravity_field_element.h:70
          const char* doc =
R"""(Computes the generalized forces ``tau_g(q)`` due to ``this`` gravity
field element as a function of the generalized positions ``q`` stored
in the input ``context``, for the multibody model to which ``this``
element belongs. ``tau_g(q)`` is defined such that it appears on the
right hand side of the equations of motion together with any other
generalized forces, like so:


::

    Mv̇ + C(q, v)v = tau_g(q) + tau_app

where ``tau_app`` includes any other generalized forces applied on the
system.

Parameter ``context``:
    The context storing the state of the multibody model to which this
    element belongs.

Returns:
    tau_g A vector containing the generalized forces due to this
    gravity field force element. The generalized forces are consistent
    with the vector of generalized velocities ``v`` for the parent
    MultibodyTree model so that the inner product ``v⋅tau_g``
    corresponds to the power applied by the gravity forces on the
    mechanical system. That is, ``v⋅tau_g > 0`` corresponds to
    potential energy going into the system, as either mechanical
    kinetic energy, some other potential energy, or heat, and
    therefore to a decrease of potential energy.)""";
        } CalcGravityGeneralizedForces;
        // Symbol: drake::multibody::UniformGravityFieldElement::CalcNonConservativePower
        struct /* CalcNonConservativePower */ {
          // Source: drake/multibody/tree/uniform_gravity_field_element.h:88
          const char* doc = R"""()""";
        } CalcNonConservativePower;
        // Symbol: drake::multibody::UniformGravityFieldElement::CalcPotentialEnergy
        struct /* CalcPotentialEnergy */ {
          // Source: drake/multibody/tree/uniform_gravity_field_element.h:79
          const char* doc =
R"""(Computes the total potential energy of all bodies in the model in this
uniform gravity field. The definition of potential energy allows to
arbitrarily choose the zero energy height. This element takes the zero
energy height to be the same as the world's height. That is, a body
will have zero potential energy when its the height of its center of
mass is at the world's origin.)""";
        } CalcPotentialEnergy;
        // Symbol: drake::multibody::UniformGravityFieldElement::DoCalcAndAddForceContribution
        struct /* DoCalcAndAddForceContribution */ {
          // Source: drake/multibody/tree/uniform_gravity_field_element.h:94
          const char* doc = R"""()""";
        } DoCalcAndAddForceContribution;
        // Symbol: drake::multibody::UniformGravityFieldElement::DoCloneToScalar
        struct /* DoCloneToScalar */ {
          // Source: drake/multibody/tree/uniform_gravity_field_element.h:100
          const char* doc = R"""()""";
        } DoCloneToScalar;
        // Symbol: drake::multibody::UniformGravityFieldElement::UniformGravityFieldElement<T>
        struct /* ctor */ {
          // Source: drake/multibody/tree/uniform_gravity_field_element.h:31
          const char* doc_0args =
R"""(Constructs a uniform gravity field element with a default strength (on
the earth's surface) and direction (-z).)""";
          // Source: drake/multibody/tree/uniform_gravity_field_element.h:35
          const char* doc_1args =
R"""(Constructs a uniform gravity field element with a strength given by
the acceleration of gravity vector ``g_W``, expressed in the world
frame W.)""";
        } ctor;
        // Symbol: drake::multibody::UniformGravityFieldElement::gravity_vector
        struct /* gravity_vector */ {
          // Source: drake/multibody/tree/uniform_gravity_field_element.h:39
          const char* doc =
R"""(Returns the acceleration of the gravity vector in m/s², expressed in
the world frame W.)""";
        } gravity_vector;
        // Symbol: drake::multibody::UniformGravityFieldElement::set_gravity_vector
        struct /* set_gravity_vector */ {
          // Source: drake/multibody/tree/uniform_gravity_field_element.h:43
          const char* doc =
R"""(Sets the acceleration of gravity vector, expressed in the world frame
W in m/s².)""";
        } set_gravity_vector;
      } UniformGravityFieldElement;
      // Symbol: drake::multibody::UnitInertia
      struct /* UnitInertia */ {
        // Source: drake/multibody/tree/unit_inertia.h:39
        const char* doc =
R"""(This class is used to represent rotational inertias for unit mass
bodies. Therefore, unlike RotationalInertia whose units are kg⋅m², the
units of a UnitInertia are those of length squared. A unit inertia is
a useful concept to represent the geometric distribution of mass in a
body regardless of the actual value of the body mass. The rotational
inertia of a body can therefore be obtained by multiplying its unit
inertia by its mass. Unit inertia matrices can also be called
**gyration** matrices and therefore we choose to represent them in
source code notation with the capital letter G. In contrast, the
capital letter I is used to represent non-unit mass rotational
inertias. This class restricts the set of allowed operations on a unit
inertia to ensure the unit-mass invariant. For instance,
multiplication by a scalar can only return a general RotationalInertia
but not a UnitInertia.

Note:
    This class has no means to check at construction from user
    provided parameters whether it actually represents the unit
    inertia or gyration matrix of a unit-mass body. However, as
    previously noted, once a unit inertia is created, a number of
    operations are disallowed to ensure the unit-mass invariant. Also
    notice that once a unit inertia is created, it *is* the unit
    inertia of *some* body, perhaps with scaled geometry from the
    user's intention.)""";
        // Symbol: drake::multibody::UnitInertia::AxiallySymmetric
        struct /* AxiallySymmetric */ {
          // Source: drake/multibody/tree/unit_inertia.h:349
          const char* doc =
R"""(Returns the unit inertia for a unit-mass body B for which there exists
a line L passing through the body's center of mass ``Bcm`` having the
property that the body's moment of inertia about all lines
perpendicular to L are equal. Examples of bodies with an axially
symmetric inertia include axisymmetric objects such as cylinders and
cones. Other commonly occurring geometries with this property are, for
instance, propellers with 3+ evenly spaced blades. Given a unit vector
b defining the symmetry line L, the moment of inertia J about this
line L and the moment of inertia K about any line perpendicular to L,
the axially symmetric unit inertia G is computed as:


::

    G = K * Id + (J - K) * b ⊗ b

where ``Id`` is the identity matrix and ⊗ denotes the tensor product
operator. See Mitiguy, P., 2016. Advanced Dynamics & Motion
Simulation.

Raises:
    RuntimeError - J is negative. J can be zero. - K is negative. K
    can be zero. - J ≤ 2 * K, this corresponds to the triangle
    inequality, see CouldBePhysicallyValid(). - ``b_E`` is the zero
    vector. That is if ``‖b_E‖₂ ≤ ε``, where ε is the machine epsilon.

Note:
    J is a principal moment of inertia with principal axis equal to b.
    K is a principal moment with multiplicity of two. Any two axes
    perpendicular to b are principal axes with principal moment K.

Parameter ``J``:
    Unit inertia about axis b.

Parameter ``K``:
    Unit inertia about any axis perpendicular to b.

Parameter ``b_E``:
    Vector defining the symmetry axis, expressed in a frame E. ``b_E``
    can have a norm different from one; however, it will be normalized
    before using it. Therefore its norm is ignored and only its
    direction is used.

Returns ``G_Bcm_E``:
    An axially symmetric unit inertia about body B's center of mass,
    expressed in the same frame E as the input unit vector ``b_E``.)""";
        } AxiallySymmetric;
        // Symbol: drake::multibody::UnitInertia::HollowSphere
        struct /* HollowSphere */ {
          // Source: drake/multibody/tree/unit_inertia.h:239
          const char* doc =
R"""(Computes the unit inertia for a unit-mass hollow sphere of radius
``r`` consisting of an infinitesimally thin shell of uniform density.
The unit inertia is taken about the center of the sphere.)""";
        } HollowSphere;
        // Symbol: drake::multibody::UnitInertia::PointMass
        struct /* PointMass */ {
          // Source: drake/multibody/tree/unit_inertia.h:219
          const char* doc =
R"""(Construct a unit inertia for a point mass of unit mass located at
point Q, whose location in a frame F is given by the position vector
``p_FQ`` (that is, p_FoQ_F). The unit inertia ``G_QFo_F`` of point
mass Q about the origin ``Fo`` of frame F and expressed in F for this
unit mass point equals the square of the cross product matrix of
``p_FQ``. In coordinate-free form:

.. math:: G^{Q/F_o} = (^Fp^Q_\times)^2 = (^Fp^Q_\times)^T \, ^Fp^Q_\times =
              -^Fp^Q_\times \, ^Fp^Q_\times

where :math:`^Fp^Q_\times` is the cross product matrix of vector
:math:`^Fp^Q`. In source code the above expression is written as:


::

    G_QFo_F = px_FQ² = px_FQᵀ * px_FQ = -px_FQ * px_FQ

where ``px_FQ`` denotes the cross product matrix of the position
vector ``p_FQ`` (expressed in F) such that the cross product with
another vector ``a`` can be obtained as ``px.cross(a) = px * a``. The
cross product matrix ``px`` is skew-symmetric. The square of the cross
product matrix is a symmetric matrix with non-negative diagonals and
obeys the triangle inequality. Matrix ``px²`` can be used to compute
the triple vector product as ``-p x (p x a) = -p.cross(p.cross(a)) =
px² * a``.)""";
        } PointMass;
        // Symbol: drake::multibody::UnitInertia::ReExpress
        struct /* ReExpress */ {
          // Source: drake/multibody/tree/unit_inertia.h:112
          const char* doc =
R"""(Given ``this`` unit inertia ``G_BP_E`` of a body B about a point P and
expressed in frame E, this method computes the same unit inertia
re-expressed in another frame A as ``G_BP_A = R_AE * G_BP_E *
(R_AE)ᵀ``.

Parameter ``R_AE``:
    RotationMatrix relating frames A and E.

Returns ``G_BP_A``:
    The same unit inertia for body B about point P but now
    re-expressed in frame A.)""";
        } ReExpress;
        // Symbol: drake::multibody::UnitInertia::ReExpressInPlace
        struct /* ReExpressInPlace */ {
          // Source: drake/multibody/tree/unit_inertia.h:101
          const char* doc =
R"""(Re-express a unit inertia in a different frame, performing the
operation in place and modifying the original object.

See also:
    ReExpress() for details.)""";
        } ReExpressInPlace;
        // Symbol: drake::multibody::UnitInertia::SetFromRotationalInertia
        struct /* SetFromRotationalInertia */ {
          // Source: drake/multibody/tree/unit_inertia.h:92
          const char* doc =
R"""(Sets ``this`` unit inertia from a generally non-unit inertia I
corresponding to a body with a given ``mass``.

Note:
    In Debug builds, this operation aborts if the provided ``mass`` is
    not strictly positive.)""";
        } SetFromRotationalInertia;
        // Symbol: drake::multibody::UnitInertia::ShiftFromCenterOfMass
        struct /* ShiftFromCenterOfMass */ {
          // Source: drake/multibody/tree/unit_inertia.h:138
          const char* doc =
R"""(Shifts this central unit inertia to a different point, and returns the
result. See ShiftFromCenterOfMassInPlace() for details.

Parameter ``p_BcmQ_E``:
    A vector from the body's centroid ``Bcm`` to point Q expressed in
    the same frame E in which ``this`` inertia is expressed.

Returns ``G_BQ_E``:
    This same unit inertia taken about a point Q instead of the
    centroid ``Bcm``.)""";
        } ShiftFromCenterOfMass;
        // Symbol: drake::multibody::UnitInertia::ShiftFromCenterOfMassInPlace
        struct /* ShiftFromCenterOfMassInPlace */ {
          // Source: drake/multibody/tree/unit_inertia.h:126
          const char* doc =
R"""(For a central unit inertia ``G_Bcm_E`` computed about a body's center
of mass (or centroid) ``Bcm`` and expressed in a frame E, this method
shifts this inertia using the parallel axis theorem to be computed
about a point Q. This operation is performed in place, modifying the
original object which is no longer a central inertia.

Parameter ``p_BcmQ_E``:
    A vector from the body's centroid ``Bcm`` to point Q expressed in
    the same frame E in which ``this`` inertia is expressed.

Returns:
    A reference to ``this`` unit inertia, which has now been taken
    about point Q so can be written as ``G_BQ_E``.)""";
        } ShiftFromCenterOfMassInPlace;
        // Symbol: drake::multibody::UnitInertia::ShiftToCenterOfMass
        struct /* ShiftToCenterOfMass */ {
          // Source: drake/multibody/tree/unit_inertia.h:180
          const char* doc =
R"""(For the unit inertia ``G_BQ_E`` of a body or composite body B computed
about a point Q and expressed in a frame E, this method shifts this
inertia using the parallel axis theorem to be computed about the
center of mass ``Bcm`` of B. See ShiftToCenterOfMassInPlace() for
details.

Parameter ``p_QBcm_E``:
    A position vector from the about point Q to the body's centroid
    ``Bcm`` expressed in the same frame E in which ``this`` inertia is
    expressed.

Returns ``G_Bcm_E``:
    This same unit which has now been taken about point ``Bcm`` so
    that it can be written as ``G_BBcm_E``, or ``G_Bcm_E``.

Warning:
    This operation could result in a non-physical rotational inertia.
    Use with care. See ShiftToCenterOfMassInPlace() for details.)""";
        } ShiftToCenterOfMass;
        // Symbol: drake::multibody::UnitInertia::ShiftToCenterOfMassInPlace
        struct /* ShiftToCenterOfMassInPlace */ {
          // Source: drake/multibody/tree/unit_inertia.h:163
          const char* doc = R"""()""";
        } ShiftToCenterOfMassInPlace;
        // Symbol: drake::multibody::UnitInertia::SolidBox
        struct /* SolidBox */ {
          // Source: drake/multibody/tree/unit_inertia.h:250
          const char* doc =
R"""(Computes the unit inertia for a unit-mass solid box of uniform density
taken about its geometric center. If one length is zero the inertia
corresponds to that of a thin rectangular sheet. If two lengths are
zero the inertia corresponds to that of a thin rod in the remaining
direction.

Parameter ``Lx``:
    The length of the box edge in the principal x-axis.

Parameter ``Ly``:
    The length of the box edge in the principal y-axis.

Parameter ``Lz``:
    The length of the box edge in the principal z-axis.)""";
        } SolidBox;
        // Symbol: drake::multibody::UnitInertia::SolidCube
        struct /* SolidCube */ {
          // Source: drake/multibody/tree/unit_inertia.h:262
          const char* doc =
R"""(Computes the unit inertia for a unit-mass solid cube (a box with
equal-sized sides) of uniform density taken about its geometric
center.

Parameter ``L``:
    The length of each of the cube's sides.)""";
        } SolidCube;
        // Symbol: drake::multibody::UnitInertia::SolidCylinder
        struct /* SolidCylinder */ {
          // Source: drake/multibody/tree/unit_inertia.h:289
          const char* doc =
R"""(Computes the unit inertia for a unit-mass cylinder B, of uniform
density, having its axis of revolution along input vector ``b_E``. The
resulting unit inertia is computed about the cylinder's center of mass
``Bcm`` and is expressed in the same frame E as the input axis of
revolution ``b_E``.

Parameter ``r``:
    The radius of the cylinder, it must be non-negative.

Parameter ``L``:
    The length of the cylinder, it must be non-negative.

Parameter ``b_E``:
    Vector defining the axis of revolution of the cylinder, expressed
    in a frame E. ``b_E`` can have a norm different from one; however,
    it will be normalized before using it. Therefore its norm is
    ignored and only its direction is used. It defaults to
    ``Vector3<T>::UnitZ()``.

Returns ``G_Bcm_E``:
    The unit inertia for a solid cylinder B, of uniform density, with
    axis of revolution along ``b_E``, computed about the cylinder's
    center of mass ``Bcm``, and expressed in the same frame E as the
    input axis of rotation ``b_E``.

Raises:
    RuntimeError - Radius r is negative. - Length L is negative. -
    ``b_E`` is the zero vector. That is if ``‖b_E‖₂ ≤ ε``, where ε is
    the machine epsilon.)""";
        } SolidCylinder;
        // Symbol: drake::multibody::UnitInertia::SolidCylinderAboutEnd
        struct /* SolidCylinderAboutEnd */ {
          // Source: drake/multibody/tree/unit_inertia.h:304
          const char* doc =
R"""(Computes the unit inertia for a unit-mass cylinder of uniform density
oriented along the z-axis computed about a point at the center of its
base.

Parameter ``r``:
    The radius of the cylinder.

Parameter ``L``:
    The length of the cylinder.)""";
        } SolidCylinderAboutEnd;
        // Symbol: drake::multibody::UnitInertia::SolidSphere
        struct /* SolidSphere */ {
          // Source: drake/multibody/tree/unit_inertia.h:232
          const char* doc =
R"""(Computes the unit inertia for a unit-mass solid sphere of uniform
density and radius ``r`` taken about its center.)""";
        } SolidSphere;
        // Symbol: drake::multibody::UnitInertia::StraightLine
        struct /* StraightLine */ {
          // Source: drake/multibody/tree/unit_inertia.h:388
          const char* doc =
R"""(Computes the unit inertia for a body B of unit-mass uniformly
distributed along a straight, finite, line L with direction ``b_E``
and with moment of inertia K about any axis perpendicular to this
line. Since the mass of the body is uniformly distributed on this line
L, its center of mass is located right at the center. As an example,
consider the inertia of a thin rod for which its transversal
dimensions can be neglected, see ThinRod().

This method aborts if K is not positive.

Note:
    This is the particular case for an axially symmetric unit inertia
    with zero moment about its axis, see AxiallySymmetric().

Parameter ``K``:
    Unit inertia about any axis perpendicular to the line.

Parameter ``b_E``:
    Vector defining the direction of the line, expressed in a frame E.
    ``b_E`` can have a norm different from one. Its norm is ignored
    and only its direction is needed.

Returns ``G_Bcm_E``:
    The unit inertia for a body B of unit mass uniformly distributed
    along a straight line L, about its center of mass ``Bcm`` which is
    located at the center of the line, expressed in the same frame E
    as the input unit vector ``b_E``.)""";
        } StraightLine;
        // Symbol: drake::multibody::UnitInertia::ThinRod
        struct /* ThinRod */ {
          // Source: drake/multibody/tree/unit_inertia.h:408
          const char* doc =
R"""(Computes the unit inertia for a unit mass rod B of length L, about its
center of mass, with its mass uniformly distributed along a line
parallel to vector ``b_E``.

This method aborts if L is not positive.

Parameter ``L``:
    The length of the rod. It must be positive.

Parameter ``b_E``:
    Vector defining the axis of the rod, expressed in a frame E.
    ``b_E`` can have a norm different from one. Its norm is ignored
    and only its direction is needed.

Returns ``G_Bcm_E``:
    The unit inertia of the rod B about its center of mass ``Bcm``,
    expressed in the same frame E as the input unit vector ``b_E``.)""";
        } ThinRod;
        // Symbol: drake::multibody::UnitInertia::TriaxiallySymmetric
        struct /* TriaxiallySymmetric */ {
          // Source: drake/multibody/tree/unit_inertia.h:419
          const char* doc = R"""()""";
        } TriaxiallySymmetric;
        // Symbol: drake::multibody::UnitInertia::UnitInertia<T>
        struct /* ctor */ {
          // Source: drake/multibody/tree/unit_inertia.h:45
          const char* doc_0args =
R"""(Default UnitInertia constructor sets all entries to NaN for quick
detection of uninitialized values.)""";
          // Source: drake/multibody/tree/unit_inertia.h:51
          const char* doc_3args =
R"""(Creates a unit inertia with moments of inertia ``Ixx``, `Iyy`,
``Izz``, and with each product of inertia set to zero. In debug
builds, throws RuntimeError if unit inertia constructed from these
arguments violates RotationalInertia::CouldBePhysicallyValid().)""";
          // Source: drake/multibody/tree/unit_inertia.h:58
          const char* doc_6args =
R"""(Creates a unit inertia with moments of inertia ``Ixx``, `Iyy`,
``Izz``, and with products of inertia ``Ixy``, `Ixz`, ``Iyz``. In
debug builds, throws RuntimeError if unit inertia constructed from
these arguments violates RotationalInertia::CouldBePhysicallyValid().)""";
          // Source: drake/multibody/tree/unit_inertia.h:68
          const char* doc_1args =
R"""(Constructs a UnitInertia from a RotationalInertia. This constructor
has no way to verify that the input rotational inertia actually is a
unit inertia. But the construction will nevertheless succeed, and the
values of the input rotational inertia will henceforth be considered a
valid unit inertia. It is the responsibility of the user to pass a
valid unit inertia.)""";
        } ctor;
        // Symbol: drake::multibody::UnitInertia::cast
        struct /* cast */ {
          // Source: drake/multibody/tree/unit_inertia.h:84
          const char* doc =
R"""(Returns a new UnitInertia object templated on ``Scalar`` initialized
from the value of ``this`` unit inertia.

Template parameter ``Scalar``:
    The scalar type on which the new unit inertia will be templated.

Note:
    ``UnitInertia<From>::cast<To>()`` creates a new
    ``UnitInertia<To>`` from a ``UnitInertia<From>`` but only if type
    ``To`` is constructible from type ``From``. As an example of this,
    ``UnitInertia<double>::cast<AutoDiffXd>()`` is valid since
    ``AutoDiffXd a(1.0)`` is valid. However,
    ``UnitInertia<AutoDiffXd>::cast<double>()`` is not.)""";
        } cast;
        // Symbol: drake::multibody::UnitInertia::operator*=
        struct /* operator_imul */ {
          // Source: drake/multibody/tree/unit_inertia.h:439
          const char* doc = R"""()""";
        } operator_imul;
        // Symbol: drake::multibody::UnitInertia::operator+=
        struct /* operator_iadd */ {
          // Source: drake/multibody/tree/unit_inertia.h:437
          const char* doc = R"""()""";
        } operator_iadd;
        // Symbol: drake::multibody::UnitInertia::operator-=
        struct /* operator_isub */ {
          // Source: drake/multibody/tree/unit_inertia.h:438
          const char* doc = R"""()""";
        } operator_isub;
        // Symbol: drake::multibody::UnitInertia::operator/=
        struct /* operator_idiv */ {
          // Source: drake/multibody/tree/unit_inertia.h:440
          const char* doc = R"""()""";
        } operator_idiv;
      } UnitInertia;
      // Symbol: drake::multibody::UnitQuaternionConstraint
      struct /* UnitQuaternionConstraint */ {
        // Source: drake/multibody/inverse_kinematics/unit_quaternion_constraint.h:14
        const char* doc =
R"""(Constrains the quaternion to have a unit length.)""";
        // Symbol: drake::multibody::UnitQuaternionConstraint::UnitQuaternionConstraint
        struct /* ctor */ {
          // Source: drake/multibody/inverse_kinematics/unit_quaternion_constraint.h:16
          const char* doc = R"""()""";
        } ctor;
      } UnitQuaternionConstraint;
      // Symbol: drake::multibody::UniversalJoint
      struct /* UniversalJoint */ {
        // Source: drake/multibody/tree/universal_joint.h:45
        const char* doc =
R"""(This joint models a universal joint allowing two bodies to rotate
relative to one another with two degrees of freedom. A universal joint
can be thought of as a mechanism consisting of three bodies; the
parent body P, an intermediate cross-shaped body I, and the child body
B. In a physical universal joint, body I has a significantly smaller
mass than P or B. This universal joint model corresponds to the
mathematical limit of having a body I of negligible mass. Given a
frame F attached to the parent body P and a frame M attached to the
child body B (see the Joint class's documentation), the orientation of
M in F can then naturally be defined as follows using a body fixed
rotation sequence. A first rotation of θ₁ about Fx defines the
orientation R_FI of the intermediate frame I attached to body I
(notice that by definition Ix = Fx at all times). A second rotation of
θ₂ about Iy defines the orientation R_IM of frame M (notice that by
definition My = Iy at all times). Mathematically, the orientation of
frame M in F is given by


::

    R_FM(q) = R_FI(θ₁) * R_IM(θ₂)

No translational motion of M in F is allowed and the origins, ``Mo``
and ``Fo``, of frames M and F respectively remain coincident. The
angles of rotation about F's x-axis and M's y-axis, along with their
rates, specify the state of the joint. Zero θ₁, θ₂ angles corresponds
to frames F, I, and M being coincident. Angles (θ₁, θ₂) are defined to
be positive according to the right-hand-rule with the thumb aligned in
the direction of their respective axes.)""";
        // Symbol: drake::multibody::UniversalJoint::DoAddInDamping
        struct /* DoAddInDamping */ {
          // Source: drake/multibody/tree/universal_joint.h:202
          const char* doc =
R"""(Joint<T> override called through public NVI, Joint::AddInDamping().
Therefore arguments were already checked to be valid. This method adds
into ``forces`` a dissipative torque according to the viscous law ``τ
= -d⋅ω``, with d the damping coefficient (see damping()).)""";
        } DoAddInDamping;
        // Symbol: drake::multibody::UniversalJoint::DoAddInOneForce
        struct /* DoAddInOneForce */ {
          // Source: drake/multibody/tree/universal_joint.h:188
          const char* doc =
R"""(Joint<T> override called through public NVI, Joint::AddInForce().
Therefore arguments were already checked to be valid. For a
UniversalJoint, we must always have ``joint_dof < 2`` since there are
two degrees of freedom (num_velocities() == 2). ``joint_tau`` is the
torque applied about the axis specified by ``joint_dof``, the x-axis
of the parent frame F if ``joint_dof = 0`` or the y-axis of the child
frame M if ``joint_dof = 1``. The torque is applied to the body
declared as child (according to the universal joint's constructor) at
the origin of the child frame M (which is coincident with the origin
of the parent frame F at all times). The torque is defined to be
positive according to the right-hand-rule with the thumb aligned in
the direction of the selected axis. That is, a positive torque causes
a positive rotational acceleration (of the child body frame).)""";
        } DoAddInOneForce;
        // Symbol: drake::multibody::UniversalJoint::UniversalJoint<T>
        struct /* ctor */ {
          // Source: drake/multibody/tree/universal_joint.h:71
          const char* doc =
R"""(Constructor to create a universal joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B rotate as described in the class's documentation. See
class documentation for details on the angles defining orientation.
This constructor signature creates a joint with no joint limits, i.e.
the joint position, velocity and acceleration limits are the pair
``(-∞, ∞)``. These can be set using the Joint methods
set_position_limits(), set_velocity_limits() and
set_acceleration_limits(). The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class's documentation for details. The additional parameters are:

Parameter ``damping``:
    Viscous damping coefficient, in N⋅m⋅s, used to model losses within
    the joint. See documentation of damping() for details on modelling
    of the damping torque.

Raises:
    RuntimeError if damping is negative.)""";
        } ctor;
        // Symbol: drake::multibody::UniversalJoint::damping
        struct /* damping */ {
          // Source: drake/multibody/tree/universal_joint.h:100
          const char* doc =
R"""(Returns ``this`` joint's damping constant in N⋅m⋅s. The damping torque
(in N⋅m) is modeled as ``τᵢ = -damping⋅ωᵢ, i = 1, 2`` i.e. opposing
motion, with ωᵢ the angular rates about the i-th axis for ``this``
joint (see get_angular_rates())and τᵢ the torque on child body B about
the same i-th axis.)""";
        } damping;
        // Symbol: drake::multibody::UniversalJoint::get_angles
        struct /* get_angles */ {
          // Source: drake/multibody/tree/universal_joint.h:111
          const char* doc =
R"""(Gets the rotation angles of ``this`` joint from ``context``. See class
documentation for the definition of these angles.

Parameter ``context``:
    The context of the model this joint belongs to.

Returns:
    The angle coordinates of ``this`` joint stored in the ``context``
    ordered as (θ₁, θ₂).)""";
        } get_angles;
        // Symbol: drake::multibody::UniversalJoint::get_angular_rates
        struct /* get_angular_rates */ {
          // Source: drake/multibody/tree/universal_joint.h:133
          const char* doc =
R"""(Gets the rates of change, in radians per second, of ``this`` joint's
angles (see class documentation) from ``context``.

Parameter ``context``:
    The context of the model this joint belongs to.

Returns:
    The rates of change of ``this`` joint's angles as stored in the
    ``context``.)""";
        } get_angular_rates;
        // Symbol: drake::multibody::UniversalJoint::get_default_angles
        struct /* get_default_angles */ {
          // Source: drake/multibody/tree/universal_joint.h:155
          const char* doc =
R"""(Gets the default angles for ``this`` joint. Wrapper for the more
general ``Joint::default_positions()``.

Returns:
    The default angles of ``this`` stored in ``default_positions_``)""";
        } get_default_angles;
        // Symbol: drake::multibody::UniversalJoint::set_angles
        struct /* set_angles */ {
          // Source: drake/multibody/tree/universal_joint.h:122
          const char* doc =
R"""(Sets the ``context`` so that the generalized coordinates corresponding
to the rotation angles of ``this`` joint equals ``angles``.

Parameter ``context``:
    The context of the model this joint belongs to.

Parameter ``angles``:
    The desired angles in radians to be stored in ``context`` ordered
    as (θ₁, θ₂). See class documentation for details.

Returns:
    a constant reference to ``this`` joint.)""";
        } set_angles;
        // Symbol: drake::multibody::UniversalJoint::set_angular_rates
        struct /* set_angular_rates */ {
          // Source: drake/multibody/tree/universal_joint.h:144
          const char* doc =
R"""(Sets the rates of change, in radians per second, of this ``this``
joint's angles (see class documentation) to ``theta_dot``. The new
rates of change get stored in ``context``.

Parameter ``context``:
    The context of the model this joint belongs to.

Parameter ``theta_dot``:
    The desired rates of change of ``this`` joints's angles in radians
    per second.

Returns:
    a constant reference to ``this`` joint.)""";
        } set_angular_rates;
        // Symbol: drake::multibody::UniversalJoint::set_default_angles
        struct /* set_default_angles */ {
          // Source: drake/multibody/tree/universal_joint.h:161
          const char* doc =
R"""(Sets the default angles of this joint.

Parameter ``angles``:
    The desired default angles of the joint)""";
        } set_default_angles;
        // Symbol: drake::multibody::UniversalJoint::set_random_angles_distribution
        struct /* set_random_angles_distribution */ {
          // Source: drake/multibody/tree/universal_joint.h:168
          const char* doc =
R"""(Sets the random distribution that angles of this joint will be
randomly sampled from. See class documentation for details on the
definition of the angles.)""";
        } set_random_angles_distribution;
        // Symbol: drake::multibody::UniversalJoint::type_name
        struct /* type_name */ {
          // Source: drake/multibody/tree/universal_joint.h:90
          const char* doc = R"""()""";
        } type_name;
      } UniversalJoint;
      // Symbol: drake::multibody::WeldJoint
      struct /* WeldJoint */ {
        // Source: drake/multibody/tree/weld_joint.h:22
        const char* doc =
R"""(This Joint fixes the relative pose between two frames as if "welding"
them together.)""";
        // Symbol: drake::multibody::WeldJoint::DoAddInOneForce
        struct /* DoAddInOneForce */ {
          // Source: drake/multibody/tree/weld_joint.h:61
          const char* doc =
R"""(Joint<T> override called through public NVI, Joint::AddInForce().
Since frame P and C are welded together, it is physically not possible
to apply forces between them. Therefore this method throws an
exception if invoked.)""";
        } DoAddInOneForce;
        // Symbol: drake::multibody::WeldJoint::WeldJoint<T>
        struct /* ctor */ {
          // Source: drake/multibody/tree/weld_joint.h:34
          const char* doc =
R"""(Constructor for a WeldJoint between a ``parent_frame_P`` and a
``child_frame_C`` so that their relative pose ``X_PC`` is fixed as if
they were "welded" together.)""";
        } ctor;
        // Symbol: drake::multibody::WeldJoint::X_PC
        struct /* X_PC */ {
          // Source: drake/multibody/tree/weld_joint.h:52
          const char* doc = R"""(Returns the pose X_PC of frame C in P.)""";
        } X_PC;
        // Symbol: drake::multibody::WeldJoint::type_name
        struct /* type_name */ {
          // Source: drake/multibody/tree/weld_joint.h:46
          const char* doc = R"""()""";
        } type_name;
      } WeldJoint;
      // Symbol: drake::multibody::benchmarks
      struct /* benchmarks */ {
        // Symbol: drake::multibody::benchmarks::Acrobot
        struct /* Acrobot */ {
          // Source: drake/multibody/benchmarks/acrobot/acrobot.h:23
          const char* doc =
R"""(The Acrobot - a canonical underactuated system as described in <a
href="http://underactuated.mit.edu/underactuated.html?chapter=3">Chapter
3 of Underactuated Robotics</a>.

This system essentially is a double pendulum consisting of two links.
Link 1 is connected to the world by a "shoulder" revolute joint
parameterized by angle theta1 and Link 2 is connected to Link 1 by an
"elbow" revolute joint parameterized by angle theta2.)""";
          // Symbol: drake::multibody::benchmarks::Acrobot::Acrobot<T>
          struct /* ctor */ {
            // Source: drake/multibody/benchmarks/acrobot/acrobot.h:50
            const char* doc =
R"""(Creates an acrobot model in a plane passing through the world's origin
and normal to ``normal``. Vector ``up`` defines the upwards direction
on this plane. Both ``normal`` and ``up`` are expressed in the world's
frame. Essentially the two dimensional equations of the acrobot are
described in a model frame D within a x-y plane with y the vertical
direction and gravity pointing downwards. Therefore the axes defining
the model frame D are:


::

    z_W = normal_W.normalized()
      y_W = (up - up.dot(z_W) * z_W).normalized()
      x_W = y_W.cross(z_W)

The remaining arguments define the properties of the double pendulum
system:

- m1: mass of the first link.
- m2: mass of the second link.
- l1: length of the first link.
- l2: length of the second link.
- lc1: length from the shoulder to the center of mass of the first link.
- lc2: length from the elbow to the center of mass of the second link.
- Ic1: moment of inertia about the center of mass for the first link.
- Ic2: moment of inertia about the center of mass for the second link.
- b1: damping coefficient of the shoulder joint.
- b2: damping coefficient of the elbow joint.
- g: acceleration of gavity.)""";
          } ctor;
          // Symbol: drake::multibody::benchmarks::Acrobot::CalcCoriolisVector
          struct /* CalcCoriolisVector */ {
            // Source: drake/multibody/benchmarks/acrobot/acrobot.h:70
            const char* doc =
R"""(Computes the bias term ``C(q, v) * v`` containing Coriolis and
gyroscopic effects as a function of the state of the pendulum.)""";
          } CalcCoriolisVector;
          // Symbol: drake::multibody::benchmarks::Acrobot::CalcElbowOutboardFramePoseInWorldFrame
          struct /* CalcElbowOutboardFramePoseInWorldFrame */ {
            // Source: drake/multibody/benchmarks/acrobot/acrobot.h:102
            const char* doc =
R"""(Computes the pose of the elbow outboard frame ``Eo`` in the world
frame W.

Parameter ``theta1``:
    The shoulder angle in radians.

Parameter ``theta2``:
    The elbow angle in radians.

Returns:
    X_WEo the pose of the elbow frame Eo in the world frame W.)""";
          } CalcElbowOutboardFramePoseInWorldFrame;
          // Symbol: drake::multibody::benchmarks::Acrobot::CalcGravityVector
          struct /* CalcGravityVector */ {
            // Source: drake/multibody/benchmarks/acrobot/acrobot.h:79
            const char* doc =
R"""(Computes the effective joint-space torques induced by gravity
``tau_g(q)`` containing the effect of gravity as a function of the
configuration of the pendulum. Unlike
http://underactuated.mit.edu/underactuated.html?chapter=3, cited in
this class's documentation, we define ``tau_g(q)`` to be on the right
hand side of the equations of motion, that is, ``Mv̇ + C(q, v)v =
tau_g(q)``.)""";
          } CalcGravityVector;
          // Symbol: drake::multibody::benchmarks::Acrobot::CalcLink1PoseInWorldFrame
          struct /* CalcLink1PoseInWorldFrame */ {
            // Source: drake/multibody/benchmarks/acrobot/acrobot.h:87
            const char* doc =
R"""(Computes the pose of the center of mass of link 1 measured and
expressed in the world frame.

Parameter ``theta1``:
    The shoulder angle in radians.

Parameter ``theta2``:
    The elbow angle in radians.

Returns:
    X_WL1 the pose of link 1 measured and expressed in the world
    frame.)""";
          } CalcLink1PoseInWorldFrame;
          // Symbol: drake::multibody::benchmarks::Acrobot::CalcLink1SpatialAccelerationInWorldFrame
          struct /* CalcLink1SpatialAccelerationInWorldFrame */ {
            // Source: drake/multibody/benchmarks/acrobot/acrobot.h:137
            const char* doc =
R"""(Computes the spatial acceleration of the center of mass of link 1
expressed in the world frame.

Parameter ``theta1``:
    The shoulder angle in radians.

Parameter ``theta1dot``:
    The shoulder angular velocity in radians per second.

Parameter ``theta1dotdot``:
    The elbow angular acceleration in radians per second squared.

Returns ``A_WL1_W``:
    the spatial acceleration of the center of mass of link 1 with
    respect to the world and expressed in the world frame.)""";
          } CalcLink1SpatialAccelerationInWorldFrame;
          // Symbol: drake::multibody::benchmarks::Acrobot::CalcLink1SpatialVelocityInWorldFrame
          struct /* CalcLink1SpatialVelocityInWorldFrame */ {
            // Source: drake/multibody/benchmarks/acrobot/acrobot.h:111
            const char* doc =
R"""(Computes the spatial velocity of the center of mass of link 1
expressed in the world frame.

Parameter ``theta1``:
    The shoulder angle in radians.

Parameter ``theta1dot``:
    The shoulder angular velocity in radians per second.

Returns:
    V_WL1_W the spatial velocity of the center of mass of link 1 with
    respect to the world and expressed in the world frame.)""";
          } CalcLink1SpatialVelocityInWorldFrame;
          // Symbol: drake::multibody::benchmarks::Acrobot::CalcLink2PoseInWorldFrame
          struct /* CalcLink2PoseInWorldFrame */ {
            // Source: drake/multibody/benchmarks/acrobot/acrobot.h:95
            const char* doc =
R"""(Computes the pose of the center of mass of link 2 measured and
expressed in the world frame.

Parameter ``theta1``:
    The shoulder angle in radians.

Parameter ``theta2``:
    The elbow angle in radians.

Returns:
    X_WL2 the pose of link 2 measured and expressed in the world
    frame.)""";
          } CalcLink2PoseInWorldFrame;
          // Symbol: drake::multibody::benchmarks::Acrobot::CalcLink2SpatialAccelerationInWorldFrame
          struct /* CalcLink2SpatialAccelerationInWorldFrame */ {
            // Source: drake/multibody/benchmarks/acrobot/acrobot.h:157
            const char* doc =
R"""(Computes the spatial acceleration of the center of mass of link 2
expressed in the world frame.

Parameter ``theta1``:
    The shoulder angle in radians.

Parameter ``theta2``:
    The elbow angle in radians.

Parameter ``theta1dot``:
    The shoulder angular velocity in radians per second.

Parameter ``theta2dot``:
    The elbow angular velocity in radians per second.

Parameter ``theta1dotdot``:
    The shoulder angular acceleration in radians per second squared.

Parameter ``theta2dotdot``:
    The elbow angular acceleration in radians per second squared.

Returns ``A_WL2_W``:
    the spatial acceleration of the center of mass of link 2 with
    respect to the world and expressed in the world frame.)""";
          } CalcLink2SpatialAccelerationInWorldFrame;
          // Symbol: drake::multibody::benchmarks::Acrobot::CalcLink2SpatialVelocityInWorldFrame
          struct /* CalcLink2SpatialVelocityInWorldFrame */ {
            // Source: drake/multibody/benchmarks/acrobot/acrobot.h:122
            const char* doc =
R"""(Computes the spatial velocity of the center of mass of link 2
expressed in the world frame.

Parameter ``theta1``:
    The shoulder angle in radians.

Parameter ``theta2``:
    The elbow angle in radians.

Parameter ``theta1dot``:
    The shoulder angular velocity in radians per second.

Parameter ``theta2dot``:
    The elbow angular velocity in radians per second.

Returns:
    V_WL2_W the spatial velocity of the center of mass of link 2 with
    respect to the world and expressed in the world frame.)""";
          } CalcLink2SpatialVelocityInWorldFrame;
          // Symbol: drake::multibody::benchmarks::Acrobot::CalcMassMatrix
          struct /* CalcMassMatrix */ {
            // Source: drake/multibody/benchmarks/acrobot/acrobot.h:66
            const char* doc =
R"""(Computes the mass matrix ``H(q)`` for the double pendulum system. It
turns out that for this system the mass matrix is independent of the
shoulder angle ``theta1``.)""";
          } CalcMassMatrix;
          // Symbol: drake::multibody::benchmarks::Acrobot::CalcPotentialEnergy
          struct /* CalcPotentialEnergy */ {
            // Source: drake/multibody/benchmarks/acrobot/acrobot.h:165
            const char* doc =
R"""(Computes the total potential energy due to gravity of the acrobot
system for the state given by angles ``theta1`` and ``theta2``. The
zero potential energy is defined for ``y = 0``.)""";
          } CalcPotentialEnergy;
        } Acrobot;
        // Symbol: drake::multibody::benchmarks::MassDamperSpringAnalyticalSolution
        struct /* MassDamperSpringAnalyticalSolution */ {
          // Source: drake/multibody/benchmarks/mass_damper_spring/mass_damper_spring_analytical_solution.h:28
          const char* doc =
R"""(This class provides an analytical solution to a mass-damper-spring
system. The system consists of a particle Q of mass m that can only
move left/right on flat Earth (frame N). Particle Q is connected by an
ideal translational spring/damper. The other end of the spring/damper
is welded to point No (the origin of frame N). Q's position from No is
x*Nx where x(t) is a time- dependent variable (to-be-calculated) and
Nx is a horizontal unit vector fixed in Earth (N). The spring force on
Q is -k*x*Nx, where k is a spring constant. The damper force on Q is
-b*ẋ*Nx where b is a damper constant and ẋ is the time-derivative of
x.

Note:
    All units must be self-consistent (e.g., standard SI with MKS
    units). The solution provided herein is also applicable to a
    rotating system, e.g., having rigid-body inertia, rotational
    damper, rotational spring.)""";
          // Symbol: drake::multibody::benchmarks::MassDamperSpringAnalyticalSolution::CalculateOutput
          struct /* CalculateOutput */ {
            // Source: drake/multibody/benchmarks/mass_damper_spring/mass_damper_spring_analytical_solution.h:52
            const char* doc =
R"""(For ``this`` mass-damper-spring system, and with the given initial
values, this method calculates the values of x, ẋ, ẍ at time t.

Parameter ``t``:
    The value of time at which output is requested.

Returns:
    Three-element matrix consisting of x, ẋ, ẍ, respectively.)""";
          } CalculateOutput;
          // Symbol: drake::multibody::benchmarks::MassDamperSpringAnalyticalSolution::MassDamperSpringAnalyticalSolution<T>
          struct /* ctor */ {
            // Source: drake/multibody/benchmarks/mass_damper_spring/mass_damper_spring_analytical_solution.h:37
            const char* doc =
R"""(This constructs the aforementioned mass-damper-spring system.

Parameter ``mass``:
    Mass of system (particle Q).

Parameter ``b``:
    Linear damping constant.

Parameter ``k``:
    Linear spring constant.)""";
          } ctor;
          // Symbol: drake::multibody::benchmarks::MassDamperSpringAnalyticalSolution::SetInitialValue
          struct /* SetInitialValue */ {
            // Source: drake/multibody/benchmarks/mass_damper_spring/mass_damper_spring_analytical_solution.h:44
            const char* doc =
R"""(Sets the initial values of x and ẋ for ``this`` system.

Parameter ``x0``:
    Initial value of x (value of x at time t = 0).

Parameter ``xDt0``:
    Initial value of ẋ (value of ẋ at time t = 0).)""";
          } SetInitialValue;
          // Symbol: drake::multibody::benchmarks::MassDamperSpringAnalyticalSolution::get_x
          struct /* get_x */ {
            // Source: drake/multibody/benchmarks/mass_damper_spring/mass_damper_spring_analytical_solution.h:55
            const char* doc =
R"""(Returns x (Nx measure of Q's position from No) at time t.)""";
          } get_x;
          // Symbol: drake::multibody::benchmarks::MassDamperSpringAnalyticalSolution::get_xDt
          struct /* get_xDt */ {
            // Source: drake/multibody/benchmarks/mass_damper_spring/mass_damper_spring_analytical_solution.h:58
            const char* doc =
R"""(Returns ẋ (Nx measure of Q's velocity in N) at time t.)""";
          } get_xDt;
          // Symbol: drake::multibody::benchmarks::MassDamperSpringAnalyticalSolution::get_xDtDt
          struct /* get_xDtDt */ {
            // Source: drake/multibody/benchmarks/mass_damper_spring/mass_damper_spring_analytical_solution.h:61
            const char* doc =
R"""(Returns ẍ (Nx measure of Q's acceleration in N) at time t.)""";
          } get_xDtDt;
        } MassDamperSpringAnalyticalSolution;
        // Symbol: drake::multibody::benchmarks::acrobot
        struct /* acrobot */ {
          // Symbol: drake::multibody::benchmarks::acrobot::AcrobotParameters
          struct /* AcrobotParameters */ {
            // Source: drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:25
            const char* doc =
R"""(This class is used to store the numerical parameters defining the
model of an acrobot with the method MakeAcrobotPlant(). Refer to this
the documentation of this class's constructor for further details on
the parameters stored by this class and their default values.

Note:
    The default constructor initializes the parameters in accordance
    to the ``acrobot.sdf`` file in this same directory. Therefore this
    file and ``acrobot.sdf`` MUST be kept in sync.)""";
            // Symbol: drake::multibody::benchmarks::acrobot::AcrobotParameters::AcrobotParameters
            struct /* ctor */ {
              // Source: drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:59
              const char* doc =
R"""(Constructor used to initialize the physical parameters for an acrobot
model. The parameters are defaulted to values in Spong's paper [Spong
1994].

Parameter ``m1``:
    Mass of link 1 (kg).

Parameter ``m2``:
    Mass of link 2 (kg).

Parameter ``l1``:
    Length of link 1 (m).

Parameter ``l2``:
    Length of link 2 (m).

Parameter ``lc1``:
    Vertical distance from shoulder joint to center of mass of link 1
    (m).

Parameter ``lc2``:
    Vertical distance from elbow joint to center of mass of link 2
    (m).

Parameter ``Ic1``:
    Inertia of link 1 about the center of mass of link 1 (kg⋅m²).

Parameter ``Ic2``:
    Inertia of link 2 about the center of mass of link 2 (kg*m^2).

Parameter ``b1``:
    Damping coefficient of the shoulder joint (N⋅m⋅s).

Parameter ``b2``:
    Damping coefficient of the elbow joint (N⋅m⋅s).

Parameter ``g``:
    Gravitational constant (m/s²).

- [Spong 1994] Spong, M.W., 1994. Swing up control of the acrobot. In
Robotics and Automation, 1994. Proceedings., 1994 IEEE International
Conference on (pp. 2356-2361). IEEE.)""";
            } ctor;
            // Symbol: drake::multibody::benchmarks::acrobot::AcrobotParameters::Gc1
            struct /* Gc1 */ {
              // Source: drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:95
              const char* doc = R"""()""";
            } Gc1;
            // Symbol: drake::multibody::benchmarks::acrobot::AcrobotParameters::Gc2
            struct /* Gc2 */ {
              // Source: drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:96
              const char* doc = R"""()""";
            } Gc2;
            // Symbol: drake::multibody::benchmarks::acrobot::AcrobotParameters::Ic1
            struct /* Ic1 */ {
              // Source: drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:93
              const char* doc = R"""()""";
            } Ic1;
            // Symbol: drake::multibody::benchmarks::acrobot::AcrobotParameters::Ic2
            struct /* Ic2 */ {
              // Source: drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:94
              const char* doc = R"""()""";
            } Ic2;
            // Symbol: drake::multibody::benchmarks::acrobot::AcrobotParameters::actuator_name
            struct /* actuator_name */ {
              // Source: drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:115
              const char* doc = R"""()""";
            } actuator_name;
            // Symbol: drake::multibody::benchmarks::acrobot::AcrobotParameters::b1
            struct /* b1 */ {
              // Source: drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:97
              const char* doc = R"""()""";
            } b1;
            // Symbol: drake::multibody::benchmarks::acrobot::AcrobotParameters::b2
            struct /* b2 */ {
              // Source: drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:98
              const char* doc = R"""()""";
            } b2;
            // Symbol: drake::multibody::benchmarks::acrobot::AcrobotParameters::elbow_joint_name
            struct /* elbow_joint_name */ {
              // Source: drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:112
              const char* doc = R"""()""";
            } elbow_joint_name;
            // Symbol: drake::multibody::benchmarks::acrobot::AcrobotParameters::g
            struct /* g */ {
              // Source: drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:99
              const char* doc = R"""()""";
            } g;
            // Symbol: drake::multibody::benchmarks::acrobot::AcrobotParameters::l1
            struct /* l1 */ {
              // Source: drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:89
              const char* doc = R"""()""";
            } l1;
            // Symbol: drake::multibody::benchmarks::acrobot::AcrobotParameters::l2
            struct /* l2 */ {
              // Source: drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:90
              const char* doc = R"""()""";
            } l2;
            // Symbol: drake::multibody::benchmarks::acrobot::AcrobotParameters::lc1
            struct /* lc1 */ {
              // Source: drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:91
              const char* doc = R"""()""";
            } lc1;
            // Symbol: drake::multibody::benchmarks::acrobot::AcrobotParameters::lc2
            struct /* lc2 */ {
              // Source: drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:92
              const char* doc = R"""()""";
            } lc2;
            // Symbol: drake::multibody::benchmarks::acrobot::AcrobotParameters::link1_name
            struct /* link1_name */ {
              // Source: drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:107
              const char* doc = R"""()""";
            } link1_name;
            // Symbol: drake::multibody::benchmarks::acrobot::AcrobotParameters::link2_name
            struct /* link2_name */ {
              // Source: drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:108
              const char* doc = R"""()""";
            } link2_name;
            // Symbol: drake::multibody::benchmarks::acrobot::AcrobotParameters::m1
            struct /* m1 */ {
              // Source: drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:87
              const char* doc = R"""()""";
            } m1;
            // Symbol: drake::multibody::benchmarks::acrobot::AcrobotParameters::m2
            struct /* m2 */ {
              // Source: drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:88
              const char* doc = R"""()""";
            } m2;
            // Symbol: drake::multibody::benchmarks::acrobot::AcrobotParameters::r1
            struct /* r1 */ {
              // Source: drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:103
              const char* doc = R"""()""";
            } r1;
            // Symbol: drake::multibody::benchmarks::acrobot::AcrobotParameters::r2
            struct /* r2 */ {
              // Source: drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:104
              const char* doc = R"""()""";
            } r2;
            // Symbol: drake::multibody::benchmarks::acrobot::AcrobotParameters::shoulder_joint_name
            struct /* shoulder_joint_name */ {
              // Source: drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:109
              const char* doc = R"""()""";
            } shoulder_joint_name;
          } AcrobotParameters;
          // Symbol: drake::multibody::benchmarks::acrobot::MakeAcrobotPlant
          struct /* MakeAcrobotPlant */ {
            // Source: drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:157
            const char* doc =
R"""(This method makes a MultibodyPlant model of the Acrobot - a canonical
underactuated system as described in <a
href="http://underactuated.mit.edu/underactuated.html?chapter=3">Chapter
3 of Underactuated Robotics</a>.

Parameter ``default_parameters``:
    Default parameters of the model set at construction. These
    parameters include masses, link lengths, rotational inertias, etc.
    Refer to the documentation of AcrobotParameters for further
    details.

Parameter ``finalize``:
    If ``True``, MultibodyPlant::Finalize() gets called on the new
    plant.

Parameter ``scene_graph``:
    If a SceneGraph is provided with this argument, this factory
    method will register the new multibody plant to be a source for
    that geometry system and it will also register geometry for
    visualization. If this argument is omitted, no geometry will be
    registered.)""";
          } MakeAcrobotPlant;
        } acrobot;
        // Symbol: drake::multibody::benchmarks::free_body
        struct /* free_body */ {
          // Symbol: drake::multibody::benchmarks::free_body::FreeBody
          struct /* FreeBody */ {
            // Source: drake/multibody/benchmarks/free_body/free_body.h:35
            const char* doc =
R"""(The purpose of the FreeBody class is to provide the data (initial
values and gravity) and methods for calculating the exact analytical
solution for the translational and rotational motion of a torque-free
rigid body B with axially symmetric inertia, in a Newtonian frame
(World) N. Examples of bodies with axially symmetric inertia include
cylinders, rods or bars with a circular or square cross section and
spinning tops. Since the only external forces on B are uniform
gravitational forces, there exists an exact closed-form analytical
solution for B's motion. The closed- form rotational solution is
available since B is "torque-free", i.e., the moment of all forces
about B's mass center is zero. This class calculates the body B's
quaternion, angular velocity and angular acceleration expressed in B
(body-frame) as well as the position, velocity, acceleration of Bcm
(B's center of mass) in N (World). Algorithm from [Kane, 1983]
Sections 1.13 and 3.1, Pages 60-62 and 159-169.

- [Kane, 1983] "Spacecraft Dynamics," McGraw-Hill Book Co., New York, 1983.
  (with P. W. Likins and D. A. Levinson).  Available for free .pdf download:
  https:///ecommons.cornell.edu/handle/1813/637)""";
            // Symbol: drake::multibody::benchmarks::free_body::FreeBody::CalcAngularRates_s_p
            struct /* CalcAngularRates_s_p */ {
              // Source: drake/multibody/benchmarks/free_body/free_body.h:182
              const char* doc =
R"""(Returns angular rates associated with spin ``s`` and precession ``p``
from the analytical solution [Kane, 1983] for rotational motion
(angular velocity and quaternion) for torque-free motion of an
axis-symmetric rigid body B in a Newtonian frame (World). Kane's
solution for B's angular velocity ``wx*Bx + wy*By + wz*Bz`` is in
terms of initial values wx0, wy0, wz0 as wx = wx0 * cos(s * t) + wy0 *
sin(s * t) wy = -wx0 * sin(s * t) + wy0 * cos(s * t) wz = wz0 For more
information, see [Kane, 1983] Pages 60-62 and 159-169.

Note:
    the return value of ``s`` may be negative, zero, or positive,
    whereas the return value of ``p`` is nonnegative. The values of
    ``s`` and ``p`` are returned in units of radian/second.

- [Kane, 1983] "Spacecraft Dynamics," McGraw-Hill Book Co., New York,
  1983. (with P. W. Likins and D. A. Levinson).  Available for free .pdf
  download: https:///ecommons.cornell.edu/handle/1813/637)""";
            } CalcAngularRates_s_p;
            // Symbol: drake::multibody::benchmarks::free_body::FreeBody::CalcInitial_v_NBcm_N
            struct /* CalcInitial_v_NBcm_N */ {
              // Source: drake/multibody/benchmarks/free_body/free_body.h:95
              const char* doc = R"""()""";
            } CalcInitial_v_NBcm_N;
            // Symbol: drake::multibody::benchmarks::free_body::FreeBody::CalcInitial_w_NB_N
            struct /* CalcInitial_w_NB_N */ {
              // Source: drake/multibody/benchmarks/free_body/free_body.h:85
              const char* doc = R"""()""";
            } CalcInitial_w_NB_N;
            // Symbol: drake::multibody::benchmarks::free_body::FreeBody::CalculateExactRotationalSolutionNB
            struct /* CalculateExactRotationalSolutionNB */ {
              // Source: drake/multibody/benchmarks/free_body/free_body.h:149
              const char* doc =
R"""(Calculates exact solutions for quaternion and angular velocity
expressed in body-frame, and their time derivatives for torque-free
rotational motion of axis-symmetric rigid body B in Newtonian frame
(World) N, where torque-free means the moment of forces about B's mass
center is zero. The quaternion characterizes the orientation between
right-handed orthogonal unit vectors Nx, Ny, Nz fixed in N and
right-handed orthogonal unit vectors Bx, By, Bz fixed in B, where Bz
is parallel to B's symmetry axis.

Note:
    CalculateExactRotationalSolutionABInitiallyAligned() implements
    the algorithm from [Kane, 1983] Sections 1.13 and 3.1, Pages 60-62
    and 159-169.

Parameter ``t``:
    Current value of time.

Returns:
    Machine-precision values at time t are returned as defined below.

Note:
    This function allows for initial misalignment of Nx, Ny, Nz and
    Bx, By, Bz.

std::tuple | Description
-----------|------------------------------------------------- quat_NB
| Quaternion relating frame N to frame B: [e0, e1, e2, e3] | Note:
quat_NB is analogous to the rotation matrix R_NB. quatDt |
Time-derivative of `quat_NB', i.e., [ė0, ė1, ė2, ė3]. w_NB_B | B's
angular velocity in N, expressed in B. alpha_NB_B | B's angular
acceleration in N, expressed in B.

- [Kane, 1983] "Spacecraft Dynamics," McGraw-Hill Book Co., New York,
  1983. (with P. W. Likins and D. A. Levinson).  Available for free .pdf
  download: https:///ecommons.cornell.edu/handle/1813/637)""";
            } CalculateExactRotationalSolutionNB;
            // Symbol: drake::multibody::benchmarks::free_body::FreeBody::CalculateExactTranslationalSolution
            struct /* CalculateExactTranslationalSolution */ {
              // Source: drake/multibody/benchmarks/free_body/free_body.h:164
              const char* doc =
R"""(Calculates exact solutions for translational motion of an arbitrary
rigid body B in a Newtonian frame (world) N. Algorithm from
high-school physics.

Parameter ``t``:
    Current value of time.

Returns:
    Machine-precision values at time t are returned as defined below.

std::tuple | Description
-----------|-----------------------------------------------------------
xyz | Vector3d [x, y, z], Bcm's position from No, expressed in N.
xyzDt | Vector3d [ẋ, ẏ, ż] Bcm's velocity in N, expressed in N.
xyzDDt | Vector3d [ẍ ÿ z̈], Bcm's acceleration in N, expressed in N.)""";
            } CalculateExactTranslationalSolution;
            // Symbol: drake::multibody::benchmarks::free_body::FreeBody::FreeBody
            struct /* ctor */ {
              // Source: drake/multibody/benchmarks/free_body/free_body.h:53
              const char* doc =
R"""(Constructs a class that can be queried for exact values of
orientation, position, and motion of a torque-free rigid body at time
t.

Parameter ``initial_quat_NB``:
    Value at time t = 0 of the quaternion relating right-handed
    orthonormal vectors Nx, Ny, Nz fixed in N (world) to right-handed
    orthonormal unit vectors Bx, By, Bz fixed in B (body). Note: The
    unit vector Bz is parallel to body B's symmetry axis. Note: The
    quaternion should already be normalized before it is passed.

Parameter ``initial_W_NB_B``:
    Value at time t = 0 of the angular velocity in N of body B,
    expressed in N.

Parameter ``initial_p_NoBcm_N``:
    Value at time t = 0 of the position vector from No (origin of
    world N) to Bcm (B's center of mass), expressed in N.

Parameter ``initial_v_NBcm_N``:
    Value at time t = 0 of the velocity in N of Bcm (B's center of
    mass), expressed in N.

Parameter ``gravity_N``:
    Local gravitational acceleration, expressed in N.)""";
            } ctor;
            // Symbol: drake::multibody::benchmarks::free_body::FreeBody::SetUniformGravityExpressedInWorld
            struct /* SetUniformGravityExpressedInWorld */ {
              // Source: drake/multibody/benchmarks/free_body/free_body.h:113
              const char* doc = R"""()""";
            } SetUniformGravityExpressedInWorld;
            // Symbol: drake::multibody::benchmarks::free_body::FreeBody::get_I
            struct /* get_I */ {
              // Source: drake/multibody/benchmarks/free_body/free_body.h:71
              const char* doc =
R"""(Returns body B's moment of inertia about any axis that passes through
Bcm (B's center of mass) and is perpendicular to B's inertia symmetry
axis. For example, for a cylinder of radius r, length h and uniformly
distributed mass m with its cylindrical axis aligned along its body
frame z-axis this would be: I = Ixx = Iyy = m / 12 (3 r² + h²))""";
            } get_I;
            // Symbol: drake::multibody::benchmarks::free_body::FreeBody::get_J
            struct /* get_J */ {
              // Source: drake/multibody/benchmarks/free_body/free_body.h:78
              const char* doc =
R"""(Returns body's moment of inertia about the axis that passes through
Bcm (B's center of mass) and is parallel to B's inertia symmetry axis.
For example, for a cylinder of radius r, length h and uniformly
distributed mass m with its cylindrical axis aligned along its body
frame z-axis this would be: J = Izz = m r² / 2)""";
            } get_J;
            // Symbol: drake::multibody::benchmarks::free_body::FreeBody::get_initial_p_NoBcm_N
            struct /* get_initial_p_NoBcm_N */ {
              // Source: drake/multibody/benchmarks/free_body/free_body.h:89
              const char* doc = R"""()""";
            } get_initial_p_NoBcm_N;
            // Symbol: drake::multibody::benchmarks::free_body::FreeBody::get_initial_quat_NB
            struct /* get_initial_quat_NB */ {
              // Source: drake/multibody/benchmarks/free_body/free_body.h:81
              const char* doc = R"""()""";
            } get_initial_quat_NB;
            // Symbol: drake::multibody::benchmarks::free_body::FreeBody::get_initial_w_NB_B
            struct /* get_initial_w_NB_B */ {
              // Source: drake/multibody/benchmarks/free_body/free_body.h:84
              const char* doc = R"""()""";
            } get_initial_w_NB_B;
            // Symbol: drake::multibody::benchmarks::free_body::FreeBody::get_uniform_gravity_expressed_in_world
            struct /* get_uniform_gravity_expressed_in_world */ {
              // Source: drake/multibody/benchmarks/free_body/free_body.h:92
              const char* doc = R"""()""";
            } get_uniform_gravity_expressed_in_world;
            // Symbol: drake::multibody::benchmarks::free_body::FreeBody::set_initial_p_NoBcm_N
            struct /* set_initial_p_NoBcm_N */ {
              // Source: drake/multibody/benchmarks/free_body/free_body.h:107
              const char* doc = R"""()""";
            } set_initial_p_NoBcm_N;
            // Symbol: drake::multibody::benchmarks::free_body::FreeBody::set_initial_quat_NB
            struct /* set_initial_quat_NB */ {
              // Source: drake/multibody/benchmarks/free_body/free_body.h:101
              const char* doc = R"""()""";
            } set_initial_quat_NB;
            // Symbol: drake::multibody::benchmarks::free_body::FreeBody::set_initial_v_NBcm_B
            struct /* set_initial_v_NBcm_B */ {
              // Source: drake/multibody/benchmarks/free_body/free_body.h:110
              const char* doc = R"""()""";
            } set_initial_v_NBcm_B;
            // Symbol: drake::multibody::benchmarks::free_body::FreeBody::set_initial_w_NB_B
            struct /* set_initial_w_NB_B */ {
              // Source: drake/multibody/benchmarks/free_body/free_body.h:104
              const char* doc = R"""()""";
            } set_initial_w_NB_B;
          } FreeBody;
        } free_body;
        // Symbol: drake::multibody::benchmarks::inclined_plane
        struct /* inclined_plane */ {
          // Symbol: drake::multibody::benchmarks::inclined_plane::AddInclinedPlaneAndGravityToPlant
          struct /* AddInclinedPlaneAndGravityToPlant */ {
            // Source: drake/multibody/benchmarks/inclined_plane/inclined_plane_plant.h:49
            const char* doc =
R"""(Creates an inclined plane A and adds it to an existing plant.

See also:
    inclined_plane_parameters "Description of parameters")""";
          } AddInclinedPlaneAndGravityToPlant;
          // Symbol: drake::multibody::benchmarks::inclined_plane::AddInclinedPlaneWithBlockToPlant
          struct /* AddInclinedPlaneWithBlockToPlant */ {
            // Source: drake/multibody/benchmarks/inclined_plane/inclined_plane_plant.h:64
            const char* doc =
R"""(Creates an inclined plane A and a uniform-density block (body B),
optionally with 4 spheres welded to it, and adds them to an existing
plant.

Parameter ``block_dimensions``:
    Dimensions (lengths) of block in the Bx, By, Bz directions
    (meters). To be valid data, these dimensions must be positive.

Parameter ``is_block_with_4Spheres``:
    This flag is ``True`` if block B's contact with inclined plane A
    is modeled using 4 identical massless spheres welded to the block
    B's four "bottom" corners, whereas this flag is `false`if block
    B's contact is modeled with a block (box).

See also:
    inclined_plane_parameters "Description of other parameters")""";
          } AddInclinedPlaneWithBlockToPlant;
          // Symbol: drake::multibody::benchmarks::inclined_plane::AddInclinedPlaneWithSphereToPlant
          struct /* AddInclinedPlaneWithSphereToPlant */ {
            // Source: drake/multibody/benchmarks/inclined_plane/inclined_plane_plant.h:78
            const char* doc =
R"""(Creates an inclined plane A and a uniform-density sphere (body B) and
adds them to an existing plant.

Parameter ``radiusB``:
    The radius of sphere B (meters), which must be positive.

See also:
    inclined_plane_parameters "Description of other parameters"

Note:
    Decorative visual geometry is added to the sphere to facilitate
    visualizing the sphere's rotation.)""";
          } AddInclinedPlaneWithSphereToPlant;
        } inclined_plane;
        // Symbol: drake::multibody::benchmarks::kuka_iiwa_robot
        struct /* kuka_iiwa_robot */ {
          // Symbol: drake::multibody::benchmarks::kuka_iiwa_robot::MakeKukaIiwaModel
          struct /* MakeKukaIiwaModel */ {
            // Source: drake/multibody/benchmarks/kuka_iiwa_robot/make_kuka_iiwa_model.h:159
            const char* doc =
R"""(This method makes a MultibodyTree model for a Kuka Iiwa arm as
specified in the file kuka_iiwa_robot.urdf contained in this same
directory. Links can be accessed by their name "iiwa_link_1" (base)
through "iiwa_link_7" (end effector). The "world" body can be accessed
with MultibodyTree::world_body(). Joints can be accessed by their name
"iiwa_joint_1" (from the base) through "iiwa_joint_7" (to the end
effector). The new MultibodyTree model is finalized by
MultibodyTree::Finalize() and therefore no more modeling elements can
be added.

Parameter ``finalize_model``:
    If ``True``, the model is finalized with
    MultibodyTree::Finalize(). A non-finalized model can be requested
    if adding more multibody elements is desired.

Parameter ``gravity``:
    The value of the acceleration of gravity, in m/s².)""";
          } MakeKukaIiwaModel;
        } kuka_iiwa_robot;
        // Symbol: drake::multibody::benchmarks::pendulum
        struct /* pendulum */ {
          // Symbol: drake::multibody::benchmarks::pendulum::MakePendulumPlant
          struct /* MakePendulumPlant */ {
            // Source: drake/multibody/benchmarks/pendulum/make_pendulum_plant.h:103
            const char* doc =
R"""(This method makes a MultibodyPlant model of an idealized pendulum with
a point mass at the end of a massless rigid rod. The pendulum
oscillates in the x-z plane with its revolute axis coincident with the
y-axis. Gravity points downwards in the -z axis direction.

The parameters of the plant are:

- mass: the mass of the idealized point mass.
- length: the length of the massless rod on which the mass is suspended.
- gravity: the acceleration of gravity.

The simple pendulum is a canonical dynamical system as described in <a
href="http://underactuated.csail.mit.edu/underactuated.html?chapter=pend">
Chapter 2 of Underactuated Robotics</a>.

Parameter ``default_parameters``:
    Default parameters of the model set at construction. Refer to the
    documentation of PendulumParameters for further details.

Parameter ``scene_graph``:
    If a SceneGraph is provided with this argument, this factory
    method will register the new multibody plant to be a source for
    that geometry system and it will also register geometry for
    visualization. If this argument is omitted, no geometry will be
    registered.)""";
          } MakePendulumPlant;
          // Symbol: drake::multibody::benchmarks::pendulum::PendulumParameters
          struct /* PendulumParameters */ {
            // Source: drake/multibody/benchmarks/pendulum/make_pendulum_plant.h:21
            const char* doc =
R"""(This class is used to store the numerical parameters defining the
model of a simple pendulum with the method MakePendulumPlant(). Refer
to this the documentation of this class's constructor for further
details on the parameters stored by this class and their default
values.)""";
            // Symbol: drake::multibody::benchmarks::pendulum::PendulumParameters::PendulumParameters
            struct /* ctor */ {
              // Source: drake/multibody/benchmarks/pendulum/make_pendulum_plant.h:36
              const char* doc =
R"""(Constructor used to initialize the physical parameters for a simple
pendulum model.

Parameter ``mass``:
    Value of the mass of the pendulum's point mass [kg].

Parameter ``length``:
    Length of the massless rod connecting the point mass to the world
    [m].

Parameter ``damping``:
    The joint's damping in N⋅m⋅s.

Parameter ``gravity``:
    Gravitational constant (m/s²).)""";
            } ctor;
            // Symbol: drake::multibody::benchmarks::pendulum::PendulumParameters::actuator_name
            struct /* actuator_name */ {
              // Source: drake/multibody/benchmarks/pendulum/make_pendulum_plant.h:59
              const char* doc = R"""()""";
            } actuator_name;
            // Symbol: drake::multibody::benchmarks::pendulum::PendulumParameters::body_name
            struct /* body_name */ {
              // Source: drake/multibody/benchmarks/pendulum/make_pendulum_plant.h:57
              const char* doc = R"""()""";
            } body_name;
            // Symbol: drake::multibody::benchmarks::pendulum::PendulumParameters::damping
            struct /* damping */ {
              // Source: drake/multibody/benchmarks/pendulum/make_pendulum_plant.h:49
              const char* doc = R"""()""";
            } damping;
            // Symbol: drake::multibody::benchmarks::pendulum::PendulumParameters::g
            struct /* g */ {
              // Source: drake/multibody/benchmarks/pendulum/make_pendulum_plant.h:50
              const char* doc = R"""()""";
            } g;
            // Symbol: drake::multibody::benchmarks::pendulum::PendulumParameters::l
            struct /* l */ {
              // Source: drake/multibody/benchmarks/pendulum/make_pendulum_plant.h:48
              const char* doc = R"""()""";
            } l;
            // Symbol: drake::multibody::benchmarks::pendulum::PendulumParameters::m
            struct /* m */ {
              // Source: drake/multibody/benchmarks/pendulum/make_pendulum_plant.h:47
              const char* doc = R"""()""";
            } m;
            // Symbol: drake::multibody::benchmarks::pendulum::PendulumParameters::massless_rod_radius
            struct /* massless_rod_radius */ {
              // Source: drake/multibody/benchmarks/pendulum/make_pendulum_plant.h:54
              const char* doc = R"""()""";
            } massless_rod_radius;
            // Symbol: drake::multibody::benchmarks::pendulum::PendulumParameters::pin_joint_name
            struct /* pin_joint_name */ {
              // Source: drake/multibody/benchmarks/pendulum/make_pendulum_plant.h:58
              const char* doc = R"""()""";
            } pin_joint_name;
            // Symbol: drake::multibody::benchmarks::pendulum::PendulumParameters::point_mass_radius
            struct /* point_mass_radius */ {
              // Source: drake/multibody/benchmarks/pendulum/make_pendulum_plant.h:52
              const char* doc = R"""()""";
            } point_mass_radius;
          } PendulumParameters;
        } pendulum;
      } benchmarks;
      // Symbol: drake::multibody::constraint
      struct /* constraint */ {
        // Symbol: drake::multibody::constraint::ConstraintAccelProblemData
        struct /* ConstraintAccelProblemData */ {
          // Source: drake/multibody/constraint/constraint_problem_data.h:35
          const char* doc =
R"""(Structure for holding constraint data for computing forces due to
constraints and the resulting multibody accelerations.

The Newton-Euler equations (essentially F = ma) coupled with
constraints on the positional coordinates g(q) yields an Index-3 DAE
(see [Hairer 1996]), and generally makes initial value problems hard
to solve, computationally speaking; coupling the Newton-Euler
equations with the second time derivative of such constraint equations
(i.e., g̈(q,v,v̇)) yields a far more manageable Index-1 DAE, again
with regard to computation. This structure stores problem data for
computing dynamics under such constraints and others (nonholonomic
constraints, Coulomb friction constraints, etc.)

**Definition of variables specific to this class**

(See constraint_variable_defs) for the more general set of
definitions).

- ns ∈ ℕ   The number of contacts at which sliding is occurring. Note
           that nc = ns + nns, where nc is the number of points of contact.
- nns ∈ ℕ   The number of contacts at which sliding is not occurring. Note
           that nc = ns + nns.)""";
          // Symbol: drake::multibody::constraint::ConstraintAccelProblemData::ConstraintAccelProblemData<T>
          struct /* ctor */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:38
            const char* doc =
R"""(Constructs acceleration problem data for a system with a ``gv_dim``
dimensional generalized velocity.)""";
          } ctor;
          // Symbol: drake::multibody::constraint::ConstraintAccelProblemData::F_mult
          struct /* F_mult */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:220
            const char* doc =
R"""(An operator that performs the multiplication F⋅v. The default operator
returns an empty vector.)""";
          } F_mult;
          // Symbol: drake::multibody::constraint::ConstraintAccelProblemData::F_transpose_mult
          struct /* F_transpose_mult */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:225
            const char* doc =
R"""(An operator that performs the multiplication Fᵀ⋅f, where f ∈ ℝⁿⁿˢʳ
corresponds to frictional force magnitudes. The default operator
returns a zero vector of dimension equal to that of the generalized
forces.)""";
          } F_transpose_mult;
          // Symbol: drake::multibody::constraint::ConstraintAccelProblemData::G_mult
          struct /* G_mult */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:129
            const char* doc =
R"""(An operator that performs the multiplication G⋅v. The default operator
returns an empty vector.)""";
          } G_mult;
          // Symbol: drake::multibody::constraint::ConstraintAccelProblemData::G_transpose_mult
          struct /* G_transpose_mult */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:134
            const char* doc =
R"""(An operator that performs the multiplication Gᵀ⋅f where f ∈ ℝⁿᵇ are
the magnitudes of the constraint forces. The default operator returns
a zero vector of dimension equal to that of the generalized forces.)""";
          } G_transpose_mult;
          // Symbol: drake::multibody::constraint::ConstraintAccelProblemData::L_mult
          struct /* L_mult */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:262
            const char* doc =
R"""(An operator that performs the multiplication L⋅v. The default operator
returns an empty vector.)""";
          } L_mult;
          // Symbol: drake::multibody::constraint::ConstraintAccelProblemData::L_transpose_mult
          struct /* L_transpose_mult */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:267
            const char* doc =
R"""(An operator that performs the multiplication Lᵀ⋅f where f ∈ ℝⁿᵘ are
the magnitudes of the constraint forces. The default operator returns
a zero vector of dimension equal to that of the generalized forces.)""";
          } L_transpose_mult;
          // Symbol: drake::multibody::constraint::ConstraintAccelProblemData::N_minus_muQ_transpose_mult
          struct /* N_minus_muQ_transpose_mult */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:182
            const char* doc =
R"""(An operator that performs the multiplication (Nᵀ - μQᵀ)⋅f, where μ is
a diagonal matrix with nonzero entries corresponding to the
coefficients of friction at the s sliding contact points, and (Nᵀ -
μQᵀ) transforms forces (f ∈ ℝⁿᶜ) applied along the contact normals at
the nc point contacts into generalized forces. The default operator
returns a zero vector of dimension equal to that of the generalized
forces.)""";
          } N_minus_muQ_transpose_mult;
          // Symbol: drake::multibody::constraint::ConstraintAccelProblemData::N_mult
          struct /* N_mult */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:174
            const char* doc =
R"""(An operator that performs the multiplication N⋅v. The default operator
returns an empty vector.)""";
          } N_mult;
          // Symbol: drake::multibody::constraint::ConstraintAccelProblemData::kF
          struct /* kF */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:228
            const char* doc =
R"""(This ℝⁿⁿˢʳ vector is the vector kᶠ(t,q,v) defined above.)""";
          } kF;
          // Symbol: drake::multibody::constraint::ConstraintAccelProblemData::kG
          struct /* kG */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:137
            const char* doc =
R"""(This ℝⁿᵇ vector is the vector kᴳ(t,q,v) defined above.)""";
          } kG;
          // Symbol: drake::multibody::constraint::ConstraintAccelProblemData::kL
          struct /* kL */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:270
            const char* doc =
R"""(This ℝⁿᵘ vector is the vector kᴸ(t,q,v) defined above.)""";
          } kL;
          // Symbol: drake::multibody::constraint::ConstraintAccelProblemData::kN
          struct /* kN */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:185
            const char* doc =
R"""(This ℝⁿᶜ vector is the vector kᴺ(t,q,v) defined above.)""";
          } kN;
          // Symbol: drake::multibody::constraint::ConstraintAccelProblemData::mu_non_sliding
          struct /* mu_non_sliding */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:101
            const char* doc =
R"""(Coefficients of friction for the nns = nc - ns non-sliding contacts
(where ``ns`` is the number of sliding contacts). The size of this
vector should be equal to ``non_sliding_contacts.size()``.)""";
          } mu_non_sliding;
          // Symbol: drake::multibody::constraint::ConstraintAccelProblemData::mu_sliding
          struct /* mu_sliding */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:96
            const char* doc =
R"""(Coefficients of friction for the ns = nc - nns sliding contacts (where
``nns`` is the number of non-sliding contacts). The size of this
vector should be equal to ``sliding_contacts.size()``.)""";
          } mu_sliding;
          // Symbol: drake::multibody::constraint::ConstraintAccelProblemData::non_sliding_contacts
          struct /* non_sliding_contacts */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:79
            const char* doc =
R"""(The indices of the non-sliding contacts (those contacts at which there
is zero relative velocity between bodies in the plane tangent to the
point of contact), out of the set of all contact indices (0...nc-1).
This vector must be in sorted order.)""";
          } non_sliding_contacts;
          // Symbol: drake::multibody::constraint::ConstraintAccelProblemData::r
          struct /* r */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:91
            const char* doc =
R"""(The number of spanning vectors in the contact tangents (used to
linearize the friction cone) at the n *non-sliding* contact points.
For contact problems in two dimensions, each element of r will be one.
For contact problems in three dimensions, a friction pyramid (for
example), for a contact point i will have rᵢ = 2. [Anitescu 1997]
define k such vectors and require that, for each vector w in the
spanning set, -w also exists in the spanning set. The
RigidContactAccelProblemData structure expects that the contact
solving mechanism negates the spanning vectors so ``r`` = k/2 spanning
vectors will correspond to a k-edge polygon friction cone
approximation.)""";
          } r;
          // Symbol: drake::multibody::constraint::ConstraintAccelProblemData::sliding_contacts
          struct /* sliding_contacts */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:73
            const char* doc =
R"""(The indices of the sliding contacts (those contacts at which there is
non-zero relative velocity between bodies in the plane tangent to the
point of contact), out of the set of all contact indices (0...nc-1).
This vector must be in sorted order.)""";
          } sliding_contacts;
          // Symbol: drake::multibody::constraint::ConstraintAccelProblemData::solve_inertia
          struct /* solve_inertia */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:283
            const char* doc =
R"""(A function for solving the equation MX = B for matrix X, given input
matrix B, where M is the generalized inertia matrix for the rigid body
system.)""";
          } solve_inertia;
          // Symbol: drake::multibody::constraint::ConstraintAccelProblemData::tau
          struct /* tau */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:278
            const char* doc =
R"""(The ℝⁿᵛ vector tau, the generalized external force vector that
comprises gravitational, centrifugal, Coriolis, actuator, etc. forces
applied to the rigid body system at q. m is the dimension of the
generalized force, which is also equal to the dimension of the
generalized velocity.)""";
          } tau;
          // Symbol: drake::multibody::constraint::ConstraintAccelProblemData::use_complementarity_problem_solver
          struct /* use_complementarity_problem_solver */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:67
            const char* doc =
R"""(Flag for whether the complementarity problem solver should be used to
solve this particular problem instance. If every constraint in the
problem data is active, using the linear system solver
(``use_complementarity_problem_solver=false``) will yield a solution
much more quickly. If it is unknown whether every constraint is
active, the complementarity problem solver should be used; otherwise,
the inequality constraints embedded in the problem data may not be
satisfied. The safe (and slower) value of ``True`` is the default.)""";
          } use_complementarity_problem_solver;
        } ConstraintAccelProblemData;
        // Symbol: drake::multibody::constraint::ConstraintSolver
        struct /* ConstraintSolver */ {
          // Source: drake/multibody/constraint/constraint_solver.h:69
          const char* doc =
R"""(Solves constraint problems for constraint forces. Specifically, given
problem data corresponding to a rigid or multi-body system constrained
bilaterally and/or unilaterally and acted upon by friction, this class
computes the constraint forces.

This problem can be formulated as a mixed linear complementarity
problem (MLCP)- for 2D problems with Coulomb friction or 3D problems
without Coulomb friction- or a mixed complementarity problem (for 3D
problems with Coulomb friction). We use a polygonal approximation (of
selectable accuracy) to the friction cone, which yields a MLCP in all
cases.

Existing algorithms for solving MLCPs, which are based upon algorithms
for solving "pure" linear complementarity problems (LCPs), solve
smaller classes of problems than the corresponding LCP versions. For
example, Lemke's Algorithm, which is provably able to solve the
impacting problems covered by this class, can solve LCPs with
copositive matrices [Cottle 1992] but MLCPs with only positive
semi-definite matrices (the latter is a strict subset of the former)
[Sargent 1978].

Rather than using one of these MLCP algorithms, we instead transform
the problem into a pure LCP by first solving for the bilateral
constraint forces. This method yields an implication of which the user
should be aware. Bilateral constraint forces are computed before
unilateral constraint forces: the constraint forces will not be evenly
distributed between bilateral and unilateral constraints (assuming
such a distribution were even possible).

For the normal case of unilateral constraints admitting degrees of
freedom, the solution methods in this class support "softening" of the
constraints, as described in [Lacoursiere 2007] via the constraint
force mixing (CFM) and error reduction parameter (ERP) parameters that
are now ubiquitous in game multi-body dynamics simulation libraries.

- [Cottle 1992]   R. W. Cottle, J.-S. Pang, and R. E. Stone. The Linear
                  Complementarity Problem. SIAM Classics in Applied
                  Mathematics, 1992.
- [Judice 1992]   J. J. Judice, J. Machado, and A. Faustino. An extension of
                  the Lemke's method for the solution of a generalized
                  linear complementarity problem. In System Modeling and
                  Optimization (Lecture Notes in Control and Information
                  Sciences), Springer-Verlag, 1992.
- [Lacoursiere 2007]  C. Lacoursiere. Ghosts and Machines: Regularized
                      Variational Methods for Interactive Simulations of
                      Multibodies with Dry Frictional Contacts.
                      Ph. D. thesis (Umea University), 2007.
- [Sargent 1978]  R. W. H. Sargent. An efficient implementation of the Lemke
                  Algorithm and its extension to deal with upper and lower
                  bounds. Mathematical Programming Study, 7, 1978.)""";
          // Symbol: drake::multibody::constraint::ConstraintSolver::CalcContactForcesInContactFrames
          struct /* CalcContactForcesInContactFrames */ {
            // Source: drake/multibody/constraint/constraint_solver.h:546
            const char* doc_was_unable_to_choose_unambiguous_names =
R"""(Gets the contact forces expressed in each contact frame *for 2D
contact problems* from the "packed" solution returned by
SolveConstraintProblem().

Parameter ``cf``:
    the output from SolveConstraintProblem()

Parameter ``problem_data``:
    the problem data input to SolveConstraintProblem()

Parameter ``contact_frames``:
    the contact frames corresponding to the contacts. The first column
    of each matrix should give the contact normal, while the second
    column gives a contact tangent. For sliding contacts, the contact
    tangent should point along the direction of sliding. For
    non-sliding contacts, the tangent direction should be that used to
    determine ``problem_data.F``. All vectors should be expressed in
    the global frame.

Parameter ``contact_forces``:
    a non-null vector of a doublet of values, where the iᵗʰ element
    represents the force along each basis vector in the iᵗʰ contact
    frame.

Raises:
    RuntimeError if ``contact_forces`` is null, if ``contact_forces``
    is not empty, if ``cf`` is not the proper size, if the number of
    tangent directions is not one per non-sliding contact (indicating
    that the contact problem might not be 2D), if the number of
    contact frames is not equal to the number of contacts, or if a
    contact frame does not appear to be orthonormal.

Note:
    On return, the contact force at the iᵗʰ contact point expressed in
    the world frame is ``contact_frames[i]`` * ``contact_forces[i]``.)""";
          } CalcContactForcesInContactFrames;
          // Symbol: drake::multibody::constraint::ConstraintSolver::ComputeGeneralizedAcceleration
          struct /* ComputeGeneralizedAcceleration */ {
            // Source: drake/multibody/constraint/constraint_solver.h:455
            const char* doc_3args =
R"""(Computes the system generalized acceleration due to both external
forces and constraint forces.

Parameter ``problem_data``:
    The acceleration-level constraint data.

Parameter ``cf``:
    The computed constraint forces, in the packed storage format
    described in documentation for SolveConstraintProblem.

Parameter ``generalized_acceleration``:
    The generalized acceleration, on return.

Raises:
    RuntimeError if ``generalized_acceleration`` is null or ``cf``
    vector is incorrectly sized.)""";
            // Source: drake/multibody/constraint/constraint_solver.h:483
            const char* doc_5args =
R"""(Computes a first-order approximation of generalized acceleration due
*only* to constraint forces.

Parameter ``problem_data``:
    The velocity-level constraint data.

Parameter ``cf``:
    The computed constraint forces, in the packed storage format
    described in documentation for SolveConstraintProblem.

Parameter ``v``:
    The system generalized velocity at time t.

Parameter ``dt``:
    The discretization time constant (i.e., the "time step" for
    simulations) used to take the system's generalized velocities from
    time t to time t + ``dt``.

Parameter ``generalized_acceleration``:
    The generalized acceleration, on return. The original will be
    resized (if necessary) and overwritten.

Warning:
    This method uses the method ``problem_data.solve_inertia()`` in
    order to compute ``v(t+dt)``, so the computational demands may be
    significant.

Raises:
    RuntimeError if ``generalized_acceleration`` is null or ``cf``
    vector is incorrectly sized.

Precondition:
    ``dt`` is positive.)""";
          } ComputeGeneralizedAcceleration;
          // Symbol: drake::multibody::constraint::ConstraintSolver::ComputeGeneralizedAccelerationFromConstraintForces
          struct /* ComputeGeneralizedAccelerationFromConstraintForces */ {
            // Source: drake/multibody/constraint/constraint_solver.h:496
            const char* doc =
R"""(Computes the system generalized acceleration due *only* to constraint
forces.

Parameter ``cf``:
    The computed constraint forces, in the packed storage format
    described in documentation for SolveConstraintProblem.

Raises:
    RuntimeError if ``generalized_acceleration`` is null or ``cf``
    vector is incorrectly sized.)""";
          } ComputeGeneralizedAccelerationFromConstraintForces;
          // Symbol: drake::multibody::constraint::ConstraintSolver::ComputeGeneralizedForceFromConstraintForces
          struct /* ComputeGeneralizedForceFromConstraintForces */ {
            // Source: drake/multibody/constraint/constraint_solver.h:423
            const char* doc_was_unable_to_choose_unambiguous_names =
R"""(Computes the generalized force on the system from the constraint
forces given in packed storage.

Parameter ``problem_data``:
    The data used to compute the contact forces.

Parameter ``cf``:
    The computed constraint forces, in the packed storage format
    described in documentation for SolveConstraintProblem.

Parameter ``generalized_force``:
    The generalized force acting on the system from the total
    constraint wrench is stored here, on return. This method will
    resize ``generalized_force`` as necessary. The indices of
    ``generalized_force`` will exactly match the indices of
    ``problem_data.f``.

Raises:
    RuntimeError if ``generalized_force`` is null or ``cf`` vector is
    incorrectly sized.)""";
          } ComputeGeneralizedForceFromConstraintForces;
          // Symbol: drake::multibody::constraint::ConstraintSolver::ComputeGeneralizedVelocityChange
          struct /* ComputeGeneralizedVelocityChange */ {
            // Source: drake/multibody/constraint/constraint_solver.h:518
            const char* doc =
R"""(Computes the change to the system generalized velocity from constraint
impulses.

Parameter ``cf``:
    The computed constraint impulses, in the packed storage format
    described in documentation for SolveImpactProblem.

Raises:
    RuntimeError if ``generalized_delta_v`` is null or ``cf`` vector
    is incorrectly sized.)""";
          } ComputeGeneralizedVelocityChange;
          // Symbol: drake::multibody::constraint::ConstraintSolver::ConstraintSolver<T>
          struct /* ctor */ {
            // Source: drake/multibody/constraint/constraint_solver.h:71
            const char* doc = R"""()""";
          } ctor;
          // Symbol: drake::multibody::constraint::ConstraintSolver::ConstructBaseDiscretizedTimeLcp
          struct /* ConstructBaseDiscretizedTimeLcp */ {
            // Source: drake/multibody/constraint/constraint_solver.h:297
            const char* doc =
R"""(Computes the base time-discretization of the system using the problem
data, resulting in the ``MM`` and ``qq`` described in
velocity-level-MLCPs; if ``MM`` and ``qq`` are modified no further,
the LCP corresponds to an impact problem (i.e., the multibody dynamics
problem would not be discretized). The data output
(``mlcp_to_lcp_data``, `MM`, and ``qq``) can be updated using a
particular time step in UpdateDiscretizedTimeLcp(), resulting in a
non-impulsive problem formulation. In that case, the multibody
dynamics equations *are* discretized, as described in
UpdateDiscretizedTimeLcp().

Note:
    If you really do wish to solve an impact problem, you should use
    SolveImpactProblem() instead.

Parameter ``problem_data``:
    the constraint problem data.

Parameter ``mlcp_to_lcp_data``:
    a pointer to a valid MlcpToLcpData object; the caller must ensure
    that this pointer remains valid through the constraint solution
    process.

Parameter ``MM``:
    a pointer to a matrix that will contain the parts of the LCP
    matrix not dependent upon the time step on return.

Parameter ``qq``:
    a pointer to a vector that will contain the parts of the LCP
    vector not dependent upon the time step on return.

Precondition:
    ``mlcp_to_lcp_data``, `MM`, and ``qq`` are non-null on entry.

See also:
    UpdateDiscretizedTimeLcp())""";
          } ConstructBaseDiscretizedTimeLcp;
          // Symbol: drake::multibody::constraint::ConstraintSolver::MlcpToLcpData
          struct /* MlcpToLcpData */ {
            // Source: drake/multibody/constraint/constraint_solver.h:76
            const char* doc =
R"""(Structure used to convert a mixed linear complementarity problem to a
pure linear complementarity problem (by solving for free variables).)""";
            // Symbol: drake::multibody::constraint::ConstraintSolver::MlcpToLcpData::A_solve
            struct /* A_solve */ {
              // Source: drake/multibody/constraint/constraint_solver.h:83
              const char* doc =
R"""(A function pointer for solving linear systems using MLCP "A" matrix
(see Velocity-level-MLCPs).)""";
            } A_solve;
            // Symbol: drake::multibody::constraint::ConstraintSolver::MlcpToLcpData::delassus_QTZ
            struct /* delassus_QTZ */ {
              // Source: drake/multibody/constraint/constraint_solver.h:79
              const char* doc =
R"""(Decomposition of the Delassus matrix GM⁻¹Gᵀ, where G is the bilateral
constraint matrix and M is the system generalized inertia matrix.)""";
            } delassus_QTZ;
            // Symbol: drake::multibody::constraint::ConstraintSolver::MlcpToLcpData::fast_A_solve
            struct /* fast_A_solve */ {
              // Source: drake/multibody/constraint/constraint_solver.h:98
              const char* doc =
R"""(A function pointer for solving linear systems using only the upper
left block of A⁺ in the MLCP (see Velocity-level-MLCPs), where A⁺ is a
singularity-robust pseudo-inverse of A, toward exploiting operations
with zero blocks. For example:


::

    A⁺ | b |
       | 0 |

and


::

    A⁺ | B |
       | 0 |

where ``b ∈ ℝⁿᵛ`` is an arbitrary vector of dimension equal to the
generalized velocities and ``B ∈ ℝⁿᵛˣᵐ`` is an arbitrary matrix with
row dimension equal to the dimension of the generalized velocities and
arbitrary number of columns (denoted ``m`` here).)""";
            } fast_A_solve;
          } MlcpToLcpData;
          // Symbol: drake::multibody::constraint::ConstraintSolver::PopulatePackedConstraintForcesFromLcpSolution
          struct /* PopulatePackedConstraintForcesFromLcpSolution */ {
            // Source: drake/multibody/constraint/constraint_solver.h:376
            const char* doc =
R"""(Populates the packed constraint force vector from the solution to the
linear complementarity problem (LCP) constructed using
ConstructBaseDiscretizedTimeLcp() and UpdateDiscretizedTimeLcp().

Parameter ``problem_data``:
    the constraint problem data.

Parameter ``mlcp_to_lcp_data``:
    a reference to a MlcpToLcpData object.

Parameter ``zz``:
    the solution to the LCP resulting from UpdateDiscretizedTimeLcp().

Parameter ``a``:
    the vector ``a`` output from UpdateDiscretizedTimeLcp().

Parameter ``dt``:
    the time step used to discretize the problem.

Parameter ``cf``:
    the constraint forces, on return. The first ``nc`` elements of
    ``cf`` correspond to the magnitudes of the contact forces applied
    along the normals of the ``nc`` contact points. The next elements
    of ``cf`` correspond to the frictional forces along the ``r``
    spanning directions at each point of contact. The first ``r``
    values (after the initial ``nc`` elements) correspond to the first
    contact, the next ``r`` values correspond to the second contact,
    etc. The next ``ℓ`` values of ``cf`` correspond to the impulsive
    forces applied to enforce unilateral constraint functions. The
    final ``b`` values of ``cf`` correspond to the forces applied to
    enforce generic bilateral constraints. This packed storage format
    can be turned into more useful representations through
    ComputeGeneralizedForceFromConstraintForces() and
    CalcContactForcesInContactFrames().

Precondition:
    cf is non-null.)""";
          } PopulatePackedConstraintForcesFromLcpSolution;
          // Symbol: drake::multibody::constraint::ConstraintSolver::SolveConstraintProblem
          struct /* SolveConstraintProblem */ {
            // Source: drake/multibody/constraint/constraint_solver.h:408
            const char* doc =
R"""(Solves the appropriate constraint problem at the acceleration level.

Parameter ``problem_data``:
    The data used to compute the constraint forces.

Parameter ``cf``:
    The computed constraint forces, on return, in a packed storage
    format. The first ``nc`` elements of ``cf`` correspond to the
    magnitudes of the contact forces applied along the normals of the
    ``nc`` contact points. The next elements of ``cf`` correspond to
    the frictional forces along the ``r`` spanning directions at each
    non-sliding point of contact. The first ``r`` values (after the
    initial ``nc`` elements) correspond to the first non-sliding
    contact, the next ``r`` values correspond to the second
    non-sliding contact, etc. The next ``ℓ`` values of ``cf``
    correspond to the forces applied to enforce generic unilateral
    constraints. The final ``b`` values of ``cf`` correspond to the
    forces applied to enforce generic bilateral constraints. This
    packed storage format can be turned into more useful
    representations through
    ComputeGeneralizedForceFromConstraintForces() and
    CalcContactForcesInContactFrames(). ``cf`` will be resized as
    necessary.

Precondition:
    Constraint data has been computed.

Raises:
    RuntimeError if the constraint forces cannot be computed (due to,
    e.g., an "inconsistent" rigid contact configuration).

Raises:
    RuntimeError if ``cf`` is null.)""";
          } SolveConstraintProblem;
          // Symbol: drake::multibody::constraint::ConstraintSolver::SolveImpactProblem
          struct /* SolveImpactProblem */ {
            // Source: drake/multibody/constraint/constraint_solver.h:349
            const char* doc =
R"""(Solves the impact problem described above.

Parameter ``problem_data``:
    The data used to compute the impulsive constraint forces.

Parameter ``cf``:
    The computed impulsive forces, on return, in a packed storage
    format. The first ``nc`` elements of ``cf`` correspond to the
    magnitudes of the contact impulses applied along the normals of
    the ``nc`` contact points. The next elements of ``cf`` correspond
    to the frictional impulses along the ``r`` spanning directions at
    each point of contact. The first ``r`` values (after the initial
    ``nc`` elements) correspond to the first contact, the next ``r``
    values correspond to the second contact, etc. The next ``ℓ``
    values of ``cf`` correspond to the impulsive forces applied to
    enforce unilateral constraint functions. The final ``b`` values of
    ``cf`` correspond to the forces applied to enforce generic
    bilateral constraints. This packed storage format can be turned
    into more useful representations through
    ComputeGeneralizedForceFromConstraintForces() and
    CalcContactForcesInContactFrames(). ``cf`` will be resized as
    necessary.

Precondition:
    Constraint data has been computed.

Raises:
    RuntimeError if the constraint forces cannot be computed (due to,
    e.g., the effects of roundoff error in attempting to solve a
    complementarity problem); in such cases, it is recommended to
    increase regularization and attempt again.

Raises:
    RuntimeError if ``cf`` is null.)""";
          } SolveImpactProblem;
          // Symbol: drake::multibody::constraint::ConstraintSolver::UpdateDiscretizedTimeLcp
          struct /* UpdateDiscretizedTimeLcp */ {
            // Source: drake/multibody/constraint/constraint_solver.h:316
            const char* doc =
R"""(Updates the time-discretization of the LCP initially computed in
ConstructBaseDiscretizedTimeLcp() using the problem data and time step
``h``. Solving the resulting pure LCP yields non-impulsive constraint
forces that can be obtained from
PopulatePackedConstraintForcesFromLcpSolution().

Parameter ``problem_data``:
    the constraint problem data.

Parameter ``mlcp_to_lcp_data``:
    a pointer to a valid MlcpToLcpData object; the caller must ensure
    that this pointer remains valid through the constraint solution
    process.

Parameter ``a``:
    the vector corresponding to the MLCP vector ``a``, on return.

Parameter ``MM``:
    a pointer to the updated LCP matrix on return.

Parameter ``qq``:
    a pointer to the updated LCP vector on return.

Precondition:
    ``mlcp_to_lcp_data``, `a`, ``MM``, and ``qq`` are non-null on
    entry.

See also:
    ConstructBaseDiscretizedTimeLcp())""";
          } UpdateDiscretizedTimeLcp;
        } ConstraintSolver;
        // Symbol: drake::multibody::constraint::ConstraintVelProblemData
        struct /* ConstraintVelProblemData */ {
          // Source: drake/multibody/constraint/constraint_problem_data.h:289
          const char* doc =
R"""(Structure for holding constraint data for computing constraint forces
at the velocity-level (i.e., impact problems).)""";
          // Symbol: drake::multibody::constraint::ConstraintVelProblemData::ConstraintVelProblemData<T>
          struct /* ctor */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:292
            const char* doc =
R"""(Constructs velocity problem data for a system with a ``gv_dim``
dimensional generalized velocity.)""";
          } ctor;
          // Symbol: drake::multibody::constraint::ConstraintVelProblemData::F_mult
          struct /* F_mult */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:440
            const char* doc =
R"""(An operator that performs the multiplication F⋅v. The default operator
returns an empty vector.)""";
          } F_mult;
          // Symbol: drake::multibody::constraint::ConstraintVelProblemData::F_transpose_mult
          struct /* F_transpose_mult */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:446
            const char* doc =
R"""(An operator that performs the multiplication Fᵀ⋅f, where f ∈ ℝⁿᶜʳ
corresponds to frictional impulsive force magnitudes. The default
operator returns a zero vector of dimension equal to that of the
generalized forces.)""";
          } F_transpose_mult;
          // Symbol: drake::multibody::constraint::ConstraintVelProblemData::G_mult
          struct /* G_mult */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:360
            const char* doc =
R"""(An operator that performs the multiplication G⋅v. The default operator
returns an empty vector.)""";
          } G_mult;
          // Symbol: drake::multibody::constraint::ConstraintVelProblemData::G_transpose_mult
          struct /* G_transpose_mult */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:365
            const char* doc =
R"""(An operator that performs the multiplication Gᵀ⋅f where f ∈ ℝⁿᵇ are
the magnitudes of the constraint forces. The default operator returns
a zero vector of dimension equal to that of the generalized forces.)""";
          } G_transpose_mult;
          // Symbol: drake::multibody::constraint::ConstraintVelProblemData::L_mult
          struct /* L_mult */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:488
            const char* doc =
R"""(An operator that performs the multiplication L⋅v. The default operator
returns an empty vector.)""";
          } L_mult;
          // Symbol: drake::multibody::constraint::ConstraintVelProblemData::L_transpose_mult
          struct /* L_transpose_mult */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:494
            const char* doc =
R"""(An operator that performs the multiplication Lᵀ⋅f where f ∈ ℝᵗ are the
magnitudes of the impulsive constraint forces. The default operator
returns a zero vector of dimension equal to that of the generalized
forces.)""";
          } L_transpose_mult;
          // Symbol: drake::multibody::constraint::ConstraintVelProblemData::Mv
          struct /* Mv */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:505
            const char* doc =
R"""(The ℝⁿᵛ generalized momentum immediately before any impulsive forces
(from impact) are applied.)""";
          } Mv;
          // Symbol: drake::multibody::constraint::ConstraintVelProblemData::N_mult
          struct /* N_mult */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:392
            const char* doc =
R"""(An operator that performs the multiplication N⋅v. The default operator
returns an empty vector.)""";
          } N_mult;
          // Symbol: drake::multibody::constraint::ConstraintVelProblemData::N_transpose_mult
          struct /* N_transpose_mult */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:399
            const char* doc =
R"""(An operator that performs the multiplication Nᵀ⋅f, where f ∈ ℝⁿᶜ are
the the magnitudes of the impulsive forces applied along the contact
normals at the nc point contacts. The default operator returns a zero
vector of dimension equal to that of the generalized velocities (which
should be identical to the dimension of the generalized forces).)""";
          } N_transpose_mult;
          // Symbol: drake::multibody::constraint::ConstraintVelProblemData::Reinitialize
          struct /* Reinitialize */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:298
            const char* doc =
R"""(Reinitializes the constraint problem data using the specified
dimension of the generalized velocities.)""";
          } Reinitialize;
          // Symbol: drake::multibody::constraint::ConstraintVelProblemData::gammaE
          struct /* gammaE */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:455
            const char* doc =
R"""(This ℝⁿᶜ vector represents the diagonal matrix γᴱ.)""";
          } gammaE;
          // Symbol: drake::multibody::constraint::ConstraintVelProblemData::gammaF
          struct /* gammaF */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:452
            const char* doc =
R"""(This ℝⁿᶜʳ vector represents the diagonal matrix γᶠ.)""";
          } gammaF;
          // Symbol: drake::multibody::constraint::ConstraintVelProblemData::gammaL
          struct /* gammaL */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:500
            const char* doc =
R"""(This ℝⁿᵘ vector represents the diagonal matrix γᴸ.)""";
          } gammaL;
          // Symbol: drake::multibody::constraint::ConstraintVelProblemData::gammaN
          struct /* gammaN */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:405
            const char* doc =
R"""(This ℝⁿᶜ vector represents the diagonal matrix γᴺ.)""";
          } gammaN;
          // Symbol: drake::multibody::constraint::ConstraintVelProblemData::kF
          struct /* kF */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:449
            const char* doc =
R"""(This ℝⁿᶜʳ vector is the vector kᶠ(t,q,v) defined above.)""";
          } kF;
          // Symbol: drake::multibody::constraint::ConstraintVelProblemData::kG
          struct /* kG */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:368
            const char* doc =
R"""(This ℝⁿᵇ vector is the vector kᴳ(t,q) defined above.)""";
          } kG;
          // Symbol: drake::multibody::constraint::ConstraintVelProblemData::kL
          struct /* kL */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:497
            const char* doc =
R"""(This ℝⁿᵘ vector is the vector kᴸ(t,q) defined above.)""";
          } kL;
          // Symbol: drake::multibody::constraint::ConstraintVelProblemData::kN
          struct /* kN */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:402
            const char* doc =
R"""(This ℝⁿᶜ vector is the vector kᴺ(t,q,v) defined above.)""";
          } kN;
          // Symbol: drake::multibody::constraint::ConstraintVelProblemData::mu
          struct /* mu */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:332
            const char* doc =
R"""(Coefficients of friction for the nc contacts. This problem
specification does not distinguish between static and dynamic friction
coefficients.)""";
          } mu;
          // Symbol: drake::multibody::constraint::ConstraintVelProblemData::r
          struct /* r */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:328
            const char* doc =
R"""(The number of spanning vectors in the contact tangents (used to
linearize the friction cone) at the nc contact points. For contact
problems in two dimensions, each element of r will be one. For contact
problems in three dimensions, a friction pyramid (for example), for a
contact point i will have rᵢ = 2. [Anitescu 1997] define k such
vectors and require that, for each vector w in the spanning set, -w
also exists in the spanning set. The RigidContactVelProblemData
structure expects that the contact solving mechanism negates the
spanning vectors so ``r`` = k/2 spanning vectors will correspond to a
k-edge polygon friction cone approximation.)""";
          } r;
          // Symbol: drake::multibody::constraint::ConstraintVelProblemData::solve_inertia
          struct /* solve_inertia */ {
            // Source: drake/multibody/constraint/constraint_problem_data.h:510
            const char* doc =
R"""(A function for solving the equation MX = B for matrix X, given input
matrix B, where M is the generalized inertia matrix for the rigid body
system.)""";
          } solve_inertia;
        } ConstraintVelProblemData;
      } constraint;
      // Symbol: drake::multibody::contact_solvers
      struct /* contact_solvers */ {
      } contact_solvers;
      // Symbol: drake::multibody::default_model_instance
      struct /* default_model_instance */ {
        // Source: drake/multibody/tree/multibody_tree_indexes.h:60
        const char* doc =
R"""(Returns the model instance which contains all tree elements with no
explicit model instance specified.)""";
      } default_model_instance;
      // Symbol: drake::multibody::hydroelastics
      struct /* hydroelastics */ {
      } hydroelastics;
      // Symbol: drake::multibody::operator+
      struct /* operator_add */ {
        // Source: drake/multibody/math/spatial_acceleration.h:434
        const char* doc_2args_constSpatialAcceleration_constSpatialAcceleration =
R"""((Advanced) Addition operator. Implements the addition of A1 and A2 as
elements in ℝ⁶.

Warning:
    Composing spatial accelerations A1 and A2 cannot be simply
    accomplished by adding them with this operator. The composition of
    accelerations involves additional centrifugal and Coriolis terms,
    see SpatialAcceleration::ComposeWithMovingFrameAcceleration() for
    details.)""";
        // Source: drake/multibody/math/spatial_force.h:242
        const char* doc_2args_constSpatialForce_constSpatialForce =
R"""(Computes the resultant spatial force as the addition of two spatial
forces ``F1_Sp_E`` and ``F2_Sp_E`` on a same system or body S, at the
same point P and expressed in the same frame E.

Returns ``Fr_Sp_E``:
    The resultant spatial force on system or body S from combining
    ``F1_Sp_E`` and ``F2_Sp_E``, applied at the same point P and in
    the same expressed-in frame E as the operand spatial forces.)""";
        // Source: drake/multibody/math/spatial_momentum.h:200
        const char* doc_2args_constSpatialMomentum_constSpatialMomentum =
R"""(Computes the resultant spatial momentum as the addition of two spatial
momenta ``L1_NSp_E`` and ``L2_NSp_E`` on a same system S, about the
same point P and expressed in the same frame E.

Returns ``Lc_NSp_E``:
    The combined spatial momentum of system S from combining
    ``L1_NSp_E`` and ``L2_NSp_E``, applied about the same point P, and
    in the same expressed-in frame E as the operand spatial momenta.)""";
        // Source: drake/multibody/math/spatial_velocity.h:279
        const char* doc_2args_constSpatialVelocity_constSpatialVelocity =
R"""(Performs the addition of two spatial velocities. This operator returns
the spatial velocity that results from adding the operands as if they
were 6-dimensional vectors. In other words, the resulting spatial
velocity contains a rotational component which is the 3-dimensional
addition of the operand's rotational components and a translational
component which is the 3-dimensional addition of the operand's
translational components.

The addition of two spatial velocities has a clear physical meaning
but can only be performed if the operands meet strict conditions. In
addition the the usual requirement of common expressed-in frames, both
spatial velocities must be for frames with the same origin point. The
general idea is that if frame A has a spatial velocity with respect to
M, and frame B has a spatial velocity with respect to A, we want to
"compose" them so that we get frame B's spatial velocity in M. But
that can't be done directly since frames A and B don't have the same
origin. So:

Given the velocity V_MA_E of a frame A in a measured-in frame M, and
the velocity V_AB_E of a frame B measured in frame A (both expressed
in a common frame E), we can calculate V_MB_E as their sum after
shifting A's velocity to point Bo:


::

    V_MB_E = V_MA_E.Shift(p_AB_E) + V_AB_E

where ``p_AB_E`` is the position vector from A's origin to B's origin,
expressed in E. This shift can also be thought of as yielding the
spatial velocity of a new frame Ab, which is an offset frame rigidly
aligned with A, but with its origin shifted to B's origin:


::

    V_MAb_E = V_MA_E.Shift(p_AB_E)
      V_MB_E = V_MAb_E + V_AB_E

The addition in the last expression is what is carried out by this
operator; the caller must have already performed the necessary shift.)""";
      } operator_add;
      // Symbol: drake::multibody::operator-
      struct /* operator_sub */ {
        // Source: drake/multibody/math/spatial_acceleration.h:449
        const char* doc_2args_constSpatialAcceleration_constSpatialAcceleration =
R"""((Advanced) Subtraction operator. Implements the subtraction of A1 and
A2 as elements in ℝ⁶.

Warning:
    With ``As = A1 - A2``, `A1 = As + A2` does not correspond to the
    physical composition of spatial accelerations As and A2. Please
    refere to operator+(const SpatialAcceleration<T>&, const
    SpatialAcceleration<T>&) for details.)""";
        // Source: drake/multibody/math/spatial_force.h:255
        const char* doc_2args_constSpatialForce_constSpatialForce =
R"""(Subtracts spatial force ``F2_Sp_E ` from `F1_Sp_E``. Both spatial
forces act on the same system or body S, at point P and are expressed
in the same frame E.)""";
        // Source: drake/multibody/math/spatial_momentum.h:214
        const char* doc_2args_constSpatialMomentum_constSpatialMomentum =
R"""(Spatial momentum is additive, see operator+(const SpatialMomentum<T>&,
const SpatialMomentum<T>&). This operator subtracts L2_NSp_E from the
total momentum in L1_NSp_E. The momenta in both operands as well as
the result are for the same system S, about the same point P and
expressed in the same frame E.)""";
        // Source: drake/multibody/math/spatial_velocity.h:307
        const char* doc_2args_constSpatialVelocity_constSpatialVelocity =
R"""(The addition of two spatial velocities relates to the composition of
the spatial velocities for two frames given we know the relative
spatial velocity between them, see operator+(const
SpatialVelocity<T>&, const SpatialVelocity<T>&) for further details.

Mathematically, operator-(v1, v2) is equivalent ot operator+(v1, -v2).

Physically, the subtraction operation allow us to compute the relative
velocity between two frames. As an example, consider having the the
spatial velocities ``V_MA`` and ``V_MB`` of two frames A and B
respectively measured in the same frame M. The velocity of B in A can
be obtained as:


::

    V_AB_E = V_MB_E - V_MAb_E = V_AB_E = V_MB_E - V_MA_E.Shift(p_AB_E)

where we have expressed all quantities in a common frame E. Notice
that, as explained in the documentation for operator+(const
SpatialVelocity<T>&, const SpatialVelocity<T>&) a shift operation with
SpatialVelocity::Shift() operation is needed.)""";
      } operator_sub;
      // Symbol: drake::multibody::parsing
      struct /* parsing */ {
        // Symbol: drake::multibody::parsing::AddDirectives
        struct /* AddDirectives */ {
          // Source: drake/multibody/parsing/model_directives.h:128
          const char* doc =
R"""(Directive to incorporate another model directives file, optionally
with its elements prefixed with a namespace.)""";
          // Symbol: drake::multibody::parsing::AddDirectives::IsValid
          struct /* IsValid */ {
            // Source: drake/multibody/parsing/model_directives.h:129
            const char* doc = R"""()""";
          } IsValid;
          // Symbol: drake::multibody::parsing::AddDirectives::Serialize
          struct /* Serialize */ {
            // Source: drake/multibody/parsing/model_directives.h:138
            const char* doc = R"""()""";
          } Serialize;
          // Symbol: drake::multibody::parsing::AddDirectives::file
          struct /* file */ {
            // Source: drake/multibody/parsing/model_directives.h:144
            const char* doc =
R"""(The ``package://`` URI of the file to add.)""";
          } file;
          // Symbol: drake::multibody::parsing::AddDirectives::model_namespace
          struct /* model_namespace */ {
            // Source: drake/multibody/parsing/model_directives.h:155
            const char* doc =
R"""(Namespaces base model instance for processing directive files. Affects
scoping (i.e. the following members): - AddModel::name -
AddModelInstance::name - AddFrame::name - AddWeld::parent -
AddWeld::child - AddFrame::X_PF::base_frame -
AddDirectives::model_namespace See ``README.md`` for example
references and namespacing.)""";
          } model_namespace;
        } AddDirectives;
        // Symbol: drake::multibody::parsing::AddFrame
        struct /* AddFrame */ {
          // Source: drake/multibody/parsing/model_directives.h:100
          const char* doc =
R"""(Directive to add a Frame to the scene. The added frame must have a
name and a transform with a base frame and offset.)""";
          // Symbol: drake::multibody::parsing::AddFrame::IsValid
          struct /* IsValid */ {
            // Source: drake/multibody/parsing/model_directives.h:101
            const char* doc = R"""()""";
          } IsValid;
          // Symbol: drake::multibody::parsing::AddFrame::Serialize
          struct /* Serialize */ {
            // Source: drake/multibody/parsing/model_directives.h:113
            const char* doc = R"""()""";
          } Serialize;
          // Symbol: drake::multibody::parsing::AddFrame::X_PF
          struct /* X_PF */ {
            // Source: drake/multibody/parsing/model_directives.h:123
            const char* doc =
R"""(Pose of frame to be added, ``F``, w.r.t. parent frame ``P`` (as
defined by ``X_PF.base_frame``).)""";
          } X_PF;
          // Symbol: drake::multibody::parsing::AddFrame::name
          struct /* name */ {
            // Source: drake/multibody/parsing/model_directives.h:120
            const char* doc =
R"""(Name of frame to be added. If scope is specified, will override model
instance; otherwise, will use `X_PF.base_frame`s instance.)""";
          } name;
        } AddFrame;
        // Symbol: drake::multibody::parsing::AddModel
        struct /* AddModel */ {
          // Source: drake/multibody/parsing/model_directives.h:56
          const char* doc =
R"""(Directive to add a model from a URDF or SDFormat file to a scene,
using a given name for the added instance.)""";
          // Symbol: drake::multibody::parsing::AddModel::IsValid
          struct /* IsValid */ {
            // Source: drake/multibody/parsing/model_directives.h:57
            const char* doc = R"""()""";
          } IsValid;
          // Symbol: drake::multibody::parsing::AddModel::Serialize
          struct /* Serialize */ {
            // Source: drake/multibody/parsing/model_directives.h:69
            const char* doc = R"""()""";
          } Serialize;
          // Symbol: drake::multibody::parsing::AddModel::file
          struct /* file */ {
            // Source: drake/multibody/parsing/model_directives.h:75
            const char* doc =
R"""(The ``package://`` URI of the file to add.)""";
          } file;
          // Symbol: drake::multibody::parsing::AddModel::name
          struct /* name */ {
            // Source: drake/multibody/parsing/model_directives.h:77
            const char* doc = R"""(The model instance name.)""";
          } name;
        } AddModel;
        // Symbol: drake::multibody::parsing::AddModelInstance
        struct /* AddModelInstance */ {
          // Source: drake/multibody/parsing/model_directives.h:81
          const char* doc =
R"""(Directive to add an empty, named model instance to a scene.)""";
          // Symbol: drake::multibody::parsing::AddModelInstance::IsValid
          struct /* IsValid */ {
            // Source: drake/multibody/parsing/model_directives.h:82
            const char* doc = R"""()""";
          } IsValid;
          // Symbol: drake::multibody::parsing::AddModelInstance::Serialize
          struct /* Serialize */ {
            // Source: drake/multibody/parsing/model_directives.h:90
            const char* doc = R"""()""";
          } Serialize;
          // Symbol: drake::multibody::parsing::AddModelInstance::name
          struct /* name */ {
            // Source: drake/multibody/parsing/model_directives.h:95
            const char* doc = R"""(The model instance name.)""";
          } name;
        } AddModelInstance;
        // Symbol: drake::multibody::parsing::AddWeld
        struct /* AddWeld */ {
          // Source: drake/multibody/parsing/model_directives.h:30
          const char* doc =
R"""(Directive to add a weld between two named frames, a parent and a
child.)""";
          // Symbol: drake::multibody::parsing::AddWeld::IsValid
          struct /* IsValid */ {
            // Source: drake/multibody/parsing/model_directives.h:31
            const char* doc = R"""()""";
          } IsValid;
          // Symbol: drake::multibody::parsing::AddWeld::Serialize
          struct /* Serialize */ {
            // Source: drake/multibody/parsing/model_directives.h:43
            const char* doc = R"""()""";
          } Serialize;
          // Symbol: drake::multibody::parsing::AddWeld::child
          struct /* child */ {
            // Source: drake/multibody/parsing/model_directives.h:51
            const char* doc =
R"""(Child frame. Can (and should) specify scope.)""";
          } child;
          // Symbol: drake::multibody::parsing::AddWeld::parent
          struct /* parent */ {
            // Source: drake/multibody/parsing/model_directives.h:49
            const char* doc = R"""(Parent frame. Can specify scope.)""";
          } parent;
        } AddWeld;
        // Symbol: drake::multibody::parsing::FlattenModelDirectives
        struct /* FlattenModelDirectives */ {
          // Source: drake/multibody/parsing/process_model_directives.h:48
          const char* doc = R"""(Flatten model directives.)""";
        } FlattenModelDirectives;
        // Symbol: drake::multibody::parsing::GetInstanceScopeName
        struct /* GetInstanceScopeName */ {
          // Source: drake/multibody/parsing/scoped_names.h:64
          const char* doc =
R"""(Gets the namespace prefix for a given model instance.)""";
        } GetInstanceScopeName;
        // Symbol: drake::multibody::parsing::GetScopedFrameByName
        struct /* GetScopedFrameByName */ {
          // Source: drake/multibody/parsing/scoped_names.h:28
          const char* doc =
R"""(Equivalent to ``GetScopedFrameByNameMaybe``, but throws if the frame
is not found.)""";
        } GetScopedFrameByName;
        // Symbol: drake::multibody::parsing::GetScopedFrameByNameMaybe
        struct /* GetScopedFrameByNameMaybe */ {
          // Source: drake/multibody/parsing/scoped_names.h:21
          const char* doc =
R"""(Finds an optionally model-scoped frame, using the naming rules of
``ParseScopedName``.

Returns ``nullptr`` if the frame is not found, as well as all the
error cases of ``MultibodyPlant::HasFrameByName(std::string)``.)""";
        } GetScopedFrameByNameMaybe;
        // Symbol: drake::multibody::parsing::GetScopedFrameName
        struct /* GetScopedFrameName */ {
          // Source: drake/multibody/parsing/scoped_names.h:39
          const char* doc =
R"""(Constructs and returns a scoped frame name for the requested frame.)""";
        } GetScopedFrameName;
        // Symbol: drake::multibody::parsing::LoadModelDirectives
        struct /* LoadModelDirectives */ {
          // Source: drake/multibody/parsing/process_model_directives.h:17
          const char* doc = R"""()""";
        } LoadModelDirectives;
        // Symbol: drake::multibody::parsing::ModelDirective
        struct /* ModelDirective */ {
          // Source: drake/multibody/parsing/model_directives.h:164
          const char* doc =
R"""(Union structure for model directives.

Note:
    This was designed before support for ``std::variant<>`` was
    around, and thus we used a parent field, rather than a YAML tag,
    to designate the intended type for the directive.)""";
          // Symbol: drake::multibody::parsing::ModelDirective::IsValid
          struct /* IsValid */ {
            // Source: drake/multibody/parsing/model_directives.h:165
            const char* doc = R"""()""";
          } IsValid;
          // Symbol: drake::multibody::parsing::ModelDirective::Serialize
          struct /* Serialize */ {
            // Source: drake/multibody/parsing/model_directives.h:189
            const char* doc = R"""()""";
          } Serialize;
          // Symbol: drake::multibody::parsing::ModelDirective::add_directives
          struct /* add_directives */ {
            // Source: drake/multibody/parsing/model_directives.h:201
            const char* doc = R"""()""";
          } add_directives;
          // Symbol: drake::multibody::parsing::ModelDirective::add_frame
          struct /* add_frame */ {
            // Source: drake/multibody/parsing/model_directives.h:199
            const char* doc = R"""()""";
          } add_frame;
          // Symbol: drake::multibody::parsing::ModelDirective::add_model
          struct /* add_model */ {
            // Source: drake/multibody/parsing/model_directives.h:197
            const char* doc = R"""()""";
          } add_model;
          // Symbol: drake::multibody::parsing::ModelDirective::add_model_instance
          struct /* add_model_instance */ {
            // Source: drake/multibody/parsing/model_directives.h:198
            const char* doc = R"""()""";
          } add_model_instance;
          // Symbol: drake::multibody::parsing::ModelDirective::add_weld
          struct /* add_weld */ {
            // Source: drake/multibody/parsing/model_directives.h:200
            const char* doc = R"""()""";
          } add_weld;
        } ModelDirective;
        // Symbol: drake::multibody::parsing::ModelDirectives
        struct /* ModelDirectives */ {
          // Source: drake/multibody/parsing/model_directives.h:205
          const char* doc =
R"""(Top-level structure for a model directives yaml file schema.)""";
          // Symbol: drake::multibody::parsing::ModelDirectives::IsValid
          struct /* IsValid */ {
            // Source: drake/multibody/parsing/model_directives.h:206
            const char* doc = R"""()""";
          } IsValid;
          // Symbol: drake::multibody::parsing::ModelDirectives::Serialize
          struct /* Serialize */ {
            // Source: drake/multibody/parsing/model_directives.h:214
            const char* doc = R"""()""";
          } Serialize;
          // Symbol: drake::multibody::parsing::ModelDirectives::directives
          struct /* directives */ {
            // Source: drake/multibody/parsing/model_directives.h:218
            const char* doc = R"""()""";
          } directives;
        } ModelDirectives;
        // Symbol: drake::multibody::parsing::ModelInstanceInfo
        struct /* ModelInstanceInfo */ {
          // Source: drake/multibody/parsing/process_model_directives.h:34
          const char* doc =
R"""(Convenience structure to hold all of the information to add a model
instance from a file.)""";
          // Symbol: drake::multibody::parsing::ModelInstanceInfo::X_PC
          struct /* X_PC */ {
            // Source: drake/multibody/parsing/process_model_directives.h:43
            const char* doc = R"""()""";
          } X_PC;
          // Symbol: drake::multibody::parsing::ModelInstanceInfo::child_frame_name
          struct /* child_frame_name */ {
            // Source: drake/multibody/parsing/process_model_directives.h:42
            const char* doc =
R"""(This is the unscoped frame name belonging to ``model_instance``.)""";
          } child_frame_name;
          // Symbol: drake::multibody::parsing::ModelInstanceInfo::model_instance
          struct /* model_instance */ {
            // Source: drake/multibody/parsing/process_model_directives.h:44
            const char* doc = R"""()""";
          } model_instance;
          // Symbol: drake::multibody::parsing::ModelInstanceInfo::model_name
          struct /* model_name */ {
            // Source: drake/multibody/parsing/process_model_directives.h:36
            const char* doc = R"""(Model name (possibly scoped).)""";
          } model_name;
          // Symbol: drake::multibody::parsing::ModelInstanceInfo::model_path
          struct /* model_path */ {
            // Source: drake/multibody/parsing/process_model_directives.h:38
            const char* doc = R"""(File path.)""";
          } model_path;
          // Symbol: drake::multibody::parsing::ModelInstanceInfo::parent_frame_name
          struct /* parent_frame_name */ {
            // Source: drake/multibody/parsing/process_model_directives.h:40
            const char* doc =
R"""(WARNING: This is the *unscoped* parent frame, assumed to be unique.)""";
          } parent_frame_name;
        } ModelInstanceInfo;
        // Symbol: drake::multibody::parsing::ModelWeldErrorFunction
        struct /* ModelWeldErrorFunction */ {
          // Source: drake/multibody/parsing/process_model_directives.h:63
          const char* doc =
R"""((Advanced) Provides a magical way to inject error into model
directives, for instance if the caller has modeling error to add that
is not reflected in the directives file. Maps from (parent_frame,
child_frame) -> X_PCe, where Ce is the perturbed child frame pose
w.r.t. parent frame P. If there is no error, then nullopt should be
returned.)""";
        } ModelWeldErrorFunction;
        // Symbol: drake::multibody::parsing::ParseScopedName
        struct /* ParseScopedName */ {
          // Source: drake/multibody/parsing/scoped_names.h:58
          const char* doc =
R"""(Attempts to find a name using the following scoping rules: - The
delimiter "::" may appear zero or more times. - If one more delimiters
are present, the full name is split by the *last* delimiter. The
provided model instance name must exist.)""";
        } ParseScopedName;
        // Symbol: drake::multibody::parsing::PrefixName
        struct /* PrefixName */ {
          // Source: drake/multibody/parsing/scoped_names.h:61
          const char* doc =
R"""(Composes a "namespace::name" name from its components.)""";
        } PrefixName;
        // Symbol: drake::multibody::parsing::ProcessModelDirectives
        struct /* ProcessModelDirectives */ {
          // Source: drake/multibody/parsing/process_model_directives.h:72
          const char* doc =
R"""(Processes model directives for a given MultibodyPlant.

Note:
    the ModelWeldErrorFunction argument, described above, is likely to
    go away when a cleaner mechanism is developed.)""";
        } ProcessModelDirectives;
        // Symbol: drake::multibody::parsing::ResolveModelDirectiveUri
        struct /* ResolveModelDirectiveUri */ {
          // Source: drake/multibody/parsing/process_model_directives.h:24
          const char* doc =
R"""(Converts URIs into filesystem absolute paths.

ModelDirectives refer to their resources by URIs like
``package://somepackage/somepath/somefile.sdf``, where somepackage
refers to the ROS-style package.xml system.)""";
        } ResolveModelDirectiveUri;
        // Symbol: drake::multibody::parsing::ScopedName
        struct /* ScopedName */ {
          // Source: drake/multibody/parsing/scoped_names.h:44
          const char* doc = R"""(Convenience class for a scoped name.)""";
          // Symbol: drake::multibody::parsing::ScopedName::instance_name
          struct /* instance_name */ {
            // Source: drake/multibody/parsing/scoped_names.h:47
            const char* doc =
R"""(The name of the multibody instance part of a scoped name. If empty,
implies no multibody instance scope.)""";
          } instance_name;
          // Symbol: drake::multibody::parsing::ScopedName::name
          struct /* name */ {
            // Source: drake/multibody/parsing/scoped_names.h:51
            const char* doc =
R"""(The model-instance-specific part of the name, ie the name of the
frame, body, etc. within the instance.)""";
          } name;
        } ScopedName;
      } parsing;
      // Symbol: drake::multibody::world_index
      struct /* world_index */ {
        // Source: drake/multibody/tree/multibody_tree_indexes.h:49
        const char* doc =
R"""(For every MultibodyTree the **world** body *always* has this unique
index and it is always zero.)""";
      } world_index;
      // Symbol: drake::multibody::world_model_instance
      struct /* world_model_instance */ {
        // Source: drake/multibody/tree/multibody_tree_indexes.h:54
        const char* doc =
R"""(Returns the model instance containing the *world* body. For every
MultibodyTree the **world** body *always* has this unique model
instance and it is always zero (as described in #3088).)""";
      } world_model_instance;
    } multibody;
    // Symbol: drake::never_destroyed
    struct /* never_destroyed */ {
      // Source: drake/common/never_destroyed.h:62
      const char* doc = R"""()""";
      // Symbol: drake::never_destroyed::access
      struct /* access */ {
        // Source: drake/common/never_destroyed.h:77
        const char* doc = R"""(Returns the underlying T reference.)""";
      } access;
      // Symbol: drake::never_destroyed::never_destroyed<T>
      struct /* ctor */ {
        // Source: drake/common/never_destroyed.h:68
        const char* doc =
R"""(Passes the constructor arguments along to T using perfect forwarding.)""";
      } ctor;
    } never_destroyed;
    // Symbol: drake::none
    struct /* none */ {
      // Source: drake/common/drake_bool.h:81
      const char* doc =
R"""(Checks that no elements of ``m`` are true. An empty matrix returns
true.)""";
    } none;
    // Symbol: drake::none_of
    struct /* none_of */ {
      // Source: drake/common/drake_bool.h:90
      const char* doc =
R"""(Checks if unary predicate ``pred`` holds for no elements in the matrix
``m``. An empty matrix returns true.)""";
    } none_of;
    // Symbol: drake::operator!=
    struct /* operator_ne */ {
      // Source: drake/common/sorted_pair.h:117
      const char* doc =
R"""(Determine whether two SortedPair objects are not equal using
``operator==``.)""";
    } operator_ne;
    // Symbol: drake::operator<
    struct /* operator_lt */ {
      // Source: drake/common/sorted_pair.h:111
      const char* doc =
R"""(Compares two pairs using lexicographic ordering.)""";
    } operator_lt;
    // Symbol: drake::operator<=
    struct /* operator_le */ {
      // Source: drake/common/sorted_pair.h:130
      const char* doc =
R"""(Determines whether ``x <= y`` using ``operator<``.)""";
    } operator_le;
    // Symbol: drake::operator>
    struct /* operator_gt */ {
      // Source: drake/common/sorted_pair.h:124
      const char* doc =
R"""(Determines whether ``x > y`` using ``operator<``.)""";
    } operator_gt;
    // Symbol: drake::operator>=
    struct /* operator_ge */ {
      // Source: drake/common/sorted_pair.h:137
      const char* doc =
R"""(Determines whether ``x >= y`` using ``operator<``.)""";
    } operator_ge;
    // Symbol: drake::perception
    struct /* perception */ {
      // Symbol: drake::perception::DepthImageToPointCloud
      struct /* DepthImageToPointCloud */ {
        // Source: drake/perception/depth_image_to_point_cloud.h:48
        const char* doc =
R"""(Converts a depth image to a point cloud.

.. pydrake_system::

    name: DepthImageToPointCloud
    input_ports:
    - depth_image
    - color_image (optional)
    - camera_pose (optional)
    output_ports:
    - point_cloud

The system has an input port that takes a depth image, an optional
input port that takes a color image, and an additional optional input
port that takes the camera_pose, X_PC. If the camera_pose input is
connected, then the point cloud is represented in the parent frame
(e.g., if camera_pose is the pose of the camera in the world frame,
then the point_cloud output will be a PointCloud in the world frame).
If the camera_pose input is not connected, the PointCloud will be
represented in the camera frame. Note that if a color image is
provided, it must be in the same frame as the depth image.

If a pixel is NaN, the converted point will be (NaN, NaN, NaN). If a
pixel is kTooClose or kTooFar (as defined by ImageTraits), the
converted point will be (+Inf, +Inf, +Inf). Note that this matches the
convention used by the Point Cloud Library (PCL).)""";
        // Symbol: drake::perception::DepthImageToPointCloud::Convert
        struct /* Convert */ {
          // Source: drake/perception/depth_image_to_point_cloud.h:99
          const char* doc =
R"""(Converts a depth image to a point cloud using direct arguments instead
of System input and output ports. The semantics are the same as
documented in the class overview and constructor.

Parameter ``cloud``:
    Destination for point data; must not be nullptr. The ``cloud``
    will be resized to match the size of the depth image. The
    ``cloud`` must have the XYZ channel enabled.)""";
        } Convert;
        // Symbol: drake::perception::DepthImageToPointCloud::DepthImageToPointCloud
        struct /* ctor */ {
          // Source: drake/perception/depth_image_to_point_cloud.h:61
          const char* doc =
R"""(Constructs the converter.

Parameter ``camera_info``:
    The camera info.

Parameter ``depth_pixel_type``:
    The pixel type of the depth image input. Only 16U and 32F are
    supported.

Parameter ``scale``:
    The depth image input is multiplied by this scale factor before
    projecting to a point cloud. (This is useful for converting mm to
    meters, etc.)

Parameter ``fields``:
    The fields the point cloud contains.)""";
        } ctor;
        // Symbol: drake::perception::DepthImageToPointCloud::camera_pose_input_port
        struct /* camera_pose_input_port */ {
          // Source: drake/perception/depth_image_to_point_cloud.h:81
          const char* doc =
R"""(Returns the abstract valued input port that expects X_PC as a
RigidTransformd. (This input port does not necessarily need to be
connected; refer to the class overview for details.))""";
        } camera_pose_input_port;
        // Symbol: drake::perception::DepthImageToPointCloud::color_image_input_port
        struct /* color_image_input_port */ {
          // Source: drake/perception/depth_image_to_point_cloud.h:74
          const char* doc =
R"""(Returns the abstract valued input port that expects an ImageRgba8U.)""";
        } color_image_input_port;
        // Symbol: drake::perception::DepthImageToPointCloud::depth_image_input_port
        struct /* depth_image_input_port */ {
          // Source: drake/perception/depth_image_to_point_cloud.h:69
          const char* doc =
R"""(Returns the abstract valued input port that expects either an
ImageDepth16U or ImageDepth32F (depending on the constructor
argument).)""";
        } depth_image_input_port;
        // Symbol: drake::perception::DepthImageToPointCloud::point_cloud_output_port
        struct /* point_cloud_output_port */ {
          // Source: drake/perception/depth_image_to_point_cloud.h:88
          const char* doc =
R"""(Returns the abstract valued output port that provides a PointCloud.
Only the channels passed into the constructor argument "fields" are
present.)""";
        } point_cloud_output_port;
      } DepthImageToPointCloud;
      // Symbol: drake::perception::PointCloud
      struct /* PointCloud */ {
        // Source: drake/perception/point_cloud.h:68
        const char* doc =
R"""(Implements a point cloud (with contiguous storage), whose main goal is
to offer a convenient, synchronized interface to commonly used fields
and data types applicable for basic 3D perception.

This is a mix between the philosophy of PCL (templated interface to
provide a compile-time open set, run-time closed set) and VTK
(non-templated interface to provide a very free form run-time open
set). You may construct one PointCloud which will contain different
sets of data, but you cannot change the contained data types after
construction. However, you can mutate the data contained within the
structure and resize the cloud.

Definitions:

- point - An entry in a point cloud (not exclusively an XYZ point).
- feature - Abstract representation of local properties (geometric and
  non-geometric)
- descriptor - Concrete representation of a feature.
- field - A feature or descriptor described by the point cloud.

This point cloud class provides the following fields:

- xyz - Cartesian XYZ coordinates (float[3]).
- descriptor - A descriptor that is run-time defined (float[X]).

Note:
    "contiguous" here means contiguous in memory. This was chosen to
    avoid ambiguity between PCL and Eigen, where in PCL "dense"
    implies that the point cloud corresponds to a cloud with invalid
    values, and in Eigen "dense" implies contiguous storage.

Note:
    The accessors / mutators for the point fields of this class
    returns references to the original Eigen matrices. This implies
    that they are invalidated whenever memory is reallocated for the
    values. Given this, minimize the lifetime of these references to
    be as short as possible. Additionally, algorithms wanting fast
    access to values should avoid the single point accessors /
    mutatotrs (e.g. ``xyz(i)``, `mutable_descriptor(i)`) to avoid
    overhead when accessing a single element (either copying or
    creating a reference).

Note:
    The definitions presented here for "feature" and "descriptor" are
    loosely based on their definitions within PCL and Radu Rusu's
    dissertation: Rusu, Radu Bogdan. "Semantic 3d object maps for
    everyday manipulation in human living environments." KI-Künstliche
    Intelligenz 24.4 (2010): 345-348. This differs from other
    definitions, such as having "feature" describe geometric
    quantities and "descriptor" describe non-geometric quantities
    which is presented in the following survey paper: Pomerleau,
    François, Francis Colas, and Roland Siegwart. "A review of point
    cloud registration algorithms for mobile robotics." Foundations
    and Trends® in Robotics 4.1 (2015): 1-104.)""";
        // Symbol: drake::perception::PointCloud::C
        struct /* C */ {
          // Source: drake/perception/point_cloud.h:74
          const char* doc = R"""(Color channel scalar type.)""";
        } C;
        // Symbol: drake::perception::PointCloud::D
        struct /* D */ {
          // Source: drake/perception/point_cloud.h:77
          const char* doc = R"""(Descriptor scalar type.)""";
        } D;
        // Symbol: drake::perception::PointCloud::Expand
        struct /* Expand */ {
          // Source: drake/perception/point_cloud.h:275
          const char* doc =
R"""(Adds ``add_size`` default-initialized points.

Parameter ``add_size``:
    Number of points to add.

Parameter ``skip_initialization``:
    Do not require that the new values be initialized.)""";
        } Expand;
        // Symbol: drake::perception::PointCloud::HasExactFields
        struct /* HasExactFields */ {
          // Source: drake/perception/point_cloud.h:293
          const char* doc =
R"""(Returns if a point cloud has exactly a given set of fields.

See also:
    HasFields for preconditions.)""";
        } HasExactFields;
        // Symbol: drake::perception::PointCloud::HasFields
        struct /* HasFields */ {
          // Source: drake/perception/point_cloud.h:283
          const char* doc =
R"""(Returns if a point cloud has a given set of fields.)""";
        } HasFields;
        // Symbol: drake::perception::PointCloud::IsDefaultValue
        struct /* IsDefaultValue */ {
          // Source: drake/perception/point_cloud.h:82
          const char* doc = R"""()""";
        } IsDefaultValue;
        // Symbol: drake::perception::PointCloud::IsInvalidValue
        struct /* IsInvalidValue */ {
          // Source: drake/perception/point_cloud.h:83
          const char* doc = R"""()""";
        } IsInvalidValue;
        // Symbol: drake::perception::PointCloud::PointCloud
        struct /* ctor */ {
          // Source: drake/perception/point_cloud.h:94
          const char* doc_3args =
R"""(Constructs a point cloud of a given ``new_size``, with the prescribed
``fields``. If ``kDescriptors`` is one of the fields, then
``descriptor`` should be included and should not be ``kNone``.

Parameter ``new_size``:
    Size of the point cloud after construction.

Parameter ``fields``:
    Fields that the point cloud contains.

Parameter ``skip_initialize``:
    Do not default-initialize new values.)""";
          // Source: drake/perception/point_cloud.h:99
          const char* doc_copy =
R"""(Copies another point cloud's fields and data.)""";
          // Source: drake/perception/point_cloud.h:103
          const char* doc_move =
R"""(Takes ownership of another point cloud's data.)""";
          // Source: drake/perception/point_cloud.h:112
          const char* doc_2args =
R"""(Copies another point cloud's fields and data.

Parameter ``copy_fields``:
    Fields to copy. If this is ``kInherit``, then `other`s fields will
    be copied. Otherwise, only the specified fields will be copied;
    the remaining fields in this cloud are left default initialized.)""";
        } ctor;
        // Symbol: drake::perception::PointCloud::RequireExactFields
        struct /* RequireExactFields */ {
          // Source: drake/perception/point_cloud.h:299
          const char* doc =
R"""(Requires the exact given set of fields.

See also:
    HasFields for preconditions.

Raises:
    RuntimeError if this point cloud does not have exactly these
    fields.)""";
        } RequireExactFields;
        // Symbol: drake::perception::PointCloud::RequireFields
        struct /* RequireFields */ {
          // Source: drake/perception/point_cloud.h:289
          const char* doc =
R"""(Requires a given set of fields.

See also:
    HasFields for preconditions.

Raises:
    RuntimeError if this point cloud does not have these fields.)""";
        } RequireFields;
        // Symbol: drake::perception::PointCloud::SetFrom
        struct /* SetFrom */ {
          // Source: drake/perception/point_cloud.h:263
          const char* doc =
R"""(Copies all points from another point cloud.

Parameter ``other``:
    Other point cloud.

Parameter ``fields_in``:
    Fields to copy. If this is ``kInherit``, then both clouds must
    have the exact same fields. Otherwise, both clouds must support
    the fields indicated this parameter.

Parameter ``allow_resize``:
    Permit resizing to the other cloud's size.)""";
        } SetFrom;
        // Symbol: drake::perception::PointCloud::T
        struct /* T */ {
          // Source: drake/perception/point_cloud.h:71
          const char* doc = R"""(Geometric scalar type.)""";
        } T;
        // Symbol: drake::perception::PointCloud::descriptor
        struct /* descriptor */ {
          // Source: drake/perception/point_cloud.h:241
          const char* doc =
R"""(Returns access to a descriptor value.

Precondition:
    ``has_descriptors()`` must be true.)""";
        } descriptor;
        // Symbol: drake::perception::PointCloud::descriptor_type
        struct /* descriptor_type */ {
          // Source: drake/perception/point_cloud.h:227
          const char* doc = R"""(Returns the descriptor type.)""";
        } descriptor_type;
        // Symbol: drake::perception::PointCloud::descriptors
        struct /* descriptors */ {
          // Source: drake/perception/point_cloud.h:233
          const char* doc =
R"""(Returns access to descriptor values.

Precondition:
    ``has_descriptors()`` must be true.)""";
        } descriptors;
        // Symbol: drake::perception::PointCloud::fields
        struct /* fields */ {
          // Source: drake/perception/point_cloud.h:123
          const char* doc =
R"""(Returns the fields provided by this point cloud.)""";
        } fields;
        // Symbol: drake::perception::PointCloud::has_descriptors
        struct /* has_descriptors */ {
          // Source: drake/perception/point_cloud.h:221
          const char* doc_0args =
R"""(Returns if this point cloud provides descriptor values.)""";
          // Source: drake/perception/point_cloud.h:224
          const char* doc_1args =
R"""(Returns if the point cloud provides a specific descriptor.)""";
        } has_descriptors;
        // Symbol: drake::perception::PointCloud::has_normals
        struct /* has_normals */ {
          // Source: drake/perception/point_cloud.h:169
          const char* doc = R"""(Returns if this cloud provides normals.)""";
        } has_normals;
        // Symbol: drake::perception::PointCloud::has_rgbs
        struct /* has_rgbs */ {
          // Source: drake/perception/point_cloud.h:195
          const char* doc =
R"""(Returns if this cloud provides RGB colors.)""";
        } has_rgbs;
        // Symbol: drake::perception::PointCloud::has_xyzs
        struct /* has_xyzs */ {
          // Source: drake/perception/point_cloud.h:143
          const char* doc =
R"""(Returns if this cloud provides XYZ values.)""";
        } has_xyzs;
        // Symbol: drake::perception::PointCloud::mutable_descriptor
        struct /* mutable_descriptor */ {
          // Source: drake/perception/point_cloud.h:245
          const char* doc =
R"""(Returns mutable access to a descriptor value.

Precondition:
    ``has_descriptors()`` must be true.)""";
        } mutable_descriptor;
        // Symbol: drake::perception::PointCloud::mutable_descriptors
        struct /* mutable_descriptors */ {
          // Source: drake/perception/point_cloud.h:237
          const char* doc =
R"""(Returns mutable access to descriptor values.

Precondition:
    ``has_descriptors()`` must be true.)""";
        } mutable_descriptors;
        // Symbol: drake::perception::PointCloud::mutable_normal
        struct /* mutable_normal */ {
          // Source: drake/perception/point_cloud.h:185
          const char* doc =
R"""(Returns mutable access to a normal.

Precondition:
    ``has_normals()`` must be true.)""";
        } mutable_normal;
        // Symbol: drake::perception::PointCloud::mutable_normals
        struct /* mutable_normals */ {
          // Source: drake/perception/point_cloud.h:177
          const char* doc =
R"""(Returns mutable access to normals.

Precondition:
    ``has_normals()`` must be true.)""";
        } mutable_normals;
        // Symbol: drake::perception::PointCloud::mutable_rgb
        struct /* mutable_rgb */ {
          // Source: drake/perception/point_cloud.h:211
          const char* doc =
R"""(Returns mutable access to an RGB color.

Precondition:
    ``has_rgbs()`` must be true.)""";
        } mutable_rgb;
        // Symbol: drake::perception::PointCloud::mutable_rgbs
        struct /* mutable_rgbs */ {
          // Source: drake/perception/point_cloud.h:203
          const char* doc =
R"""(Returns mutable access to RGB colors.

Precondition:
    ``has_rgbs()`` must be true.)""";
        } mutable_rgbs;
        // Symbol: drake::perception::PointCloud::mutable_xyz
        struct /* mutable_xyz */ {
          // Source: drake/perception/point_cloud.h:159
          const char* doc =
R"""(Returns mutable access to an XYZ value.

Precondition:
    ``has_xyzs()`` must be true.)""";
        } mutable_xyz;
        // Symbol: drake::perception::PointCloud::mutable_xyzs
        struct /* mutable_xyzs */ {
          // Source: drake/perception/point_cloud.h:151
          const char* doc =
R"""(Returns mutable access to XYZ values.

Precondition:
    ``has_xyzs()`` must be true.)""";
        } mutable_xyzs;
        // Symbol: drake::perception::PointCloud::normal
        struct /* normal */ {
          // Source: drake/perception/point_cloud.h:181
          const char* doc =
R"""(Returns access to a normal.

Precondition:
    ``has_normals()`` must be true.)""";
        } normal;
        // Symbol: drake::perception::PointCloud::normals
        struct /* normals */ {
          // Source: drake/perception/point_cloud.h:173
          const char* doc =
R"""(Returns access to normals.

Precondition:
    ``has_normals()`` must be true.)""";
        } normals;
        // Symbol: drake::perception::PointCloud::resize
        struct /* resize */ {
          // Source: drake/perception/point_cloud.h:137
          const char* doc =
R"""(Conservative resize; will maintain existing data, and initialize new
data to their invalid values.

Parameter ``new_size``:
    The new size of the value. If less than the present ``size()``,
    then the values will be truncated. If greater than the present
    ``size()``, then the new values will be uninitialized if
    ``skip_initialize`` is not true.

Parameter ``skip_initialize``:
    Do not default-initialize new values.)""";
        } resize;
        // Symbol: drake::perception::PointCloud::rgb
        struct /* rgb */ {
          // Source: drake/perception/point_cloud.h:207
          const char* doc =
R"""(Returns access to an RGB color.

Precondition:
    ``has_rgbs()`` must be true.)""";
        } rgb;
        // Symbol: drake::perception::PointCloud::rgbs
        struct /* rgbs */ {
          // Source: drake/perception/point_cloud.h:199
          const char* doc =
R"""(Returns access to RGB colors.

Precondition:
    ``has_rgbs()`` must be true.)""";
        } rgbs;
        // Symbol: drake::perception::PointCloud::size
        struct /* size */ {
          // Source: drake/perception/point_cloud.h:126
          const char* doc =
R"""(Returns the number of points in this point cloud.)""";
        } size;
        // Symbol: drake::perception::PointCloud::xyz
        struct /* xyz */ {
          // Source: drake/perception/point_cloud.h:155
          const char* doc =
R"""(Returns access to an XYZ value.

Precondition:
    ``has_xyzs()`` must be true.)""";
        } xyz;
        // Symbol: drake::perception::PointCloud::xyzs
        struct /* xyzs */ {
          // Source: drake/perception/point_cloud.h:147
          const char* doc =
R"""(Returns access to XYZ values.

Precondition:
    ``has_xyzs()`` must be true.)""";
        } xyzs;
      } PointCloud;
      // Symbol: drake::perception::pc_flags
      struct /* pc_flags */ {
        // Symbol: drake::perception::pc_flags::BaseField
        struct /* BaseField */ {
          // Source: drake/perception/point_cloud_flags.h:18
          const char* doc =
R"""(Indicates the data the point cloud stores.)""";
          // Symbol: drake::perception::pc_flags::BaseField::kInherit
          struct /* kInherit */ {
            // Source: drake/perception/point_cloud_flags.h:22
            const char* doc =
R"""(Inherit other fields. May imply an intersection of all compatible
descriptors.)""";
          } kInherit;
          // Symbol: drake::perception::pc_flags::BaseField::kNone
          struct /* kNone */ {
            // Source: drake/perception/point_cloud_flags.h:19
            const char* doc = R"""()""";
          } kNone;
          // Symbol: drake::perception::pc_flags::BaseField::kNormals
          struct /* kNormals */ {
            // Source: drake/perception/point_cloud_flags.h:26
            const char* doc = R"""(Normals.)""";
          } kNormals;
          // Symbol: drake::perception::pc_flags::BaseField::kRGBs
          struct /* kRGBs */ {
            // Source: drake/perception/point_cloud_flags.h:28
            const char* doc = R"""(RGB colors.)""";
          } kRGBs;
          // Symbol: drake::perception::pc_flags::BaseField::kXYZs
          struct /* kXYZs */ {
            // Source: drake/perception/point_cloud_flags.h:24
            const char* doc = R"""(XYZ point in Cartesian space.)""";
          } kXYZs;
        } BaseField;
        // Symbol: drake::perception::pc_flags::BaseFieldT
        struct /* BaseFieldT */ {
          // Source: drake/perception/point_cloud_flags.h:16
          const char* doc = R"""()""";
        } BaseFieldT;
        // Symbol: drake::perception::pc_flags::DescriptorType
        struct /* DescriptorType */ {
          // Source: drake/perception/point_cloud_flags.h:46
          const char* doc =
R"""(Describes an descriptor field with a name and the descriptor's size.

Note:
    This is defined as follows to enable an open set of descriptors,
    but ensure that these descriptor types are appropriately matched.
    As ``PointCloud`` evolves and more algorithms are mapped into
    Drake, promoting an descriptor field to a proper field should be
    considered if (a) it is used frequently enough AND (b) if it is
    often used in conjunction with other fields.)""";
          // Symbol: drake::perception::pc_flags::DescriptorType::DescriptorType
          struct /* ctor */ {
            // Source: drake/perception/point_cloud_flags.h:48
            const char* doc = R"""()""";
          } ctor;
          // Symbol: drake::perception::pc_flags::DescriptorType::name
          struct /* name */ {
            // Source: drake/perception/point_cloud_flags.h:55
            const char* doc = R"""()""";
          } name;
          // Symbol: drake::perception::pc_flags::DescriptorType::operator!=
          struct /* operator_ne */ {
            // Source: drake/perception/point_cloud_flags.h:59
            const char* doc = R"""()""";
          } operator_ne;
          // Symbol: drake::perception::pc_flags::DescriptorType::size
          struct /* size */ {
            // Source: drake/perception/point_cloud_flags.h:54
            const char* doc = R"""()""";
          } size;
        } DescriptorType;
        // Symbol: drake::perception::pc_flags::Fields
        struct /* Fields */ {
          // Source: drake/perception/point_cloud_flags.h:83
          const char* doc =
R"""(Allows combination of ``BaseField`` and ``DescriptorType`` for a
``PointCloud``. You may combine multiple ``BaseField`s, but you may
have only zero or one `DescriptorType``.

This provides the mechanism to use basic bit-mask operators (| &) to
combine / intersect fields for convenience.)""";
          // Symbol: drake::perception::pc_flags::Fields::Fields
          struct /* ctor */ {
            // Source: drake/perception/point_cloud_flags.h:89
            const char* doc =
R"""(Raises:
    RuntimeError if ``base_fields`` is not composed of valid
    `BaseField`s.)""";
          } ctor;
          // Symbol: drake::perception::pc_flags::Fields::base_fields
          struct /* base_fields */ {
            // Source: drake/perception/point_cloud_flags.h:106
            const char* doc = R"""(Returns the contained base fields.)""";
          } base_fields;
          // Symbol: drake::perception::pc_flags::Fields::contains
          struct /* contains */ {
            // Source: drake/perception/point_cloud_flags.h:160
            const char* doc =
R"""(Returns whether this set of fields contains (is a superset of)
``rhs``.)""";
          } contains;
          // Symbol: drake::perception::pc_flags::Fields::descriptor_type
          struct /* descriptor_type */ {
            // Source: drake/perception/point_cloud_flags.h:114
            const char* doc = R"""(Returns the contained descriptor type.)""";
          } descriptor_type;
          // Symbol: drake::perception::pc_flags::Fields::empty
          struct /* empty */ {
            // Source: drake/perception/point_cloud_flags.h:155
            const char* doc =
R"""(Returns whether both value types (BaseField + DescriptorType) are
none.)""";
          } empty;
          // Symbol: drake::perception::pc_flags::Fields::has_base_fields
          struct /* has_base_fields */ {
            // Source: drake/perception/point_cloud_flags.h:109
            const char* doc =
R"""(Returns whether there are any base fields contained by this set of
fields.)""";
          } has_base_fields;
          // Symbol: drake::perception::pc_flags::Fields::has_descriptor
          struct /* has_descriptor */ {
            // Source: drake/perception/point_cloud_flags.h:117
            const char* doc =
R"""(Returns whether there is a descriptor contained by this set of fields.)""";
          } has_descriptor;
          // Symbol: drake::perception::pc_flags::Fields::operator!=
          struct /* operator_ne */ {
            // Source: drake/perception/point_cloud_flags.h:169
            const char* doc = R"""()""";
          } operator_ne;
          // Symbol: drake::perception::pc_flags::Fields::operator&
          struct /* operator_band */ {
            // Source: drake/perception/point_cloud_flags.h:150
            const char* doc = R"""(Provides intersection.)""";
          } operator_band;
          // Symbol: drake::perception::pc_flags::Fields::operator&=
          struct /* operator_iand */ {
            // Source: drake/perception/point_cloud_flags.h:141
            const char* doc = R"""(Provides in-place intersection.)""";
          } operator_iand;
          // Symbol: drake::perception::pc_flags::Fields::operator|
          struct /* operator_bor */ {
            // Source: drake/perception/point_cloud_flags.h:136
            const char* doc =
R"""(Provides union.

See also:
    operator|= for preconditions.)""";
          } operator_bor;
          // Symbol: drake::perception::pc_flags::Fields::operator|=
          struct /* operator_ior */ {
            // Source: drake/perception/point_cloud_flags.h:124
            const char* doc =
R"""(Provides in-place union.

Raises:
    RuntimeError if multiple non-None `DescriptorType`s are specified.)""";
          } operator_ior;
        } Fields;
        // Symbol: drake::perception::pc_flags::operator|
        struct /* operator_bor */ {
          // Source: drake/perception/point_cloud_flags.h:185
          const char* doc_was_unable_to_choose_unambiguous_names =
R"""(Makes operator| compatible for ``BaseField`` + ``DescriptorType``.

See also:
    Fields::operator|= for preconditions.)""";
        } operator_bor;
      } pc_flags;
    } perception;
    // Symbol: drake::pow
    struct /* pow */ {
      // Source: drake/common/polynomial.h:482
      const char* doc = R"""(Provides power function for Polynomial.)""";
    } pow;
    // Symbol: drake::reset_after_move
    struct /* reset_after_move */ {
      // Source: drake/common/reset_after_move.h:49
      const char* doc =
R"""(Type wrapper that performs value-initialization on the wrapped type,
and guarantees that when moving from this type that the donor object
is reset to its value-initialized value.

Background:

For performance reasons, we often like to provide overloaded move
functions on our types, instead of relying on the copy functions. When
doing so, it is more robust to rely on the compiler's ``= default``
implementation using member-wise move, instead of writing out the
operations manually. In general, move functions should reset the donor
object of the move to its default-constructed (empty) resource state.
Inductively, the member fields' existing move implementations do this
already, except in the case of non-class (primitive) members, where
the donor object's primitives will not be zeroed. By wrapping
primitive members fields with this type, they are guaranteed to be
zeroed on construction and after being moved from.

Example:


::

    class Foo {
     public:
      DRAKE_DEFAULT_COPY_AND_MOVE_AND_ASSIGN(Foo)
      Foo() = default;
    
     private:
      std::vector<int> items_;
      reset_after_move<int> sum_;
    };

When moving from ``Foo``, the donor object will reset to its default
state: ``items_`` will be empty and ``sum_`` will be zero. If ``Foo``
had not used the ``reset_after_move`` wrapper, the ``sum_`` would
remain intact (be copied) while moving, even though ``items_`` was
cleared.

Template parameter ``T``:
    must support CopyConstructible, CopyAssignable, MoveConstructible,
    and MoveAssignable and must not throw exceptions during
    construction or assignment.

See also:
    reset_on_copy)""";
      // Symbol: drake::reset_after_move::operator const type-parameter-0-0 &
      struct /* operator_const_T0_ */ {
        // Source: drake/common/reset_after_move.h:83
        const char* doc = R"""()""";
      } operator_const_T0_;
      // Symbol: drake::reset_after_move::operator type-parameter-0-0 &
      struct /* operator_T0_ */ {
        // Source: drake/common/reset_after_move.h:82
        const char* doc = R"""()""";
      } operator_T0_;
      // Symbol: drake::reset_after_move::operator*
      struct /* operator_mul */ {
        // Source: drake/common/reset_after_move.h:97
        const char* doc = R"""()""";
      } operator_mul;
      // Symbol: drake::reset_after_move::reset_after_move<T>
      struct /* ctor */ {
        // Source: drake/common/reset_after_move.h:53
        const char* doc_0args =
R"""(Constructs a reset_after_move<T> with a value-initialized wrapped
value. See
http://en.cppreference.com/w/cpp/language/value_initialization.)""";
        // Source: drake/common/reset_after_move.h:59
        const char* doc_1args =
R"""(Constructs a reset_after_move<T> with the given wrapped value. This is
an implicit conversion, so that reset_after_move<T> behaves more like
the unwrapped type.)""";
      } ctor;
    } reset_after_move;
    // Symbol: drake::reset_on_copy
    struct /* reset_on_copy */ {
      // Source: drake/common/reset_on_copy.h:80
      const char* doc =
R"""(Type wrapper that performs value-initialization on copy construction
or assignment.

Rather than copying the source supplied for copy construction or copy
assignment, this wrapper instead value-initializes the destination
object. Move assignment and construction preserve contents in the
destination as usual, but reset the source to its value-initialized
value.

Only types T that satisfy ``std::is_scalar<T>`` are currently
permitted: integral and floating point types, enums, and pointers.
Value initialization means the initialization performed when a
variable is constructed with an empty initializer ``{}``. For the
restricted set of types we support, that just means that numeric types
are set to zero and pointer types are set to nullptr. Also, all the
methods here are noexcept due to the ``std::is_scalar<T>``
restriction. See
http://en.cppreference.com/w/cpp/language/value_initialization.

Background:

It is preferable to use default copy construction for classes whenever
possible because it avoids difficult-to-maintain enumeration of member
fields in bespoke copy constructors. The presence of fields that must
be reset to zero in the copy (counters, for example) prevents use of
default copy construction. Similarly, pointers that would be invalid
in the copy need to be set to null to avoid stale references. By
wrapping those problematic data members in this adapter, default copy
construction can continue to be used, with all data members copied
properly except the designated ones, which are value-initialized
instead. The resetting of the source on move doesn't change semantics
since the condition of the source after a move is generally undefined.
It is instead opportunistic good hygiene for early detection of bugs,
taking advantage of the fact that we know type T can be
value-initialized. See reset_after_move for more discussion.

Example:


::

    class Foo {
     public:
      DRAKE_DEFAULT_COPY_AND_MOVE_AND_ASSIGN(Foo)
      Foo() = default;
    
     private:
      std::vector<int> items_;
      reset_on_copy<int> use_count_;
    };

When copying from ``Foo``, the new object will contain a copy of
``items_`` but ``use_count_`` will be zero. If ``Foo`` had not used
the ``reset_on_copy`` wrapper, ``use_count_`` would have been copied
also, which we're assuming is not the desired behavior here.

Warning:
    Even if you initialize a reset_on_copy member to a non-zero value
    using an initializer like ``reset_on_copy<int> some_member_{5}``
    it will be *reset* to zero, not *reinitialized* to 5 when copied.

Note:
    Enum types T are permitted, but be aware that they will be reset
    to zero, regardless of whether 0 is one of the specified
    enumeration values.

Template parameter ``T``:
    must satisfy ``std::is_scalar<T>``.

See also:
    reset_after_move)""";
      // Symbol: drake::reset_on_copy::operator const type-parameter-0-0 &
      struct /* operator_const_T0_ */ {
        // Source: drake/common/reset_on_copy.h:153
        const char* doc = R"""()""";
      } operator_const_T0_;
      // Symbol: drake::reset_on_copy::operator type-parameter-0-0 &
      struct /* operator_T0_ */ {
        // Source: drake/common/reset_on_copy.h:152
        const char* doc = R"""()""";
      } operator_T0_;
      // Symbol: drake::reset_on_copy::operator*
      struct /* operator_mul */ {
        // Source: drake/common/reset_on_copy.h:168
        const char* doc = R"""()""";
      } operator_mul;
      // Symbol: drake::reset_on_copy::reset_on_copy<T>
      struct /* ctor */ {
        // Source: drake/common/reset_on_copy.h:87
        const char* doc_was_unable_to_choose_unambiguous_names =
R"""(Constructs a reset_on_copy<T> with a value-initialized wrapped value.)""";
      } ctor;
    } reset_on_copy;
    // Symbol: drake::scalar_predicate
    struct /* scalar_predicate */ {
      // Source: drake/common/drake_bool.h:16
      const char* doc =
R"""(A traits struct that describes the return type of predicates over a
scalar type (named ``T``). For example, a predicate that evaluates
``double`s will return a `bool``, but a predicate that evaluates
symbolic::Expression will return a symbolic::Formula. By default, the
return type is inferred from the type's comparison operator, but
scalar types are permitted to specialize this template for their
needs.)""";
      // Symbol: drake::scalar_predicate::type
      struct /* type */ {
        // Source: drake/common/drake_bool.h:18
        const char* doc = R"""(The return type of predicates over T.)""";
      } type;
    } scalar_predicate;
    // Symbol: drake::schema
    struct /* schema */ {
      // Symbol: drake::schema::Deterministic
      struct /* Deterministic */ {
        // Source: drake/common/schema/stochastic.h:217
        const char* doc = R"""(A single deterministic ``value``.)""";
        // Symbol: drake::schema::Deterministic::Deterministic
        struct /* ctor */ {
          // Source: drake/common/schema/stochastic.h:219
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::schema::Deterministic::Mean
        struct /* Mean */ {
          // Source: drake/common/schema/stochastic.h:227
          const char* doc = R"""()""";
        } Mean;
        // Symbol: drake::schema::Deterministic::Sample
        struct /* Sample */ {
          // Source: drake/common/schema/stochastic.h:226
          const char* doc = R"""()""";
        } Sample;
        // Symbol: drake::schema::Deterministic::Serialize
        struct /* Serialize */ {
          // Source: drake/common/schema/stochastic.h:231
          const char* doc = R"""()""";
        } Serialize;
        // Symbol: drake::schema::Deterministic::ToSymbolic
        struct /* ToSymbolic */ {
          // Source: drake/common/schema/stochastic.h:228
          const char* doc = R"""()""";
        } ToSymbolic;
        // Symbol: drake::schema::Deterministic::value
        struct /* value */ {
          // Source: drake/common/schema/stochastic.h:235
          const char* doc = R"""()""";
        } value;
      } Deterministic;
      // Symbol: drake::schema::DeterministicVector
      struct /* DeterministicVector */ {
        // Source: drake/common/schema/stochastic.h:367
        const char* doc =
R"""(A single deterministic vector ``value``.

Template parameter ``Size``:
    rows at compile time (max 6) or else Eigen::Dynamic.)""";
        // Symbol: drake::schema::DeterministicVector::DeterministicVector<Size>
        struct /* ctor */ {
          // Source: drake/common/schema/stochastic.h:369
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::schema::DeterministicVector::Mean
        struct /* Mean */ {
          // Source: drake/common/schema/stochastic.h:376
          const char* doc = R"""()""";
        } Mean;
        // Symbol: drake::schema::DeterministicVector::Sample
        struct /* Sample */ {
          // Source: drake/common/schema/stochastic.h:375
          const char* doc = R"""()""";
        } Sample;
        // Symbol: drake::schema::DeterministicVector::Serialize
        struct /* Serialize */ {
          // Source: drake/common/schema/stochastic.h:380
          const char* doc = R"""()""";
        } Serialize;
        // Symbol: drake::schema::DeterministicVector::ToSymbolic
        struct /* ToSymbolic */ {
          // Source: drake/common/schema/stochastic.h:377
          const char* doc = R"""()""";
        } ToSymbolic;
        // Symbol: drake::schema::DeterministicVector::value
        struct /* value */ {
          // Source: drake/common/schema/stochastic.h:384
          const char* doc = R"""()""";
        } value;
      } DeterministicVector;
      // Symbol: drake::schema::Distribution
      struct /* Distribution */ {
        // Source: drake/common/schema/stochastic.h:203
        const char* doc =
R"""(Base class for a single distribution, to be used with YAML archives.
(See class DistributionVector for vector-valued distributions.)

See serialize_tips for implementation details, especially the
unusually public member fields in our subclasses.)""";
        // Symbol: drake::schema::Distribution::Distribution
        struct /* ctor */ {
          // Source: drake/common/schema/stochastic.h:212
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::schema::Distribution::Mean
        struct /* Mean */ {
          // Source: drake/common/schema/stochastic.h:208
          const char* doc = R"""()""";
        } Mean;
        // Symbol: drake::schema::Distribution::Sample
        struct /* Sample */ {
          // Source: drake/common/schema/stochastic.h:207
          const char* doc = R"""()""";
        } Sample;
        // Symbol: drake::schema::Distribution::ToSymbolic
        struct /* ToSymbolic */ {
          // Source: drake/common/schema/stochastic.h:209
          const char* doc = R"""()""";
        } ToSymbolic;
      } Distribution;
      // Symbol: drake::schema::DistributionVariant
      struct /* DistributionVariant */ {
        // Source: drake/common/schema/stochastic.h:306
        const char* doc =
R"""(Variant over all kinds of distributions.)""";
      } DistributionVariant;
      // Symbol: drake::schema::DistributionVector
      struct /* DistributionVector */ {
        // Source: drake/common/schema/stochastic.h:351
        const char* doc =
R"""(Base class for a vector of distributions, to be used with YAML
archives. (See class Distribution for scalar-valued distributions.)

See serialize_tips for implementation details, especially the
unusually public member fields in our subclasses.)""";
        // Symbol: drake::schema::DistributionVector::DistributionVector
        struct /* ctor */ {
          // Source: drake/common/schema/stochastic.h:360
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::schema::DistributionVector::Mean
        struct /* Mean */ {
          // Source: drake/common/schema/stochastic.h:356
          const char* doc = R"""()""";
        } Mean;
        // Symbol: drake::schema::DistributionVector::Sample
        struct /* Sample */ {
          // Source: drake/common/schema/stochastic.h:355
          const char* doc = R"""()""";
        } Sample;
        // Symbol: drake::schema::DistributionVector::ToSymbolic
        struct /* ToSymbolic */ {
          // Source: drake/common/schema/stochastic.h:357
          const char* doc = R"""()""";
        } ToSymbolic;
      } DistributionVector;
      // Symbol: drake::schema::DistributionVectorVariantX
      struct /* DistributionVectorVariantX */ {
        // Source: drake/common/schema/stochastic.h:483
        const char* doc =
R"""(DistributionVectorVariant that permits any vector size dynamically.)""";
      } DistributionVectorVariantX;
      // Symbol: drake::schema::Gaussian
      struct /* Gaussian */ {
        // Source: drake/common/schema/stochastic.h:239
        const char* doc =
R"""(A gaussian distribution with ``mean`` and ``stddev``.)""";
        // Symbol: drake::schema::Gaussian::Gaussian
        struct /* ctor */ {
          // Source: drake/common/schema/stochastic.h:241
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::schema::Gaussian::Mean
        struct /* Mean */ {
          // Source: drake/common/schema/stochastic.h:248
          const char* doc = R"""()""";
        } Mean;
        // Symbol: drake::schema::Gaussian::Sample
        struct /* Sample */ {
          // Source: drake/common/schema/stochastic.h:247
          const char* doc = R"""()""";
        } Sample;
        // Symbol: drake::schema::Gaussian::Serialize
        struct /* Serialize */ {
          // Source: drake/common/schema/stochastic.h:252
          const char* doc = R"""()""";
        } Serialize;
        // Symbol: drake::schema::Gaussian::ToSymbolic
        struct /* ToSymbolic */ {
          // Source: drake/common/schema/stochastic.h:249
          const char* doc = R"""()""";
        } ToSymbolic;
        // Symbol: drake::schema::Gaussian::mean
        struct /* mean */ {
          // Source: drake/common/schema/stochastic.h:257
          const char* doc = R"""()""";
        } mean;
        // Symbol: drake::schema::Gaussian::stddev
        struct /* stddev */ {
          // Source: drake/common/schema/stochastic.h:258
          const char* doc = R"""()""";
        } stddev;
      } Gaussian;
      // Symbol: drake::schema::GaussianVector
      struct /* GaussianVector */ {
        // Source: drake/common/schema/stochastic.h:399
        const char* doc =
R"""(A gaussian distribution with vector ``mean`` and vector or scalar
``stddev``.

When ``mean`` and ``stddev`` both have the same number of elements,
that denotes an elementwise pairing of the 0th mean with 0th stddev,
1st mean with 1st stddev, etc.

Alternatively, ``stddev`` can be a vector with a single element, no
matter the size of ``mean``; that denotes the same ``stddev`` value
applied to every element of ``mean``.

Template parameter ``Size``:
    rows at compile time (max 6) or else Eigen::Dynamic.)""";
        // Symbol: drake::schema::GaussianVector::GaussianVector<Size>
        struct /* ctor */ {
          // Source: drake/common/schema/stochastic.h:401
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::schema::GaussianVector::Mean
        struct /* Mean */ {
          // Source: drake/common/schema/stochastic.h:409
          const char* doc = R"""()""";
        } Mean;
        // Symbol: drake::schema::GaussianVector::Sample
        struct /* Sample */ {
          // Source: drake/common/schema/stochastic.h:408
          const char* doc = R"""()""";
        } Sample;
        // Symbol: drake::schema::GaussianVector::Serialize
        struct /* Serialize */ {
          // Source: drake/common/schema/stochastic.h:413
          const char* doc = R"""()""";
        } Serialize;
        // Symbol: drake::schema::GaussianVector::ToSymbolic
        struct /* ToSymbolic */ {
          // Source: drake/common/schema/stochastic.h:410
          const char* doc = R"""()""";
        } ToSymbolic;
        // Symbol: drake::schema::GaussianVector::mean
        struct /* mean */ {
          // Source: drake/common/schema/stochastic.h:418
          const char* doc = R"""()""";
        } mean;
        // Symbol: drake::schema::GaussianVector::stddev
        struct /* stddev */ {
          // Source: drake/common/schema/stochastic.h:419
          const char* doc = R"""()""";
        } stddev;
      } GaussianVector;
      // Symbol: drake::schema::GetDeterministicValue
      struct /* GetDeterministicValue */ {
        // Source: drake/common/schema/stochastic.h:342
        const char* doc_1args_var =
R"""(If ``var`` is deterministic, retrieves its value.

Raises:
    exception if ``var`` is not deterministic.)""";
        // Source: drake/common/schema/stochastic.h:500
        const char* doc_1args_constDistributionVectorVariant =
R"""(If ``vec`` is deterministic, retrieves its value.

Raises:
    exception if ``vec`` is not deterministic.

Template parameter ``Size``:
    rows at compile time (max 6) or else Eigen::Dynamic.)""";
      } GetDeterministicValue;
      // Symbol: drake::schema::IsDeterministic
      struct /* IsDeterministic */ {
        // Source: drake/common/schema/stochastic.h:338
        const char* doc_1args_var =
R"""(Returns true iff ``var`` is set to a deterministic value.)""";
        // Source: drake/common/schema/stochastic.h:494
        const char* doc_1args_constDistributionVectorVariant =
R"""(Returns true iff all of `vec`'s elements are set to a deterministic
value.

Template parameter ``Size``:
    rows at compile time (max 6) or else Eigen::Dynamic.)""";
      } IsDeterministic;
      // Symbol: drake::schema::Mean
      struct /* Mean */ {
        // Source: drake/common/schema/stochastic.h:318
        const char* doc_1args_var =
R"""(Like Distribution::Mean, but on a DistributionVariant instead.)""";
        // Source: drake/common/schema/stochastic.h:330
        const char* doc_1args_vec =
R"""(Like Distribution::Mean, but elementwise over a collection of
possibly-heterogenous DistributionVariant instead.)""";
      } Mean;
      // Symbol: drake::schema::Rotation
      struct /* Rotation */ {
        // Source: drake/common/schema/rotation.h:25
        const char* doc =
R"""(A specification for an SO(3) rotation, to be used for serialization
purposes, e.g., to define stochastic scenarios. This structure
specifies either one specific rotation or else a distribution of
possible rotations. It does not provide mathematical operators to
compose or mutate rotations. Instead, users should call either
GetDeterministicValue() or ToSymbolic() to obtain a RotationMatrix
value that can be operated on.

For an overview of configuring stochastic transforms, see
schema_transform and schema_stochastic.

See serialize_tips for implementation details, especially the
unusually public member fields.)""";
        // Symbol: drake::schema::Rotation::AngleAxis
        struct /* AngleAxis */ {
          // Source: drake/common/schema/rotation.h:62
          const char* doc =
R"""(Rotation constructed from a fixed axis and an angle.)""";
          // Symbol: drake::schema::Rotation::AngleAxis::AngleAxis
          struct /* ctor */ {
            // Source: drake/common/schema/rotation.h:63
            const char* doc = R"""()""";
          } ctor;
          // Symbol: drake::schema::Rotation::AngleAxis::Serialize
          struct /* Serialize */ {
            // Source: drake/common/schema/rotation.h:67
            const char* doc = R"""()""";
          } Serialize;
          // Symbol: drake::schema::Rotation::AngleAxis::angle_deg
          struct /* angle_deg */ {
            // Source: drake/common/schema/rotation.h:72
            const char* doc = R"""()""";
          } angle_deg;
          // Symbol: drake::schema::Rotation::AngleAxis::axis
          struct /* axis */ {
            // Source: drake/common/schema/rotation.h:73
            const char* doc = R"""()""";
          } axis;
        } AngleAxis;
        // Symbol: drake::schema::Rotation::GetDeterministicValue
        struct /* GetDeterministicValue */ {
          // Source: drake/common/schema/rotation.h:90
          const char* doc =
R"""(If this is deterministic, retrieves its value.

Raises:
    exception if this is not fully deterministic.)""";
        } GetDeterministicValue;
        // Symbol: drake::schema::Rotation::Identity
        struct /* Identity */ {
          // Source: drake/common/schema/rotation.h:39
          const char* doc = R"""(No-op rotation.)""";
          // Symbol: drake::schema::Rotation::Identity::Identity
          struct /* ctor */ {
            // Source: drake/common/schema/rotation.h:40
            const char* doc = R"""()""";
          } ctor;
          // Symbol: drake::schema::Rotation::Identity::Serialize
          struct /* Serialize */ {
            // Source: drake/common/schema/rotation.h:44
            const char* doc = R"""()""";
          } Serialize;
        } Identity;
        // Symbol: drake::schema::Rotation::IsDeterministic
        struct /* IsDeterministic */ {
          // Source: drake/common/schema/rotation.h:86
          const char* doc =
R"""(Returns true iff this is fully deterministic.)""";
        } IsDeterministic;
        // Symbol: drake::schema::Rotation::Rotation
        struct /* ctor */ {
          // Source: drake/common/schema/rotation.h:30
          const char* doc_0args = R"""(Constructs the Identity rotation.)""";
          // Source: drake/common/schema/rotation.h:33
          const char* doc_1args =
R"""(Constructs an Rpy rotation with the given value.)""";
        } ctor;
        // Symbol: drake::schema::Rotation::Rpy
        struct /* Rpy */ {
          // Source: drake/common/schema/rotation.h:49
          const char* doc =
R"""(A roll-pitch-yaw rotation, using the angle conventions of Drake's
RollPitchYaw.)""";
          // Symbol: drake::schema::Rotation::Rpy::Rpy
          struct /* ctor */ {
            // Source: drake/common/schema/rotation.h:50
            const char* doc = R"""()""";
          } ctor;
          // Symbol: drake::schema::Rotation::Rpy::Serialize
          struct /* Serialize */ {
            // Source: drake/common/schema/rotation.h:54
            const char* doc = R"""()""";
          } Serialize;
          // Symbol: drake::schema::Rotation::Rpy::deg
          struct /* deg */ {
            // Source: drake/common/schema/rotation.h:58
            const char* doc = R"""()""";
          } deg;
        } Rpy;
        // Symbol: drake::schema::Rotation::Serialize
        struct /* Serialize */ {
          // Source: drake/common/schema/rotation.h:103
          const char* doc = R"""()""";
        } Serialize;
        // Symbol: drake::schema::Rotation::ToSymbolic
        struct /* ToSymbolic */ {
          // Source: drake/common/schema/rotation.h:95
          const char* doc =
R"""(Returns the symbolic form of this rotation. If this is deterministic,
the result will contain no variables. If this is random, the result
will contain one or more random variables, based on the distributions
in use.)""";
        } ToSymbolic;
        // Symbol: drake::schema::Rotation::Uniform
        struct /* Uniform */ {
          // Source: drake/common/schema/rotation.h:77
          const char* doc =
R"""(Rotation sampled from a uniform distribution over SO(3).)""";
          // Symbol: drake::schema::Rotation::Uniform::Serialize
          struct /* Serialize */ {
            // Source: drake/common/schema/rotation.h:82
            const char* doc = R"""()""";
          } Serialize;
          // Symbol: drake::schema::Rotation::Uniform::Uniform
          struct /* ctor */ {
            // Source: drake/common/schema/rotation.h:78
            const char* doc = R"""()""";
          } ctor;
        } Uniform;
        // Symbol: drake::schema::Rotation::Variant
        struct /* Variant */ {
          // Source: drake/common/schema/rotation.h:107
          const char* doc = R"""()""";
        } Variant;
        // Symbol: drake::schema::Rotation::set_rpy_deg
        struct /* set_rpy_deg */ {
          // Source: drake/common/schema/rotation.h:98
          const char* doc =
R"""(Sets this value to the given deterministic RPY, in degrees.)""";
        } set_rpy_deg;
        // Symbol: drake::schema::Rotation::value
        struct /* value */ {
          // Source: drake/common/schema/rotation.h:108
          const char* doc = R"""()""";
        } value;
      } Rotation;
      // Symbol: drake::schema::Sample
      struct /* Sample */ {
        // Source: drake/common/schema/stochastic.h:314
        const char* doc_2args_var_generator =
R"""(Like Distribution::Sample, but on a DistributionVariant instead.)""";
        // Source: drake/common/schema/stochastic.h:325
        const char* doc_2args_vec_generator =
R"""(Like Distribution::Sample, but elementwise over a collection of
possibly-heterogenous DistributionVariant instead.)""";
      } Sample;
      // Symbol: drake::schema::ToDistribution
      struct /* ToDistribution */ {
        // Source: drake/common/schema/stochastic.h:310
        const char* doc =
R"""(Copies the given variant into a Distribution base class.)""";
      } ToDistribution;
      // Symbol: drake::schema::ToDistributionVector
      struct /* ToDistributionVector */ {
        // Source: drake/common/schema/stochastic.h:488
        const char* doc =
R"""(Copies the given variant into a DistributionVector base class.

Template parameter ``Size``:
    rows at compile time (max 6) or else Eigen::Dynamic.)""";
      } ToDistributionVector;
      // Symbol: drake::schema::ToSymbolic
      struct /* ToSymbolic */ {
        // Source: drake/common/schema/stochastic.h:321
        const char* doc_1args_var =
R"""(Like Distribution::ToSymbolic, but on a DistributionVariant instead.)""";
        // Source: drake/common/schema/stochastic.h:334
        const char* doc_1args_vec =
R"""(Like Distribution::ToSymbolic, but elementwise over a collection of
possibly-heterogenous DistributionVariant instead.)""";
      } ToSymbolic;
      // Symbol: drake::schema::Transform
      struct /* Transform */ {
        // Source: drake/common/schema/transform.h:152
        const char* doc =
R"""(A specification for a 3d rotation and translation, optionally with
respect to a base frame.

For an overview of configuring stochastic transforms, see
schema_transform and schema_stochastic.

See serialize_tips for implementation details, especially the
unusually public member fields.)""";
        // Symbol: drake::schema::Transform::GetDeterministicValue
        struct /* GetDeterministicValue */ {
          // Source: drake/common/schema/transform.h:172
          const char* doc =
R"""(If this is deterministic, retrieves its value.

Raises:
    exception if this is not fully deterministic.)""";
        } GetDeterministicValue;
        // Symbol: drake::schema::Transform::IsDeterministic
        struct /* IsDeterministic */ {
          // Source: drake/common/schema/transform.h:168
          const char* doc =
R"""(Returns true iff this is fully deterministic.)""";
        } IsDeterministic;
        // Symbol: drake::schema::Transform::Mean
        struct /* Mean */ {
          // Source: drake/common/schema/transform.h:185
          const char* doc =
R"""(Returns the mean of this rotation. If this is deterministic, the
result is the same as GetDeterministicValue. If this is random, note
that the mean here is simply defined as setting all of the random
variables individually to their mean. Various other measures of the
resulting RigidTransform (e.g., the distribution of one of the Euler
angles) may not necessarily match that measure on the returned value.)""";
        } Mean;
        // Symbol: drake::schema::Transform::Sample
        struct /* Sample */ {
          // Source: drake/common/schema/transform.h:189
          const char* doc =
R"""(Samples this Transform. If this is deterministic, the result is the
same as GetDeterministicValue.)""";
        } Sample;
        // Symbol: drake::schema::Transform::Serialize
        struct /* Serialize */ {
          // Source: drake/common/schema/transform.h:192
          const char* doc = R"""()""";
        } Serialize;
        // Symbol: drake::schema::Transform::ToSymbolic
        struct /* ToSymbolic */ {
          // Source: drake/common/schema/transform.h:177
          const char* doc =
R"""(Returns the symbolic form of this rotation. If this is deterministic,
the result will contain no variables. If this is random, the result
will contain one or more random variables, based on the distributions
in use.)""";
        } ToSymbolic;
        // Symbol: drake::schema::Transform::Transform
        struct /* ctor */ {
          // Source: drake/common/schema/transform.h:157
          const char* doc_0args = R"""(Constructs the Identity transform.)""";
          // Source: drake/common/schema/transform.h:160
          const char* doc_1args = R"""(Constructs the given transform.)""";
        } ctor;
        // Symbol: drake::schema::Transform::base_frame
        struct /* base_frame */ {
          // Source: drake/common/schema/transform.h:200
          const char* doc =
R"""(An optional base frame name for this transform. When left unspecified,
the default depends on the semantics of the enclosing struct.)""";
        } base_frame;
        // Symbol: drake::schema::Transform::rotation
        struct /* rotation */ {
          // Source: drake/common/schema/transform.h:206
          const char* doc =
R"""(A variant that allows for several ways to specify a rotation.)""";
        } rotation;
        // Symbol: drake::schema::Transform::set_rotation_rpy_deg
        struct /* set_rotation_rpy_deg */ {
          // Source: drake/common/schema/transform.h:163
          const char* doc =
R"""(Sets the rotation field to the given deterministic RPY, in degrees.)""";
        } set_rotation_rpy_deg;
        // Symbol: drake::schema::Transform::translation
        struct /* translation */ {
          // Source: drake/common/schema/transform.h:203
          const char* doc = R"""(A translation vector, in meters.)""";
        } translation;
      } Transform;
      // Symbol: drake::schema::Uniform
      struct /* Uniform */ {
        // Source: drake/common/schema/stochastic.h:262
        const char* doc =
R"""(A uniform distribution with ``min`` inclusive and ``max`` exclusive.)""";
        // Symbol: drake::schema::Uniform::Mean
        struct /* Mean */ {
          // Source: drake/common/schema/stochastic.h:271
          const char* doc = R"""()""";
        } Mean;
        // Symbol: drake::schema::Uniform::Sample
        struct /* Sample */ {
          // Source: drake/common/schema/stochastic.h:270
          const char* doc = R"""()""";
        } Sample;
        // Symbol: drake::schema::Uniform::Serialize
        struct /* Serialize */ {
          // Source: drake/common/schema/stochastic.h:275
          const char* doc = R"""()""";
        } Serialize;
        // Symbol: drake::schema::Uniform::ToSymbolic
        struct /* ToSymbolic */ {
          // Source: drake/common/schema/stochastic.h:272
          const char* doc = R"""()""";
        } ToSymbolic;
        // Symbol: drake::schema::Uniform::Uniform
        struct /* ctor */ {
          // Source: drake/common/schema/stochastic.h:264
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::schema::Uniform::max
        struct /* max */ {
          // Source: drake/common/schema/stochastic.h:281
          const char* doc = R"""()""";
        } max;
        // Symbol: drake::schema::Uniform::min
        struct /* min */ {
          // Source: drake/common/schema/stochastic.h:280
          const char* doc = R"""()""";
        } min;
      } Uniform;
      // Symbol: drake::schema::UniformDiscrete
      struct /* UniformDiscrete */ {
        // Source: drake/common/schema/stochastic.h:285
        const char* doc =
R"""(Chooses from among discrete ``values`` with equal probability.)""";
        // Symbol: drake::schema::UniformDiscrete::Mean
        struct /* Mean */ {
          // Source: drake/common/schema/stochastic.h:294
          const char* doc = R"""()""";
        } Mean;
        // Symbol: drake::schema::UniformDiscrete::Sample
        struct /* Sample */ {
          // Source: drake/common/schema/stochastic.h:293
          const char* doc = R"""()""";
        } Sample;
        // Symbol: drake::schema::UniformDiscrete::Serialize
        struct /* Serialize */ {
          // Source: drake/common/schema/stochastic.h:298
          const char* doc = R"""()""";
        } Serialize;
        // Symbol: drake::schema::UniformDiscrete::ToSymbolic
        struct /* ToSymbolic */ {
          // Source: drake/common/schema/stochastic.h:295
          const char* doc = R"""()""";
        } ToSymbolic;
        // Symbol: drake::schema::UniformDiscrete::UniformDiscrete
        struct /* ctor */ {
          // Source: drake/common/schema/stochastic.h:287
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::schema::UniformDiscrete::values
        struct /* values */ {
          // Source: drake/common/schema/stochastic.h:302
          const char* doc = R"""()""";
        } values;
      } UniformDiscrete;
      // Symbol: drake::schema::UniformVector
      struct /* UniformVector */ {
        // Source: drake/common/schema/stochastic.h:426
        const char* doc =
R"""(A uniform distribution with vector ``min`` inclusive and vector
``max`` exclusive.

Template parameter ``Size``:
    rows at compile time (max 6) or else Eigen::Dynamic.)""";
        // Symbol: drake::schema::UniformVector::Mean
        struct /* Mean */ {
          // Source: drake/common/schema/stochastic.h:436
          const char* doc = R"""()""";
        } Mean;
        // Symbol: drake::schema::UniformVector::Sample
        struct /* Sample */ {
          // Source: drake/common/schema/stochastic.h:435
          const char* doc = R"""()""";
        } Sample;
        // Symbol: drake::schema::UniformVector::Serialize
        struct /* Serialize */ {
          // Source: drake/common/schema/stochastic.h:440
          const char* doc = R"""()""";
        } Serialize;
        // Symbol: drake::schema::UniformVector::ToSymbolic
        struct /* ToSymbolic */ {
          // Source: drake/common/schema/stochastic.h:437
          const char* doc = R"""()""";
        } ToSymbolic;
        // Symbol: drake::schema::UniformVector::UniformVector<Size>
        struct /* ctor */ {
          // Source: drake/common/schema/stochastic.h:428
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::schema::UniformVector::max
        struct /* max */ {
          // Source: drake/common/schema/stochastic.h:446
          const char* doc = R"""()""";
        } max;
        // Symbol: drake::schema::UniformVector::min
        struct /* min */ {
          // Source: drake/common/schema/stochastic.h:445
          const char* doc = R"""()""";
        } min;
      } UniformVector;
    } schema;
    // Symbol: drake::solvers
    struct /* solvers */ {
      // Symbol: drake::solvers::AddBilinearProductMcCormickEnvelopeMultipleChoice
      struct /* AddBilinearProductMcCormickEnvelopeMultipleChoice */ {
        // Source: drake/solvers/mixed_integer_optimization_util.h:405
        const char* doc =
R"""(Add constraints to the optimization program, such that the bilinear
product x * y is approximated by w, using Mixed Integer constraint
with "Multiple Choice" model. To do so, we assume that the range of x
is [x_min, x_max], and the range of y is [y_min, y_max]. We first
consider two arrays φˣ, φʸ, satisfying


::

    x_min = φˣ₀ < φˣ₁ < ... < φˣₘ = x_max
    y_min = φʸ₀ < φʸ₁ < ... < φʸₙ = y_max

, and divide the range of x into intervals [φˣ₀, φˣ₁], [φˣ₁, φˣ₂], ...
, [φˣₘ₋₁, φˣₘ] and the range of y into intervals [φʸ₀, φʸ₁], [φʸ₁,
φʸ₂], ... , [φʸₙ₋₁, φʸₙ]. The xy plane is thus cut into rectangles,
with each rectangle as [φˣᵢ, φˣᵢ₊₁] x [φʸⱼ, φʸⱼ₊₁]. The convex hull of
the surface z = x * y for x, y in each rectangle is a tetrahedron. We
then approximate the bilinear product x * y with w, such that (x, y,
w) is in one of the tetrahedrons.

Parameter ``prog``:
    The optimization problem to which the constraints will be added.

Parameter ``x``:
    A variable in the bilinear product.

Parameter ``y``:
    A variable in the bilinear product.

Parameter ``w``:
    The expression that approximates the bilinear product x * y.

Parameter ``phi_x``:
    φˣ in the documentation above. Will be used to cut the range of x
    into small intervals.

Parameter ``phi_y``:
    φʸ in the documentation above. Will be used to cut the range of y
    into small intervals.

Parameter ``Bx``:
    The binary-valued expression indicating which interval x is in.
    Bx(i) = 1 => φˣᵢ ≤ x ≤ φˣᵢ₊₁.

Parameter ``By``:
    The binary-valued expression indicating which interval y is in.
    By(i) = 1 => φʸⱼ ≤ y ≤ φʸⱼ₊₁.

One formulation of the constraint is


::

    x = ∑ᵢⱼ x̂ᵢⱼ
    y = ∑ᵢⱼ ŷᵢⱼ
    Bˣʸᵢⱼ = Bˣᵢ ∧ Bʸⱼ
    ∑ᵢⱼ Bˣʸᵢⱼ = 1
    φˣᵢ Bˣʸᵢⱼ ≤ x̂ᵢⱼ ≤ φˣᵢ₊₁ Bˣʸᵢⱼ
    φʸⱼ Bˣʸᵢⱼ ≤ ŷᵢⱼ ≤ φʸⱼ₊₁ Bˣʸᵢⱼ
    w ≥ ∑ᵢⱼ (x̂ᵢⱼ φʸⱼ   + φˣᵢ   ŷᵢⱼ - φˣᵢ  φʸⱼ   Bˣʸᵢⱼ)
    w ≥ ∑ᵢⱼ (x̂ᵢⱼ φʸⱼ₊₁ + φˣᵢ₊₁ ŷᵢⱼ - φˣᵢ₊₁ φʸⱼ₊₁ Bˣʸᵢⱼ)
    w ≤ ∑ᵢⱼ (x̂ᵢⱼ φʸⱼ   + φˣᵢ₊₁ ŷᵢⱼ - φˣᵢ₊₁ φʸⱼ   Bˣʸᵢⱼ)
    w ≤ ∑ᵢⱼ (x̂ᵢⱼ φʸⱼ₊₁ + φˣᵢ   ŷᵢⱼ - φˣᵢ   φʸⱼ₊₁ Bˣʸᵢⱼ)

The "logical and" constraint Bˣʸᵢⱼ = Bˣᵢ ∧ Bʸⱼ can be imposed as


::

    Bˣʸᵢⱼ ≥ Bˣᵢ + Bʸⱼ - 1
    Bˣʸᵢⱼ ≤ Bˣᵢ
    Bˣʸᵢⱼ ≤ Bʸⱼ
    0 ≤ Bˣʸᵢⱼ ≤ 1

This formulation will introduce slack variables x̂, ŷ and Bˣʸ, in
total 3 * m * n variables.

In order to reduce the number of slack variables, we can further
simplify these constraints, by defining two vectors ``x̅ ∈ ℝⁿ``, `y̅ ∈
ℝᵐ` as


::

    x̅ⱼ = ∑ᵢ x̂ᵢⱼ
    y̅ᵢ = ∑ⱼ ŷᵢⱼ

and the constraints above can be re-formulated using ``x̅`` and ``y̅``
as


::

    x = ∑ⱼ x̅ⱼ
    y = ∑ᵢ y̅ᵢ
    Bˣʸᵢⱼ = Bˣᵢ ∧ Bʸⱼ
    ∑ᵢⱼ Bˣʸᵢⱼ = 1
    ∑ᵢ φˣᵢ Bˣʸᵢⱼ ≤ x̅ⱼ ≤ ∑ᵢ φˣᵢ₊₁ Bˣʸᵢⱼ
    ∑ⱼ φʸⱼ Bˣʸᵢⱼ ≤ y̅ᵢ ≤ ∑ⱼ φʸⱼ₊₁ Bˣʸᵢⱼ
    w ≥ ∑ⱼ( x̅ⱼ φʸⱼ   ) + ∑ᵢ( φˣᵢ   y̅ᵢ ) - ∑ᵢⱼ( φˣᵢ   φʸⱼ   Bˣʸᵢⱼ )
    w ≥ ∑ⱼ( x̅ⱼ φʸⱼ₊₁ ) + ∑ᵢ( φˣᵢ₊₁ y̅ᵢ ) - ∑ᵢⱼ( φˣᵢ₊₁ φʸⱼ₊₁ Bˣʸᵢⱼ )
    w ≤ ∑ⱼ( x̅ⱼ φʸⱼ   ) + ∑ᵢ( φˣᵢ₊₁ y̅ⱼ ) - ∑ᵢⱼ( φˣᵢ₊₁ φʸⱼ   Bˣʸᵢⱼ )
    w ≤ ∑ⱼ( x̅ⱼ φʸⱼ₊₁ ) + ∑ᵢ( φˣᵢ   y̅ᵢ ) - ∑ᵢⱼ( φˣᵢ   φʸⱼ₊₁ Bˣʸᵢⱼ ).

In this formulation, we introduce new continuous variables ``x̅``,
`y̅`, ``Bˣʸ``. The total number of new variables is m + n + m * n.

In section 3.3 of Mixed-Integer Models for Nonseparable Piecewise
Linear Optimization: Unifying Framework and Extensions by Juan P
Vielma, Shabbir Ahmed and George Nemhauser, this formulation is called
"Multiple Choice Model".

Note:
    We DO NOT add the constraint Bx(i) ∈ {0, 1}, By(j) ∈ {0, 1} in
    this function. It is the user's responsibility to ensure that
    these binary constraints are enforced. The users can also add
    cutting planes ∑ᵢBx(i) = 1, ∑ⱼBy(j) = 1. Without these two cutting
    planes, (x, y, w) is still in the McCormick envelope of z = x * y,
    but these two cutting planes "might" improve the computation speed
    in the mixed-integer solver.)""";
      } AddBilinearProductMcCormickEnvelopeMultipleChoice;
      // Symbol: drake::solvers::AddBilinearProductMcCormickEnvelopeSos2
      struct /* AddBilinearProductMcCormickEnvelopeSos2 */ {
        // Source: drake/solvers/mixed_integer_optimization_util.h:251
        const char* doc =
R"""(Add constraints to the optimization program, such that the bilinear
product x * y is approximated by w, using Special Ordered Set of Type
2 (sos2) constraint. To do so, we assume that the range of x is
[x_min, x_max], and the range of y is [y_min, y_max]. We first
consider two arrays φˣ, φʸ, satisfying


::

    x_min = φˣ₀ < φˣ₁ < ... < φˣₘ = x_max
    y_min = φʸ₀ < φʸ₁ < ... < φʸₙ = y_max

, and divide the range of x into intervals [φˣ₀, φˣ₁], [φˣ₁, φˣ₂], ...
, [φˣₘ₋₁, φˣₘ] and the range of y into intervals [φʸ₀, φʸ₁], [φʸ₁,
φʸ₂], ... , [φʸₙ₋₁, φʸₙ]. The xy plane is thus cut into rectangles,
with each rectangle as [φˣᵢ, φˣᵢ₊₁] x [φʸⱼ, φʸⱼ₊₁]. The convex hull of
the surface z = x * y for x, y in each rectangle is a tetrahedron. We
then approximate the bilinear product x * y with w, such that (x, y,
w) is in one of the tetrahedrons.

We use two different encoding schemes on the binary variables, to
determine which interval is active. We can choose either linear or
logarithmic binning. When using linear binning, for a variable with N
intervals, we use N binary variables, and B(i) = 1 indicates the
variable is in the i'th interval. When using logarithmic binning, we
use ⌈log₂(N)⌉ binary variables. If these binary variables represent
integer M in the reflected Gray code, then the continuous variable is
in the M'th interval.

Parameter ``prog``:
    The program to which the bilinear product constraint is added

Parameter ``x``:
    The decision variable.

Parameter ``y``:
    The decision variable.

Parameter ``w``:
    The expression to approximate x * y

Parameter ``phi_x``:
    The end points of the intervals for ``x``.

Parameter ``phi_y``:
    The end points of the intervals for ``y``.

Parameter ``Bx``:
    The binary variables for the interval in which x stays encoded as
    described above.

Parameter ``By``:
    The binary variables for the interval in which y stays encoded as
    described above.

Parameter ``binning``:
    Determine whether to use linear binning or logarithmic binning.

Returns:
    lambda The auxiliary continuous variables.

The constraints we impose are


::

    x = (φˣ)ᵀ * ∑ⱼ λᵢⱼ
    y = (φʸ)ᵀ * ∑ᵢ λᵢⱼ
    w = ∑ᵢⱼ φˣᵢ * φʸⱼ * λᵢⱼ
    Both ∑ⱼ λᵢⱼ = λ.rowwise().sum() and ∑ᵢ λᵢⱼ = λ.colwise().sum() satisfy SOS2
    constraint.

If x ∈ [φx(M), φx(M+1)] and y ∈ [φy(N), φy(N+1)], then only λ(M, N),
λ(M + 1, N), λ(M, N + 1) and λ(M+1, N+1) can be strictly positive, all
other λ(i, j) are zero.

Note:
    We DO NOT add the constraint Bx(i) ∈ {0, 1}, By(j) ∈ {0, 1} in
    this function. It is the user's responsibility to ensure that
    these constraints are enforced.)""";
      } AddBilinearProductMcCormickEnvelopeSos2;
      // Symbol: drake::solvers::AddBoundingBoxConstraintsImpliedByRollPitchYawLimits
      struct /* AddBoundingBoxConstraintsImpliedByRollPitchYawLimits */ {
        // Source: drake/solvers/rotation_constraint.h:74
        const char* doc =
R"""(Applies *very conservative* limits on the entries of R for the cases
when rotations can be limited (for instance, if you want to search
over rotations, but there is an obvious symmetry in the problem so
that e.g. 0 < pitch < PI need not be considered). A matrix so
constrained may still contain rotations outside of this envelope.
Note: For simple rotational symmetry over PI, prefer
kPitch_NegPI_2_to_PI_2 (over 0_to_PI) because it adds one more
constraint (when combined with constraints on roll and yaw). Note: The
Roll-Pitch-Yaw angles follow the convention in RollPitchYaw, namely
extrinsic rotations about Space-fixed x-y-z axes, respectively.)""";
      } AddBoundingBoxConstraintsImpliedByRollPitchYawLimits;
      // Symbol: drake::solvers::AddLogarithmicSos1Constraint
      struct /* AddLogarithmicSos1Constraint */ {
        // Source: drake/solvers/mixed_integer_optimization_util.h:135
        const char* doc_4args =
R"""(Adds the special ordered set of type 1 (SOS1) constraint. Namely


::

    λ(0) + ... + λ(n-1) = 1
      λ(i) ≥ 0 ∀i
      ∃ j ∈ {0, 1, ..., n-1}, s.t λ(j) = 1

where one and only one of λ(i) is 1, all other λ(j) are 0. We will
need to add ⌈log₂(n)⌉ binary variables, where n is the number of rows
in λ. For more information, please refer to Modeling Disjunctive
Constraints with a Logarithmic Number of Binary Variables and
Constraints by J. Vielma and G. Nemhauser, 2011.

Parameter ``prog``:
    The program to which the SOS1 constraint is added.

Parameter ``lambda``:
    lambda is in SOS1.

Parameter ``y``:
    The binary variables indicating which λ is positive. For a given
    assignment on the binary variable ``y``, if (y(0), ...,
    y(⌈log₂(n)⌉) represents integer M in ``binary_encoding``, then
    only λ(M) is positive. Namely, if (y(0), ..., y(⌈log₂(n)⌉) equals
    to binary_encoding.row(M), then λ(M) = 1

Parameter ``binary_encoding``:
    A n x ⌈log₂(n)⌉ matrix. binary_encoding.row(i) represents integer
    i. No two rows of ``binary_encoding`` can be the same.

Raises:
    RuntimeError if ``binary_encoding`` has a non-binary entry (0, 1).)""";
        // Source: drake/solvers/mixed_integer_optimization_util.h:165
        const char* doc_2args =
R"""(Adds the special ordered set of type 1 (SOS1) constraint. Namely


::

    λ(0) + ... + λ(n-1) = 1
      λ(i) ≥ 0 ∀i
      ∃ j ∈ {0, 1, ..., n-1}, s.t λ(j) = 1

where one and only one of λ(i) is 1, all other λ(j) are 0. We will
need to add ⌈log₂(n)⌉ binary variables, where n is the number of rows
in λ. For more information, please refer to Modeling Disjunctive
Constraints with a Logarithmic Number of Binary Variables and
Constraints by J. Vielma and G. Nemhauser, 2011.

Parameter ``prog``:
    The program to which the SOS1 constraint is added.

Parameter ``num_lambda``:
    n in the documentation above.

Returns:
    (lambda, y) lambda is λ in the documentation above. Notice that λ
    are declared as continuous variables, but they only admit binary
    solutions. y are binary variables of size ⌈log₂(n)⌉. When this
    sos1 constraint is satisfied, suppose that λ(i)=1 and λ(j)=0 ∀
    j≠i, then y is the Reflected Gray code of i. For example, suppose
    n = 8, i = 5, then y is a vector of size ⌈log₂(n)⌉ = 3, and the
    value of y is (1, 1, 0) which equals to 5 according to reflected
    Gray code.)""";
      } AddLogarithmicSos1Constraint;
      // Symbol: drake::solvers::AddLogarithmicSos2Constraint
      struct /* AddLogarithmicSos2Constraint */ {
        // Source: drake/solvers/mixed_integer_optimization_util.h:71
        const char* doc_3args_drakesolversMathematicalProgram_constEigenMatrixBase_conststdstring =
R"""(Adds the special ordered set 2 (SOS2) constraint,


::

    λ(0) + ... + λ(n) = 1
      ∀i. λ(i) ≥ 0
      ∃ j ∈ {0, 1, ..., n-1}, s.t λ(i) = 0 if i ≠ j and i ≠ j + 1

Namely at most two entries in λ can be strictly positive, and these
two entries have to be adjacent. All other λ should be zero. Moreover,
the non-zero λ satisfies λ(j) + λ(j + 1) = 1. We will need to add
⌈log₂(n - 1)⌉ binary variables, where n is the number of rows in λ.
For more information, please refer to Modeling Disjunctive Constraints
with a Logarithmic Number of Binary Variables and Constraints by J.
Vielma and G. Nemhauser, 2011.

Parameter ``prog``:
    Add the SOS2 constraint to this mathematical program.

Parameter ``lambda``:
    At most two entries in λ can be strictly positive, and these two
    entries have to be adjacent. All other entries are zero.

Returns:
    y The newly added binary variables. The assignment of the binary
    variable y implies which two λ can be strictly positive. With a
    binary assignment on y, and suppose the integer M corresponds to
    (y(0), y(1), ..., y(⌈log₂(n - 1)⌉)) in Gray code, then only λ(M)
    and λ(M + 1) can be non-zero. For example, if the assignment of y
    = (1, 1), in Gray code, (1, 1) represents integer 2, so only λ(2)
    and λ(3) can be strictly positive.)""";
        // Source: drake/solvers/mixed_integer_optimization_util.h:86
        const char* doc_3args_prog_lambda_y =
R"""(Adds the special ordered set 2 (SOS2) constraint,

See also:
    AddLogarithmicSos2Constraint.)""";
      } AddLogarithmicSos2Constraint;
      // Symbol: drake::solvers::AddRelaxNonConvexQuadraticConstraintInTrustRegion
      struct /* AddRelaxNonConvexQuadraticConstraintInTrustRegion */ {
        // Source: drake/solvers/non_convex_optimization_util.h:156
        const char* doc =
R"""(For a non-convex quadratic constraint lb ≤ xᵀQ₁x - xᵀQ₂x + pᵀy ≤ ub
where Q₁, Q₂ are both positive semidefinite matrices. ``y`` is a
vector that can overlap with ``x``. We relax this non-convex
constraint by several convex constraints. The steps are 1. Introduce
two new variables z₁, z₂, to replace xᵀQ₁x and xᵀQ₂x respectively. The
constraint becomes


::

    lb ≤ z₁ - z₂ + pᵀy ≤ ub              (1)

2. Ideally, we would like to enforce z₁ = xᵀQ₁x and z₂ = xᵀQ₂x through convex
   constraints. To this end, we first bound z₁ and z₂ from below, as
   


::

    z₁ ≥ xᵀQ₁x                            (2)
         z₂ ≥ xᵀQ₂x                            (3)

These two constraints are second order cone constraints. 3. To bound
z₁ and z₂ from above, we linearize the quadratic forms xᵀQ₁x and xᵀQ₂x
at a point x₀. Due to the convexity of the quadratic form, we know
that given a positive scalar d > 0, there exists a neighbourhood N(x₀)
around x₀, s.t ∀ x ∈ N(x₀)


::

    xᵀQ₁x ≤ 2 x₀ᵀQ₁(x - x₀) + x₀ᵀQ₁x₀ + d   (4)
       xᵀQ₂x ≤ 2 x₀ᵀQ₂(x - x₀) + x₀ᵀQ₂x₀ + d   (5)

Notice N(x₀) is the intersection of two ellipsoids, as formulated in
(4) and (5). Therefore, we also enforce the linear constraints


::

    z₁ ≤ 2 x₀ᵀQ₁(x - x₀) + x₀ᵀQ₁x₀ + d    (6)
         z₂ ≤ 2 x₀ᵀQ₂(x - x₀) + x₀ᵀQ₂x₀ + d    (7)

So we relax the original non-convex constraint, with the convex
constraints (1)-(3), (6) and (7).

The trust region is the neighbourhood N(x₀) around x₀, such that the
inequalities (4), (5) are satisfied ∀ x ∈ N(x₀).

The positive scalar d controls both how much the constraint relaxation
is (the original constraint can be violated by at most d), and how big
the trust region is.

If there is a solution satisfying the relaxed constraint, this
solution can violate the original non-convex constraint by at most d;
on the other hand, if there is not a solution satisfying the relaxed
constraint, it proves that the original non-convex constraint does not
have a solution in the trust region.

This approach is outlined in section III of On Time Optimization of
Centroidal Momentum Dynamics by Brahayam Ponton, Alexander Herzog,
Stefan Schaal and Ludovic Righetti, ICRA, 2018

The special cases are when Q₁ = 0 or Q₂ = 0. 1. When Q₁ = 0, the
original constraint becomes lb ≤ -xᵀQ₂x + pᵀy ≤ ub If ub = +∞, then
the original constraint is the convex rotated Lorentz cone constraint
xᵀQ₂x ≤ pᵀy - lb. The user should not call this function to relax this
convex constraint.

Raises:
    RuntimeError if Q₁ = 0 and ub = +∞. If ub < +∞, then we introduce
    a new variable z, with the constraints lb ≤ -z + pᵀy ≤ ub z ≥
    xᵀQ₂x z ≤ 2 x₀ᵀQ₂(x - x₀) + x₀ᵀQ₂x₀ + d 2. When Q₂ = 0, the
    constraint becomes lb ≤ xᵀQ₁x + pᵀy ≤ ub If lb = -∞, then the
    original constraint is the convex rotated Lorentz cone constraint
    xᵀQ₁x ≤ ub - pᵀy. The user should not call this function to relax
    this convex constraint.

Raises:
    RuntimeError if Q₂ = 0 and lb = -∞. If lb > -∞, then we introduce
    a new variable z, with the constraints lb ≤ z + pᵀy ≤ ub z ≥ xᵀQ₁x
    z ≤ 2 x₀ᵀQ₁(x - x₀) + x₀ᵀQ₁x₀ + d 3. If both Q₁ and Q₂ are zero,
    then the original constraint is a convex linear constraint lb ≤
    pᵀx ≤ ub. The user should not call this function to relax this
    convex constraint. Throw a runtime error.

Parameter ``prog``:
    The MathematicalProgram to which the relaxed constraints are
    added.

Parameter ``x``:
    The decision variables which appear in the original non-convex
    constraint.

Parameter ``Q1``:
    A positive semidefinite matrix.

Parameter ``Q2``:
    A positive semidefinite matrix.

Parameter ``y``:
    A vector, the variables in the linear term of the quadratic form.

Parameter ``p``:
    A vector, the linear coefficients of the quadratic form.

Parameter ``linearization_point``:
    The vector ``x₀`` in the documentation above.

Parameter ``lower_bound``:
    The left-hand side of the original non-convex constraint.

Parameter ``upper_bound``:
    The right-hand side of the original non-convex constraint.

Parameter ``trust_region_gap``:
    The user-specified positive scalar, ``d`` in the documentation
    above. This gap determines both the maximal constraint violation
    and the size of the trust region. @retval <linear_constraint,
    rotated_lorentz_cones, z> linear_constraint includes (1)(6)(7)
    rotated_lorentz_cones are (2) (3) When either Q1 or Q2 is zero,
    rotated_lorentz_cones contains only one rotated Lorentz cone,
    either (2) or (3). z is the newly added variable.

Precondition:
1. Q1, Q2 are positive semidefinite.
     2. d is positive.
     3. Q1, Q2, x, x₀ are all of the consistent size.
     4. p and y are of the consistent size.
     5. lower_bound ≤ upper_bound.

    $Raises:

RuntimeError when the precondition is not satisfied.)""";
      } AddRelaxNonConvexQuadraticConstraintInTrustRegion;
      // Symbol: drake::solvers::AddRotationMatrixBoxSphereIntersectionMilpConstraints
      struct /* AddRotationMatrixBoxSphereIntersectionMilpConstraints */ {
        // Source: drake/solvers/mixed_integer_rotation_constraint.h:228
        const char* doc =
R"""(Adds binary variables that constrain the value of the column *and* row
vectors of R, in order to add the following (in some cases non-convex)
constraints as an MILP. Specifically, for column vectors Ri, we
constrain:

- forall i, |Ri| = 1 ± envelope,
- forall i,j. i ≠ j, Ri.dot(Rj) = 0 ± envelope,
- R2 = R0.cross(R1) ± envelope,
     and again for R0=R1.cross(R2), and R1=R2.cross(R0).

Then all of the same constraints are also added to R^T. The size of
the envelope decreases quickly as num_binary_variables_per_half_axis
is is increased.

Note:
    Creates ``9*2*num_binary_variables_per_half_axis binary``
    variables named "BRpos*(*,*)" and "BRneg*(*,*)", and the same
    number of continuous variables named "CRpos*(*,*)" and
    "CRneg*(*,*)".

Note:
    The particular representation/algorithm here was developed in an
    attempt: - to enable efficient reuse of the variables between the
    constraints between multiple rows/columns (e.g. the constraints on
    Rᵀ use the same variables as the constraints on R), and - to
    facilitate branch-and-bound solution techniques -- binary regions
    are layered so that constraining one region establishes
    constraints on large portions of SO(3), and confers hopefully
    "useful" constraints the on other binary variables.

Parameter ``R``:
    The rotation matrix

Parameter ``num_intervals_per_half_axis``:
    number of intervals for a half axis.

Parameter ``prog``:
    The mathematical program to which the constraints are added.

Note:
    This method uses the same approach as
    MixedIntegerRotationConstraintGenerator with
    kBoxSphereIntersection, namely the feasible sets to both
    relaxation are the same. But they use different sets of binary
    variables, and thus the computation speed can be different inside
    optimization solvers.)""";
      } AddRotationMatrixBoxSphereIntersectionMilpConstraints;
      // Symbol: drake::solvers::AddRotationMatrixBoxSphereIntersectionReturn
      struct /* AddRotationMatrixBoxSphereIntersectionReturn */ {
        // Source: drake/solvers/mixed_integer_rotation_constraint.h:183
        const char* doc =
R"""(Some of the newly added variables in function
AddRotationMatrixBoxSphereIntersectionMilpConstraints. CRpos, CRneg,
BRpos and BRneg can only take value 0 or 1. ``CRpos`` and ``CRneg``
are declared as continuous variables, while ``BRpos`` and ``BRneg``
are declared as binary variables. The definition for these variables
are


::

    CRpos[k](i, j) = 1 => k / N <= R(i, j) <= (k+1) / N
      CRneg[k](i, j) = 1 => -(k+1) / N <= R(i, j) <= -k / N
      BRpos[k](i, j) = 1 => R(i, j) >= k / N
      BRneg[k](i, j) = 1 => R(i, j) <= -k / N

where ``N`` is ``num_intervals_per_half_axis``, one of the input
argument of AddRotationMatrixBoxSphereIntersectionMilpConstraints.)""";
        // Symbol: drake::solvers::AddRotationMatrixBoxSphereIntersectionReturn::BRneg
        struct /* BRneg */ {
          // Source: drake/solvers/mixed_integer_rotation_constraint.h:187
          const char* doc = R"""()""";
        } BRneg;
        // Symbol: drake::solvers::AddRotationMatrixBoxSphereIntersectionReturn::BRpos
        struct /* BRpos */ {
          // Source: drake/solvers/mixed_integer_rotation_constraint.h:186
          const char* doc = R"""()""";
        } BRpos;
        // Symbol: drake::solvers::AddRotationMatrixBoxSphereIntersectionReturn::CRneg
        struct /* CRneg */ {
          // Source: drake/solvers/mixed_integer_rotation_constraint.h:185
          const char* doc = R"""()""";
        } CRneg;
        // Symbol: drake::solvers::AddRotationMatrixBoxSphereIntersectionReturn::CRpos
        struct /* CRpos */ {
          // Source: drake/solvers/mixed_integer_rotation_constraint.h:184
          const char* doc = R"""()""";
        } CRpos;
      } AddRotationMatrixBoxSphereIntersectionReturn;
      // Symbol: drake::solvers::AddRotationMatrixOrthonormalSocpConstraint
      struct /* AddRotationMatrixOrthonormalSocpConstraint */ {
        // Source: drake/solvers/rotation_constraint.h:91
        const char* doc =
R"""(Adds a set of convex constraints which approximate the set of
orthogonal matrices, O(3). Adds the bilinear constraints that the each
column Ri has length <= 1 and that Ri'Rj approx 0 via -2 + |Ri|^2 +
|Rj|^2 <= 2Ri'Rj <= 2 - |Ri|^2 - |Rj|^2 (for all i!=j), using a
second-order-cone relaxation. Additionally, the same constraints are
applied to all of the rows.)""";
      } AddRotationMatrixOrthonormalSocpConstraint;
      // Symbol: drake::solvers::AddRotationMatrixSpectrahedralSdpConstraint
      struct /* AddRotationMatrixSpectrahedralSdpConstraint */ {
        // Source: drake/solvers/rotation_constraint.h:81
        const char* doc =
R"""(Adds constraint (10) from https://arxiv.org/pdf/1403.4914.pdf , which
exactly represents the convex hull of all rotation matrices in 3D.)""";
      } AddRotationMatrixSpectrahedralSdpConstraint;
      // Symbol: drake::solvers::AddSos2Constraint
      struct /* AddSos2Constraint */ {
        // Source: drake/solvers/mixed_integer_optimization_util.h:106
        const char* doc =
R"""(Adds the special ordered set 2 (SOS2) constraint. y(i) takes binary
values (either 0 or 1).


::

    y(i) = 1 => λ(i) + λ(i + 1) = 1.

See also:
    AddLogarithmicSos2Constraint for a complete explanation on SOS2
    constraint.

Parameter ``prog``:
    The optimization program to which the SOS2 constraint is added.

Parameter ``lambda``:
    At most two entries in λ can be strictly positive, and these two
    entries have to be adjacent. All other entries are zero. Moreover,
    these two entries should sum up to 1.

Parameter ``y``:
    y(i) takes binary value, and determines which two entries in λ can
    be strictly positive. Throw a runtime error if y.rows() !=
    lambda.rows() - 1.)""";
      } AddSos2Constraint;
      // Symbol: drake::solvers::AggregateBoundingBoxConstraints
      struct /* AggregateBoundingBoxConstraints */ {
        // Source: drake/solvers/aggregate_costs_constraints.h:64
        const char* doc_1args =
R"""(Aggregates many bounding box constraints, returns the intersection
(the tightest bounds) of these constraints.

Parameter ``bounding_box_constraints``:
    The constraints to be aggregated.

Returns ``aggregated_bounds``:
    aggregated_bounds[var.get_id()] returns the (lower, upper) bounds
    of that variable as the tightest bounds of
    ``bounding_box_constraints``.)""";
        // Source: drake/solvers/aggregate_costs_constraints.h:79
        const char* doc_3args =
R"""(Aggregates all the BoundingBoxConstraints inside ``prog``, returns the
intersection of the bounding box constraints as the lower and upper
bound for each variable in ``prog``.

Parameter ``prog``:
    The optimization program containing decision variables and
    BoundingBoxConstraints.

Parameter ``lower``:
    (*lower)[i] is the lower bound of prog.decision_variable(i).

Parameter ``upper``:
    (*upper)[i] is the upper bound of prog.decision_variable(i).)""";
      } AggregateBoundingBoxConstraints;
      // Symbol: drake::solvers::AggregateLinearCosts
      struct /* AggregateLinearCosts */ {
        // Source: drake/solvers/aggregate_costs_constraints.h:21
        const char* doc =
R"""(Given many linear costs, aggregate them into

aᵀ*x + b,

Parameter ``linear_costs``:
    the linear costs to be aggregated.

Parameter ``linear_coeff``:
    [out] a in the documentation above.

Parameter ``vars``:
    [out] x in the documentation above.

Parameter ``constant_cost``:
    [out] b in the documentation above.)""";
      } AggregateLinearCosts;
      // Symbol: drake::solvers::AggregateQuadraticAndLinearCosts
      struct /* AggregateQuadraticAndLinearCosts */ {
        // Source: drake/solvers/aggregate_costs_constraints.h:38
        const char* doc =
R"""(Given many linear and quadratic costs, aggregate them into

0.5*x₁ᵀQx₁ + bᵀx₂ + c where x₁ and x₂ don't need to be the same.

Parameter ``quadratic_costs``:
    The quadratic costs to be aggregated.

Parameter ``linear_costs``:
    The linear costs to be aggregated.

Parameter ``Q_lower``:
    [out] The lower triangular part of the matrix Q.

Parameter ``quadratic_vars``:
    [out] x₁ in the documentation above.

Parameter ``linear_coeff``:
    [out] b in the documentation above.

Parameter ``linear_vars``:
    [out] x₂ in the documentation above.

Parameter ``constant_cost``:
    [out] c in the documentation above.)""";
      } AggregateQuadraticAndLinearCosts;
      // Symbol: drake::solvers::AreRequiredAttributesSupported
      struct /* AreRequiredAttributesSupported */ {
        // Source: drake/solvers/program_attribute.h:44
        const char* doc =
R"""(Returns true if ``required`` is a subset of ``supported``.)""";
      } AreRequiredAttributesSupported;
      // Symbol: drake::solvers::Binding
      struct /* Binding */ {
        // Source: drake/solvers/binding.h:23
        const char* doc =
R"""(A binding on constraint type C is a mapping of the decision variables
onto the inputs of C. This allows the constraint to operate on a
vector made up of different elements of the decision variables.)""";
        // Symbol: drake::solvers::Binding::Binding<C>
        struct /* ctor */ {
          // Source: drake/solvers/binding.h:38
          const char* doc =
R"""(Concatenates each VectorDecisionVariable object in ``v`` into a single
column vector, binds this column vector of decision variables with the
constraint ``c``.)""";
        } ctor;
        // Symbol: drake::solvers::Binding::ContainsVariable
        struct /* ContainsVariable */ {
          // Source: drake/solvers/binding.h:57
          const char* doc =
R"""(Returns true iff the given ``var`` is included in this Binding.)""";
        } ContainsVariable;
        // Symbol: drake::solvers::Binding::GetNumElements
        struct /* GetNumElements */ {
          // Source: drake/solvers/binding.h:69
          const char* doc =
R"""(Returns the number of variables associated with this evaluator.)""";
        } GetNumElements;
        // Symbol: drake::solvers::Binding::evaluator
        struct /* evaluator */ {
          // Source: drake/solvers/binding.h:51
          const char* doc = R"""()""";
        } evaluator;
        // Symbol: drake::solvers::Binding::operator!=
        struct /* operator_ne */ {
          // Source: drake/solvers/binding.h:101
          const char* doc = R"""()""";
        } operator_ne;
        // Symbol: drake::solvers::Binding::to_string
        struct /* to_string */ {
          // Source: drake/solvers/binding.h:78
          const char* doc =
R"""(Returns string representation of Binding.)""";
        } to_string;
        // Symbol: drake::solvers::Binding::variables
        struct /* variables */ {
          // Source: drake/solvers/binding.h:53
          const char* doc = R"""()""";
        } variables;
      } Binding;
      // Symbol: drake::solvers::Bound
      struct /* Bound */ {
        // Source: drake/solvers/aggregate_costs_constraints.h:49
        const char* doc =
R"""(Stores the lower and upper bound of a variable.)""";
        // Symbol: drake::solvers::Bound::lower
        struct /* lower */ {
          // Source: drake/solvers/aggregate_costs_constraints.h:51
          const char* doc = R"""(Lower bound.)""";
        } lower;
        // Symbol: drake::solvers::Bound::upper
        struct /* upper */ {
          // Source: drake/solvers/aggregate_costs_constraints.h:53
          const char* doc = R"""(Upper bound.)""";
        } upper;
      } Bound;
      // Symbol: drake::solvers::BoundingBoxConstraint
      struct /* BoundingBoxConstraint */ {
        // Source: drake/solvers/constraint.h:638
        const char* doc =
R"""(Implements a constraint of the form :math:`lb <= x <= ub`

Note: the base Constraint class (as implemented at the moment) could
play this role. But this class enforces that it is ONLY a bounding box
constraint, and not something more general. Some solvers use this
information to handle bounding box constraints differently than
general constraints, so use of this form is encouraged.)""";
        // Symbol: drake::solvers::BoundingBoxConstraint::BoundingBoxConstraint
        struct /* ctor */ {
          // Source: drake/solvers/constraint.h:640
          const char* doc = R"""()""";
        } ctor;
      } BoundingBoxConstraint;
      // Symbol: drake::solvers::CeilLog2
      struct /* CeilLog2 */ {
        // Source: drake/solvers/mixed_integer_optimization_util.h:16
        const char* doc =
R"""(Return ⌈log₂(n)⌉, namely the minimal integer no smaller than log₂(n),
with base 2.

Parameter ``n``:
    A positive integer.

Returns:
    The minimal integer no smaller than log₂(n).)""";
      } CeilLog2;
      // Symbol: drake::solvers::ChooseBestSolver
      struct /* ChooseBestSolver */ {
        // Source: drake/solvers/choose_best_solver.h:18
        const char* doc =
R"""(Choose the best solver given the formulation in the optimization
program and the availability of the solvers.

Raises:
    invalid_argument if there is no available solver for ``prog``.)""";
      } ChooseBestSolver;
      // Symbol: drake::solvers::CommonSolverOption
      struct /* CommonSolverOption */ {
        // Source: drake/solvers/common_solver_option.h:13
        const char* doc =
R"""(Some options can be applied to not one solver, but many solvers (for
example, many solvers support printing out the progress in each
iteration). CommonSolverOption contain the names of these supported
options. The user can use these options as "key" in
SolverOption::SetOption().)""";
        // Symbol: drake::solvers::CommonSolverOption::kPrintFileName
        struct /* kPrintFileName */ {
          // Source: drake/solvers/common_solver_option.h:20
          const char* doc =
R"""(Many solvers support printing the progress of each iteration to a
file. The user can call SolverOptions::SetOption(kPrintFileName,
file_name) where file_name is a string. If the user doesn't want to
print to a file, then use SolverOptions::SetOption(kPrintFileName,
""), where the empty string "" indicates no print.)""";
        } kPrintFileName;
        // Symbol: drake::solvers::CommonSolverOption::kPrintToConsole
        struct /* kPrintToConsole */ {
          // Source: drake/solvers/common_solver_option.h:27
          const char* doc =
R"""(Many solvers support printing the progress of each iteration to the
console, the user can call SolverOptions::SetOption(kPrintToConsole,
1) to turn on printing to the console, or
SolverOptions::SetOption(kPrintToConsole, 0) to turn off printing to
the console.)""";
        } kPrintToConsole;
      } CommonSolverOption;
      // Symbol: drake::solvers::ConcatenateIndeterminatesRefList
      struct /* ConcatenateIndeterminatesRefList */ {
        // Source: drake/solvers/indeterminate.h:50
        const char* doc =
R"""(Concatenates each element in ``var_list`` into a single Eigen vector
of indeterminates, returns this concatenated vector.)""";
      } ConcatenateIndeterminatesRefList;
      // Symbol: drake::solvers::ConcatenateVariableRefList
      struct /* ConcatenateVariableRefList */ {
        // Source: drake/solvers/decision_variable.h:28
        const char* doc =
R"""(Concatenates each element in ``var_list`` into a single Eigen vector
of decision variables, returns this concatenated vector.)""";
      } ConcatenateVariableRefList;
      // Symbol: drake::solvers::Constraint
      struct /* Constraint */ {
        // Source: drake/solvers/constraint.h:43
        const char* doc =
R"""(A constraint is a function + lower and upper bounds.

Solver interfaces must acknowledge that these constraints are mutable.
Parameters can change after the constraint is constructed and before
the call to Solve().

It should support evaluating the constraint, and adding it to an
optimization problem.)""";
        // Symbol: drake::solvers::Constraint::CheckSatisfied
        struct /* CheckSatisfied */ {
          // Source: drake/solvers/constraint.h:89
          const char* doc =
R"""(Return whether this constraint is satisfied by the given value, ``x``.

Parameter ``x``:
    A ``num_vars`` x 1 vector.

Parameter ``tol``:
    A tolerance for bound checking.)""";
        } CheckSatisfied;
        // Symbol: drake::solvers::Constraint::Constraint
        struct /* ctor */ {
          // Source: drake/solvers/constraint.h:58
          const char* doc_5args =
R"""(Constructs a constraint which has ``num_constraints`` rows, with an
input ``num_vars`` x 1 vector.

Parameter ``num_constraints``:
    . The number of rows in the constraint output.

Parameter ``num_vars``:
    . The number of rows in the input. If the input dimension is
    unknown, then set ``num_vars`` to Eigen::Dynamic.

Parameter ``lb``:
    Lower bound, which must be a ``num_constraints`` x 1 vector.

Parameter ``ub``:
    Upper bound, which must be a ``num_constraints`` x 1 vector.

See also:
    Eval(...))""";
          // Source: drake/solvers/constraint.h:76
          const char* doc_2args =
R"""(Constructs a constraint which has ``num_constraints`` rows, with an
input ``num_vars`` x 1 vector, with no bounds.

Parameter ``num_constraints``:
    . The number of rows in the constraint output.

Parameter ``num_vars``:
    . The number of rows in the input. If the input dimension is
    unknown, then set ``num_vars`` to Eigen::Dynamic.

See also:
    Eval(...))""";
        } ctor;
        // Symbol: drake::solvers::Constraint::DoCheckSatisfied
        struct /* DoCheckSatisfied */ {
          // Source: drake/solvers/constraint.h:150
          const char* doc = R"""()""";
        } DoCheckSatisfied;
        // Symbol: drake::solvers::Constraint::UpdateLowerBound
        struct /* UpdateLowerBound */ {
          // Source: drake/solvers/constraint.h:119
          const char* doc =
R"""(Updates the lower bound.

Note:
    if the users want to expose this method in a sub-class, do using
    Constraint::UpdateLowerBound, as in LinearConstraint.)""";
        } UpdateLowerBound;
        // Symbol: drake::solvers::Constraint::UpdateUpperBound
        struct /* UpdateUpperBound */ {
          // Source: drake/solvers/constraint.h:130
          const char* doc =
R"""(Updates the upper bound.

Note:
    if the users want to expose this method in a sub-class, do using
    Constraint::UpdateUpperBound, as in LinearConstraint.)""";
        } UpdateUpperBound;
        // Symbol: drake::solvers::Constraint::lower_bound
        struct /* lower_bound */ {
          // Source: drake/solvers/constraint.h:107
          const char* doc = R"""()""";
        } lower_bound;
        // Symbol: drake::solvers::Constraint::num_constraints
        struct /* num_constraints */ {
          // Source: drake/solvers/constraint.h:111
          const char* doc =
R"""(Number of rows in the output constraint.)""";
        } num_constraints;
        // Symbol: drake::solvers::Constraint::set_bounds
        struct /* set_bounds */ {
          // Source: drake/solvers/constraint.h:144
          const char* doc =
R"""(Set the upper and lower bounds of the constraint.

Parameter ``lower_bound``:
    . A ``num_constraints`` x 1 vector.

Parameter ``upper_bound``:
    . A ``num_constraints`` x 1 vector.

Note:
    If the users want to expose this method in a sub-class, do using
    Constraint::set_bounds, as in LinearConstraint.)""";
        } set_bounds;
        // Symbol: drake::solvers::Constraint::upper_bound
        struct /* upper_bound */ {
          // Source: drake/solvers/constraint.h:108
          const char* doc = R"""()""";
        } upper_bound;
      } Constraint;
      // Symbol: drake::solvers::ConstructMonomialBasis
      struct /* ConstructMonomialBasis */ {
        // Source: drake/solvers/sos_basis_generator.h:22
        const char* doc =
R"""(Given input polynomial p, outputs a set M of monomials with the
following guarantee: if p = f1*f1 + f2*f2 + ... + fn*fn for some
(unknown) polynomials f1, f2, ..., fn, then the span of M contains f1,
f2, ..., fn, Given M, one can then find the polynomials fi using
semidefinite programming; see, e.g., Chapter 3 of Semidefinite
Optimization and Convex Algebraic Geometry by G. Blekherman, P.
Parrilo, R. Thomas.

Parameter ``p``:
    A polynomial

Returns:
    A vector whose entries are the elements of M)""";
      } ConstructMonomialBasis;
      // Symbol: drake::solvers::Cost
      struct /* Cost */ {
        // Source: drake/solvers/cost.h:20
        const char* doc =
R"""(Provides an abstract base for all costs.)""";
        // Symbol: drake::solvers::Cost::Cost
        struct /* ctor */ {
          // Source: drake/solvers/cost.h:30
          const char* doc =
R"""(Constructs a cost evaluator.

Parameter ``num_vars``:
    Number of input variables.

Parameter ``description``:
    Human-friendly description.)""";
        } ctor;
      } Cost;
      // Symbol: drake::solvers::CreateBinaryCodeMatchConstraint
      struct /* CreateBinaryCodeMatchConstraint */ {
        // Source: drake/solvers/integer_optimization_util.h:88
        const char* doc =
R"""(Create linear constraints such that, when these constraints are
satisfied, match = 1 if and only if code == expected, otherwise match
= 0

Parameter ``code``:
    code(i) should only take binary values.

Parameter ``expected``:
    The expected matched value for code.

Parameter ``match``:
    an expression that takes binary value, representing if code ==
    expected

Returns:
    the linear constraints.

This function is useful integer optimization, for example, if we have
a constraint match = ((b1 == 0) && (b2 == 1) && (b3 == 1)), we can
call the function CreateBinaryCodeMatchConstraint({b1, b2, b3}, {0, 1,
1}, match) to create the constraint.)""";
      } CreateBinaryCodeMatchConstraint;
      // Symbol: drake::solvers::CreateLogicalAndConstraint
      struct /* CreateLogicalAndConstraint */ {
        // Source: drake/solvers/integer_optimization_util.h:26
        const char* doc =
R"""(Adds linear constraints, such that when b1, b2, b1_and_b2 satisfy the
constraints, and b1, b2 take binary values, it is guaranteed that
b1_and_b2 = b1 ∧ b2 (b1 and b2). The constraints are


::

    b1_and_b2 >= b1 + b2 - 1
      b1_and_b2 <= b1
      b1_and_b2 <= b2
      0 <= b1_and_b2 <= 1

Parameter ``b1``:
    An expression that should only take a binary value.

Parameter ``b2``:
    An expression that should only take a binary value.

Parameter ``b1_and_b2``:
    Should be the logical and between ``b1`` and ``b2``.

Returns:
    The newly added constraints, such that when b1, b2, b1_and_b2
    satisfy the constraints, it is guaranteed that b1_and_b2 = b1 ∧
    b2.

Precondition:
    b1, b2, b1_and_b2 are all linear expressions.)""";
      } CreateLogicalAndConstraint;
      // Symbol: drake::solvers::CreateLogicalOrConstraint
      struct /* CreateLogicalOrConstraint */ {
        // Source: drake/solvers/integer_optimization_util.h:48
        const char* doc =
R"""(Adds linear constraints, such that when b1, b2, b1_or_b2 satisfy the
constraints, and b1, b2 take binary values, it is guaranteed that
b1_or_b2 = b1 ∨ b2 (b1 or b2). The constraints are


::

    b1_or_b2 <= b1 + b2
      b1_or_b2 >= b1
      b1_or_b2 >= b2
      0 <= b1_or_b2 <= 1

Parameter ``b1``:
    An expression that should only take a binary value.

Parameter ``b2``:
    An expression that should only take a binary value.

Parameter ``b1_or_b2``:
    Should be the logical or between ``b1`` and ``b2``.

Returns:
    The newly added constraints, such that when b1, b2, b1_or_b2
    satisfy the constraints, it is guaranteed that b1_or_b2 = b1 ∨ b2.

Precondition:
    b1, b2, b1_or_b2 are all linear expressions.)""";
      } CreateLogicalOrConstraint;
      // Symbol: drake::solvers::CreateLogicalXorConstraint
      struct /* CreateLogicalXorConstraint */ {
        // Source: drake/solvers/integer_optimization_util.h:71
        const char* doc =
R"""(Add linear constraints, such that when b1, b2, b1_xor_b2 satisfy the
constraints, and b1, b2 take binary values, it is guaranteed that
b1_xor_b2 = b1 ⊕ b2 (b1 exclusive xor b2). The constraints are


::

    b1_xor_b2 <= b1 + b2
      b1_xor_b2 >= b1 - b2
      b1_xor_b2 >= b2 - b1
      b1_xor_b2 <= 2 - b1 - b2
      0 <= b1_xor_b2 <= 1

Parameter ``b1``:
    An expression that should only take a binary value.

Parameter ``b2``:
    An expression that should only take a binary value.

Parameter ``b1_xor_b2``:
    Should be the logical exclusive or between ``b1`` and ``b2``.

Returns:
    The newly added constraints, such that when b1, b2, b1_xor_b2
    satisfy the constraints, it is guaranteed that b1_xor_b2 = b1 ⊕
    b2.

Precondition:
    b1, b2, b1_xor_b2 are all linear expressions.)""";
      } CreateLogicalXorConstraint;
      // Symbol: drake::solvers::CsdpSolver
      struct /* CsdpSolver */ {
        // Source: drake/solvers/csdp_solver.h:49
        const char* doc = R"""()""";
        // Symbol: drake::solvers::CsdpSolver::CsdpSolver
        struct /* ctor */ {
          // Source: drake/solvers/csdp_solver.h:51
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::solvers::CsdpSolver::Details
        struct /* Details */ {
          // Source: drake/solvers/csdp_solver.h:69
          const char* doc = R"""()""";
        } Details;
        // Symbol: drake::solvers::CsdpSolver::ProgramAttributesSatisfied
        struct /* ProgramAttributesSatisfied */ {
          // Source: drake/solvers/csdp_solver.h:63
          const char* doc = R"""()""";
        } ProgramAttributesSatisfied;
        // Symbol: drake::solvers::CsdpSolver::id
        struct /* id */ {
          // Source: drake/solvers/csdp_solver.h:60
          const char* doc = R"""()""";
        } id;
        // Symbol: drake::solvers::CsdpSolver::is_available
        struct /* is_available */ {
          // Source: drake/solvers/csdp_solver.h:61
          const char* doc = R"""()""";
        } is_available;
        // Symbol: drake::solvers::CsdpSolver::is_enabled
        struct /* is_enabled */ {
          // Source: drake/solvers/csdp_solver.h:62
          const char* doc = R"""()""";
        } is_enabled;
      } CsdpSolver;
      // Symbol: drake::solvers::CsdpSolverDetails
      struct /* CsdpSolverDetails */ {
        // Source: drake/solvers/csdp_solver.h:14
        const char* doc =
R"""(The CSDP solver details after calling Solve() function. The user can
call MathematicalProgramResult::get_solver_details<CsdpSolver>() to
obtain the details.)""";
        // Symbol: drake::solvers::CsdpSolverDetails::Z_val
        struct /* Z_val */ {
          // Source: drake/solvers/csdp_solver.h:46
          const char* doc = R"""()""";
        } Z_val;
        // Symbol: drake::solvers::CsdpSolverDetails::dual_objective
        struct /* dual_objective */ {
          // Source: drake/solvers/csdp_solver.h:28
          const char* doc = R"""(The dual objective value.)""";
        } dual_objective;
        // Symbol: drake::solvers::CsdpSolverDetails::primal_objective
        struct /* primal_objective */ {
          // Source: drake/solvers/csdp_solver.h:26
          const char* doc = R"""(The primal objective value.)""";
        } primal_objective;
        // Symbol: drake::solvers::CsdpSolverDetails::return_code
        struct /* return_code */ {
          // Source: drake/solvers/csdp_solver.h:24
          const char* doc =
R"""(Refer to the Return Codes section of CSDP 6.2.0 User's Guide for
explanation on the return code. Some of the common return codes are

0 Problem is solved to optimality. 1 Problem is primal infeasible. 2
Problem is dual infeasible. 3 Problem solved to near optimality. 4
Maximum iterations reached.)""";
        } return_code;
        // Symbol: drake::solvers::CsdpSolverDetails::y_val
        struct /* y_val */ {
          // Source: drake/solvers/csdp_solver.h:45
          const char* doc =
R"""(CSDP solves a primal problem of the form

max tr(C*X) s.t tr(Aᵢ*X) = aᵢ X ≽ 0

The dual form is

min aᵀy s.t ∑ᵢ yᵢAᵢ - C = Z Z ≽ 0

y, Z are the variables for the dual problem. y_val, Z_val are the
solutions to the dual problem.)""";
        } y_val;
      } CsdpSolverDetails;
      // Symbol: drake::solvers::DecisionVariable
      struct /* DecisionVariable */ {
        // Source: drake/solvers/decision_variable.h:12
        const char* doc = R"""()""";
      } DecisionVariable;
      // Symbol: drake::solvers::DecomposeNonConvexQuadraticForm
      struct /* DecomposeNonConvexQuadraticForm */ {
        // Source: drake/solvers/non_convex_optimization_util.h:43
        const char* doc =
R"""(For a non-convex homogeneous quadratic form xᵀQx, where Q is not
necessarily a positive semidefinite matrix, we decompose it as a
difference between two convex homogeneous quadratic forms xᵀQx = xᵀQ₁x
- xᵀQ₂x, Q₁, Q₂ are positive semidefinite. To find the optimal Q₁ and
Q₂, we solve the following semidefinite programming problem min s s.t
s >= trace(Q₁) s >= trace(Q₂) Q₁ - Q₂ = (Q + Qᵀ) / 2 Q₁, Q₂ are
positive semidefinite The decomposition Q = Q₁ - Q₂ can be used later,
to solve the non-convex optimization problem involving a quadratic
form xᵀQx. For more information, please refer to the papers on
difference of convex decomposition, for example Undominated d.c
Decompositions of Quadratic Functions and Applications to
Branch-and-Bound Approaches By I.M.Bomze and M. Locatelli
Computational Optimization and Applications, 2004 DC Decomposition of
Nonconvex Polynomials with Algebraic Techniques By A. A. Ahmadi and G.
Hall Mathematical Programming, 2015

Parameter ``Q``:
    A square matrix.

Raises:
    RuntimeError if Q is not square.

Returns:
    The optimal decomposition (Q₁, Q₂))""";
      } DecomposeNonConvexQuadraticForm;
      // Symbol: drake::solvers::DrealSolver
      struct /* DrealSolver */ {
        // Source: drake/solvers/dreal_solver.h:15
        const char* doc = R"""()""";
        // Symbol: drake::solvers::DrealSolver::CheckSatisfiability
        struct /* CheckSatisfiability */ {
          // Source: drake/solvers/dreal_solver.h:66
          const char* doc =
R"""(Checks the satisfiability of a given formula ``f`` with a given
precision ``delta``.

Returns:
    a model, a mapping from a variable to an interval, if ``f`` is
    δ-satisfiable.

Returns:
    a nullopt, if ``is`` unsatisfiable.)""";
        } CheckSatisfiability;
        // Symbol: drake::solvers::DrealSolver::DrealSolver
        struct /* ctor */ {
          // Source: drake/solvers/dreal_solver.h:55
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::solvers::DrealSolver::Interval
        struct /* Interval */ {
          // Source: drake/solvers/dreal_solver.h:18
          const char* doc =
R"""(Class representing an interval of doubles.)""";
          // Symbol: drake::solvers::DrealSolver::Interval::Interval
          struct /* ctor */ {
            // Source: drake/solvers/dreal_solver.h:26
            const char* doc =
R"""(Constructs an interval [low, high].

Precondition:
    Its lower bound ``low`` must be less than or equal to its upper
    bound ``high``.)""";
          } ctor;
          // Symbol: drake::solvers::DrealSolver::Interval::diam
          struct /* diam */ {
            // Source: drake/solvers/dreal_solver.h:31
            const char* doc = R"""(Returns its diameter.)""";
          } diam;
          // Symbol: drake::solvers::DrealSolver::Interval::high
          struct /* high */ {
            // Source: drake/solvers/dreal_solver.h:40
            const char* doc = R"""(Returns its upper bound.)""";
          } high;
          // Symbol: drake::solvers::DrealSolver::Interval::low
          struct /* low */ {
            // Source: drake/solvers/dreal_solver.h:37
            const char* doc = R"""(Returns its lower bound.)""";
          } low;
          // Symbol: drake::solvers::DrealSolver::Interval::mid
          struct /* mid */ {
            // Source: drake/solvers/dreal_solver.h:34
            const char* doc = R"""(Returns its mid-point.)""";
          } mid;
        } Interval;
        // Symbol: drake::solvers::DrealSolver::IntervalBox
        struct /* IntervalBox */ {
          // Source: drake/solvers/dreal_solver.h:47
          const char* doc = R"""()""";
        } IntervalBox;
        // Symbol: drake::solvers::DrealSolver::LocalOptimization
        struct /* LocalOptimization */ {
          // Source: drake/solvers/dreal_solver.h:50
          const char* doc =
R"""(Indicates whether to use dReal's --local-optimization option or not.)""";
          // Symbol: drake::solvers::DrealSolver::LocalOptimization::kNotUse
          struct /* kNotUse */ {
            // Source: drake/solvers/dreal_solver.h:52
            const char* doc =
R"""(Do not use "--local-optimization" option.)""";
          } kNotUse;
          // Symbol: drake::solvers::DrealSolver::LocalOptimization::kUse
          struct /* kUse */ {
            // Source: drake/solvers/dreal_solver.h:51
            const char* doc = R"""(Use "--local-optimization" option.)""";
          } kUse;
        } LocalOptimization;
        // Symbol: drake::solvers::DrealSolver::Minimize
        struct /* Minimize */ {
          // Source: drake/solvers/dreal_solver.h:79
          const char* doc =
R"""(Finds a solution to minimize ``objective`` function while satisfying a
given ``constraint`` using ``delta``. When ``local_optimization`` is
Localoptimization::kUse, enable "--local-optimization" dReal option
which uses NLopt's local-optimization algorithms to refine
counterexamples in the process of global optimization.

Returns:
    a model, a mapping from a variable to an interval, if a solution
    exists.

Returns:
    nullopt, if there is no solution.)""";
        } Minimize;
        // Symbol: drake::solvers::DrealSolver::ProgramAttributesSatisfied
        struct /* ProgramAttributesSatisfied */ {
          // Source: drake/solvers/dreal_solver.h:90
          const char* doc = R"""()""";
        } ProgramAttributesSatisfied;
        // Symbol: drake::solvers::DrealSolver::id
        struct /* id */ {
          // Source: drake/solvers/dreal_solver.h:87
          const char* doc = R"""()""";
        } id;
        // Symbol: drake::solvers::DrealSolver::is_available
        struct /* is_available */ {
          // Source: drake/solvers/dreal_solver.h:88
          const char* doc = R"""()""";
        } is_available;
        // Symbol: drake::solvers::DrealSolver::is_enabled
        struct /* is_enabled */ {
          // Source: drake/solvers/dreal_solver.h:89
          const char* doc = R"""()""";
        } is_enabled;
      } DrealSolver;
      // Symbol: drake::solvers::EnumerateIntegerSolutions
      struct /* EnumerateIntegerSolutions */ {
        // Source: drake/solvers/integer_inequality_solver.h:20
        const char* doc =
R"""(Finds all integer solutions x to the linear inequalities


::

    Ax <= b,
                       x <= upper_bound,
                       x >= lower_bound.

Parameter ``A``:
    An (m x n) integer matrix.

Parameter ``b``:
    An (m x 1) integer vector.

Parameter ``upper_bound``:
    A (n x 1) integer vector.

Parameter ``lower_bound``:
    A (n x 1) integer vector.

Returns:
    A (p x n) matrix whose rows are the solutions.)""";
      } EnumerateIntegerSolutions;
      // Symbol: drake::solvers::EqualityConstrainedQPSolver
      struct /* EqualityConstrainedQPSolver */ {
        // Source: drake/solvers/equality_constrained_qp_solver.h:22
        const char* doc =
R"""(Solves a quadratic program with equality constraint.

This program doesn't depend on the initial guess.

The user can set the following options:

- FeasibilityTolOptionName(). The feasible solution (both primal and dual
  variables) should satisfy their constraints, with error no larger than
  this value. The default is Eigen::dummy_precision().)""";
        // Symbol: drake::solvers::EqualityConstrainedQPSolver::EqualityConstrainedQPSolver
        struct /* ctor */ {
          // Source: drake/solvers/equality_constrained_qp_solver.h:24
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::solvers::EqualityConstrainedQPSolver::FeasibilityTolOptionName
        struct /* FeasibilityTolOptionName */ {
          // Source: drake/solvers/equality_constrained_qp_solver.h:30
          const char* doc =
R"""(Returns:
    string key for SolverOptions to set the feasibility tolerance.)""";
        } FeasibilityTolOptionName;
        // Symbol: drake::solvers::EqualityConstrainedQPSolver::ProgramAttributesSatisfied
        struct /* ProgramAttributesSatisfied */ {
          // Source: drake/solvers/equality_constrained_qp_solver.h:37
          const char* doc = R"""()""";
        } ProgramAttributesSatisfied;
        // Symbol: drake::solvers::EqualityConstrainedQPSolver::id
        struct /* id */ {
          // Source: drake/solvers/equality_constrained_qp_solver.h:34
          const char* doc = R"""()""";
        } id;
        // Symbol: drake::solvers::EqualityConstrainedQPSolver::is_available
        struct /* is_available */ {
          // Source: drake/solvers/equality_constrained_qp_solver.h:35
          const char* doc = R"""()""";
        } is_available;
        // Symbol: drake::solvers::EqualityConstrainedQPSolver::is_enabled
        struct /* is_enabled */ {
          // Source: drake/solvers/equality_constrained_qp_solver.h:36
          const char* doc = R"""()""";
        } is_enabled;
      } EqualityConstrainedQPSolver;
      // Symbol: drake::solvers::EvaluatorBase
      struct /* EvaluatorBase */ {
        // Source: drake/solvers/evaluator_base.h:31
        const char* doc =
R"""(Provides an abstract interface to represent an expression, mapping a
fixed or dynamic number of inputs to a fixed number of outputs, that
may be evaluated on a scalar type of double or AutoDiffXd.

These objects, and its derivatives, are meant to be bound to a given
set of variables using the Binding<> class.)""";
        // Symbol: drake::solvers::EvaluatorBase::Display
        struct /* Display */ {
          // Source: drake/solvers/evaluator_base.h:96
          const char* doc_2args =
R"""(Formats this evaluator into the given stream using ``vars`` for the
bound decision variable names.

The size of ``vars`` must match the ``num_vars()`` declared by this
evaluator. (If ``num_vars()`` is ``Eigen::Dynamic``, then ``vars`` may
be any size.))""";
          // Source: drake/solvers/evaluator_base.h:103
          const char* doc_1args =
R"""(Formats this evaluator into the given stream, without displaying the
decision variables it is bound to.)""";
        } Display;
        // Symbol: drake::solvers::EvaluatorBase::DoDisplay
        struct /* DoDisplay */ {
          // Source: drake/solvers/evaluator_base.h:190
          const char* doc =
R"""(NVI implementation of Display. The default implementation will report
the NiceTypeName, get_description, and list the bound variables.
Subclasses may override to customize the message.

Precondition:
    vars size is consistent with num_vars".)""";
        } DoDisplay;
        // Symbol: drake::solvers::EvaluatorBase::DoEval
        struct /* DoEval */ {
          // Source: drake/solvers/evaluator_base.h:161
          const char* doc_was_unable_to_choose_unambiguous_names =
R"""(Implements expression evaluation for scalar type double.

Parameter ``x``:
    Input vector.

Parameter ``y``:
    Output vector.

Precondition:
    x must be of size ``num_vars`` x 1.

Postcondition:
    y will be of size ``num_outputs`` x 1.)""";
        } DoEval;
        // Symbol: drake::solvers::EvaluatorBase::Eval
        struct /* Eval */ {
          // Source: drake/solvers/evaluator_base.h:44
          const char* doc =
R"""(Evaluates the expression.

Parameter ``x``:
    A ``num_vars`` x 1 input vector.

Parameter ``y``:
    A ``num_outputs`` x 1 output vector.)""";
        } Eval;
        // Symbol: drake::solvers::EvaluatorBase::EvaluatorBase
        struct /* ctor */ {
          // Source: drake/solvers/evaluator_base.h:148
          const char* doc =
R"""(Constructs a evaluator.

Parameter ``num_outputs``:
    . The number of rows in the output.

Parameter ``num_vars``:
    . The number of rows in the input. If the input dimension is not
    known, then set ``num_vars`` to Eigen::Dynamic.

Parameter ``description``:
    A human-friendly description.

See also:
    Eval(...))""";
        } ctor;
        // Symbol: drake::solvers::EvaluatorBase::SetGradientSparsityPattern
        struct /* SetGradientSparsityPattern */ {
          // Source: drake/solvers/evaluator_base.h:123
          const char* doc =
R"""(Set the sparsity pattern of the gradient matrix ∂y/∂x (the gradient of
y value in Eval, w.r.t x in Eval) . gradient_sparsity_pattern contains
*all* the pairs of (row_index, col_index) for which the corresponding
entries could have non-zero value in the gradient matrix ∂y/∂x.)""";
        } SetGradientSparsityPattern;
        // Symbol: drake::solvers::EvaluatorBase::get_description
        struct /* get_description */ {
          // Source: drake/solvers/evaluator_base.h:87
          const char* doc =
R"""(Getter for a human-friendly description for the evaluator.)""";
        } get_description;
        // Symbol: drake::solvers::EvaluatorBase::gradient_sparsity_pattern
        struct /* gradient_sparsity_pattern */ {
          // Source: drake/solvers/evaluator_base.h:135
          const char* doc =
R"""(Returns the vector of (row_index, col_index) that contains all the
entries in the gradient of Eval function (∂y/∂x) whose value could be
non-zero, namely if ∂yᵢ/∂xⱼ could be non-zero, then the pair (i, j) is
in gradient_sparsity_pattern.

Returns ``gradient_sparsity_pattern``:
    If nullopt, then we regard all entries of the gradient as
    potentially non-zero.)""";
        } gradient_sparsity_pattern;
        // Symbol: drake::solvers::EvaluatorBase::num_outputs
        struct /* num_outputs */ {
          // Source: drake/solvers/evaluator_base.h:115
          const char* doc =
R"""(Getter for the number of outputs, namely the number of rows in y, as
used in Eval(x, y).)""";
        } num_outputs;
        // Symbol: drake::solvers::EvaluatorBase::num_vars
        struct /* num_vars */ {
          // Source: drake/solvers/evaluator_base.h:109
          const char* doc =
R"""(Getter for the number of variables, namely the number of rows in x, as
used in Eval(x, y).)""";
        } num_vars;
        // Symbol: drake::solvers::EvaluatorBase::set_description
        struct /* set_description */ {
          // Source: drake/solvers/evaluator_base.h:80
          const char* doc =
R"""(Set a human-friendly description for the evaluator.)""";
        } set_description;
        // Symbol: drake::solvers::EvaluatorBase::set_num_outputs
        struct /* set_num_outputs */ {
          // Source: drake/solvers/evaluator_base.h:198
          const char* doc = R"""()""";
        } set_num_outputs;
      } EvaluatorBase;
      // Symbol: drake::solvers::EvaluatorConstraint
      struct /* EvaluatorConstraint */ {
        // Source: drake/solvers/constraint.h:415
        const char* doc =
R"""(A constraint that may be specified using another (potentially
nonlinear) evaluator.

Template parameter ``EvaluatorType``:
    The nested evaluator.)""";
        // Symbol: drake::solvers::EvaluatorConstraint::EvaluatorConstraint<EvaluatorType>
        struct /* ctor */ {
          // Source: drake/solvers/constraint.h:427
          const char* doc =
R"""(Constructs an evaluator constraint, given the EvaluatorType instance
(which will specify the number of constraints and variables), and will
forward the remaining arguments to the Constraint constructor.

Parameter ``evaluator``:
    EvaluatorType instance.

Parameter ``args``:
    Arguments to be forwarded to the constraint constructor.)""";
        } ctor;
        // Symbol: drake::solvers::EvaluatorConstraint::evaluator
        struct /* evaluator */ {
          // Source: drake/solvers/constraint.h:439
          const char* doc = R"""(Reference to the nested evaluator.)""";
        } evaluator;
      } EvaluatorConstraint;
      // Symbol: drake::solvers::EvaluatorCost
      struct /* EvaluatorCost */ {
        // Source: drake/solvers/cost.h:196
        const char* doc =
R"""(A cost that may be specified using another (potentially nonlinear)
evaluator.

Template parameter ``EvaluatorType``:
    The nested evaluator.)""";
        // Symbol: drake::solvers::EvaluatorCost::DoEval
        struct /* DoEval */ {
          // Source: drake/solvers/cost.h:207
          const char* doc = R"""()""";
        } DoEval;
        // Symbol: drake::solvers::EvaluatorCost::EvaluatorCost<EvaluatorType>
        struct /* ctor */ {
          // Source: drake/solvers/cost.h:198
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::solvers::EvaluatorCost::evaluator
        struct /* evaluator */ {
          // Source: drake/solvers/cost.h:206
          const char* doc = R"""()""";
        } evaluator;
      } EvaluatorCost;
      // Symbol: drake::solvers::ExponentialConeConstraint
      struct /* ExponentialConeConstraint */ {
        // Source: drake/solvers/constraint.h:955
        const char* doc =
R"""(An exponential cone constraint is a special type of convex cone
constraint. We constrain A * x + b to be in the exponential cone,
where A has 3 rows, and b is in ℝ³, x is the decision variable. A
vector z in ℝ³ is in the exponential cone, if {z₀, z₁, z₂ | z₀ ≥ z₁ *
exp(z₂ / z₁), z₁ > 0}. Equivalently, this constraint can be
refomulated with logarithm function {z₀, z₁, z₂ | z₂ ≤ z₁ * log(z₀ /
z₁), z₀ > 0, z₁ > 0}

The Eval function implemented in this class is z₀ - z₁ * exp(z₂ / z₁)
>= 0, z₁ > 0 where z = A * x + b. It is not recommended to solve an
exponential cone constraint through generic nonlinear optimization. It
is possible that the nonlinear solver can accidentally set z₁ = 0,
where the constraint is not well defined. Instead, the user should
consider to solve the program through conic solvers that can exploit
exponential cone, such as Mosek and SCS.)""";
        // Symbol: drake::solvers::ExponentialConeConstraint::A
        struct /* A */ {
          // Source: drake/solvers/constraint.h:971
          const char* doc = R"""(Getter for matrix A.)""";
        } A;
        // Symbol: drake::solvers::ExponentialConeConstraint::DoEval
        struct /* DoEval */ {
          // Source: drake/solvers/constraint.h:981
          const char* doc = R"""()""";
        } DoEval;
        // Symbol: drake::solvers::ExponentialConeConstraint::DoEvalGeneric
        struct /* DoEvalGeneric */ {
          // Source: drake/solvers/constraint.h:978
          const char* doc = R"""()""";
        } DoEvalGeneric;
        // Symbol: drake::solvers::ExponentialConeConstraint::ExponentialConeConstraint
        struct /* ctor */ {
          // Source: drake/solvers/constraint.h:964
          const char* doc =
R"""(Constructor for exponential cone. Constrains A * x + b to be in the
exponential cone.

Precondition:
    A has 3 rows.)""";
        } ctor;
        // Symbol: drake::solvers::ExponentialConeConstraint::b
        struct /* b */ {
          // Source: drake/solvers/constraint.h:974
          const char* doc = R"""(Getter for vector b.)""";
        } b;
      } ExponentialConeConstraint;
      // Symbol: drake::solvers::ExponentiallySmoothedHingeLoss
      struct /* ExponentiallySmoothedHingeLoss */ {
        // Source: drake/solvers/minimum_value_constraint.h:33
        const char* doc =
R"""(A hinge loss function smoothed by exponential function. This loss
function is differentiable everywhere. The fomulation is described in
section II.C of [2]. The penalty is <pre class="unicode-art"> ⎧ 0 if x
≥ 0 φ(x) = ⎨ ⎩ -x exp(1/x) if x < 0. </pre> [2] "Whole-body Motion
Planning with Centroidal Dynamics and Full Kinematics" by Hongkai Dai,
Andres Valenzuela and Russ Tedrake, IEEE-RAS International Conference
on Humanoid Robots, 2014.)""";
      } ExponentiallySmoothedHingeLoss;
      // Symbol: drake::solvers::ExpressionConstraint
      struct /* ExpressionConstraint */ {
        // Source: drake/solvers/constraint.h:893
        const char* doc =
R"""(Impose a generic (potentially nonlinear) constraint represented as a
vector of symbolic Expression. Expression::Evaluate is called on every
constraint evaluation.

Uses symbolic::Jacobian to provide the gradients to the AutoDiff
method.)""";
        // Symbol: drake::solvers::ExpressionConstraint::DoEval
        struct /* DoEval */ {
          // Source: drake/solvers/constraint.h:915
          const char* doc = R"""()""";
        } DoEval;
        // Symbol: drake::solvers::ExpressionConstraint::ExpressionConstraint
        struct /* ctor */ {
          // Source: drake/solvers/constraint.h:895
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::solvers::ExpressionConstraint::expressions
        struct /* expressions */ {
          // Source: drake/solvers/constraint.h:910
          const char* doc =
R"""(Returns:
    the symbolic expressions.)""";
        } expressions;
        // Symbol: drake::solvers::ExpressionConstraint::vars
        struct /* vars */ {
          // Source: drake/solvers/constraint.h:907
          const char* doc =
R"""(Returns:
    the list of the variables involved in the vector of expressions,
    in the order that they are expected to be received during DoEval.
    Any Binding that connects this constraint to decision variables
    should pass this list of variables to the Binding.)""";
        } vars;
      } ExpressionConstraint;
      // Symbol: drake::solvers::FunctionEvaluator
      struct /* FunctionEvaluator */ {
        // Source: drake/solvers/evaluator_base.h:280
        const char* doc =
R"""(An evaluator that may be specified using a callable object. Consider
constructing these instances using MakeFunctionEvaluator(...).

Template parameter ``F``:
    The function / functor's type.)""";
        // Symbol: drake::solvers::FunctionEvaluator::FunctionEvaluator<F>
        struct /* ctor */ {
          // Source: drake/solvers/evaluator_base.h:292
          const char* doc =
R"""(Constructs an instance by copying from an lvalue or rvalue of ``F``.

Template parameter ``FF``:
    Perfect-forwarding type of ``F`` (e.g., ``const F&``, `F&&`).

Parameter ``f``:
    The callable object. If rvalue, this value will be std::move'd.
    Otherwise, it will be copied.

Parameter ``args``:
    Arguments to be forwarded to EvaluatorBase constructor.)""";
        } ctor;
      } FunctionEvaluator;
      // Symbol: drake::solvers::GenerateSDPA
      struct /* GenerateSDPA */ {
        // Source: drake/solvers/sdpa_free_format.h:501
        const char* doc =
R"""(SDPA is a format to record an SDP problem

max tr(C*X) s.t tr(Aᵢ*X) = gᵢ X ≽ 0

or the dual of the problem

min gᵀy s.t ∑ᵢ yᵢAᵢ - C ≽ 0

where X is a symmetric block diagonal matrix. The format is described
in http://plato.asu.edu/ftp/sdpa_format.txt. Many solvers, such as
CSDP, DSDP, SDPA, sedumi and SDPT3, accept an SDPA format file as the
input. This function reads a MathematicalProgram that can be
formulated as above, and write an SDPA file.

Parameter ``prog``:
    a program that contains an optimization program.

Parameter ``file_name``:
    The name of the file, note that the extension will be added
    automatically.

Parameter ``method``:
    If ``prog`` contains free variables (i.e., variables without
    bounds), then we need to remove these free variables to write the
    program in the SDPA format. Please refer to
    RemoveFreeVariableMethod for details on how to remove the free
    variables. $*Default:* is RemoveFreeVariableMethod::kNullspace.

Returns ``is_success``:
    . Returns true if we can generate the SDPA file. The failure could
    be 1. ``prog`` cannot be captured by the formulation above. 2.
    ``prog`` cannot create a file with the given name, etc.)""";
      } GenerateSDPA;
      // Symbol: drake::solvers::GetKnownSolvers
      struct /* GetKnownSolvers */ {
        // Source: drake/solvers/choose_best_solver.h:23
        const char* doc =
R"""(Returns the set of solvers known to ChooseBestSolver.)""";
      } GetKnownSolvers;
      // Symbol: drake::solvers::GetVariableValue
      struct /* GetVariableValue */ {
        // Source: drake/solvers/mathematical_program_result.h:38
        const char* doc_3args_var_variable_index_variable_values =
R"""(Retrieve the value of a single variable ``var`` from
``variable_values``.

Parameter ``var``:
    The variable whose value is going to be retrieved.
    ``var``.get_id() must be a key in ``variable_index``.

Parameter ``variable_index``:
    maps the variable ID to its index in ``variable_values``.

Parameter ``variable_values``:
    The values of all variables.

Returns:
    variable_values(variable_index[var.get_id()]) if var.get_id() is a
    valid key of ``variable_index``.

Raises:
    an invalid_argument error if var.get_id() is not a valid key of
    ``variable_index``.

Precondition:
    All the mapped value in variable_index is in the range [0,
    variable_values.rows()))""";
        // Source: drake/solvers/mathematical_program_result.h:53
        const char* doc_3args_constEigenMatrixBase_conststdoptional_constEigenRef =
R"""(Overload GetVariableValue() function, but for an Eigen matrix of
decision variables.)""";
      } GetVariableValue;
      // Symbol: drake::solvers::GurobiSolver
      struct /* GurobiSolver */ {
        // Source: drake/solvers/gurobi_solver.h:37
        const char* doc = R"""()""";
        // Symbol: drake::solvers::GurobiSolver::AcquireLicense
        struct /* AcquireLicense */ {
          // Source: drake/solvers/gurobi_solver.h:148
          const char* doc =
R"""(This acquires a Gurobi license environment shared among all
GurobiSolver instances; the environment will stay valid as long as at
least one shared_ptr returned by this function is alive. Call this
ONLY if you must use different MathematicalProgram instances at
different instances in time, and repeatedly acquiring the license is
costly (e.g., requires contacting a license server).

Returns:
    A shared pointer to a license environment that will stay valid as
    long as any shared_ptr returned by this function is alive. If
    Gurobi not available in your build, this will return a null
    (empty) shared_ptr.

Raises:
    RuntimeError if Gurobi is available but a license cannot be
    obtained.)""";
        } AcquireLicense;
        // Symbol: drake::solvers::GurobiSolver::AddMipNodeCallback
        struct /* AddMipNodeCallback */ {
          // Source: drake/solvers/gurobi_solver.h:97
          const char* doc =
R"""(Registers a callback to be called at intermediate solutions during the
solve.

Parameter ``callback``:
    User callback function.

Parameter ``user_data``:
    Arbitrary data that will be passed to the user callback function.)""";
        } AddMipNodeCallback;
        // Symbol: drake::solvers::GurobiSolver::AddMipSolCallback
        struct /* AddMipSolCallback */ {
          // Source: drake/solvers/gurobi_solver.h:124
          const char* doc =
R"""(Registers a callback to be called at feasible solutions during the
solve.

Parameter ``callback``:
    User callback function.

Parameter ``usrdata``:
    Arbitrary data that will be passed to the user callback function.)""";
        } AddMipSolCallback;
        // Symbol: drake::solvers::GurobiSolver::Details
        struct /* Details */ {
          // Source: drake/solvers/gurobi_solver.h:42
          const char* doc =
R"""(Type of details stored in MathematicalProgramResult.)""";
        } Details;
        // Symbol: drake::solvers::GurobiSolver::GurobiSolver
        struct /* ctor */ {
          // Source: drake/solvers/gurobi_solver.h:39
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::solvers::GurobiSolver::MipNodeCallbackFunction
        struct /* MipNodeCallbackFunction */ {
          // Source: drake/solvers/gurobi_solver.h:90
          const char* doc =
R"""(Users can supply a callback to be called when the Gurobi solver finds
an intermediate solution node, which may not be feasible. See Gurobi
reference manual for more detail on callbacks:
https://www.gurobi.com/documentation/9.0/refman/callback_codes.html.
The user may supply a partial solution in the VectorXd and
VectorXDecisionVariable arguments that will be passed to Gurobi as a
candidate feasible solution. See gurobi_solver_test.cc for an example
of using std::bind to create a callback of this signature, while
allowing additional data to be passed through.

Parameter ``MathematicalProgram``:
    & The optimization wrapper, whose current variable values
    (accessible via MathematicalProgram::GetSolution) will be set to
    the intermediate solution values.

Parameter ``SolveStatusInfo``:
    & Intermediate solution status information values queried from
    Gurobi.

Parameter ``VectorXd*``:
    User may assign this to be the values of the variable assignments.

Parameter ``VectorXDecisionVariable*``:
    User may assign this to be the decision variables being assigned.
    Must have the same number of elements as the VectorXd assignment.)""";
        } MipNodeCallbackFunction;
        // Symbol: drake::solvers::GurobiSolver::MipSolCallbackFunction
        struct /* MipSolCallbackFunction */ {
          // Source: drake/solvers/gurobi_solver.h:117
          const char* doc =
R"""(Users can supply a callback to be called when the Gurobi solver finds
a feasible solution. See Gurobi reference manual for more detail on
callbacks:
https://www.gurobi.com/documentation/9.0/refman/callback_codes.html.
See gurobi_solver_test.cc for an example of using std::bind to create
a callback of this signature, while allowing additional data to be
passed through.

Parameter ``MathematicalProgram``:
    & The optimization wrapper, whose current variable values
    (accessible via MathematicalProgram::GetSolution) will be set to
    the intermediate solution values.

Parameter ``SolveStatusInfo``:
    & Intermediate solution status information values queried from
    Gurobi.

Parameter ``void*``:
    Arbitrary data supplied during callback registration.)""";
        } MipSolCallbackFunction;
        // Symbol: drake::solvers::GurobiSolver::ProgramAttributesSatisfied
        struct /* ProgramAttributesSatisfied */ {
          // Source: drake/solvers/gurobi_solver.h:157
          const char* doc = R"""()""";
        } ProgramAttributesSatisfied;
        // Symbol: drake::solvers::GurobiSolver::SolveStatusInfo
        struct /* SolveStatusInfo */ {
          // Source: drake/solvers/gurobi_solver.h:51
          const char* doc =
R"""(Contains info returned to a user function that handles a Node or
Solution callback.

See also:
    MipNodeCallbackFunction

See also:
    MipSolCallbackFunction)""";
          // Symbol: drake::solvers::GurobiSolver::SolveStatusInfo::best_bound
          struct /* best_bound */ {
            // Source: drake/solvers/gurobi_solver.h:59
            const char* doc = R"""(Best known objective lower bound.)""";
          } best_bound;
          // Symbol: drake::solvers::GurobiSolver::SolveStatusInfo::best_objective
          struct /* best_objective */ {
            // Source: drake/solvers/gurobi_solver.h:57
            const char* doc = R"""(Objective of best solution yet.)""";
          } best_objective;
          // Symbol: drake::solvers::GurobiSolver::SolveStatusInfo::current_objective
          struct /* current_objective */ {
            // Source: drake/solvers/gurobi_solver.h:55
            const char* doc = R"""(Objective of current solution.)""";
          } current_objective;
          // Symbol: drake::solvers::GurobiSolver::SolveStatusInfo::explored_node_count
          struct /* explored_node_count */ {
            // Source: drake/solvers/gurobi_solver.h:61
            const char* doc = R"""(Number of nodes explored so far.)""";
          } explored_node_count;
          // Symbol: drake::solvers::GurobiSolver::SolveStatusInfo::feasible_solutions_count
          struct /* feasible_solutions_count */ {
            // Source: drake/solvers/gurobi_solver.h:63
            const char* doc = R"""(Number of feasible sols found so far.)""";
          } feasible_solutions_count;
          // Symbol: drake::solvers::GurobiSolver::SolveStatusInfo::reported_runtime
          struct /* reported_runtime */ {
            // Source: drake/solvers/gurobi_solver.h:53
            const char* doc = R"""(Runtime as of this callback.)""";
          } reported_runtime;
        } SolveStatusInfo;
        // Symbol: drake::solvers::GurobiSolver::id
        struct /* id */ {
          // Source: drake/solvers/gurobi_solver.h:152
          const char* doc = R"""()""";
        } id;
        // Symbol: drake::solvers::GurobiSolver::is_available
        struct /* is_available */ {
          // Source: drake/solvers/gurobi_solver.h:153
          const char* doc = R"""()""";
        } is_available;
        // Symbol: drake::solvers::GurobiSolver::is_enabled
        struct /* is_enabled */ {
          // Source: drake/solvers/gurobi_solver.h:156
          const char* doc =
R"""(Returns true iff the environment variable GRB_LICENSE_FILE has been
set to a non-empty value.)""";
        } is_enabled;
      } GurobiSolver;
      // Symbol: drake::solvers::GurobiSolverDetails
      struct /* GurobiSolverDetails */ {
        // Source: drake/solvers/gurobi_solver.h:18
        const char* doc =
R"""(The Gurobi solver details after calling Solve() function. The user can
call MathematicalProgramResult::get_solver_details<GurobiSolver>() to
obtain the details.)""";
        // Symbol: drake::solvers::GurobiSolverDetails::error_code
        struct /* error_code */ {
          // Source: drake/solvers/gurobi_solver.h:25
          const char* doc =
R"""(The error message returned from Gurobi call. Please refer to
https://www.gurobi.com/documentation/9.0/refman/error_codes.html)""";
        } error_code;
        // Symbol: drake::solvers::GurobiSolverDetails::objective_bound
        struct /* objective_bound */ {
          // Source: drake/solvers/gurobi_solver.h:34
          const char* doc =
R"""(The best known bound on the optimal objective. This is used in mixed
integer optimization. Please refer to
https://www.gurobi.com/documentation/9.0/refman/objbound.html)""";
        } objective_bound;
        // Symbol: drake::solvers::GurobiSolverDetails::optimization_status
        struct /* optimization_status */ {
          // Source: drake/solvers/gurobi_solver.h:29
          const char* doc =
R"""(The status code when the optimize call has returned. Please refer to
https://www.gurobi.com/documentation/9.0/refman/optimization_status_codes.html)""";
        } optimization_status;
        // Symbol: drake::solvers::GurobiSolverDetails::optimizer_time
        struct /* optimizer_time */ {
          // Source: drake/solvers/gurobi_solver.h:21
          const char* doc =
R"""(The gurobi optimization time. Please refer to
https://www.gurobi.com/documentation/9.0/refman/runtime.html)""";
        } optimizer_time;
      } GurobiSolverDetails;
      // Symbol: drake::solvers::IndeterminatesRefList
      struct /* IndeterminatesRefList */ {
        // Source: drake/solvers/indeterminate.h:44
        const char* doc = R"""()""";
      } IndeterminatesRefList;
      // Symbol: drake::solvers::IntervalBinning
      struct /* IntervalBinning */ {
        // Source: drake/solvers/mixed_integer_optimization_util.h:174
        const char* doc =
R"""(For a continuous variable whose range is cut into small intervals, we
will use binary variables to represent which interval the continuous
variable is in. We support two representations, either using
logarithmic number of binary variables, or linear number of binary
variables. For more details,

See also:
    AddLogarithmicSos2Constraint and AddSos2Constraint)""";
        // Symbol: drake::solvers::IntervalBinning::kLinear
        struct /* kLinear */ {
          // Source: drake/solvers/mixed_integer_optimization_util.h:176
          const char* doc = R"""()""";
        } kLinear;
        // Symbol: drake::solvers::IntervalBinning::kLogarithmic
        struct /* kLogarithmic */ {
          // Source: drake/solvers/mixed_integer_optimization_util.h:175
          const char* doc = R"""()""";
        } kLogarithmic;
      } IntervalBinning;
      // Symbol: drake::solvers::IpoptSolver
      struct /* IpoptSolver */ {
        // Source: drake/solvers/ipopt_solver.h:43
        const char* doc = R"""()""";
        // Symbol: drake::solvers::IpoptSolver::Details
        struct /* Details */ {
          // Source: drake/solvers/ipopt_solver.h:48
          const char* doc =
R"""(Type of details stored in MathematicalProgramResult.)""";
        } Details;
        // Symbol: drake::solvers::IpoptSolver::IpoptSolver
        struct /* ctor */ {
          // Source: drake/solvers/ipopt_solver.h:45
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::solvers::IpoptSolver::ProgramAttributesSatisfied
        struct /* ProgramAttributesSatisfied */ {
          // Source: drake/solvers/ipopt_solver.h:58
          const char* doc = R"""()""";
        } ProgramAttributesSatisfied;
        // Symbol: drake::solvers::IpoptSolver::id
        struct /* id */ {
          // Source: drake/solvers/ipopt_solver.h:55
          const char* doc = R"""()""";
        } id;
        // Symbol: drake::solvers::IpoptSolver::is_available
        struct /* is_available */ {
          // Source: drake/solvers/ipopt_solver.h:56
          const char* doc = R"""()""";
        } is_available;
        // Symbol: drake::solvers::IpoptSolver::is_enabled
        struct /* is_enabled */ {
          // Source: drake/solvers/ipopt_solver.h:57
          const char* doc = R"""()""";
        } is_enabled;
      } IpoptSolver;
      // Symbol: drake::solvers::IpoptSolverDetails
      struct /* IpoptSolverDetails */ {
        // Source: drake/solvers/ipopt_solver.h:19
        const char* doc =
R"""(The Ipopt solver details after calling Solve() function. The user can
call MathematicalProgramResult::get_solver_details<IpoptSolver>() to
obtain the details.)""";
        // Symbol: drake::solvers::IpoptSolverDetails::ConvertStatusToString
        struct /* ConvertStatusToString */ {
          // Source: drake/solvers/ipopt_solver.h:40
          const char* doc =
R"""(Convert status field to string. This function is useful if you want to
interpret the meaning of status.)""";
        } ConvertStatusToString;
        // Symbol: drake::solvers::IpoptSolverDetails::g
        struct /* g */ {
          // Source: drake/solvers/ipopt_solver.h:33
          const char* doc =
R"""(The final value for the constraint function.)""";
        } g;
        // Symbol: drake::solvers::IpoptSolverDetails::lambda
        struct /* lambda */ {
          // Source: drake/solvers/ipopt_solver.h:35
          const char* doc =
R"""(The final value for the constraint multiplier.)""";
        } lambda;
        // Symbol: drake::solvers::IpoptSolverDetails::status
        struct /* status */ {
          // Source: drake/solvers/ipopt_solver.h:27
          const char* doc =
R"""(The final status of the solver. Please refer to section 6 in
Introduction to Ipopt: A tutorial for downloading, installing, and
using Ipopt. You could also find the meaning of the status as
Ipopt::SolverReturn defined in IpAlgTypes.hpp)""";
        } status;
        // Symbol: drake::solvers::IpoptSolverDetails::z_L
        struct /* z_L */ {
          // Source: drake/solvers/ipopt_solver.h:29
          const char* doc =
R"""(The final value for the lower bound multiplier.)""";
        } z_L;
        // Symbol: drake::solvers::IpoptSolverDetails::z_U
        struct /* z_U */ {
          // Source: drake/solvers/ipopt_solver.h:31
          const char* doc =
R"""(The final value for the upper bound multiplier.)""";
        } z_U;
      } IpoptSolverDetails;
      // Symbol: drake::solvers::LinearComplementarityConstraint
      struct /* LinearComplementarityConstraint */ {
        // Source: drake/solvers/constraint.h:680
        const char* doc =
R"""(Implements a constraint of the form:


::

    Mx + q >= 0
      x >= 0
      x'(Mx + q) == 0

An implied slack variable complements any 0 component of x. To get the
slack values at a given solution x, use Eval(x).)""";
        // Symbol: drake::solvers::LinearComplementarityConstraint::DoCheckSatisfied
        struct /* DoCheckSatisfied */ {
          // Source: drake/solvers/constraint.h:704
          const char* doc = R"""()""";
        } DoCheckSatisfied;
        // Symbol: drake::solvers::LinearComplementarityConstraint::DoEval
        struct /* DoEval */ {
          // Source: drake/solvers/constraint.h:695
          const char* doc = R"""()""";
        } DoEval;
        // Symbol: drake::solvers::LinearComplementarityConstraint::LinearComplementarityConstraint
        struct /* ctor */ {
          // Source: drake/solvers/constraint.h:682
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::solvers::LinearComplementarityConstraint::M
        struct /* M */ {
          // Source: drake/solvers/constraint.h:691
          const char* doc = R"""()""";
        } M;
        // Symbol: drake::solvers::LinearComplementarityConstraint::q
        struct /* q */ {
          // Source: drake/solvers/constraint.h:692
          const char* doc = R"""()""";
        } q;
      } LinearComplementarityConstraint;
      // Symbol: drake::solvers::LinearConstraint
      struct /* LinearConstraint */ {
        // Source: drake/solvers/constraint.h:503
        const char* doc =
R"""(Implements a constraint of the form :math:`lb <= Ax <= ub`)""";
        // Symbol: drake::solvers::LinearConstraint::A
        struct /* A */ {
          // Source: drake/solvers/constraint.h:522
          const char* doc = R"""()""";
        } A;
        // Symbol: drake::solvers::LinearConstraint::A_
        struct /* A_ */ {
          // Source: drake/solvers/constraint.h:572
          const char* doc = R"""()""";
        } A_;
        // Symbol: drake::solvers::LinearConstraint::DoDisplay
        struct /* DoDisplay */ {
          // Source: drake/solvers/constraint.h:569
          const char* doc = R"""()""";
        } DoDisplay;
        // Symbol: drake::solvers::LinearConstraint::DoEval
        struct /* DoEval */ {
          // Source: drake/solvers/constraint.h:560
          const char* doc = R"""()""";
        } DoEval;
        // Symbol: drake::solvers::LinearConstraint::GetSparseMatrix
        struct /* GetSparseMatrix */ {
          // Source: drake/solvers/constraint.h:517
          const char* doc = R"""()""";
        } GetSparseMatrix;
        // Symbol: drake::solvers::LinearConstraint::LinearConstraint
        struct /* ctor */ {
          // Source: drake/solvers/constraint.h:505
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::solvers::LinearConstraint::UpdateCoefficients
        struct /* UpdateCoefficients */ {
          // Source: drake/solvers/constraint.h:538
          const char* doc =
R"""(Updates the linear term, upper and lower bounds in the linear
constraint. The updated constraint is: new_lb <= new_A * x <= new_ub
Note that the size of constraints (number of rows) can change, but the
number of variables (number of cols) cannot.

Parameter ``new_A``:
    new linear term

Parameter ``new_lb``:
    new lower bound

Parameter ``new_up``:
    new upper bound)""";
        } UpdateCoefficients;
      } LinearConstraint;
      // Symbol: drake::solvers::LinearCost
      struct /* LinearCost */ {
        // Source: drake/solvers/cost.h:37
        const char* doc =
R"""(Implements a cost of the form

.. math:: a'x + b

.)""";
        // Symbol: drake::solvers::LinearCost::DoDisplay
        struct /* DoDisplay */ {
          // Source: drake/solvers/cost.h:89
          const char* doc = R"""()""";
        } DoDisplay;
        // Symbol: drake::solvers::LinearCost::DoEval
        struct /* DoEval */ {
          // Source: drake/solvers/cost.h:80
          const char* doc = R"""()""";
        } DoEval;
        // Symbol: drake::solvers::LinearCost::GetSparseMatrix
        struct /* GetSparseMatrix */ {
          // Source: drake/solvers/cost.h:52
          const char* doc = R"""()""";
        } GetSparseMatrix;
        // Symbol: drake::solvers::LinearCost::LinearCost
        struct /* ctor */ {
          // Source: drake/solvers/cost.h:47
          const char* doc =
R"""(Construct a linear cost of the form

.. math:: a'x + b

.

Parameter ``a``:
    Linear term.

Parameter ``b``:
    (optional) Constant term.)""";
        } ctor;
        // Symbol: drake::solvers::LinearCost::UpdateCoefficients
        struct /* UpdateCoefficients */ {
          // Source: drake/solvers/cost.h:69
          const char* doc =
R"""(Updates the linear term, upper and lower bounds in the linear
constraint. The updated constraint is

.. math:: a_new' x + b_new

. Note that the number of variables (number of cols) cannot change.

Parameter ``new_a``:
    New linear term.

Parameter ``new_b``:
    (optional) New constant term.)""";
        } UpdateCoefficients;
        // Symbol: drake::solvers::LinearCost::a
        struct /* a */ {
          // Source: drake/solvers/cost.h:58
          const char* doc = R"""()""";
        } a;
        // Symbol: drake::solvers::LinearCost::b
        struct /* b */ {
          // Source: drake/solvers/cost.h:60
          const char* doc = R"""()""";
        } b;
      } LinearCost;
      // Symbol: drake::solvers::LinearEqualityConstraint
      struct /* LinearEqualityConstraint */ {
        // Source: drake/solvers/constraint.h:583
        const char* doc =
R"""(Implements a constraint of the form :math:`Ax = b`)""";
        // Symbol: drake::solvers::LinearEqualityConstraint::LinearEqualityConstraint
        struct /* ctor */ {
          // Source: drake/solvers/constraint.h:585
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::solvers::LinearEqualityConstraint::UpdateCoefficients
        struct /* UpdateCoefficients */ {
          // Source: drake/solvers/constraint.h:606
          const char* doc = R"""()""";
        } UpdateCoefficients;
      } LinearEqualityConstraint;
      // Symbol: drake::solvers::LinearMatrixInequalityConstraint
      struct /* LinearMatrixInequalityConstraint */ {
        // Source: drake/solvers/constraint.h:838
        const char* doc =
R"""(Impose the matrix inequality constraint on variable x

.. math:: F_0 + x_1  F_1 + ... + x_n  F_n \text{ is p.s.d}

where p.s.d stands for positive semidefinite. :math:`F_0, F_1, ...,
F_n` are all given symmetric matrices of the same size.)""";
        // Symbol: drake::solvers::LinearMatrixInequalityConstraint::DoEval
        struct /* DoEval */ {
          // Source: drake/solvers/constraint.h:864
          const char* doc_was_unable_to_choose_unambiguous_names =
R"""(Evaluate the eigen values of the linear matrix.)""";
        } DoEval;
        // Symbol: drake::solvers::LinearMatrixInequalityConstraint::F
        struct /* F */ {
          // Source: drake/solvers/constraint.h:854
          const char* doc = R"""()""";
        } F;
        // Symbol: drake::solvers::LinearMatrixInequalityConstraint::LinearMatrixInequalityConstraint
        struct /* ctor */ {
          // Source: drake/solvers/constraint.h:847
          const char* doc =
R"""(Parameter ``F``:
    Each symmetric matrix F[i] should be of the same size.

Parameter ``symmetry_tolerance``:
    The precision to determine if the input matrices Fi are all
    symmetric.

See also:
    math::IsSymmetric().)""";
        } ctor;
        // Symbol: drake::solvers::LinearMatrixInequalityConstraint::matrix_rows
        struct /* matrix_rows */ {
          // Source: drake/solvers/constraint.h:858
          const char* doc =
R"""(Gets the number of rows in the matrix inequality constraint. Namely Fi
are all matrix_rows() x matrix_rows() matrices.)""";
        } matrix_rows;
      } LinearMatrixInequalityConstraint;
      // Symbol: drake::solvers::LinearSystemSolver
      struct /* LinearSystemSolver */ {
        // Source: drake/solvers/linear_system_solver.h:12
        const char* doc =
R"""(Finds the least-square solution to the linear system A * x = b.)""";
        // Symbol: drake::solvers::LinearSystemSolver::LinearSystemSolver
        struct /* ctor */ {
          // Source: drake/solvers/linear_system_solver.h:14
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::solvers::LinearSystemSolver::ProgramAttributesSatisfied
        struct /* ProgramAttributesSatisfied */ {
          // Source: drake/solvers/linear_system_solver.h:24
          const char* doc = R"""()""";
        } ProgramAttributesSatisfied;
        // Symbol: drake::solvers::LinearSystemSolver::id
        struct /* id */ {
          // Source: drake/solvers/linear_system_solver.h:21
          const char* doc = R"""()""";
        } id;
        // Symbol: drake::solvers::LinearSystemSolver::is_available
        struct /* is_available */ {
          // Source: drake/solvers/linear_system_solver.h:22
          const char* doc = R"""()""";
        } is_available;
        // Symbol: drake::solvers::LinearSystemSolver::is_enabled
        struct /* is_enabled */ {
          // Source: drake/solvers/linear_system_solver.h:23
          const char* doc = R"""()""";
        } is_enabled;
      } LinearSystemSolver;
      // Symbol: drake::solvers::LogarithmicSos2NewBinaryVariables
      struct /* LogarithmicSos2NewBinaryVariables */ {
        // Source: drake/solvers/mixed_integer_optimization_util.h:29
        const char* doc =
R"""(The size of the new binary variables in the compile time, for Special
Ordered Set of type 2 (SOS2) constraint. The SOS2 constraint says that


::

    λ(0) + ... + λ(n) = 1
      ∀i. λ(i) ≥ 0
      ∃ j ∈ {0, 1, ..., n-1}, s.t λ(j) + λ(j + 1) = 1

Template parameter ``NumLambda``:
    The length of the lambda vector. NumLambda = n + 1.)""";
        // Symbol: drake::solvers::LogarithmicSos2NewBinaryVariables::type
        struct /* type */ {
          // Source: drake/solvers/mixed_integer_optimization_util.h:31
          const char* doc = R"""()""";
        } type;
      } LogarithmicSos2NewBinaryVariables;
      // Symbol: drake::solvers::LorentzConeConstraint
      struct /* LorentzConeConstraint */ {
        // Source: drake/solvers/constraint.h:291
        const char* doc =
R"""(Constraining the linear expression :math:`z=Ax+b` lies within the
Lorentz cone. A vector z ∈ ℝ ⁿ lies within Lorentz cone if

.. math:: z_0 \ge \sqrt{z_1^2+...+z_{n-1}^2}

where A ∈ ℝ ⁿˣᵐ, b ∈ ℝ ⁿ are given matrices. Ideally this constraint
should be handled by a second-order cone solver. In case the user
wants to enforce this constraint through general nonlinear
optimization, we provide three different formulations on the Lorentz
cone constraint 1. g(z) = z₀ - sqrt(z₁² + ... + zₙ₋₁²) ≥ 0 This
formulation is not differentiable at z₁=...=zₙ₋₁=0 2. g(z) = z₀ -
sqrt(z₁² + ... + zₙ₋₁²) ≥ 0 but the gradient of g(z) is approximated
as ∂g(z)/∂z = [1, -z₁/sqrt(z₁² + ... zₙ₋₁² + ε), ...,
-zₙ₋₁/sqrt(z₁²+...+zₙ₋₁²+ε)] where ε is a small positive number. 3.
z₀²-(z₁²+...+zₙ₋₁²) ≥ 0 z₀ ≥ 0 This constraint is differentiable
everywhere, but z₀²-(z₁²+...+zₙ₋₁²) ≥ 0 is non-convex. The default is
to use the first formulation. For more information and visualization,
please refer to
https://inst.eecs.berkeley.edu/~ee127a/book/login/l_socp_soc.html)""";
        // Symbol: drake::solvers::LorentzConeConstraint::A
        struct /* A */ {
          // Source: drake/solvers/constraint.h:313
          const char* doc = R"""(Getter for A.)""";
        } A;
        // Symbol: drake::solvers::LorentzConeConstraint::A_dense
        struct /* A_dense */ {
          // Source: drake/solvers/constraint.h:316
          const char* doc = R"""(Getter for dense version of A.)""";
        } A_dense;
        // Symbol: drake::solvers::LorentzConeConstraint::EvalType
        struct /* EvalType */ {
          // Source: drake/solvers/constraint.h:300
          const char* doc =
R"""(We provide three possible Eval functions to represent the Lorentz cone
constraint z₀ ≥ sqrt(z₁² + ... + zₙ₋₁²). For more explanation on the
three formulations, refer to LorentzConeConstraint documentation.)""";
          // Symbol: drake::solvers::LorentzConeConstraint::EvalType::kConvex
          struct /* kConvex */ {
            // Source: drake/solvers/constraint.h:301
            const char* doc =
R"""(The constraint is g(z) = z₀ - sqrt(z₁² + ... + zₙ₋₁²) ≥ 0)""";
          } kConvex;
          // Symbol: drake::solvers::LorentzConeConstraint::EvalType::kConvexSmooth
          struct /* kConvexSmooth */ {
            // Source: drake/solvers/constraint.h:302
            const char* doc =
R"""(Same as kConvex1, but with approximated gradient.)""";
          } kConvexSmooth;
          // Symbol: drake::solvers::LorentzConeConstraint::EvalType::kNonconvex
          struct /* kNonconvex */ {
            // Source: drake/solvers/constraint.h:303
            const char* doc =
R"""(Nonconvex constraint z₀²-(z₁²+...+zₙ₋₁²) ≥ 0 and z₀ ≥ 0)""";
          } kNonconvex;
        } EvalType;
        // Symbol: drake::solvers::LorentzConeConstraint::LorentzConeConstraint
        struct /* ctor */ {
          // Source: drake/solvers/constraint.h:293
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::solvers::LorentzConeConstraint::b
        struct /* b */ {
          // Source: drake/solvers/constraint.h:319
          const char* doc = R"""(Getter for b.)""";
        } b;
      } LorentzConeConstraint;
      // Symbol: drake::solvers::MakeFunctionCost
      struct /* MakeFunctionCost */ {
        // Source: drake/solvers/cost.h:262
        const char* doc =
R"""(Converts an input of type ``F`` to a nonlinear cost.

Template parameter ``FF``:
    The forwarded function type (e.g., ``const F&, `F&&``, ...). The
    class ``F`` should have functions numInputs(), numOutputs(), and
    eval(x, y).)""";
      } MakeFunctionCost;
      // Symbol: drake::solvers::MakeFunctionEvaluator
      struct /* MakeFunctionEvaluator */ {
        // Source: drake/solvers/evaluator_base.h:336
        const char* doc =
R"""(Creates a FunctionEvaluator instance bound to a given callable object.

Template parameter ``FF``:
    Perfect-forwarding type of ``F`` (e.g., ``const F&``, `F&&`).

Parameter ``f``:
    Callable function object.

Returns:
    An implementation of EvaluatorBase using the callable object.)""";
      } MakeFunctionEvaluator;
      // Symbol: drake::solvers::MakeL2NormCost
      struct /* MakeL2NormCost */ {
        // Source: drake/solvers/cost.h:186
        const char* doc =
R"""(Creates a cost term of the form | Ax - b |^2.)""";
      } MakeL2NormCost;
      // Symbol: drake::solvers::MakeQuadraticErrorCost
      struct /* MakeQuadraticErrorCost */ {
        // Source: drake/solvers/cost.h:179
        const char* doc =
R"""(Creates a cost term of the form (x-x_desired)'*Q*(x-x_desired).)""";
      } MakeQuadraticErrorCost;
      // Symbol: drake::solvers::MakeSolver
      struct /* MakeSolver */ {
        // Source: drake/solvers/choose_best_solver.h:29
        const char* doc =
R"""(Given the solver ID, create the solver with the matching ID.

Raises:
    invalid_argument if there is no matching solver.)""";
      } MakeSolver;
      // Symbol: drake::solvers::MathematicalProgram
      struct /* MathematicalProgram */ {
        // Source: drake/solvers/mathematical_program.h:141
        const char* doc =
R"""(MathematicalProgram stores the decision variables, the constraints and
costs of an optimization problem. The user can solve the problem by
calling solvers::Solve() function, and obtain the results of the
optimization.)""";
        // Symbol: drake::solvers::MathematicalProgram::AddBoundingBoxConstraint
        struct /* AddBoundingBoxConstraint */ {
          // Source: drake/solvers/mathematical_program.h:1703
          const char* doc_3args_lb_ub_vars =
R"""(Adds bounding box constraints referencing potentially a subset of the
decision variables.

Parameter ``lb``:
    The lower bound.

Parameter ``ub``:
    The upper bound.

Parameter ``vars``:
    Will imposes constraint lb(i) <= vars(i) <= ub(i).

Returns:
    The newly constructed BoundingBoxConstraint.)""";
          // Source: drake/solvers/mathematical_program.h:1714
          const char* doc_3args_lb_ub_var =
R"""(Adds bounds for a single variable.

Parameter ``lb``:
    Lower bound.

Parameter ``ub``:
    Upper bound.

Parameter ``var``:
    The decision variable.)""";
          // Source: drake/solvers/mathematical_program.h:1770
          const char* doc_3args_double_double_constEigenMatrixBase =
R"""(Adds the same scalar lower and upper bound to every variable in
``vars``.

Template parameter ``Derived``:
    An Eigen::Matrix with Variable as the scalar type. The matrix has
    unknown number of columns at compile time, or has more than one
    column.

Parameter ``lb``:
    Lower bound.

Parameter ``ub``:
    Upper bound.

Parameter ``vars``:
    The decision variables.)""";
        } AddBoundingBoxConstraint;
        // Symbol: drake::solvers::MathematicalProgram::AddConstraint
        struct /* AddConstraint */ {
          // Source: drake/solvers/mathematical_program.h:1156
          const char* doc_1args_binding =
R"""(Adds a generic constraint to the program. This should only be used if
a more specific type of constraint is not available, as it may require
the use of a significantly more expensive solver.)""";
          // Source: drake/solvers/mathematical_program.h:1175
          const char* doc_3args_e_lb_ub =
R"""(Adds one row of constraint lb <= e <= ub where ``e`` is a symbolic
expression.

Raises:
    RuntimeError if 1. ``lb <= e <= ub`` is a trivial constraint such
    as 1 <= 2 <= 3. 2. ``lb <= e <= ub`` is unsatisfiable such as 1 <=
    -5 <= 3

Parameter ``e``:
    A symbolic expression of the the decision variables.

Parameter ``lb``:
    A scalar, the lower bound.

Parameter ``ub``:
    A scalar, the upper bound.

The resulting constraint may be a BoundingBoxConstraint,
LinearConstraint, LinearEqualityConstraint, or ExpressionConstraint,
depending on the arguments. Constraints of the form x == 1 (which
could be created as a BoundingBoxConstraint or
LinearEqualityConstraint) will be constructed as a
LinearEqualityConstraint.)""";
          // Source: drake/solvers/mathematical_program.h:1219
          const char* doc_1args_f =
R"""(Add a constraint represented by a symbolic formula to the program. The
input formula ``f`` can be of the following forms:

1. e1 <= e2
2. e1 >= e2
3. e1 == e2
4. A conjunction of relational formulas where each conjunct is
   a relational formula matched by 1, 2, or 3.

Note that first two cases might return an object of
Binding<BoundingBoxConstraint>, Binding<LinearConstraint>, or
Binding<ExpressionConstraint>, depending on ``f``. Also the third case
might return an object of Binding<LinearEqualityConstraint> or
Binding<ExpressionConstraint>.

It throws an exception if 1. ``f`` is not matched with one of the
above patterns. Especially, strict inequalities (<, >) are not
allowed. 2. ``f`` is either a trivial constraint such as "1 <= 2" or
an unsatisfiable constraint such as "2 <= 1". 3. It is not possible to
find numerical bounds of ``e1`` and ``e2`` where ``f`` = e1 ≃ e2. We
allow ``e1`` and ``e2`` to be infinite but only if there are no other
terms. For example, ``x <= ∞`` is allowed. However, ``x - ∞ <= 0`` is
not allowed because ``x ↦ ∞`` introduces ``nan`` in the evaluation.)""";
          // Source: drake/solvers/mathematical_program.h:1280
          const char* doc_matrix_formula =
R"""(Add a constraint represented by an Eigen::Matrix<symbolic::Formula> to
the program.

A formula in ``formulas`` can be of the following forms:

1. e1 <= e2
2. e1 >= e2
3. e1 == e2

It throws an exception if AddConstraint(const symbolic::Formula& f)
throws an exception for any f ∈ formulas.

Template parameter ``Derived``:
    An Eigen Matrix type of Formula.)""";
          // Source: drake/solvers/mathematical_program.h:1305
          const char* doc_2args_con_vars =
R"""(Adds a generic constraint to the program. This should only be used if
a more specific type of constraint is not available, as it may require
the use of a significantly more expensive solver.)""";
        } AddConstraint;
        // Symbol: drake::solvers::MathematicalProgram::AddCost
        struct /* AddCost */ {
          // Source: drake/solvers/mathematical_program.h:862
          const char* doc_was_unable_to_choose_unambiguous_names =
R"""(Adds a generic cost to the optimization program.)""";
        } AddCost;
        // Symbol: drake::solvers::MathematicalProgram::AddDecisionVariables
        struct /* AddDecisionVariables */ {
          // Source: drake/solvers/mathematical_program.h:401
          const char* doc =
R"""(Appends new variables to the end of the existing variables.

Parameter ``decision_variables``:
    The newly added decision_variables.

Precondition:
    ``decision_variables`` should not intersect with the existing
    variables or indeterminates in the optimization program.

Precondition:
    Each entry in ``decision_variables`` should not be a dummy
    variable.

Raises:
    RuntimeError if the preconditions are not satisfied.)""";
        } AddDecisionVariables;
        // Symbol: drake::solvers::MathematicalProgram::AddEqualityConstraintBetweenPolynomials
        struct /* AddEqualityConstraintBetweenPolynomials */ {
          // Source: drake/solvers/mathematical_program.h:2454
          const char* doc =
R"""(Constraining that two polynomials are the same (i.e., they have the
same coefficients for each monomial). This function is often used in
sum-of-squares optimization. We will impose the linear equality
constraint that the coefficient of a monomial in ``p1`` is the same as
the coefficient of the same monomial in ``p2``.

Parameter ``p1``:
    Note that p1's indeterminates should have been registered as
    indeterminates in this MathematicalProgram object, and p1's
    coefficients are affine functions of decision variables in this
    MathematicalProgram object.

Parameter ``p2``:
    Note that p2's indeterminates should have been registered as
    indeterminates in this MathematicalProgram object, and p2's
    coefficients are affine functions of decision variables in this
    MathematicalProgram object.

Note:
    It calls ``Reparse`` to enforce ``p1`` and ``p2`` to have this
    MathematicalProgram's indeterminates.)""";
        } AddEqualityConstraintBetweenPolynomials;
        // Symbol: drake::solvers::MathematicalProgram::AddExponentialConeConstraint
        struct /* AddExponentialConeConstraint */ {
          // Source: drake/solvers/mathematical_program.h:2479
          const char* doc_3args =
R"""(Adds an exponential cone constraint, that z = A * vars + b should be
in the exponential cone. Namely {z₀, z₁, z₂ | z₀ ≥ z₁ * exp(z₂ / z₁),
z₁ > 0}.

Parameter ``A``:
    The A matrix in the documentation above. A must have 3 rows.

Parameter ``b``:
    The b vector in the documentation above.

Parameter ``vars``:
    The variables bound with this constraint.)""";
          // Source: drake/solvers/mathematical_program.h:2489
          const char* doc_1args =
R"""(Add the constraint that z is in the exponential cone.

Parameter ``z``:
    The expression in the exponential cone.

Precondition:
    each entry in ``z`` is a linear expression of the decision
    variables.)""";
        } AddExponentialConeConstraint;
        // Symbol: drake::solvers::MathematicalProgram::AddIndeterminates
        struct /* AddIndeterminates */ {
          // Source: drake/solvers/mathematical_program.h:815
          const char* doc =
R"""(Adds indeterminates. This method appends some indeterminates to the
end of the program's old indeterminates.

Parameter ``new_indeterminates``:
    The indeterminates to be appended to the program's old
    indeterminates.

Precondition:
    ``new_indeterminates`` should not intersect with the program's old
    indeterminates or decision variables.

Precondition:
    Each entry in new_indeterminates should not be dummy.

Precondition:
    Each entry in new_indeterminates should be of CONTINUOUS type.)""";
        } AddIndeterminates;
        // Symbol: drake::solvers::MathematicalProgram::AddL2NormCost
        struct /* AddL2NormCost */ {
          // Source: drake/solvers/mathematical_program.h:1020
          const char* doc =
R"""(Adds a cost term of the form | Ax - b |^2.)""";
        } AddL2NormCost;
        // Symbol: drake::solvers::MathematicalProgram::AddLinearComplementarityConstraint
        struct /* AddLinearComplementarityConstraint */ {
          // Source: drake/solvers/mathematical_program.h:2162
          const char* doc =
R"""(Adds a linear complementarity constraints referencing a subset of the
decision variables.)""";
        } AddLinearComplementarityConstraint;
        // Symbol: drake::solvers::MathematicalProgram::AddLinearConstraint
        struct /* AddLinearConstraint */ {
          // Source: drake/solvers/mathematical_program.h:1323
          const char* doc_4args_A_lb_ub_vars =
R"""(Adds linear constraints referencing potentially a subset of the
decision variables (defined in the vars parameter).)""";
          // Source: drake/solvers/mathematical_program.h:1351
          const char* doc_4args_a_lb_ub_vars =
R"""(Adds one row of linear constraint referencing potentially a subset of
the decision variables (defined in the vars parameter). lb <= a*vars
<= ub

Parameter ``a``:
    A row vector.

Parameter ``lb``:
    A scalar, the lower bound.

Parameter ``ub``:
    A scalar, the upper bound.

Parameter ``vars``:
    The decision variables on which to impose the linear constraint.)""";
          // Source: drake/solvers/mathematical_program.h:1386
          const char* doc_3args_e_lb_ub =
R"""(Adds one row of linear constraint lb <= e <= ub where ``e`` is a
symbolic expression.

Raises:
    RuntimeError if 1. ``e`` is a non-linear expression. 2. ``lb <= e
    <= ub`` is a trivial constraint such as 1 <= 2 <= 3. 3. ``lb <= e
    <= ub`` is unsatisfiable such as 1 <= -5 <= 3

Parameter ``e``:
    A linear symbolic expression in the form of ``c0 + c1 * v1 + ... +
    cn * vn`` where ``c_i`` is a constant and @v_i is a variable.

Parameter ``lb``:
    A scalar, the lower bound.

Parameter ``ub``:
    A scalar, the upper bound.)""";
          // Source: drake/solvers/mathematical_program.h:1394
          const char* doc_3args_v_lb_ub =
R"""(Adds linear constraints represented by symbolic expressions to the
program. It throws if @v includes a non-linear expression or ``lb <= v
<= ub`` includes trivial/unsatisfiable constraints.)""";
          // Source: drake/solvers/mathematical_program.h:1424
          const char* doc_1args_f =
R"""(Add a linear constraint represented by a symbolic formula to the
program. The input formula ``f`` can be of the following forms:

1. e1 <= e2
2. e1 >= e2
3. e1 == e2
4. A conjunction of relational formulas where each conjunct is
   a relational formula matched by 1, 2, or 3.

Note that first two cases might return an object of
Binding<BoundingBoxConstraint> depending on ``f``. Also the third case
returns an object of Binding<LinearEqualityConstraint>.

It throws an exception if 1. ``f`` is not matched with one of the
above patterns. Especially, strict inequalities (<, >) are not
allowed. 2. ``f`` includes a non-linear expression. 3. ``f`` is either
a trivial constraint such as "1 <= 2" or an unsatisfiable constraint
such as "2 <= 1". 4. It is not possible to find numerical bounds of
``e1`` and ``e2`` where ``f`` = e1 ≃ e2. We allow ``e1`` and ``e2`` to
be infinite but only if there are no other terms. For example, ``x <=
∞`` is allowed. However, ``x - ∞ <= 0`` is not allowed because ``x ↦
∞`` introduces ``nan`` in the evaluation.)""";
          // Source: drake/solvers/mathematical_program.h:1455
          const char* doc_1args_constEigenArrayBase =
R"""(Add a linear constraint represented by an
Eigen::Array<symbolic::Formula> to the program. A common use-case of
this function is to add a linear constraint with the element-wise
comparison between two Eigen matrices, using ``A.array() <=
B.array()``. See the following example.


::

    MathematicalProgram prog;
      Eigen::Matrix<double, 2, 2> A;
      auto x = prog.NewContinuousVariables(2, "x");
      Eigen::Vector2d b;
      ... // set up A and b
      prog.AddLinearConstraint((A * x).array() <= b.array());

A formula in ``formulas`` can be of the following forms:

1. e1 <= e2 2. e1 >= e2 3. e1 == e2

It throws an exception if AddLinearConstraint(const symbolic::Formula&
f) throws an exception for f ∈ ``formulas``.

Template parameter ``Derived``:
    An Eigen Array type of Formula.)""";
        } AddLinearConstraint;
        // Symbol: drake::solvers::MathematicalProgram::AddLinearCost
        struct /* AddLinearCost */ {
          // Source: drake/solvers/mathematical_program.h:948
          const char* doc_1args =
R"""(Adds a linear cost term of the form a'*x + b.

Parameter ``e``:
    A linear symbolic expression.

Precondition:
    e is a linear expression a'*x + b, where each entry of x is a
    decision variable in the mathematical program.

Returns:
    The newly added linear constraint, together with the bound
    variables.)""";
          // Source: drake/solvers/mathematical_program.h:955
          const char* doc_3args =
R"""(Adds a linear cost term of the form a'*x + b. Applied to a subset of
the variables and pushes onto the linear cost data structure.)""";
          // Source: drake/solvers/mathematical_program.h:975
          const char* doc_2args =
R"""(Adds a linear cost term of the form a'*x. Applied to a subset of the
variables and pushes onto the linear cost data structure.)""";
        } AddLinearCost;
        // Symbol: drake::solvers::MathematicalProgram::AddLinearEqualityConstraint
        struct /* AddLinearEqualityConstraint */ {
          // Source: drake/solvers/mathematical_program.h:1491
          const char* doc_2args_e_b =
R"""(Adds one row of linear constraint e = b where ``e`` is a symbolic
expression.

Raises:
    RuntimeError if 1. ``e`` is a non-linear expression. 2. ``e`` is a
    constant.

Parameter ``e``:
    A linear symbolic expression in the form of ``c0 + c1 * x1 + ... +
    cn * xn`` where ``c_i`` is a constant and @x_i is a variable.

Parameter ``b``:
    A scalar.

Returns:
    The newly added linear equality constraint, together with the
    bound variable.)""";
          // Source: drake/solvers/mathematical_program.h:1504
          const char* doc_1args_f =
R"""(Adds a linear equality constraint represented by a symbolic formula to
the program. The input formula ``f`` is either an equality formula
(``e1 == e2``) or a conjunction of equality formulas.

It throws an exception if

1. ``f`` is neither an equality formula nor a conjunction of equalities.
2. ``f`` includes a non-linear expression.)""";
          // Source: drake/solvers/mathematical_program.h:1527
          const char* doc_2args_constEigenMatrixBase_constEigenMatrixBase =
R"""(Adds linear equality constraints :math:`v = b`, where ``v(i)`` is a
symbolic linear expression.

Raises:
    RuntimeError if 1. ``v(i)`` is a non-linear expression. 2.
    ``v(i)`` is a constant.

Template parameter ``DerivedV``:
    An Eigen Matrix type of Expression. A column vector.

Template parameter ``DerivedB``:
    An Eigen Matrix type of double. A column vector.

Parameter ``v``:
    v(i) is a linear symbolic expression in the form of `` c0 + c1 *
    x1 + ... + cn * xn `` where ci is a constant and @xi is a
    variable.

Parameter ``b``:
    A vector of doubles.

Returns:
    The newly added linear equality constraint, together with the
    bound variables.)""";
          // Source: drake/solvers/mathematical_program.h:1613
          const char* doc_3args_Aeq_beq_vars =
R"""(AddLinearEqualityConstraint

Adds linear equality constraints referencing potentially a subset of
the decision variables.

Example: to add two equality constraints which only depend on two of
the elements of x, you could use


::

    auto x = prog.NewContinuousVariables(6,"myvar");
      Eigen::Matrix2d Aeq;
      Aeq << -1, 2,
              1, 1;
      Eigen::Vector2d beq(1, 3);
      // Imposes constraint
      // -x(0) + 2x(1) = 1
      //  x(0) +  x(1) = 3
      prog.AddLinearEqualityConstraint(Aeq, beq, x.head<2>());)""";
        } AddLinearEqualityConstraint;
        // Symbol: drake::solvers::MathematicalProgram::AddLinearMatrixInequalityConstraint
        struct /* AddLinearMatrixInequalityConstraint */ {
          // Source: drake/solvers/mathematical_program.h:2290
          const char* doc =
R"""(Adds a linear matrix inequality constraint to the program.)""";
        } AddLinearMatrixInequalityConstraint;
        // Symbol: drake::solvers::MathematicalProgram::AddLorentzConeConstraint
        struct /* AddLorentzConeConstraint */ {
          // Source: drake/solvers/mathematical_program.h:1824
          const char* doc_1args_v =
R"""(Adds Lorentz cone constraint referencing potentially a subset of the
decision variables.

Parameter ``v``:
    An Eigen::Vector of symbolic::Expression. Constraining that

.. math:: v_0 \ge \sqrt{v_1^2 + ... + v_{n-1}^2}

Returns:
    The newly constructed Lorentz cone constraint with the bounded
    variables. For example, to add the Lorentz cone constraint

x+1 >= sqrt(y² + 2y + x² + 5), = sqrt((y+1)²+x²+2²) The user could
call


::

    {cc}
    Vector4<symbolic::Expression> v(x+1, y+1, x, 2.);
    prog.AddLorentzConeConstraint(v);)""";
          // Source: drake/solvers/mathematical_program.h:1863
          const char* doc_3args_linear_expression_quadratic_expression_tol =
R"""(Adds Lorentz cone constraint on the linear expression v1 and quadratic
expression v2, such that v1 >= sqrt(v2)

Parameter ``linear_expression``:
    The linear expression v1.

Parameter ``quadratic_expression``:
    The quadratic expression v2.

Parameter ``tol``:
    The tolerance to determine if the matrix in v2 is positive
    semidefinite or not.

See also:
    DecomposePositiveQuadraticForm for more explanation. $*Default:*
    is 0.

Returns ``binding``:
    The newly added Lorentz cone constraint, together with the bound
    variables.

Precondition:
1. ``v1`` is a linear expression, in the form of c'*x + d.
2. ``v2`` is a quadratic expression, in the form of
   


::

    x'*Q*x + b'x + a

Also the quadratic expression has to be convex, namely Q is a positive
semidefinite matrix, and the quadratic expression needs to be
non-negative for any x.

Raises:
    RuntimeError if the preconditions are not satisfied.

Notice this constraint is equivalent to the vector [z;y] is within a
Lorentz cone, where


::

    z = v1
     y = R * x + d

while (R, d) satisfies y'*y = x'*Q*x + b'*x + a For example, to add
the Lorentz cone constraint

x+1 >= sqrt(y² + 2y + x² + 4), the user could call


::

    {cc}
    prog.AddLorentzConeConstraint(x+1, pow(y, 2) + 2 * y + pow(x, 2) + 4);)""";
          // Source: drake/solvers/mathematical_program.h:1924
          const char* doc_3args_A_b_vars =
R"""(Adds Lorentz cone constraint referencing potentially a subset of the
decision variables (defined in the vars parameter). The linear
expression :math:`z=Ax+b` is in the Lorentz cone. A vector :math:`z
\in\mathbb{R}^n` is in the Lorentz cone, if

.. math:: z_0 \ge \sqrt{z_1^2 + ... + z_{n-1}^2}

Parameter ``A``:
    A :math:`\mathbb{R}^{n\times m}` matrix, whose number of columns
    equals to the size of the decision variables.

Parameter ``b``:
    A :math:`\mathbb{R}^n` vector, whose number of rows equals to the
    size of the decision variables.

Parameter ``vars``:
    The Eigen vector of :math:`m` decision variables.

Returns:
    The newly added Lorentz cone constraint.

For example, to add the Lorentz cone constraint

x+1 >= sqrt(y² + 2y + x² + 5) = sqrt((y+1)² + x² + 2²), the user could
call


::

    {cc}
    Eigen::Matrix<double, 4, 2> A;
    Eigen::Vector4d b;
    A << 1, 0, 0, 1, 1, 0, 0, 0;
    b << 1, 1, 0, 2;
    // A * [x;y] + b = [x+1; y+1; x; 2]
    prog.AddLorentzConeConstraint(A, b, Vector2<symbolic::Variable>(x, y));)""";
        } AddLorentzConeConstraint;
        // Symbol: drake::solvers::MathematicalProgram::AddMaximizeGeometricMeanCost
        struct /* AddMaximizeGeometricMeanCost */ {
          // Source: drake/solvers/mathematical_program.h:1132
          const char* doc_3args =
R"""(An overloaded version of maximize_geometric_mean.

Precondition:
    A.rows() == b.rows(), A.rows() >= 2.)""";
          // Source: drake/solvers/mathematical_program.h:1146
          const char* doc_2args =
R"""(An overloaded version of maximize_geometric_mean. We add the cost to
maximize the geometric mean of x, i.e., c*power(∏ᵢx(i), 1/n).

Parameter ``c``:
    The positive coefficient of the geometric mean cost, $*Default:*
    is 1.

Precondition:
    x.rows() >= 2.

Precondition:
    c > 0.)""";
        } AddMaximizeGeometricMeanCost;
        // Symbol: drake::solvers::MathematicalProgram::AddMaximizeLogDeterminantSymmetricMatrixCost
        struct /* AddMaximizeLogDeterminantSymmetricMatrixCost */ {
          // Source: drake/solvers/mathematical_program.h:1100
          const char* doc =
R"""(Adds the cost to maximize the log determinant of symmetric matrix X.
log(det(X)) is a concave function of X, so we can maximize it through
convex optimization. In order to do that, we introduce slack variables
t, and a lower triangular matrix Z, with the constraints ⌈X Z⌉ is
positive semidifinite. ⌊Zᵀ diag(Z)⌋ log(Z(i, i)) >= t(i) and we will
minimize -∑ᵢt(i).

Parameter ``X``:
    A symmetric positive semidefinite matrix X, whose log(det(X)) will
    be maximized.

Precondition:
    X is a symmetric matrix.

Note:
    The constraint log(Z(i, i)) >= t(i) is imposed as an exponential
    cone constraint. Please make sure your have a solver that supports
    exponential cone constraint (currently SCS does).)""";
        } AddMaximizeLogDeterminantSymmetricMatrixCost;
        // Symbol: drake::solvers::MathematicalProgram::AddPolynomialConstraint
        struct /* AddPolynomialConstraint */ {
          // Source: drake/solvers/mathematical_program.h:2182
          const char* doc =
R"""(Adds a polynomial constraint to the program referencing a subset of
the decision variables (defined in the vars parameter).)""";
        } AddPolynomialConstraint;
        // Symbol: drake::solvers::MathematicalProgram::AddPolynomialCost
        struct /* AddPolynomialCost */ {
          // Source: drake/solvers/mathematical_program.h:1071
          const char* doc =
R"""(Adds a cost term in the polynomial form.

Parameter ``e``:
    A symbolic expression in the polynomial form.

Returns:
    The newly created cost and the bound variables.)""";
        } AddPolynomialCost;
        // Symbol: drake::solvers::MathematicalProgram::AddPositiveDiagonallyDominantMatrixConstraint
        struct /* AddPositiveDiagonallyDominantMatrixConstraint */ {
          // Source: drake/solvers/mathematical_program.h:2327
          const char* doc =
R"""(Adds the constraint that a symmetric matrix is diagonally dominant
with non-negative diagonal entries. A symmetric matrix X is diagonally
dominant with non-negative diagonal entries if X(i, i) >= ∑ⱼ |X(i, j)|
∀ j ≠ i namely in each row, the diagonal entry is larger than the sum
of the absolute values of all other entries in the same row. A matrix
being diagonally dominant with non-negative diagonals is a sufficient
(but not necessary) condition of a matrix being positive semidefinite.
Internally we will create a matrix Y as slack variables, such that
Y(i, j) represents the absolute value |X(i, j)| ∀ j ≠ i. The diagonal
entries Y(i, i) = X(i, i) The users can refer to "DSOS and SDSOS
Optimization: More Tractable Alternatives to Sum of Squares and
Semidefinite Optimization" by Amir Ali Ahmadi and Anirudha Majumdar,
with arXiv link https://arxiv.org/abs/1706.02586

Parameter ``X``:
    The matrix X. We will use 0.5(X+Xᵀ) as the "symmetric version" of
    X.

Returns:
    Y The slack variable. Y(i, j) represents |X(i, j)| ∀ j ≠ i, with
    the constraint Y(i, j) >= X(i, j) and Y(i, j) >= -X(i, j). Y is a
    symmetric matrix. The diagonal entries Y(i, i) = X(i, i))""";
        } AddPositiveDiagonallyDominantMatrixConstraint;
        // Symbol: drake::solvers::MathematicalProgram::AddPositiveSemidefiniteConstraint
        struct /* AddPositiveSemidefiniteConstraint */ {
          // Source: drake/solvers/mathematical_program.h:2225
          const char* doc_1args_symmetric_matrix_var =
R"""(Adds a positive semidefinite constraint on a symmetric matrix.

Raises:
    RuntimeError in Debug mode if ``symmetric_matrix_var`` is not
    symmetric.

Parameter ``symmetric_matrix_var``:
    A symmetric MatrixDecisionVariable object.)""";
          // Source: drake/solvers/mathematical_program.h:2258
          const char* doc_1args_constEigenMatrixBase =
R"""(Adds a positive semidefinite constraint on a symmetric matrix of
symbolic expressions ``e``. We create a new symmetric matrix of
variables M being positive semidefinite, with the linear equality
constraint e == M.

Template parameter ``Derived``:
    An Eigen Matrix of symbolic expressions.

Parameter ``e``:
    Imposes constraint "e is positive semidefinite".

Precondition:
    {1. e is symmetric. 2. e(i, j) is linear for all i, j }

Returns:
    The newly added positive semidefinite constraint, with the bound
    variable M that are also newly added.

For example, to add a constraint that

⌈x + 1 2x + 3 x+y⌉ |2x+ 3 2 0| is positive semidefinite ⌊x + y 0 x⌋
The user could call


::

    {cc}
    Matrix3<symbolic::Expression> e
    e << x+1, 2*x+3, x+y,
         2*x+3,   2,   0,
         x+y,     0,   x;
    prog.AddPositiveSemidefiniteConstraint(e);)""";
        } AddPositiveSemidefiniteConstraint;
        // Symbol: drake::solvers::MathematicalProgram::AddQuadraticCost
        struct /* AddQuadraticCost */ {
          // Source: drake/solvers/mathematical_program.h:996
          const char* doc_1args =
R"""(Add a quadratic cost term of the form 0.5*x'*Q*x + b'*x + c. Notice
that in the optimization program, the constant term ``c`` in the cost
is ignored.

Parameter ``e``:
    A quadratic symbolic expression.

Raises:
    std::runtime error if the expression is not quadratic.

Returns:
    The newly added cost together with the bound variables.)""";
          // Source: drake/solvers/mathematical_program.h:1052
          const char* doc_4args =
R"""(Adds a cost term of the form 0.5*x'*Q*x + b'x + c Applied to subset of
the variables.)""";
          // Source: drake/solvers/mathematical_program.h:1061
          const char* doc_3args =
R"""(Adds a cost term of the form 0.5*x'*Q*x + b'x Applied to subset of the
variables.)""";
        } AddQuadraticCost;
        // Symbol: drake::solvers::MathematicalProgram::AddQuadraticErrorCost
        struct /* AddQuadraticErrorCost */ {
          // Source: drake/solvers/mathematical_program.h:1001
          const char* doc =
R"""(Adds a cost term of the form (x-x_desired)'*Q*(x-x_desired).)""";
        } AddQuadraticErrorCost;
        // Symbol: drake::solvers::MathematicalProgram::AddRotatedLorentzConeConstraint
        struct /* AddRotatedLorentzConeConstraint */ {
          // Source: drake/solvers/mathematical_program.h:2023
          const char* doc_4args_linear_expression1_linear_expression2_quadratic_expression_tol =
R"""(Adds rotated Lorentz cone constraint on the linear expression v1, v2
and quadratic expression u, such that v1 * v2 >= u, v1 >= 0, v2 >= 0

Parameter ``linear_expression1``:
    The linear expression v1.

Parameter ``linear_expression2``:
    The linear expression v2.

Parameter ``quadratic_expression``:
    The quadratic expression u.

Parameter ``tol``:
    The tolerance to determine if the matrix in v2 is positive
    semidefinite or not.

See also:
    DecomposePositiveQuadraticForm for more explanation. $*Default:*
    is 0.

Returns ``binding``:
    The newly added rotated Lorentz cone constraint, together with the
    bound variables.

Precondition:
1. ``linear_expression1`` is a linear (affine) expression, in the form of
   v1 = c1'*x + d1.
2. ``linear_expression2`` is a linear (affine) expression, in the form of
   v2 = c2'*x + d2.
2. ``quadratic_expression`` is a quadratic expression, in the form of
   


::

    u = x'*Q*x + b'x + a

Also the quadratic expression has to be convex, namely Q is a positive
semidefinite matrix, and the quadratic expression needs to be
non-negative for any x.

Raises:
    RuntimeError if the preconditions are not satisfied.

For example, to add the rotated Lorentz cone constraint

(x+1)(x+y) >= x²+z²+2z+5 x+1 >= 0 x+y >= 0 The user could call


::

    {cc}
    prog.AddRotatedLorentzConeConstraint(x+1, x+y, pow(x, 2) + pow(z, 2) +
    2*z+5);)""";
          // Source: drake/solvers/mathematical_program.h:2053
          const char* doc_1args_v =
R"""(Adds a constraint that a symbolic expression

Parameter ``v``:
    is in the rotated Lorentz cone, i.e.,

.. math:: v_0v_1 \ge v_2^2 + ... + v_{n-1}^2\
v_0 \ge 0, v_1 \ge 0

Parameter ``v``:
    A linear expression of variables, :math:`v = A x + b`, where
    :math:`A, b` are given matrices of the correct size, :math:`x` is
    the vector of decision variables.

Returns ``binding``:
    The newly added rotated Lorentz cone constraint, together with the
    bound variables.

For example, to add the rotated Lorentz cone constraint

(x+1)(x+y) >= x²+z²+2z+5 = x² + (z+1)² + 2² x+1 >= 0 x+y >= 0 The user
could call


::

    {cc}
    Eigen::Matrix<symbolic::Expression, 5, 1> v;
    v << x+1, x+y, x, z+1, 2;
    prog.AddRotatedLorentzConeConstraint(v);)""";
          // Source: drake/solvers/mathematical_program.h:2075
          const char* doc_3args_A_b_vars =
R"""(Adds a rotated Lorentz cone constraint referencing potentially a
subset of decision variables, The linear expression :math:`z=Ax+b` is
in rotated Lorentz cone. A vector :math:`z \in\mathbb{R}^n` is in the
rotated Lorentz cone, if

.. math:: z_0z_1 \ge z_2^2 + ... + z_{n-1}^2

where :math:`A\in\mathbb{R}^{n\times m}, b\in\mathbb{R}^n` are given
matrices.

Parameter ``A``:
    A matrix whose number of columns equals to the size of the
    decision variables.

Parameter ``b``:
    A vector whose number of rows equals to the size fo the decision
    variables.

Parameter ``vars``:
    The decision variables on which the constraint is imposed.)""";
          // Source: drake/solvers/mathematical_program.h:2120
          const char* doc_1args_vars =
R"""(Impose that a vector :math:`x\in\mathbb{R}^m` is in rotated Lorentz
cone. Namely

.. math:: x_0 x_1 \ge x_2^2 + ... + x_{m-1}^2\
x_0 \ge 0, x_1 \ge 0

Parameter ``vars``:
    The stacked column of vars lies in the rotated Lorentz cone.

Returns:
    The newly added rotated Lorentz cone constraint.)""";
        } AddRotatedLorentzConeConstraint;
        // Symbol: drake::solvers::MathematicalProgram::AddScaledDiagonallyDominantMatrixConstraint
        struct /* AddScaledDiagonallyDominantMatrixConstraint */ {
          // Source: drake/solvers/mathematical_program.h:2366
          const char* doc_was_unable_to_choose_unambiguous_names =
R"""(This is an overloaded variant of addsdd "scaled diagonally dominant
matrix constraint"

Parameter ``X``:
    The matrix X to be constrained scaled diagonally dominant. X.

Precondition:
    X(i, j) should be a linear expression of decision variables.

Returns:
    M A vector of vectors of 2 x 2 symmetric matrices M. For i < j,
    M[i][j] is


::

    [Mⁱʲ(i, i), Mⁱʲ(i, j)]
    [Mⁱʲ(i, j), Mⁱʲ(j, j)].

Note that M[i][j](0, 1) = Mⁱʲ(i, j) = (X(i, j) + X(j, i)) / 2 for i >=
j, M[i][j] is the zero matrix.)""";
        } AddScaledDiagonallyDominantMatrixConstraint;
        // Symbol: drake::solvers::MathematicalProgram::AddSosConstraint
        struct /* AddSosConstraint */ {
          // Source: drake/solvers/mathematical_program.h:2392
          const char* doc_2args_p_monomial_basis =
R"""(Adds constraints that a given polynomial ``p`` is a sums-of-squares
(SOS), that is, ``p`` can be decomposed into ``mᵀQm``, where m is the
``monomial_basis``. It returns the coefficients matrix Q, which is
positive semidefinite.

Note:
    It calls ``Reparse`` to enforce ``p`` to have this
    MathematicalProgram's indeterminates if necessary.)""";
          // Source: drake/solvers/mathematical_program.h:2409
          const char* doc_1args_p =
R"""(Adds constraints that a given polynomial ``p`` is a sums-of-squares
(SOS), that is, ``p`` can be decomposed into ``mᵀQm``, where m is a
monomial basis selected from the sparsity of ``p``. It returns a pair
of constraint bindings expressing:

Note:
    It calls ``Reparse`` to enforce ``p`` to have this
    MathematicalProgram's indeterminates if necessary.

- The coefficients matrix Q, which is positive semidefinite. - The
monomial basis m.)""";
          // Source: drake/solvers/mathematical_program.h:2419
          const char* doc_2args_e_monomial_basis =
R"""(Adds constraints that a given symbolic expression ``e`` is a
sums-of-squares (SOS), that is, ``p`` can be decomposed into ``mᵀQm``,
where m is the ``monomial_basis``. Note that it decomposes ``e`` into
a polynomial with respect to ``indeterminates()`` in this mathematical
program. It returns the coefficients matrix Q, which is positive
semidefinite.)""";
          // Source: drake/solvers/mathematical_program.h:2433
          const char* doc_1args_e =
R"""(Adds constraints that a given symbolic expression ``e`` is a
sums-of-squares (SOS), that is, ``e`` can be decomposed into ``mᵀQm``.
Note that it decomposes ``e`` into a polynomial with respect to
``indeterminates()`` in this mathematical program. It returns a pair
expressing:

- The coefficients matrix Q, which is positive semidefinite. - The
monomial basis m.)""";
        } AddSosConstraint;
        // Symbol: drake::solvers::MathematicalProgram::AddVisualizationCallback
        struct /* AddVisualizationCallback */ {
          // Source: drake/solvers/mathematical_program.h:832
          const char* doc =
R"""(Adds a callback method to visualize intermediate results of the
optimization.

Note:
    Just like other costs/constraints, not all solvers support
    callbacks. Adding a callback here will force
    MathematicalProgram::Solve to select a solver that support
    callbacks. For instance, adding a visualization callback to a
    quadratic programming problem may result in using a nonlinear
    programming solver as the default solver.

Parameter ``callback``:
    a std::function that accepts an Eigen::Vector of doubles
    representing the bound decision variables.

Parameter ``vars``:
    the decision variables that should be passed to the callback.)""";
        } AddVisualizationCallback;
        // Symbol: drake::solvers::MathematicalProgram::Clone
        struct /* Clone */ {
          // Source: drake/solvers/mathematical_program.h:170
          const char* doc =
R"""(Clones an optimization program. The clone will be functionally
equivalent to the source program with the same:

- decision variables
- constraints
- costs
- solver settings
- initial guess

However, the clone's x values will be initialized to NaN, and all
internal solvers will be freshly constructed.

Returns ``new_prog``:
    . The newly constructed mathematical program.)""";
        } Clone;
        // Symbol: drake::solvers::MathematicalProgram::EvalBinding
        struct /* EvalBinding */ {
          // Source: drake/solvers/mathematical_program.h:2817
          const char* doc =
R"""(Evaluates the value of some binding, for some input value for all
decision variables.

Parameter ``binding``:
    A Binding whose variables are decision variables in this program.

Parameter ``prog_var_vals``:
    The value of all the decision variables in this program.

Raises:
    RuntimeError if the size of ``prog_var_vals`` is invalid.)""";
        } EvalBinding;
        // Symbol: drake::solvers::MathematicalProgram::EvalBindingAtInitialGuess
        struct /* EvalBindingAtInitialGuess */ {
          // Source: drake/solvers/mathematical_program.h:2933
          const char* doc =
R"""(Evaluates the evaluator in ``binding`` at the initial guess.

Returns:
    The value of ``binding`` at the initial guess.)""";
        } EvalBindingAtInitialGuess;
        // Symbol: drake::solvers::MathematicalProgram::EvalBindings
        struct /* EvalBindings */ {
          // Source: drake/solvers/mathematical_program.h:2849
          const char* doc =
R"""(Evaluates a set of bindings (plural version of ``EvalBinding``).

Parameter ``bindings``:
    List of bindings.

Parameter ``prog``:
    $Parameter ``prog_var_vals``:

The value of all the decision variables in this program.

Returns:
    All binding values, concatenated into a single vector.

Raises:
    RuntimeError if the size of ``prog_var_vals`` is invalid.)""";
        } EvalBindings;
        // Symbol: drake::solvers::MathematicalProgram::EvalVisualizationCallbacks
        struct /* EvalVisualizationCallbacks */ {
          // Source: drake/solvers/mathematical_program.h:2902
          const char* doc =
R"""(Evaluates all visualization callbacks registered with the
MathematicalProgram.

Parameter ``prog_var_vals``:
    The value of all the decision variables in this program.

Raises:
    RuntimeError if the size does not match.)""";
        } EvalVisualizationCallbacks;
        // Symbol: drake::solvers::MathematicalProgram::FindDecisionVariableIndex
        struct /* FindDecisionVariableIndex */ {
          // Source: drake/solvers/mathematical_program.h:2779
          const char* doc =
R"""(Returns the index of the decision variable. Internally the solvers
thinks all variables are stored in an array, and it accesses each
individual variable using its index. This index is used when adding
constraints and costs for each solver.

Precondition:
    {``var`` is a decision variable in the mathematical program,
    otherwise this function throws a runtime error.})""";
        } FindDecisionVariableIndex;
        // Symbol: drake::solvers::MathematicalProgram::FindDecisionVariableIndices
        struct /* FindDecisionVariableIndices */ {
          // Source: drake/solvers/mathematical_program.h:2790
          const char* doc =
R"""(Returns the indices of the decision variables. Internally the solvers
thinks all variables are stored in an array, and it accesses each
individual variable using its index. This index is used when adding
constraints and costs for each solver.

Precondition:
    {``vars`` are decision variables in the mathematical program,
    otherwise this function throws a runtime error.})""";
        } FindDecisionVariableIndices;
        // Symbol: drake::solvers::MathematicalProgram::FindIndeterminateIndex
        struct /* FindIndeterminateIndex */ {
          // Source: drake/solvers/mathematical_program.h:2803
          const char* doc =
R"""(Returns the index of the indeterminate. Internally a solver thinks all
indeterminates are stored in an array, and it accesses each individual
indeterminate using its index. This index is used when adding
constraints and costs for each solver.

Precondition:
    ``var`` is a indeterminate in the mathematical program, otherwise
    this function throws a runtime error.)""";
        } FindIndeterminateIndex;
        // Symbol: drake::solvers::MathematicalProgram::GetAllConstraints
        struct /* GetAllConstraints */ {
          // Source: drake/solvers/mathematical_program.h:2739
          const char* doc =
R"""(Getter for returning all constraints.

Returns:
    Vector of all constraint bindings.

Note:
    The group ordering may change as more constraint types are added.)""";
        } GetAllConstraints;
        // Symbol: drake::solvers::MathematicalProgram::GetAllCosts
        struct /* GetAllCosts */ {
          // Source: drake/solvers/mathematical_program.h:2714
          const char* doc =
R"""(Getter returning all costs.

Returns:
    Vector of all cost bindings.

Note:
    The group ordering may change as more cost types are added.)""";
        } GetAllCosts;
        // Symbol: drake::solvers::MathematicalProgram::GetAllLinearConstraints
        struct /* GetAllLinearConstraints */ {
          // Source: drake/solvers/mathematical_program.h:2727
          const char* doc =
R"""(Getter returning all linear constraints (both linear equality and
inequality constraints).

Returns:
    Vector of all linear constraint bindings.)""";
        } GetAllLinearConstraints;
        // Symbol: drake::solvers::MathematicalProgram::GetBindingVariableValues
        struct /* GetBindingVariableValues */ {
          // Source: drake/solvers/mathematical_program.h:2883
          const char* doc =
R"""(Given the value of all decision variables, namely
this.decision_variable(i) takes the value prog_var_vals(i), returns
the vector that contains the value of the variables in
binding.variables().

Parameter ``binding``:
    binding.variables() must be decision variables in this
    MathematicalProgram.

Parameter ``prog_var_vals``:
    The value of ALL the decision variables in this program.

Returns:
    binding_variable_vals binding_variable_vals(i) is the value of
    binding.variables()(i) in prog_var_vals.)""";
        } GetBindingVariableValues;
        // Symbol: drake::solvers::MathematicalProgram::GetInitialGuess
        struct /* GetInitialGuess */ {
          // Source: drake/solvers/mathematical_program.h:2497
          const char* doc_1args_decision_variable =
R"""(Gets the initial guess for a single variable.

Precondition:
    ``decision_variable`` has been registered in the optimization
    program.

Raises:
    RuntimeError if the pre condition is not satisfied.)""";
          // Source: drake/solvers/mathematical_program.h:2510
          const char* doc_1args_constEigenMatrixBase =
R"""(Gets the initial guess for some variables.

Precondition:
    Each variable in ``decision_variable_mat`` has been registered in
    the optimization program.

Raises:
    RuntimeError if the pre condition is not satisfied.)""";
        } GetInitialGuess;
        // Symbol: drake::solvers::MathematicalProgram::GetSolverOptionsDouble
        struct /* GetSolverOptionsDouble */ {
          // Source: drake/solvers/mathematical_program.h:2619
          const char* doc = R"""()""";
        } GetSolverOptionsDouble;
        // Symbol: drake::solvers::MathematicalProgram::GetSolverOptionsInt
        struct /* GetSolverOptionsInt */ {
          // Source: drake/solvers/mathematical_program.h:2624
          const char* doc = R"""()""";
        } GetSolverOptionsInt;
        // Symbol: drake::solvers::MathematicalProgram::GetSolverOptionsStr
        struct /* GetSolverOptionsStr */ {
          // Source: drake/solvers/mathematical_program.h:2629
          const char* doc = R"""()""";
        } GetSolverOptionsStr;
        // Symbol: drake::solvers::MathematicalProgram::GetVariableScaling
        struct /* GetVariableScaling */ {
          // Source: drake/solvers/mathematical_program.h:3000
          const char* doc =
R"""(Returns the mapping from a decision variable index to its scaling
factor.

See variable_scaling "Variable scaling" for more information.)""";
        } GetVariableScaling;
        // Symbol: drake::solvers::MathematicalProgram::MakeCost
        struct /* MakeCost */ {
          // Source: drake/solvers/mathematical_program.h:893
          const char* doc =
R"""(Convert an input of type ``F`` to a FunctionCost object.

Template parameter ``F``:
    This class should have functions numInputs(), numOutputs and
    eval(x, y).)""";
        } MakeCost;
        // Symbol: drake::solvers::MathematicalProgram::MakePolynomial
        struct /* MakePolynomial */ {
          // Source: drake/solvers/mathematical_program.h:628
          const char* doc =
R"""(Creates a symbolic polynomial from the given expression ``e``. It uses
this MathematicalProgram's ``indeterminates()`` in constructing the
polynomial.

This method helps a user create a polynomial with the right set of
indeterminates which are declared in this MathematicalProgram. We
recommend users to use this method over an explicit call to Polynomial
constructors to avoid a possible mismatch between this
MathematicalProgram's indeterminates and the user-specified
indeterminates (or unspecified, which then includes all symbolic
variables in the expression ``e``). Consider the following example.

e = ax + bx + c

MP.indeterminates() = {x} MP.decision_variables() = {a, b}

- ``MP.MakePolynomial(e)`` create a polynomial, ``(a + b)x + c``.  Here only
  ``x`` is an indeterminate of this polynomial.

- In contrast, ``symbolic::Polynomial(e)`` returns ``ax + bx + c`` where all
  variables ``{a, b, x}`` are indeterminates. Note that this is problematic
  as its indeterminates, ``{a, b, x}`` and the MathematicalProgram's decision
  variables, ``{a, b}`` overlap.

Note:
    This function does not require that the decision variables in
    ``e`` is a subset of the decision variables in
    MathematicalProgram.)""";
        } MakePolynomial;
        // Symbol: drake::solvers::MathematicalProgram::MathematicalProgram
        struct /* ctor */ {
          // Source: drake/solvers/mathematical_program.h:143
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::solvers::MathematicalProgram::NewBinaryVariables
        struct /* NewBinaryVariables */ {
          // Source: drake/solvers/mathematical_program.h:304
          const char* doc_3args =
R"""(Adds binary variables, appending them to an internal vector of any
existing vars. The initial guess values for the new variables are set
to NaN, to indicate that an initial guess has not been assigned.
Callers are expected to add costs and/or constraints to have any
effect during optimization. Callers can also set the initial guess of
the decision variables through SetInitialGuess() or
SetInitialGuessForAllVariables().

Template parameter ``Rows``:
    The number of rows in the new variables.

Template parameter ``Cols``:
    The number of columns in the new variables.

Parameter ``rows``:
    The number of rows in the new variables.

Parameter ``cols``:
    The number of columns in the new variables.

Parameter ``name``:
    The commonly shared name of the new variables.

Returns:
    The MatrixDecisionVariable of size rows x cols, containing the new
    vars (not all the vars stored).

Example:


::

    MathematicalProgram prog;
    auto b = prog.NewBinaryVariables(2, 3, "b");

This adds a 2 x 3 matrix decision variables into the program.

The name of the variable is only used for the user in order to ease
readability.)""";
          // Source: drake/solvers/mathematical_program.h:324
          const char* doc_1args =
R"""(Adds a matrix of binary variables into the optimization program.

Template parameter ``Rows``:
    The number of rows in the newly added binary variables.

Template parameter ``Cols``:
    The number of columns in the new variables. The default is 1.

Parameter ``name``:
    Each newly added binary variable will share the same name. The
    default name is "b".

Returns:
    A matrix containing the newly added variables.)""";
          // Source: drake/solvers/mathematical_program.h:335
          const char* doc_2args =
R"""(Adds binary variables to this MathematicalProgram. The new variables
are viewed as a column vector, with size ``rows`` x 1.

See also:
    NewBinaryVariables(int rows, int cols, const
    std::vector<std::string>& names);)""";
        } NewBinaryVariables;
        // Symbol: drake::solvers::MathematicalProgram::NewContinuousVariables
        struct /* NewContinuousVariables */ {
          // Source: drake/solvers/mathematical_program.h:197
          const char* doc_2args =
R"""(Adds continuous variables, appending them to an internal vector of any
existing vars. The initial guess values for the new variables are set
to NaN, to indicate that an initial guess has not been assigned.
Callers are expected to add costs and/or constraints to have any
effect during optimization. Callers can also set the initial guess of
the decision variables through SetInitialGuess() or
SetInitialGuessForAllVariables().

Parameter ``rows``:
    The number of rows in the new variables.

Parameter ``name``:
    The name of the newly added variables

Returns:
    The VectorDecisionVariable of size rows x 1, containing the new
    vars (not all the vars stored).

Example:


::

    MathematicalProgram prog;
    auto x = prog.NewContinuousVariables(2, "x");

This adds a 2 x 1 vector containing decision variables into the
program. The names of the variables are "x(0)" and "x(1)".

The name of the variable is only used for the user in order to ease
readability.)""";
          // Source: drake/solvers/mathematical_program.h:234
          const char* doc_3args =
R"""(Adds continuous variables, appending them to an internal vector of any
existing vars. The initial guess values for the new variables are set
to NaN, to indicate that an initial guess has not been assigned.
Callers are expected to add costs and/or constraints to have any
effect during optimization. Callers can also set the initial guess of
the decision variables through SetInitialGuess() or
SetInitialGuessForAllVariables().

Template parameter ``Rows``:
    The number of rows of the new variables, in the compile time.

Template parameter ``Cols``:
    The number of columns of the new variables, in the compile time.

Parameter ``rows``:
    The number of rows in the new variables. When Rows is not
    Eigen::Dynamic, rows is ignored.

Parameter ``cols``:
    The number of columns in the new variables. When Cols is not
    Eigen::Dynamic, cols is ignored.

Parameter ``name``:
    All variables will share the same name, but different index.

Returns:
    The MatrixDecisionVariable of size Rows x Cols, containing the new
    vars (not all the vars stored).

Example:


::

    MathematicalProgram prog;
    auto x = prog.NewContinuousVariables(2, 3, "X");
    auto y = prog.NewContinuousVariables<2, 3>(2, 3, "X");

This adds a 2 x 3 matrix decision variables into the program.

The name of the variable is only used for the user in order to ease
readability.)""";
          // Source: drake/solvers/mathematical_program.h:271
          const char* doc_1args =
R"""(Adds continuous variables, appending them to an internal vector of any
existing vars. The initial guess values for the new variables are set
to NaN, to indicate that an initial guess has not been assigned.
Callers are expected to add costs and/or constraints to have any
effect during optimization. Callers can also set the initial guess of
the decision variables through SetInitialGuess() or
SetInitialGuessForAllVariables().

Template parameter ``Rows``:
    The number of rows in the new variables.

Template parameter ``Cols``:
    The number of columns in the new variables. The default is 1.

Parameter ``name``:
    All variables will share the same name, but different index.

Returns:
    The MatrixDecisionVariable of size rows x cols, containing the new
    vars (not all the vars stored).

Example:


::

    MathematicalProgram prog;
    auto x = prog.NewContinuousVariables<2, 3>("X");

This adds a 2 x 3 matrix decision variables into the program.

The name of the variable is only used for the user in order to ease
readability.)""";
        } NewContinuousVariables;
        // Symbol: drake::solvers::MathematicalProgram::NewEvenDegreeDsosPolynomial
        struct /* NewEvenDegreeDsosPolynomial */ {
          // Source: drake/solvers/mathematical_program.h:596
          const char* doc =
R"""(see even_degree_nonnegative_polynomial for details. Variant that
produces a DSOS polynomial. Same as NewEvenDegreeSosPolynomial, except
the returned polynomial is diagonally dominant sum of squares (dsos).)""";
        } NewEvenDegreeDsosPolynomial;
        // Symbol: drake::solvers::MathematicalProgram::NewEvenDegreeFreePolynomial
        struct /* NewEvenDegreeFreePolynomial */ {
          // Source: drake/solvers/mathematical_program.h:424
          const char* doc =
R"""(Returns a free polynomial that only contains even degree monomials. A
monomial is even degree if its total degree (sum of all variables'
degree) is even. For example, xy is an even degree monomial (degree 2)
while x²y is not (degree 3).

Parameter ``indeterminates``:
    The monomial basis is over these indeterminates.

Parameter ``degree``:
    The highest degree of the polynomial.

Parameter ``coeff_name``:
    The coefficients of the polynomial are decision variables with
    this name as a base. The variable name would be "a1", "a2", etc.)""";
        } NewEvenDegreeFreePolynomial;
        // Symbol: drake::solvers::MathematicalProgram::NewEvenDegreeNonnegativePolynomial
        struct /* NewEvenDegreeNonnegativePolynomial */ {
          // Source: drake/solvers/mathematical_program.h:567
          const char* doc =
R"""(See even_degree_nonnegative_polynomial for more details. Variant that
produces different non-negative polynomials depending on ``type``.

Parameter ``type``:
    The returned polynomial p(x) can be either SOS, SDSOS or DSOS,
    depending on ``type``.)""";
        } NewEvenDegreeNonnegativePolynomial;
        // Symbol: drake::solvers::MathematicalProgram::NewEvenDegreeSdsosPolynomial
        struct /* NewEvenDegreeSdsosPolynomial */ {
          // Source: drake/solvers/mathematical_program.h:585
          const char* doc =
R"""(see even_degree_nonnegative_polynomial for details. Variant that
produces an SDSOS polynomial.)""";
        } NewEvenDegreeSdsosPolynomial;
        // Symbol: drake::solvers::MathematicalProgram::NewEvenDegreeSosPolynomial
        struct /* NewEvenDegreeSosPolynomial */ {
          // Source: drake/solvers/mathematical_program.h:576
          const char* doc =
R"""(See even_degree_nonnegative_polynomial for more details. Variant that
produces a SOS polynomial.)""";
        } NewEvenDegreeSosPolynomial;
        // Symbol: drake::solvers::MathematicalProgram::NewFreePolynomial
        struct /* NewFreePolynomial */ {
          // Source: drake/solvers/mathematical_program.h:410
          const char* doc =
R"""(Returns a free polynomial in a monomial basis over ``indeterminates``
of a given ``degree``. It uses ``coeff_name`` to make new decision
variables and use them as coefficients. For example,
``NewFreePolynomial({x₀, x₁}, 2)`` returns a₀x₁² + a₁x₀x₁ + a₂x₀² +
a₃x₁ + a₄x₀ + a₅.)""";
        } NewFreePolynomial;
        // Symbol: drake::solvers::MathematicalProgram::NewIndeterminates
        struct /* NewIndeterminates */ {
          // Source: drake/solvers/mathematical_program.h:767
          const char* doc_2args =
R"""(Adds indeterminates to this MathematicalProgram, with default name
"x".

See also:
    NewIndeterminates(int rows, int cols, const
    std::vector<std::string>& names);)""";
          // Source: drake/solvers/mathematical_program.h:802
          const char* doc_3args =
R"""(Adds indeterminates to this MathematicalProgram, with default name
"X". The new variables are returned and viewed as a matrix, with size
``rows`` x ``cols``.

See also:
    NewIndeterminates(int rows, int cols, const
    std::vector<std::string>& names);)""";
        } NewIndeterminates;
        // Symbol: drake::solvers::MathematicalProgram::NewNonnegativePolynomial
        struct /* NewNonnegativePolynomial */ {
          // Source: drake/solvers/mathematical_program.h:471
          const char* doc_2args_monomial_basis_type =
R"""(Returns a pair of nonnegative polynomial p = mᵀQm and the Grammian
matrix Q, where m is ``monomial_basis``. Adds Q as decision variables
to the program. Depending on the type of the polynomial, we will
impose different constraint on Q. - if type = kSos, we impose Q being
positive semidefinite. - if type = kSdsos, we impose Q being scaled
diagonally dominant. - if type = kDsos, we impose Q being positive
diagonally dominant.

Parameter ``monomial_basis``:
    The monomial basis.

Parameter ``type``:
    The type of the nonnegative polynomial.

Returns:
    (p, Q) The polynomial p and the Grammian matrix Q. Q has been
    added as decision variables to the program.)""";
          // Source: drake/solvers/mathematical_program.h:479
          const char* doc_3args_grammian_monomial_basis_type =
R"""(Overloads NewNonnegativePolynomial(), except the Grammian matrix Q is
an input instead of an output.)""";
          // Source: drake/solvers/mathematical_program.h:499
          const char* doc_3args_indeterminates_degree_type =
R"""(Overloads NewNonnegativePolynomial(). Instead of passing the monomial
basis, we use a monomial basis that contains all monomials of
``indeterminates`` of total order up to ``degree`` / 2, hence the
returned polynomial p contains all the monomials of ``indeterminates``
of total order up to ``degree``.

Parameter ``indeterminates``:
    All the indeterminates in the polynomial p.

Parameter ``degree``:
    The polynomial p will contain all the monomials up to order
    ``degree``.

Parameter ``type``:
    The type of the nonnegative polynomial.

Returns:
    (p, Q) The polynomial p and the Grammian matrix Q. Q has been
    added as decision variables to the program.

Precondition:
    ``degree`` is a positive even number.)""";
        } NewNonnegativePolynomial;
        // Symbol: drake::solvers::MathematicalProgram::NewOddDegreeFreePolynomial
        struct /* NewOddDegreeFreePolynomial */ {
          // Source: drake/solvers/mathematical_program.h:438
          const char* doc =
R"""(Returns a free polynomial that only contains odd degree monomials. A
monomial is odd degree if its total degree (sum of all variables'
degree) is even. For example, xy is not an odd degree monomial (degree
2) while x²y is (degree 3).

Parameter ``indeterminates``:
    The monomial basis is over these indeterminates.

Parameter ``degree``:
    The highest degree of the polynomial.

Parameter ``coeff_name``:
    The coefficients of the polynomial are decision variables with
    this name as a base. The variable name would be "a1", "a2", etc.)""";
        } NewOddDegreeFreePolynomial;
        // Symbol: drake::solvers::MathematicalProgram::NewSosPolynomial
        struct /* NewSosPolynomial */ {
          // Source: drake/solvers/mathematical_program.h:511
          const char* doc_1args =
R"""(Returns a pair of a SOS polynomial p = mᵀQm and the Grammian matrix Q,
where m is the ``monomial`` basis. For example,
``NewSosPolynomial(Vector2<Monomial>{x,y})`` returns a polynomial p =
Q₍₀,₀₎x² + 2Q₍₁,₀₎xy + Q₍₁,₁₎y² and Q.

Note:
    Q is a symmetric monomial_basis.rows() x monomial_basis.rows()
    matrix.)""";
          // Source: drake/solvers/mathematical_program.h:524
          const char* doc_2args =
R"""(Returns a pair of a SOS polynomial p = m(x)ᵀQm(x) of degree ``degree``
and the Grammian matrix Q that should be PSD, where m(x) is the result
of calling ``MonomialBasis(indeterminates, degree/2)``. For example,
``NewSosPolynomial({x}, 4)`` returns a pair of a polynomial p =
Q₍₀,₀₎x⁴ + 2Q₍₁,₀₎ x³ + (2Q₍₂,₀₎ + Q₍₁,₁₎)x² + 2Q₍₂,₁₎x + Q₍₂,₂₎ and
Q.

Raises:
    RuntimeError if ``degree`` is not a positive even integer.

See also:
    MonomialBasis.)""";
        } NewSosPolynomial;
        // Symbol: drake::solvers::MathematicalProgram::NewSymmetricContinuousVariables
        struct /* NewSymmetricContinuousVariables */ {
          // Source: drake/solvers/mathematical_program.h:358
          const char* doc_2args =
R"""(Adds a runtime sized symmetric matrix as decision variables to this
MathematicalProgram. The optimization will only use the stacked
columns of the lower triangular part of the symmetric matrix as
decision variables.

Parameter ``rows``:
    The number of rows in the symmetric matrix.

Parameter ``name``:
    The name of the matrix. It is only used the for user to understand
    the optimization program. The default name is "Symmetric", and
    each variable will be named as


::

    Symmetric(0, 0)     Symmetric(1, 0)     ... Symmetric(rows-1, 0)
    Symmetric(1, 0)     Symmetric(1, 1)     ... Symmetric(rows-1, 1)
               ...
    Symmetric(rows-1,0) Symmetric(rows-1,1) ... Symmetric(rows-1, rows-1)

Notice that the (i,j)'th entry and (j,i)'th entry has the same name.

Returns:
    The newly added decision variables.)""";
          // Source: drake/solvers/mathematical_program.h:380
          const char* doc_1args =
R"""(Adds a static sized symmetric matrix as decision variables to this
MathematicalProgram. The optimization will only use the stacked
columns of the lower triangular part of the symmetric matrix as
decision variables.

Template parameter ``rows``:
    The number of rows in the symmetric matrix.

Parameter ``name``:
    The name of the matrix. It is only used the for user to understand
    the optimization program. The default name is "Symmetric", and
    each variable will be named as


::

    Symmetric(0, 0)     Symmetric(1, 0)     ... Symmetric(rows-1, 0)
    Symmetric(1, 0)     Symmetric(1, 1)     ... Symmetric(rows-1, 1)
               ...
    Symmetric(rows-1,0) Symmetric(rows-1,1) ... Symmetric(rows-1, rows-1)

Notice that the (i,j)'th entry and (j,i)'th entry has the same name.

Returns:
    The newly added decision variables.)""";
        } NewSymmetricContinuousVariables;
        // Symbol: drake::solvers::MathematicalProgram::NonnegativePolynomial
        struct /* NonnegativePolynomial */ {
          // Source: drake/solvers/mathematical_program.h:451
          const char* doc =
R"""(Types of non-negative polynomial that can be found through conic
optimization. We currently support SOS, SDSOS and DSOS. For more
information about these polynomial types, please refer to "DSOS and
SDSOS Optimization: More Tractable Alternatives to Sum of Squares and
Semidefinite Optimization" by Amir Ali Ahmadi and Anirudha Majumdar,
with arXiv link https://arxiv.org/abs/1706.02586)""";
          // Symbol: drake::solvers::MathematicalProgram::NonnegativePolynomial::kDsos
          struct /* kDsos */ {
            // Source: drake/solvers/mathematical_program.h:454
            const char* doc =
R"""(A diagonally dominant sum-of-squares polynomial.)""";
          } kDsos;
          // Symbol: drake::solvers::MathematicalProgram::NonnegativePolynomial::kSdsos
          struct /* kSdsos */ {
            // Source: drake/solvers/mathematical_program.h:453
            const char* doc =
R"""(A scaled-diagonally dominant sum-of-squares polynomial.)""";
          } kSdsos;
          // Symbol: drake::solvers::MathematicalProgram::NonnegativePolynomial::kSos
          struct /* kSos */ {
            // Source: drake/solvers/mathematical_program.h:452
            const char* doc = R"""(A sum-of-squares polynomial.)""";
          } kSos;
        } NonnegativePolynomial;
        // Symbol: drake::solvers::MathematicalProgram::Reparse
        struct /* Reparse */ {
          // Source: drake/solvers/mathematical_program.h:635
          const char* doc =
R"""(Reparses the polynomial ``p`` using this MathematicalProgram's
indeterminates.)""";
        } Reparse;
        // Symbol: drake::solvers::MathematicalProgram::SetDecisionVariableValueInVector
        struct /* SetDecisionVariableValueInVector */ {
          // Source: drake/solvers/mathematical_program.h:2571
          const char* doc_3args_decision_variable_decision_variable_new_value_values =
R"""(Updates the value of a single ``decision_variable`` inside the
``values`` vector to be ``decision_variable_new_value``. The other
decision variables' values in ``values`` are unchanged.

Parameter ``decision_variable``:
    a registered decision variable in this program.

Parameter ``decision_variable_new_value``:
    the variable's new values.

Parameter ``values``:
    The vector to be tweaked; must be of size num_vars().)""";
          // Source: drake/solvers/mathematical_program.h:2585
          const char* doc_3args_decision_variables_decision_variables_new_values_values =
R"""(Updates the values of some ``decision_variables`` inside the
``values`` vector to be ``decision_variables_new_values``. The other
decision variables' values in ``values`` are unchanged.

Parameter ``decision_variables``:
    registered decision variables in this program.

Parameter ``decision_variables_new_values``:
    the variables' respective new values; must have the same rows()
    and cols() sizes and ``decision_variables``.

Parameter ``values``:
    The vector to be tweaked; must be of size num_vars().)""";
        } SetDecisionVariableValueInVector;
        // Symbol: drake::solvers::MathematicalProgram::SetInitialGuess
        struct /* SetInitialGuess */ {
          // Source: drake/solvers/mathematical_program.h:2531
          const char* doc_2args_decision_variable_variable_guess_value =
R"""(Sets the initial guess for a single variable ``decision_variable``.
The guess is stored as part of this program.

Precondition:
    decision_variable is a registered decision variable in the
    program.

Raises:
    RuntimeError if precondition is not satisfied.)""";
          // Source: drake/solvers/mathematical_program.h:2540
          const char* doc_2args_constEigenMatrixBase_constEigenMatrixBase =
R"""(Sets the initial guess for the decision variables stored in
``decision_variable_mat`` to be ``x0``. The guess is stored as part of
this program.)""";
        } SetInitialGuess;
        // Symbol: drake::solvers::MathematicalProgram::SetInitialGuessForAllVariables
        struct /* SetInitialGuessForAllVariables */ {
          // Source: drake/solvers/mathematical_program.h:2558
          const char* doc =
R"""(Set the initial guess for ALL decision variables. Note that variables
begin with a default initial guess of NaN to indicate that no guess is
available.

Parameter ``x0``:
    A vector of appropriate size (num_vars() x 1).)""";
        } SetInitialGuessForAllVariables;
        // Symbol: drake::solvers::MathematicalProgram::SetSolverOption
        struct /* SetSolverOption */ {
          // Source: drake/solvers/mathematical_program.h:2590
          const char* doc = R"""()""";
        } SetSolverOption;
        // Symbol: drake::solvers::MathematicalProgram::SetSolverOptions
        struct /* SetSolverOptions */ {
          // Source: drake/solvers/mathematical_program.h:2610
          const char* doc =
R"""(Overwrite the stored solver options inside MathematicalProgram with
the provided solver options.)""";
        } SetSolverOptions;
        // Symbol: drake::solvers::MathematicalProgram::SetVariableScaling
        struct /* SetVariableScaling */ {
          // Source: drake/solvers/mathematical_program.h:3012
          const char* doc =
R"""(Setter for the scaling of decision variables starting from index
``idx_start`` to ``idx_end`` (including ``idx_end)``.

Parameter ``var``:
    the decision variable to be scaled.

Parameter ``s``:
    scaling factor (must be positive).

See variable_scaling "Variable scaling" for more information.)""";
        } SetVariableScaling;
        // Symbol: drake::solvers::MathematicalProgram::VarType
        struct /* VarType */ {
          // Source: drake/solvers/mathematical_program.h:144
          const char* doc = R"""()""";
        } VarType;
        // Symbol: drake::solvers::MathematicalProgram::bounding_box_constraints
        struct /* bounding_box_constraints */ {
          // Source: drake/solvers/mathematical_program.h:2755
          const char* doc = R"""(Getter for all bounding box constraints)""";
        } bounding_box_constraints;
        // Symbol: drake::solvers::MathematicalProgram::decision_variable
        struct /* decision_variable */ {
          // Source: drake/solvers/mathematical_program.h:2943
          const char* doc =
R"""(Getter for the decision variable with index ``i`` in the program.)""";
        } decision_variable;
        // Symbol: drake::solvers::MathematicalProgram::decision_variable_index
        struct /* decision_variable_index */ {
          // Source: drake/solvers/mathematical_program.h:2966
          const char* doc =
R"""(Returns the mapping from a decision variable ID to its index in the
vector containing all the decision variables in the mathematical
program.)""";
        } decision_variable_index;
        // Symbol: drake::solvers::MathematicalProgram::decision_variables
        struct /* decision_variables */ {
          // Source: drake/solvers/mathematical_program.h:2938
          const char* doc =
R"""(Getter for all decision variables in the program.)""";
        } decision_variables;
        // Symbol: drake::solvers::MathematicalProgram::exponential_cone_constraints
        struct /* exponential_cone_constraints */ {
          // Source: drake/solvers/mathematical_program.h:2705
          const char* doc =
R"""(Getter for exponential cone constraints.)""";
        } exponential_cone_constraints;
        // Symbol: drake::solvers::MathematicalProgram::generic_constraints
        struct /* generic_constraints */ {
          // Source: drake/solvers/mathematical_program.h:2652
          const char* doc = R"""(Getter for all generic constraints)""";
        } generic_constraints;
        // Symbol: drake::solvers::MathematicalProgram::generic_costs
        struct /* generic_costs */ {
          // Source: drake/solvers/mathematical_program.h:2645
          const char* doc = R"""(Getter for all generic costs.)""";
        } generic_costs;
        // Symbol: drake::solvers::MathematicalProgram::indeterminate
        struct /* indeterminate */ {
          // Source: drake/solvers/mathematical_program.h:2951
          const char* doc =
R"""(Getter for the indeterminate with index ``i`` in the program.)""";
        } indeterminate;
        // Symbol: drake::solvers::MathematicalProgram::indeterminates
        struct /* indeterminates */ {
          // Source: drake/solvers/mathematical_program.h:2948
          const char* doc =
R"""(Getter for all indeterminates in the program.)""";
        } indeterminates;
        // Symbol: drake::solvers::MathematicalProgram::indeterminates_index
        struct /* indeterminates_index */ {
          // Source: drake/solvers/mathematical_program.h:2974
          const char* doc =
R"""(Returns the mapping from an indeterminate ID to its index in the
vector containing all the indeterminates in the mathematical program.)""";
        } indeterminates_index;
        // Symbol: drake::solvers::MathematicalProgram::initial_guess
        struct /* initial_guess */ {
          // Source: drake/solvers/mathematical_program.h:2770
          const char* doc = R"""(Getter for the initial guess)""";
        } initial_guess;
        // Symbol: drake::solvers::MathematicalProgram::linear_complementarity_constraints
        struct /* linear_complementarity_constraints */ {
          // Source: drake/solvers/mathematical_program.h:2762
          const char* doc =
R"""(Getter for all linear complementarity constraints.)""";
        } linear_complementarity_constraints;
        // Symbol: drake::solvers::MathematicalProgram::linear_constraints
        struct /* linear_constraints */ {
          // Source: drake/solvers/mathematical_program.h:2675
          const char* doc = R"""(Getter for linear constraints.)""";
        } linear_constraints;
        // Symbol: drake::solvers::MathematicalProgram::linear_costs
        struct /* linear_costs */ {
          // Source: drake/solvers/mathematical_program.h:2665
          const char* doc = R"""(Getter for linear costs.)""";
        } linear_costs;
        // Symbol: drake::solvers::MathematicalProgram::linear_equality_constraints
        struct /* linear_equality_constraints */ {
          // Source: drake/solvers/mathematical_program.h:2660
          const char* doc = R"""(Getter for linear equality constraints.)""";
        } linear_equality_constraints;
        // Symbol: drake::solvers::MathematicalProgram::linear_matrix_inequality_constraints
        struct /* linear_matrix_inequality_constraints */ {
          // Source: drake/solvers/mathematical_program.h:2699
          const char* doc =
R"""(Getter for linear matrix inequality constraints.)""";
        } linear_matrix_inequality_constraints;
        // Symbol: drake::solvers::MathematicalProgram::lorentz_cone_constraints
        struct /* lorentz_cone_constraints */ {
          // Source: drake/solvers/mathematical_program.h:2680
          const char* doc = R"""(Getter for Lorentz cone constraints.)""";
        } lorentz_cone_constraints;
        // Symbol: drake::solvers::MathematicalProgram::num_indeterminates
        struct /* num_indeterminates */ {
          // Source: drake/solvers/mathematical_program.h:2794
          const char* doc =
R"""(Gets the number of indeterminates in the optimization program)""";
        } num_indeterminates;
        // Symbol: drake::solvers::MathematicalProgram::num_vars
        struct /* num_vars */ {
          // Source: drake/solvers/mathematical_program.h:2767
          const char* doc =
R"""(Getter for number of variables in the optimization program)""";
        } num_vars;
        // Symbol: drake::solvers::MathematicalProgram::positive_semidefinite_constraints
        struct /* positive_semidefinite_constraints */ {
          // Source: drake/solvers/mathematical_program.h:2693
          const char* doc =
R"""(Getter for positive semidefinite constraints.)""";
        } positive_semidefinite_constraints;
        // Symbol: drake::solvers::MathematicalProgram::quadratic_costs
        struct /* quadratic_costs */ {
          // Source: drake/solvers/mathematical_program.h:2670
          const char* doc = R"""(Getter for quadratic costs.)""";
        } quadratic_costs;
        // Symbol: drake::solvers::MathematicalProgram::required_capabilities
        struct /* required_capabilities */ {
          // Source: drake/solvers/mathematical_program.h:2957
          const char* doc =
R"""(Getter for the required capability on the solver, given the
cost/constraint/variable types in the program.)""";
        } required_capabilities;
        // Symbol: drake::solvers::MathematicalProgram::rotated_lorentz_cone_constraints
        struct /* rotated_lorentz_cone_constraints */ {
          // Source: drake/solvers/mathematical_program.h:2687
          const char* doc =
R"""(Getter for rotated Lorentz cone constraints.)""";
        } rotated_lorentz_cone_constraints;
        // Symbol: drake::solvers::MathematicalProgram::solver_options
        struct /* solver_options */ {
          // Source: drake/solvers/mathematical_program.h:2617
          const char* doc =
R"""(Returns the solver options stored inside MathematicalProgram.)""";
        } solver_options;
        // Symbol: drake::solvers::MathematicalProgram::visualization_callbacks
        struct /* visualization_callbacks */ {
          // Source: drake/solvers/mathematical_program.h:2637
          const char* doc = R"""(Getter for all callbacks.)""";
        } visualization_callbacks;
      } MathematicalProgram;
      // Symbol: drake::solvers::MathematicalProgramResult
      struct /* MathematicalProgramResult */ {
        // Source: drake/solvers/mathematical_program_result.h:75
        const char* doc =
R"""(The result returned by MathematicalProgram::Solve(). It stores the
solvers::SolutionResult (whether the program is solved to optimality,
detected infeasibility, etc), the optimal value for the decision
variables, the optimal cost, and solver specific details.)""";
        // Symbol: drake::solvers::MathematicalProgramResult::AddSuboptimalSolution
        struct /* AddSuboptimalSolution */ {
          // Source: drake/solvers/mathematical_program_result.h:438
          const char* doc =
R"""(Adds the suboptimal solution to the result. See solution_pools
"solution pools".

Parameter ``suboptimal_objective``:
    The objective value computed from this suboptimal solution.

Parameter ``suboptimal_x``:
    The values of the decision variables in this suboptimal solution.)""";
        } AddSuboptimalSolution;
        // Symbol: drake::solvers::MathematicalProgramResult::EvalBinding
        struct /* EvalBinding */ {
          // Source: drake/solvers/mathematical_program_result.h:359
          const char* doc =
R"""(Evaluate a Binding at the solution.

Parameter ``binding``:
    A binding between a constraint/cost and the variables.

Precondition:
    The binding.variables() must be the within the decision variables
    in the MathematicalProgram that generated this
    MathematicalProgramResult.

Precondition:
    The user must have called set_decision_variable_index() function.)""";
        } EvalBinding;
        // Symbol: drake::solvers::MathematicalProgramResult::GetDualSolution
        struct /* GetDualSolution */ {
          // Source: drake/solvers/mathematical_program_result.h:319
          const char* doc =
R"""(Gets the dual solution associated with a constraint.

For constraints in the form lower <= f(x) <= upper (including linear
inequality, linear equality, bounding box constraints, and general
nonlinear constraints), we interpret the dual variable value as the
"shadow price" of the original problem. Namely if we change the
constraint bound by one unit (each unit is infinitesimally small), the
change of the optimal cost is the value of the dual solution times the
unit. Mathematically dual_solution = ∂optimal_cost / ∂bound.

For a linear equality constraint Ax = b where b ∈ ℝⁿ, the vector of
dual variables has n rows, and dual_solution(i) is the value of the
dual variable for the constraint A(i,:)*x = b(i).

For a linear inequality constraint lower <= A*x <= upper where lower
and upper ∈ ℝⁿ, dual_solution also has n rows. dual_solution(i) is the
value of the dual variable for constraint lower(i) <= A(i,:)*x <=
upper(i). If neither side of the constraint is active, then
dual_solution(i) is 0. If the left hand-side lower(i) <= A(i, :)*x is
active (meaning lower(i) = A(i, :)*x at the solution), then
dual_solution(i) is non-negative (because the objective is to minimize
a cost, increasing the lower bound means the constraint set is
tighter, hence the optimal solution cannot decrease. Thus the shadow
price is non-negative). If the right hand-side A(i, :)*x<=upper(i) is
active (meaning A(i,:)*x=upper(i) at the solution), then
dual_solution(i) is non-positive.

For a bounding box constraint lower <= x <= upper, the interpretation
of the dual solution is the same as the linear inequality constraint.

For a Lorentz cone or rotated Lorentz cone constraint that Ax + b is
in the cone, depending on the solver, the dual solution has different
meanings: 1. If the solver is Gurobi, then the user can only obtain
the dual solution by explicitly setting the options for computing dual
solution.


::

    auto constraint = prog.AddLorentzConeConstraint(...);
       GurobiSolver solver;
       // Explicitly tell the solver to compute the dual solution for Lorentz
       // cone or rotated Lorentz cone constraint, check
       // https://www.gurobi.com/documentation/9.0/refman/qcpdual.html for
       // more information.
       SolverOptions options;
       options.SetOption(GurobiSolver::id(), "QCPDual", 1);
       MathematicalProgramResult result = solver.Solve(prog, {}, options);
       Eigen::VectorXd dual_solution = result.GetDualSolution(constraint);

The dual solution has size 1, dual_solution(0) is the shadow price for
the constraint z₁² + ... +zₙ² ≤ z₀² for Lorentz cone constraint, and
the shadow price for the constraint z₂² + ... +zₙ² ≤ z₀z₁ for rotated
Lorentz cone constraint, where z is the slack variable representing z
= A*x+b and z in the Lorentz cone/rotated Lorentz cone. 2. For
nonlinear solvers like IPOPT, the dual solution for Lorentz cone
constraint (with EvalType::kConvex) is the shadow price for z₀ -
sqrt(z₁² + ... +zₙ²) ≥ 0, where z = Ax+b. 3. For other convex conic
solver such as SCS, Mosek, CSDP, etc, the dual solution to the
(rotated) Lorentz cone constraint doesn't have the "shadow price"
interpretation, but should lie in the dual cone, and satisfy the KKT
condition. For more information, refer to
https://docs.mosek.com/9.2/capi/prob-def-conic.html#duality-for-conic-optimization
as an explanation.

The interpretation for the dual variable to conic constraint x ∈ K can
be different. Here K is a convex cone, including exponential cone,
power cone, PSD cone, etc. When the problem is solved by a convex
solver (like SCS, Mosek, CSDP, etc), often it has a dual variable z ∈
K*, where K* is the dual cone. Here the dual variable DOESN'T have the
interpretation of "shadow price", but should satisfy the KKT
condition, while the dual variable stays inside the dual cone.)""";
        } GetDualSolution;
        // Symbol: drake::solvers::MathematicalProgramResult::GetInfeasibleConstraintNames
        struct /* GetInfeasibleConstraintNames */ {
          // Source: drake/solvers/mathematical_program_result.h:470
          const char* doc =
R"""(See get_infeasible_constraints for more information.

Parameter ``prog``:
    The MathematicalProgram that was solved to obtain ``this``
    MathematicalProgramResult.

Parameter ``tolerance``:
    A positive tolerance to check the constraint violation. If no
    tolerance is provided, this method will attempt to obtain the
    constraint tolerance from the solver, or insert a conservative
    default tolerance.

Note: Currently most constraints have the empty string as the
description, so the NiceTypeName of the Constraint is used instead.
Use e.g. ``prog.AddConstraint(x ==
1).evaluator().set_description(str)`` to make this method more
specific/useful.)""";
        } GetInfeasibleConstraintNames;
        // Symbol: drake::solvers::MathematicalProgramResult::GetInfeasibleConstraints
        struct /* GetInfeasibleConstraints */ {
          // Source: drake/solvers/mathematical_program_result.h:486
          const char* doc =
R"""(See get_infeasible_constraints for more information.

Parameter ``prog``:
    The MathematicalProgram that was solved to obtain ``this``
    MathematicalProgramResult.

Parameter ``tolerance``:
    A positive tolerance to check the constraint violation. If no
    tolerance is provided, this method will attempt to obtain the
    constraint tolerance from the solver, or insert a conservative
    default tolerance.

Returns:
    infeasible_bindings A vector of all infeasible bindings
    (constraints together with the associated variables) at the
    best-effort solution.)""";
        } GetInfeasibleConstraints;
        // Symbol: drake::solvers::MathematicalProgramResult::GetSolution
        struct /* GetSolution */ {
          // Source: drake/solvers/mathematical_program_result.h:176
          const char* doc_0args =
R"""(Gets the solution of all decision variables.)""";
          // Source: drake/solvers/mathematical_program_result.h:189
          const char* doc_1args_constEigenMatrixBase =
R"""(Gets the solution of an Eigen matrix of decision variables.

Template parameter ``Derived``:
    An Eigen matrix containing Variable.

Parameter ``var``:
    The decision variables.

Returns:
    The value of the decision variable after solving the problem.)""";
          // Source: drake/solvers/mathematical_program_result.h:201
          const char* doc_1args_var =
R"""(Gets the solution of a single decision variable.

Parameter ``var``:
    The decision variable.

Returns:
    The value of the decision variable after solving the problem.

Raises:
    invalid_argument if ``var`` is not captured in the mapping
    ``decision_variable_index``, as the input argument of
    set_decision_variable_index().)""";
          // Source: drake/solvers/mathematical_program_result.h:208
          const char* doc_1args_e =
R"""(Substitutes the value of all decision variables into the Expression.

Parameter ``e``:
    The decision variable.

Returns:
    the Expression that is the result of the substitution.)""";
          // Source: drake/solvers/mathematical_program_result.h:218
          const char* doc_1args_p =
R"""(Substitutes the value of all decision variables into the coefficients
of the symbolic polynomial.

Parameter ``p``:
    A symbolic polynomial. Its indeterminates can't intersect with the
    set of decision variables of the MathematicalProgram from which
    this result is obtained.

Returns:
    the symbolic::Polynomial as the result of the substitution.)""";
        } GetSolution;
        // Symbol: drake::solvers::MathematicalProgramResult::GetSuboptimalSolution
        struct /* GetSuboptimalSolution */ {
          // Source: drake/solvers/mathematical_program_result.h:393
          const char* doc_2args_constEigenMatrixBase_int =
R"""(@name Solution Pools Some solvers (like Gurobi, Cplex, etc) can store
a pool of (suboptimal) solutions for mixed integer programming model.
Gets the suboptimal solution corresponding to a matrix of decision
variables. See solution_pools "solution pools"

Parameter ``var``:
    The decision variables.

Parameter ``solution_number``:
    The index of the sub-optimal solution.

Precondition:
    ``solution_number`` should be in the range [0,
    num_suboptimal_solution()).

Returns:
    The suboptimal values of the decision variables after solving the
    problem.)""";
          // Source: drake/solvers/mathematical_program_result.h:409
          const char* doc_2args_var_solution_number =
R"""(Gets the suboptimal solution of a decision variable. See
solution_pools "solution pools"

Parameter ``var``:
    The decision variable.

Parameter ``solution_number``:
    The index of the sub-optimal solution.

Precondition:
    ``solution_number`` should be in the range [0,
    num_suboptimal_solution()).

Returns:
    The suboptimal value of the decision variable after solving the
    problem.)""";
        } GetSuboptimalSolution;
        // Symbol: drake::solvers::MathematicalProgramResult::MathematicalProgramResult
        struct /* ctor */ {
          // Source: drake/solvers/mathematical_program_result.h:83
          const char* doc =
R"""(Constructs the result.

Note:
    The solver_details is set to nullptr.)""";
        } ctor;
        // Symbol: drake::solvers::MathematicalProgramResult::SetSolverDetailsType
        struct /* SetSolverDetailsType */ {
          // Source: drake/solvers/mathematical_program_result.h:164
          const char* doc =
R"""((Advanced.) Forces the solver_details to be stored using the given
type ``T``. Typically, only an implementation of SolverInterface will
call this method. If the storage was already typed as T, this is a
no-op. If there were not any solver_details previously, or if it was
of a different type, initializes the storage to a default-constructed
T. Returns a reference to the mutable solver_details object. The
reference remains valid until the next call to this method, or until
this MathematicalProgramResult is destroyed.)""";
        } SetSolverDetailsType;
        // Symbol: drake::solvers::MathematicalProgramResult::get_abstract_solver_details
        struct /* get_abstract_solver_details */ {
          // Source: drake/solvers/mathematical_program_result.h:152
          const char* doc =
R"""((Advanced.) Gets the type-erased solver details. Most users should use
get_solver_details() instead. Throws an error if the solver_details
has not been set.)""";
        } get_abstract_solver_details;
        // Symbol: drake::solvers::MathematicalProgramResult::get_optimal_cost
        struct /* get_optimal_cost */ {
          // Source: drake/solvers/mathematical_program_result.h:130
          const char* doc = R"""(Gets the optimal cost.)""";
        } get_optimal_cost;
        // Symbol: drake::solvers::MathematicalProgramResult::get_solution_result
        struct /* get_solution_result */ {
          // Source: drake/solvers/mathematical_program_result.h:114
          const char* doc = R"""(Gets SolutionResult.)""";
        } get_solution_result;
        // Symbol: drake::solvers::MathematicalProgramResult::get_solver_details
        struct /* get_solver_details */ {
          // Source: drake/solvers/mathematical_program_result.h:144
          const char* doc =
R"""(Gets the solver details for the ``Solver`` that solved the program.
Throws an error if the solver_details has not been set.)""";
        } get_solver_details;
        // Symbol: drake::solvers::MathematicalProgramResult::get_solver_id
        struct /* get_solver_id */ {
          // Source: drake/solvers/mathematical_program_result.h:136
          const char* doc = R"""(Gets the solver ID.)""";
        } get_solver_id;
        // Symbol: drake::solvers::MathematicalProgramResult::get_suboptimal_objective
        struct /* get_suboptimal_objective */ {
          // Source: drake/solvers/mathematical_program_result.h:426
          const char* doc =
R"""(Gets the suboptimal objective value. See solution_pools "solution
pools".

Parameter ``solution_number``:
    The index of the sub-optimal solution.

Precondition:
    ``solution_number`` should be in the range [0,
    num_suboptimal_solution()).)""";
        } get_suboptimal_objective;
        // Symbol: drake::solvers::MathematicalProgramResult::get_x_val
        struct /* get_x_val */ {
          // Source: drake/solvers/mathematical_program_result.h:111
          const char* doc = R"""(Gets the decision variable values.)""";
        } get_x_val;
        // Symbol: drake::solvers::MathematicalProgramResult::is_success
        struct /* is_success */ {
          // Source: drake/solvers/mathematical_program_result.h:90
          const char* doc =
R"""(Returns true if the optimization problem is solved successfully; false
otherwise. For more information on the solution status, the user could
call get_solver_details() to obtain the solver-specific solution
status.)""";
        } is_success;
        // Symbol: drake::solvers::MathematicalProgramResult::num_suboptimal_solution
        struct /* num_suboptimal_solution */ {
          // Source: drake/solvers/mathematical_program_result.h:416
          const char* doc =
R"""(Number of suboptimal solutions stored inside
MathematicalProgramResult. See solution_pools "solution pools".)""";
        } num_suboptimal_solution;
        // Symbol: drake::solvers::MathematicalProgramResult::set_decision_variable_index
        struct /* set_decision_variable_index */ {
          // Source: drake/solvers/mathematical_program_result.h:97
          const char* doc =
R"""(Sets decision_variable_index mapping, that maps each decision variable
to its index in the aggregated vector containing all decision
variables in MathematicalProgram. Initialize x_val to NAN.)""";
        } set_decision_variable_index;
        // Symbol: drake::solvers::MathematicalProgramResult::set_dual_solution
        struct /* set_dual_solution */ {
          // Source: drake/solvers/mathematical_program_result.h:121
          const char* doc =
R"""(Sets the dual solution associated with a given constraint.)""";
        } set_dual_solution;
        // Symbol: drake::solvers::MathematicalProgramResult::set_optimal_cost
        struct /* set_optimal_cost */ {
          // Source: drake/solvers/mathematical_program_result.h:133
          const char* doc = R"""(Sets the optimal cost.)""";
        } set_optimal_cost;
        // Symbol: drake::solvers::MathematicalProgramResult::set_solution_result
        struct /* set_solution_result */ {
          // Source: drake/solvers/mathematical_program_result.h:106
          const char* doc = R"""(Sets SolutionResult.)""";
        } set_solution_result;
        // Symbol: drake::solvers::MathematicalProgramResult::set_solver_id
        struct /* set_solver_id */ {
          // Source: drake/solvers/mathematical_program_result.h:139
          const char* doc = R"""(Sets the solver ID.)""";
        } set_solver_id;
        // Symbol: drake::solvers::MathematicalProgramResult::set_x_val
        struct /* set_x_val */ {
          // Source: drake/solvers/mathematical_program_result.h:117
          const char* doc = R"""(Sets the decision variable values.)""";
        } set_x_val;
      } MathematicalProgramResult;
      // Symbol: drake::solvers::MatrixXDecisionVariable
      struct /* MatrixXDecisionVariable */ {
        // Source: drake/solvers/decision_variable.h:18
        const char* doc = R"""()""";
      } MatrixXDecisionVariable;
      // Symbol: drake::solvers::MatrixXIndeterminate
      struct /* MatrixXIndeterminate */ {
        // Source: drake/solvers/indeterminate.h:35
        const char* doc =
R"""(MatrixXIndeterminate is used as an alias for
Eigen::Matrix<symbolic::Variable, Eigen::Dynamic, Eigen::Dynamic>.

See also:
    MatrixIndeterminate<int, int>)""";
      } MatrixXIndeterminate;
      // Symbol: drake::solvers::MinimumValueConstraint
      struct /* MinimumValueConstraint */ {
        // Source: drake/solvers/minimum_value_constraint.h:69
        const char* doc =
R"""(Constrain all elements of the vector returned by the user-provided
function to be no smaller than a specified minimum value.

The formulation of the constraint is

SmoothMax( φ((vᵢ - v_influence)/(v_influence - vₘᵢₙ)) / φ(-1) ) ≤ 1

where vᵢ is the i-th value returned by the user-provided function,
vₘᵢₙ is the minimum allowable value, v_influence is the "influence
value" (the value below which an element influences the constraint or,
conversely, the value above which an element is ignored), φ is a
solvers::MinimumValuePenaltyFunction, and SmoothMax(v) is a smooth,
conservative approximation of max(v) (i.e. SmoothMax(v) >= max(v), for
all v). We require that vₘᵢₙ < v_influence. The input scaling (vᵢ -
v_influence)/(v_influence - vₘᵢₙ) ensures that at the boundary of the
feasible set (when vᵢ == vₘᵢₙ), we evaluate the penalty function at
-1, where it is required to have a non-zero gradient. The
user-provided function may return a vector with up to
``max_num_values`` elements. If it returns a vector with fewer than
``max_num_values`` elements, the remaining elements are assumed to be
greater than the "influence value".)""";
        // Symbol: drake::solvers::MinimumValueConstraint::MinimumValueConstraint
        struct /* ctor */ {
          // Source: drake/solvers/minimum_value_constraint.h:99
          const char* doc =
R"""(Constructs a MinimumValueConstraint.

Parameter ``num_vars``:
    The number of inputs to ``value_function``

Parameter ``minimum_value``:
    The minimum allowed value, vₘᵢₙ, for all elements of the vector
    returned by ``value_function``.

Parameter ``influence_value_offset``:
    The difference between the influence value, v_influence, and the
    minimum value, vₘᵢₙ (see class documentation). This value must be
    finite and strictly positive, as it is used to scale the values
    returned by ``value_function``. Smaller values may decrease the
    amount of computation required for each constraint evaluation if
    ``value_function`` can quickly determine that some elements will
    be larger than the influence value and skip the computation
    associated with those elements. $*Default:* 1

Parameter ``max_num_values``:
    The maximum number of elements in the vector returned by
    ``value_function``.

Parameter ``value_function``:
    User-provided function that takes a ``num_vars``-element vector
    and the influence distance as inputs and returns a vector with up
    to ``max_num_values`` elements. The function can omit from the
    return vector any elements larger than the provided influence
    distance.

Parameter ``value_function_double``:
    Optional user-provide function that computes the same values as
    ``value_function`` but for double rather than AutoDiffXd. If
    omitted, ``value_function`` will be called (and the gradients
    discarded) when this constraint is evaluated for doubles.

Precondition:
    ``value_function_double(math::autoDiffToValueMatrix(x),
    v_influence) == math::autoDiffToValueMatrix(value_function(x,
    v_influence))`` for all x.

Precondition:
    ``value_function(x).size() <= max_num_values`` for all x.

Raises:
    ValueError if influence_value_offset = ∞.

Raises:
    ValueError if influence_value_offset ≤ 0.)""";
        } ctor;
        // Symbol: drake::solvers::MinimumValueConstraint::influence_value
        struct /* influence_value */ {
          // Source: drake/solvers/minimum_value_constraint.h:115
          const char* doc = R"""(Getter for the influence value.)""";
        } influence_value;
        // Symbol: drake::solvers::MinimumValueConstraint::max_num_values
        struct /* max_num_values */ {
          // Source: drake/solvers/minimum_value_constraint.h:118
          const char* doc =
R"""(Getter for maximum number of values expected from value_function.)""";
        } max_num_values;
        // Symbol: drake::solvers::MinimumValueConstraint::minimum_value
        struct /* minimum_value */ {
          // Source: drake/solvers/minimum_value_constraint.h:112
          const char* doc = R"""(Getter for the minimum value.)""";
        } minimum_value;
        // Symbol: drake::solvers::MinimumValueConstraint::set_penalty_function
        struct /* set_penalty_function */ {
          // Source: drake/solvers/minimum_value_constraint.h:121
          const char* doc = R"""(Setter for the penalty function.)""";
        } set_penalty_function;
      } MinimumValueConstraint;
      // Symbol: drake::solvers::MinimumValuePenaltyFunction
      struct /* MinimumValuePenaltyFunction */ {
        // Source: drake/solvers/minimum_value_constraint.h:18
        const char* doc =
R"""(Computes the penalty function φ(x) and its derivatives dφ(x)/dx. Valid
penalty functions must meet the following criteria:

1.     φ(x) ≥ 0 ∀ x ∈ ℝ.
2. dφ(x)/dx ≤ 0 ∀ x ∈ ℝ.
3.     φ(x) = 0 ∀ x ≥ 0.
4. dφ(x)/dx < 0 ∀ x < 0.

If ``dpenalty_dx`` is nullptr, the function should only compute φ(x).)""";
      } MinimumValuePenaltyFunction;
      // Symbol: drake::solvers::MixedIntegerBranchAndBound
      struct /* MixedIntegerBranchAndBound */ {
        // Source: drake/solvers/branch_and_bound.h:256
        const char* doc =
R"""(Given a mixed-integer optimization problem (MIP) (or more accurately,
mixed binary problem), solve this problem through branch-and-bound
process. We will first replace all the binary variables with
continuous variables, and relax the integral constraint on the binary
variables z ∈ {0, 1} with continuous constraints 0 ≤ z ≤ 1. In the
subsequent steps, at each node of the tree, we will fix some binary
variables to either 0 or 1, and solve the rest of the variables.
Notice that we will create a new set of variables in the
branch-and-bound process, since we need to replace the binary
variables with continuous variables.)""";
        // Symbol: drake::solvers::MixedIntegerBranchAndBound::GetNewVariable
        struct /* GetNewVariable */ {
          // Source: drake/solvers/branch_and_bound.h:374
          const char* doc =
R"""(Given an old variable in the original mixed-integer program, return
the corresponding new variable in the branch-and-bound process.

Parameter ``old_variable``:
    A variable in the original mixed-integer program.

Returns ``new_variable``:
    The corresponding variable in the branch-and-bound procedure.

Precondition:
    old_variable is a variable in the mixed-integer program, passed in
    the constructor of this MixedIntegerBranchAndBound.

Raises:
    RuntimeError if the pre-condition fails.)""";
        } GetNewVariable;
        // Symbol: drake::solvers::MixedIntegerBranchAndBound::GetNewVariables
        struct /* GetNewVariables */ {
          // Source: drake/solvers/branch_and_bound.h:390
          const char* doc =
R"""(Given a matrix of old variables in the original mixed-integer program,
return a matrix of corresponding new variables in the branch-and-bound
process.

Parameter ``old_variables``:
    Variables in the original mixed-integer program.

Returns ``new_variables``:
    The corresponding variables in the branch-and-bound procedure.)""";
        } GetNewVariables;
        // Symbol: drake::solvers::MixedIntegerBranchAndBound::GetOptimalCost
        struct /* GetOptimalCost */ {
          // Source: drake/solvers/branch_and_bound.h:310
          const char* doc = R"""(Get the optimal cost.)""";
        } GetOptimalCost;
        // Symbol: drake::solvers::MixedIntegerBranchAndBound::GetSolution
        struct /* GetSolution */ {
          // Source: drake/solvers/branch_and_bound.h:333
          const char* doc_2args_mip_var_nth_best_solution =
R"""(Get the n'th best integral solution for a variable. The best solutions
are sorted in the ascending order based on their costs. Each solution
is found in a separate node in the branch-and-bound tree, so the
values of the binary variables are different in each solution.

Parameter ``mip_var``:
    A variable in the original MIP.

Parameter ``nth_best_solution``:
    . The index of the best integral solution.

Precondition:
    ``mip_var`` is a variable in the original MIP.

Precondition:
    ``nth_best_solution`` is between 0 and solutions().size().

Raises:
    RuntimeError if the preconditions are not satisfied.)""";
          // Source: drake/solvers/branch_and_bound.h:351
          const char* doc_2args_constEigenMatrixBase_int =
R"""(Get the n'th best integral solution for some variables. The best
solutions are sorted in the ascending order based on their costs. Each
solution is found in a separate node in the branch-and-bound tree, so

Parameter ``mip_vars``:
    Variables in the original MIP.

Parameter ``nth_best_solution``:
    . The index of the best integral solution.

Precondition:
    ``mip_vars`` are variables in the original MIP.

Precondition:
    ``nth_best_solution`` is between 0 and solutions().size().

Raises:
    RuntimeError if the preconditions are not satisfied.)""";
        } GetSolution;
        // Symbol: drake::solvers::MixedIntegerBranchAndBound::GetSubOptimalCost
        struct /* GetSubOptimalCost */ {
          // Source: drake/solvers/branch_and_bound.h:320
          const char* doc =
R"""(Get the n'th sub-optimal cost. The costs are sorted in the ascending
order. The sub-optimal costs do not include the optimal cost.

Parameter ``nth_suboptimal_cost``:
    The n'th sub-optimal cost.

Precondition:
    ``nth_suboptimal_cost`` is between 0 and solutions().size() - 1.

Raises:
    RuntimeError if the precondition is not satisfied.)""";
        } GetSubOptimalCost;
        // Symbol: drake::solvers::MixedIntegerBranchAndBound::IsLeafNodeFathomed
        struct /* IsLeafNodeFathomed */ {
          // Source: drake/solvers/branch_and_bound.h:523
          const char* doc =
R"""(If a leaf node is fathomed, then there is no need to branch on this
node any more. A leaf node is fathomed is any of the following
conditions are satisfied:

1. The optimization problem in the node is infeasible.
2. The optimal cost of the node is larger than the best upper bound.
3. The optimal solution to the node satisfies all the integral constraints.
4. All binary variables are fixed to either 0 or 1 in this node.

Parameter ``leaf_node``:
    A leaf node to check if it is fathomed.

Precondition:
    The node should be a leaf node.

Raises:
    RuntimeError if the precondition is not satisfied.)""";
        } IsLeafNodeFathomed;
        // Symbol: drake::solvers::MixedIntegerBranchAndBound::MixedIntegerBranchAndBound
        struct /* ctor */ {
          // Source: drake/solvers/branch_and_bound.h:294
          const char* doc =
R"""(Construct a branch-and-bound tree from a mixed-integer optimization
program.

Parameter ``prog``:
    A mixed-integer optimization program.

Parameter ``solver_id``:
    The ID of the solver for the optimization.)""";
        } ctor;
        // Symbol: drake::solvers::MixedIntegerBranchAndBound::NodeCallbackFun
        struct /* NodeCallbackFun */ {
          // Source: drake/solvers/branch_and_bound.h:285
          const char* doc =
R"""(The function signature for user defined node callback function.)""";
        } NodeCallbackFun;
        // Symbol: drake::solvers::MixedIntegerBranchAndBound::NodeSelectFun
        struct /* NodeSelectFun */ {
          // Source: drake/solvers/branch_and_bound.h:280
          const char* doc =
R"""(The function signature for the user defined method to pick a branching
node or a branching variable.)""";
        } NodeSelectFun;
        // Symbol: drake::solvers::MixedIntegerBranchAndBound::NodeSelectionMethod
        struct /* NodeSelectionMethod */ {
          // Source: drake/solvers/branch_and_bound.h:270
          const char* doc =
R"""(Different methods to pick a branching node.)""";
          // Symbol: drake::solvers::MixedIntegerBranchAndBound::NodeSelectionMethod::kDepthFirst
          struct /* kDepthFirst */ {
            // Source: drake/solvers/branch_and_bound.h:272
            const char* doc =
R"""(Pick the node with the most binary variables fixed.)""";
          } kDepthFirst;
          // Symbol: drake::solvers::MixedIntegerBranchAndBound::NodeSelectionMethod::kMinLowerBound
          struct /* kMinLowerBound */ {
            // Source: drake/solvers/branch_and_bound.h:273
            const char* doc =
R"""(Pick the node with the smallest optimal cost.)""";
          } kMinLowerBound;
          // Symbol: drake::solvers::MixedIntegerBranchAndBound::NodeSelectionMethod::kUserDefined
          struct /* kUserDefined */ {
            // Source: drake/solvers/branch_and_bound.h:271
            const char* doc = R"""(User defined.)""";
          } kUserDefined;
        } NodeSelectionMethod;
        // Symbol: drake::solvers::MixedIntegerBranchAndBound::SetNodeSelectionMethod
        struct /* SetNodeSelectionMethod */ {
          // Source: drake/solvers/branch_and_bound.h:408
          const char* doc =
R"""(The user can choose the method to pick a node for branching. We
provide options such as "depth first" or "min lower bound".

Parameter ``node_selection_method``:
    The option to pick a node. If the option is
    NodeSelectionMethod::kUserDefined, then the user should also
    provide the method to pick a node through
    SetUserDefinedNodeSelectionFunction.)""";
        } SetNodeSelectionMethod;
        // Symbol: drake::solvers::MixedIntegerBranchAndBound::SetSearchIntegralSolutionByRounding
        struct /* SetSearchIntegralSolutionByRounding */ {
          // Source: drake/solvers/branch_and_bound.h:497
          const char* doc =
R"""(Set the flag to true if the user wants to search an integral solution
in each node, after the optimization problem in that node is solved.
The program can search for an integral solution based on the solution
to the optimization program in the node, by rounding the binary
variables to the nearest integer value, and solve for the continuous
variables. If a solution is obtained in this new program, then this
solution is an integral solution to the mixed-integer program.)""";
        } SetSearchIntegralSolutionByRounding;
        // Symbol: drake::solvers::MixedIntegerBranchAndBound::SetUserDefinedNodeCallbackFunction
        struct /* SetUserDefinedNodeCallbackFunction */ {
          // Source: drake/solvers/branch_and_bound.h:505
          const char* doc =
R"""(The user can set a defined callback function in each node. This
function is called after the optimization is solved in each node.)""";
        } SetUserDefinedNodeCallbackFunction;
        // Symbol: drake::solvers::MixedIntegerBranchAndBound::SetUserDefinedNodeSelectionFunction
        struct /* SetUserDefinedNodeSelectionFunction */ {
          // Source: drake/solvers/branch_and_bound.h:445
          const char* doc =
R"""(Set the user-defined method to pick the branching node. This method is
used if the user calls
SetNodeSelectionMethod(NodeSelectionMethod::kUserDefined).

For example, if the user has defined a function LeftMostNode that
would return the left-most unfathomed node in the tree, then the user
could do


::

    MixedIntegerBranchAndBoundNode* LeftMostNodeInSubTree(
        const MixedIntegerBranchAndBound& branch_and_bound,
        const MixedIntegerBranchAndBoundNode& subtree_root) {
      // Starting from the subtree root, find the left most leaf node that is
    not fathomed.
      blah
    }
    
    MixedIntegerBranchAndBound bnb(...);
    bnb.SetNodeSelectionMethod(
        MixedIntegerBranchAndBound::NodeSelectionMethod::kUserDefined);
    // Use a lambda function as the NodeSelectionFun
    bnb->SetUserDefinedNodeSelectionFunction([](
        const MixedIntegerBranchAndBound& branch_and_bound) {
      return LeftMostNodeInSubTree(branch_and_bound,
    *(branch_and_bound.root()));

A more detailed example can be found in
solvers/test/branch_and_bound_test.cc in
TestSetUserDefinedNodeSelectionFunction.

Note:
    The user defined function should pick an un-fathomed leaf node for
    branching.

Raises:
    std::_runtime error if the node is not a leaf node, or it is
    fathomed.)""";
        } SetUserDefinedNodeSelectionFunction;
        // Symbol: drake::solvers::MixedIntegerBranchAndBound::SetUserDefinedVariableSelectionFunction
        struct /* SetUserDefinedVariableSelectionFunction */ {
          // Source: drake/solvers/branch_and_bound.h:485
          const char* doc =
R"""(Set the user-defined method to pick the branching variable. This
method is used if the user calls
SetVariableSelectionMethod(VariableSelectionMethod::kUserDefined).

For example, if the user has defined a function FirstVariable, that
would return the first un-fixed binary variable in this branch as


::

    SymbolicVariable* FirstVariable(const MixedIntegerBranchAndBoundNode& node)
    {
      return node.remaining_binary_variables().begin();
    }

The user can then set the branch-and-bound to use this function to
select the branching variable as


::

    MixedIntegerBranchAndBound bnb(...);
    bnb.SetVariableSelectionMethod(
        MixedIntegerBranchAndBound:VariableSelectionMethod::kUserDefined);
    // Set VariableSelectFun by using a function pointer.
    bnb.SetUserDefinedVariableSelectionFunction(FirstVariable);)""";
        } SetUserDefinedVariableSelectionFunction;
        // Symbol: drake::solvers::MixedIntegerBranchAndBound::SetVariableSelectionMethod
        struct /* SetVariableSelectionMethod */ {
          // Source: drake/solvers/branch_and_bound.h:457
          const char* doc =
R"""(The user can choose the method to pick a variable for branching in
each node. We provide options such as "most ambivalent" or "least
ambivalent".

Parameter ``variable_selection_method``:
    The option to pick a variable. If the option is
    VariableSelectionMethod::kUserDefined, then the user should also
    provide the method to pick a variable through
    SetUserDefinedVariableSelectionFunction(...).)""";
        } SetVariableSelectionMethod;
        // Symbol: drake::solvers::MixedIntegerBranchAndBound::Solve
        struct /* Solve */ {
          // Source: drake/solvers/branch_and_bound.h:307
          const char* doc =
R"""(Solve the mixed-integer problem (MIP) through a branch and bound
process.

Returns ``solution_result``:
    If solution_result=SolutionResult::kSolutionFound, then the best
    solutions are stored inside solutions(). The user can access the
    value of each variable(s) through GetSolution(...). If
    solution_result=SolutionResult::kInfeasibleConstraints, then the
    mixed-integer problem is primal infeasible. If
    solution_result=SolutionResult::kUnbounded, then the mixed-integer
    problem is primal unbounded.)""";
        } Solve;
        // Symbol: drake::solvers::MixedIntegerBranchAndBound::VariableSelectFun
        struct /* VariableSelectFun */ {
          // Source: drake/solvers/branch_and_bound.h:282
          const char* doc = R"""()""";
        } VariableSelectFun;
        // Symbol: drake::solvers::MixedIntegerBranchAndBound::VariableSelectionMethod
        struct /* VariableSelectionMethod */ {
          // Source: drake/solvers/branch_and_bound.h:261
          const char* doc =
R"""(Different methods to pick a branching variable.)""";
          // Symbol: drake::solvers::MixedIntegerBranchAndBound::VariableSelectionMethod::kLeastAmbivalent
          struct /* kLeastAmbivalent */ {
            // Source: drake/solvers/branch_and_bound.h:263
            const char* doc =
R"""(Pick the variable whose value is closest to 0 or 1.)""";
          } kLeastAmbivalent;
          // Symbol: drake::solvers::MixedIntegerBranchAndBound::VariableSelectionMethod::kMostAmbivalent
          struct /* kMostAmbivalent */ {
            // Source: drake/solvers/branch_and_bound.h:264
            const char* doc =
R"""(Pick the variable whose value is closest to 0.5)""";
          } kMostAmbivalent;
          // Symbol: drake::solvers::MixedIntegerBranchAndBound::VariableSelectionMethod::kUserDefined
          struct /* kUserDefined */ {
            // Source: drake/solvers/branch_and_bound.h:262
            const char* doc = R"""(User defined.)""";
          } kUserDefined;
        } VariableSelectionMethod;
        // Symbol: drake::solvers::MixedIntegerBranchAndBound::absolute_gap_tol
        struct /* absolute_gap_tol */ {
          // Source: drake/solvers/branch_and_bound.h:555
          const char* doc = R"""(Getter for the absolute gap tolerance.)""";
        } absolute_gap_tol;
        // Symbol: drake::solvers::MixedIntegerBranchAndBound::best_lower_bound
        struct /* best_lower_bound */ {
          // Source: drake/solvers/branch_and_bound.h:536
          const char* doc = R"""(Getter for the best lower bound.)""";
        } best_lower_bound;
        // Symbol: drake::solvers::MixedIntegerBranchAndBound::best_upper_bound
        struct /* best_upper_bound */ {
          // Source: drake/solvers/branch_and_bound.h:533
          const char* doc = R"""(Getter for the best upper bound.)""";
        } best_upper_bound;
        // Symbol: drake::solvers::MixedIntegerBranchAndBound::relative_gap_tol
        struct /* relative_gap_tol */ {
          // Source: drake/solvers/branch_and_bound.h:565
          const char* doc = R"""(Geeter for the relative gap tolerance.)""";
        } relative_gap_tol;
        // Symbol: drake::solvers::MixedIntegerBranchAndBound::root
        struct /* root */ {
          // Source: drake/solvers/branch_and_bound.h:530
          const char* doc =
R"""(Getter for the root node. Note that this is aliased for the lifetime
of this object.)""";
        } root;
        // Symbol: drake::solvers::MixedIntegerBranchAndBound::set_absolute_gap_tol
        struct /* set_absolute_gap_tol */ {
          // Source: drake/solvers/branch_and_bound.h:552
          const char* doc =
R"""(Setter for the absolute gap tolerance. The branch-and-bound will
terminate if its difference between its best upper bound and best
lower bound is below this gap tolerance.)""";
        } set_absolute_gap_tol;
        // Symbol: drake::solvers::MixedIntegerBranchAndBound::set_relative_gap_tol
        struct /* set_relative_gap_tol */ {
          // Source: drake/solvers/branch_and_bound.h:562
          const char* doc =
R"""(Setter for the relative gap tolerance. The branch-and-bound will
terminate if (best_upper_bound() - best_lower_bound()) /
abs(best_lower_bound()) is smaller than this tolerance.)""";
        } set_relative_gap_tol;
        // Symbol: drake::solvers::MixedIntegerBranchAndBound::solutions
        struct /* solutions */ {
          // Source: drake/solvers/branch_and_bound.h:544
          const char* doc =
R"""(Getter for the solutions. Returns a list of solutions, together with
the costs evaluated at the solutions. The solutions are sorted in the
ascending order based on the cost.)""";
        } solutions;
      } MixedIntegerBranchAndBound;
      // Symbol: drake::solvers::MixedIntegerBranchAndBoundNode
      struct /* MixedIntegerBranchAndBoundNode */ {
        // Source: drake/solvers/branch_and_bound.h:37
        const char* doc =
R"""(A node in the branch-and-bound (bnb) tree. The whole branch-and-bound
tree solves the mixed-integer problem min f(x) (1) s.t g(x) ≤ 0 z ∈
{0, 1} where the binary variables z are a subset of the decision
variables x. In this node, we will fix some binary variables to either
0 and 1, and relax the rest of the binary variables to continuous
variables between 0 and 1. Namely we will solve the following problem
with all variables being continuous min f(x) (2) s.t g(x) ≤ 0 z_fixed
= b_fixed 0 ≤ z_relaxed ≤ 1 where z_fixed, z_relaxed is a partition of
the original binary variables z. z_fixed is the fixed binary
variables, z_relaxed is the relaxed binary variables. b_fixed is a
vector containing the assigned values of the fixed binary variables
z_fixed, b_fixed only contains value either 0 or 1.

Each node is created from its parent node, by fixing one binary
variable to either 0 or 1.)""";
        // Symbol: drake::solvers::MixedIntegerBranchAndBoundNode::Branch
        struct /* Branch */ {
          // Source: drake/solvers/branch_and_bound.h:82
          const char* doc =
R"""(Branches on ``binary_variable``, and creates two child nodes. In the
left child node, the binary variable is fixed to 0. In the right node,
the binary variable is fixed to 1. Solves the optimization program in
each child node.

Parameter ``binary_variable``:
    This binary variable is fixed to either 0 or 1 in the child node.

Precondition:
    binary_variable is in remaining_binary_variables_;

Raises:
    RuntimeError if the preconditions are not met.)""";
        } Branch;
        // Symbol: drake::solvers::MixedIntegerBranchAndBoundNode::ConstructRootNode
        struct /* ConstructRootNode */ {
          // Source: drake/solvers/branch_and_bound.h:70
          const char* doc =
R"""(Construct the root node from an optimization program. For the
mixed-integer optimization program min f(x) (1) s.t g(x) ≤ 0 z ∈ {0,
1} we will construct a root node for this mixed-integer program. In
the root node, it enforces all the costs and constraints in the
original program, except the binary constraint z ∈ {0, 1}. Instead, it
enforces the relaxed constraint to 0 ≤ z ≤ 1. So the root node
contains the program min f(x) (2) s.t g(x) ≤ 0 0 ≤ z ≤ 1 This
optimization program is solved during the node construction.

Parameter ``prog``:
    The mixed-integer optimization program (1) in the documentation
    above.

Parameter ``solver_id``:
    The ID of the solver for the optimization program.

Returns ``(node``:
    , map_old_vars_to_new_vars) node is the root node of the tree,
    that contains the optimization program (2) in the documentation
    above. This root node has no parent. We also need to recreate new
    decision variables in the root node, from the original
    optimization program (1), since the binary variables will be
    converted to continuous variables in (2). We thus return the map
    from the old variables to the new variables.

Precondition:
    prog should contain binary variables.

Precondition:
    solver_id can be either Gurobi or Scs.

Raises:
    RuntimeError if the preconditions are not met.)""";
        } ConstructRootNode;
        // Symbol: drake::solvers::MixedIntegerBranchAndBoundNode::IsLeaf
        struct /* IsLeaf */ {
          // Source: drake/solvers/branch_and_bound.h:92
          const char* doc =
R"""(Determine if a node is a leaf or not. A leaf node has no child nodes.)""";
        } IsLeaf;
        // Symbol: drake::solvers::MixedIntegerBranchAndBoundNode::IsRoot
        struct /* IsRoot */ {
          // Source: drake/solvers/branch_and_bound.h:87
          const char* doc =
R"""(Returns true if a node is the root. A root node has no parent.)""";
        } IsRoot;
        // Symbol: drake::solvers::MixedIntegerBranchAndBoundNode::MixedIntegerBranchAndBoundNode
        struct /* ctor */ {
          // Source: drake/solvers/branch_and_bound.h:39
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::solvers::MixedIntegerBranchAndBoundNode::fixed_binary_value
        struct /* fixed_binary_value */ {
          // Source: drake/solvers/branch_and_bound.h:144
          const char* doc =
R"""(Getter for the value of the binary variable, which was not fixed in
the parent node, but is fixed to either 0 or 1 in this node.)""";
        } fixed_binary_value;
        // Symbol: drake::solvers::MixedIntegerBranchAndBoundNode::fixed_binary_variable
        struct /* fixed_binary_variable */ {
          // Source: drake/solvers/branch_and_bound.h:136
          const char* doc =
R"""(Getter for the binary variable, whose value was not fixed in the
parent node, but is fixed to either 0 or 1 in this node.)""";
        } fixed_binary_variable;
        // Symbol: drake::solvers::MixedIntegerBranchAndBoundNode::left_child
        struct /* left_child */ {
          // Source: drake/solvers/branch_and_bound.h:107
          const char* doc = R"""(Getter for the left child.)""";
        } left_child;
        // Symbol: drake::solvers::MixedIntegerBranchAndBoundNode::mutable_left_child
        struct /* mutable_left_child */ {
          // Source: drake/solvers/branch_and_bound.h:112
          const char* doc = R"""(Getter for the mutable left child.)""";
        } mutable_left_child;
        // Symbol: drake::solvers::MixedIntegerBranchAndBoundNode::mutable_parent
        struct /* mutable_parent */ {
          // Source: drake/solvers/branch_and_bound.h:130
          const char* doc = R"""(Getter for the mutable parent node.)""";
        } mutable_parent;
        // Symbol: drake::solvers::MixedIntegerBranchAndBoundNode::mutable_right_child
        struct /* mutable_right_child */ {
          // Source: drake/solvers/branch_and_bound.h:122
          const char* doc = R"""(Getter for the mutable right child.)""";
        } mutable_right_child;
        // Symbol: drake::solvers::MixedIntegerBranchAndBoundNode::optimal_solution_is_integral
        struct /* optimal_solution_is_integral */ {
          // Source: drake/solvers/branch_and_bound.h:161
          const char* doc =
R"""(Getter for optimal_solution_is_integral.

Precondition:
    The optimization problem is solved successfully.

Raises:
    RuntimeError if the precondition is not satisfied.)""";
        } optimal_solution_is_integral;
        // Symbol: drake::solvers::MixedIntegerBranchAndBoundNode::parent
        struct /* parent */ {
          // Source: drake/solvers/branch_and_bound.h:127
          const char* doc = R"""(Getter for the parent node.)""";
        } parent;
        // Symbol: drake::solvers::MixedIntegerBranchAndBoundNode::prog
        struct /* prog */ {
          // Source: drake/solvers/branch_and_bound.h:97
          const char* doc = R"""(Getter for the mathematical program.)""";
        } prog;
        // Symbol: drake::solvers::MixedIntegerBranchAndBoundNode::prog_result
        struct /* prog_result */ {
          // Source: drake/solvers/branch_and_bound.h:102
          const char* doc =
R"""(Getter for the mathematical program result.)""";
        } prog_result;
        // Symbol: drake::solvers::MixedIntegerBranchAndBoundNode::remaining_binary_variables
        struct /* remaining_binary_variables */ {
          // Source: drake/solvers/branch_and_bound.h:149
          const char* doc =
R"""(Getter for the remaining binary variables in this node.)""";
        } remaining_binary_variables;
        // Symbol: drake::solvers::MixedIntegerBranchAndBoundNode::right_child
        struct /* right_child */ {
          // Source: drake/solvers/branch_and_bound.h:117
          const char* doc = R"""(Getter for the right child.)""";
        } right_child;
        // Symbol: drake::solvers::MixedIntegerBranchAndBoundNode::solution_result
        struct /* solution_result */ {
          // Source: drake/solvers/branch_and_bound.h:154
          const char* doc =
R"""(Getter for the solution result when solving the optimization program.)""";
        } solution_result;
        // Symbol: drake::solvers::MixedIntegerBranchAndBoundNode::solver_id
        struct /* solver_id */ {
          // Source: drake/solvers/branch_and_bound.h:164
          const char* doc = R"""(Getter for solver id.)""";
        } solver_id;
      } MixedIntegerBranchAndBoundNode;
      // Symbol: drake::solvers::MixedIntegerRotationConstraintGenerator
      struct /* MixedIntegerRotationConstraintGenerator */ {
        // Source: drake/solvers/mixed_integer_rotation_constraint.h:50
        const char* doc =
R"""(We relax the non-convex SO(3) constraint on rotation matrix R to
mixed-integer linear constraints. The formulation of these constraints
are described in Global Inverse Kinematics via Mixed-integer Convex
Optimization by Hongkai Dai, Gregory Izatt and Russ Tedrake, ISRR,
2017

The SO(3) constraint on a rotation matrix R = [r₁, r₂, r₃], rᵢ∈ℝ³ is


::

    rᵢᵀrᵢ = 1    (1)
    rᵢᵀrⱼ = 0    (2)
    r₁ x r₂ = r₃ (3)

To relax SO(3) constraint on rotation matrix R, we divide the range
[-1, 1] (the range of each entry in R) into smaller intervals [φ(i),
φ(i+1)], and then relax the SO(3) constraint within each interval. We
provide 3 approaches for relaxation 1. By replacing each bilinear
product in constraint (1), (2) and (3) with a new variable, in the
McCormick envelope of the bilinear product w = x * y. 2. By
considering the intersection region between axis-aligned boxes, and
the surface of a unit sphere in 3D. 3. By combining the two approaches
above. This will result in a tighter relaxation.

These three approaches give different relaxation of SO(3) constraint
(the feasible sets for each relaxation are different), and different
computation speed. The users can switch between the approaches to find
the best fit for their problem.

Note:
    If you have several rotation matrices that all need to be relaxed
    through mixed-integer constraint, then you can create a single
    MixedIntegerRotationConstraintGenerator object, and add the
    mixed-integer constraint to each rotation matrix, by calling
    AddToProgram() function repeatedly.)""";
        // Symbol: drake::solvers::MixedIntegerRotationConstraintGenerator::AddToProgram
        struct /* AddToProgram */ {
          // Source: drake/solvers/mixed_integer_rotation_constraint.h:120
          const char* doc =
R"""(Add the mixed-integer linear constraints to the optimization program,
as a relaxation of SO(3) constraint on the rotation matrix ``R``.

Parameter ``R``:
    The rotation matrix on which the SO(3) constraint is imposed.

Parameter ``prog``:
    The optimization program to which the mixed-integer constraints
    (and additional variables) are added.)""";
        } AddToProgram;
        // Symbol: drake::solvers::MixedIntegerRotationConstraintGenerator::Approach
        struct /* Approach */ {
          // Source: drake/solvers/mixed_integer_rotation_constraint.h:55
          const char* doc = R"""()""";
          // Symbol: drake::solvers::MixedIntegerRotationConstraintGenerator::Approach::kBilinearMcCormick
          struct /* kBilinearMcCormick */ {
            // Source: drake/solvers/mixed_integer_rotation_constraint.h:59
            const char* doc =
R"""(Relax SO(3) constraint by considering the McCormick envelope on the
bilinear product.)""";
          } kBilinearMcCormick;
          // Symbol: drake::solvers::MixedIntegerRotationConstraintGenerator::Approach::kBoth
          struct /* kBoth */ {
            // Source: drake/solvers/mixed_integer_rotation_constraint.h:61
            const char* doc =
R"""(Relax SO(3) constraint by considering both the intersection between
boxes and the unit sphere surface, and the McCormick envelope on the
bilinear product.)""";
          } kBoth;
          // Symbol: drake::solvers::MixedIntegerRotationConstraintGenerator::Approach::kBoxSphereIntersection
          struct /* kBoxSphereIntersection */ {
            // Source: drake/solvers/mixed_integer_rotation_constraint.h:56
            const char* doc =
R"""(Relax SO(3) constraint by considering the intersection between boxes
and the unit sphere surface.)""";
          } kBoxSphereIntersection;
        } Approach;
        // Symbol: drake::solvers::MixedIntegerRotationConstraintGenerator::MixedIntegerRotationConstraintGenerator
        struct /* ctor */ {
          // Source: drake/solvers/mixed_integer_rotation_constraint.h:109
          const char* doc =
R"""(Constructor

Parameter ``approach``:
    Refer to MixedIntegerRotationConstraintGenerator::Approach for the
    details.

Parameter ``num_intervals_per_half_axis``:
    We will cut the range [-1, 1] evenly to 2 *
    ``num_intervals_per_half_axis`` small intervals. The number of
    binary variables will depend on the number of intervals.

Parameter ``interval_binning``:
    The binning scheme we use to add SOS2 constraint with binary
    variables. If interval_binning = kLinear, then we will add 9 * 2 *
    ``num_intervals_per_half_axis binary`` variables; if
    interval_binning = kLogarithmic, then we will add 9 * (1 +
    log₂(num_intervals_per_half_axis)) binary variables. Refer to
    AddLogarithmicSos2Constraint and AddSos2Constraint for more
    details.)""";
        } ctor;
        // Symbol: drake::solvers::MixedIntegerRotationConstraintGenerator::ReturnType
        struct /* ReturnType */ {
          // Source: drake/solvers/mixed_integer_rotation_constraint.h:67
          const char* doc = R"""()""";
          // Symbol: drake::solvers::MixedIntegerRotationConstraintGenerator::ReturnType::B_
          struct /* B_ */ {
            // Source: drake/solvers/mixed_integer_rotation_constraint.h:78
            const char* doc =
R"""(B_ contains the new binary variables added to the program. B_`i][j]
represents in which interval R(i, j) lies. If we use linear binning,
then B_[i][j] is of length 2 * num_intervals_per_half_axis_. B_[i][j
<k>`_ = 1 => φ(k) ≤ R(i, j) ≤ φ(k + 1) B_`i][j <k>`_ = 0 => R(i, j) ≥
φ(k + 1) or R(i, j) ≤ φ(k) If we use logarithmic binning, then
B_[i][j] is of length 1 + log₂(num_intervals_per_half_axis_). If
B_[i][j] represents integer k in reflected Gray code, then R(i, j) is
in the interval [φ(k), φ(k+1)].)""";
          } B_;
          // Symbol: drake::solvers::MixedIntegerRotationConstraintGenerator::ReturnType::lambda_
          struct /* lambda_ */ {
            // Source: drake/solvers/mixed_integer_rotation_constraint.h:92
            const char* doc =
R"""(λ contains part of the new continuous variables added to the program.
λ_`i][j] is of length 2 * num_intervals_per_half_axis_ + 1, such that
R(i, j) = φᵀ * λ_[i][j]. Notice that λ_[i][j] satisfies the special
ordered set of type 2 (SOS2) constraint. Namely at most two entries in
λ_[i][j] can be strictly positive, and these two entries have to be
consecutive. Mathematically


::

    ∑ₖ λ_[i][j <k>`_ = 1
    λ_`i][j <k>`_ ≥ 0 ∀ k
    ∃ m s.t λ_`i][j <n>`_ = 0 if n ≠ m and n ≠ m+1)""";
          } lambda_;
        } ReturnType;
        // Symbol: drake::solvers::MixedIntegerRotationConstraintGenerator::approach
        struct /* approach */ {
          // Source: drake/solvers/mixed_integer_rotation_constraint.h:130
          const char* doc = R"""()""";
        } approach;
        // Symbol: drake::solvers::MixedIntegerRotationConstraintGenerator::interval_binning
        struct /* interval_binning */ {
          // Source: drake/solvers/mixed_integer_rotation_constraint.h:136
          const char* doc = R"""()""";
        } interval_binning;
        // Symbol: drake::solvers::MixedIntegerRotationConstraintGenerator::num_intervals_per_half_axis
        struct /* num_intervals_per_half_axis */ {
          // Source: drake/solvers/mixed_integer_rotation_constraint.h:132
          const char* doc = R"""()""";
        } num_intervals_per_half_axis;
        // Symbol: drake::solvers::MixedIntegerRotationConstraintGenerator::phi
        struct /* phi */ {
          // Source: drake/solvers/mixed_integer_rotation_constraint.h:125
          const char* doc = R"""(Getter for φ.)""";
        } phi;
        // Symbol: drake::solvers::MixedIntegerRotationConstraintGenerator::phi_nonnegative
        struct /* phi_nonnegative */ {
          // Source: drake/solvers/mixed_integer_rotation_constraint.h:128
          const char* doc =
R"""(Getter for φ₊, the non-negative part of φ.)""";
        } phi_nonnegative;
      } MixedIntegerRotationConstraintGenerator;
      // Symbol: drake::solvers::MobyLCPSolver
      struct /* MobyLCPSolver */ {
        // Source: drake/solvers/moby_lcp_solver.h:70
        const char* doc =
R"""(A class for solving Linear Complementarity Problems (LCPs). Solving a
LCP requires finding a solution to the problem:


::

    Mz + q = w
    z ≥ 0
    w ≥ 0
    zᵀw = 0

(where M ∈ ℝⁿˣⁿ and q ∈ ℝⁿ are problem inputs and z ∈ ℝⁿ and w ∈ ℝⁿ
are unknown vectors) or correctly reporting that such a solution does
not exist. In spite of their linear structure, solving LCPs is NP-Hard
[Cottle 1992]. However, some LCPs are significantly easier to solve.
For instance, it can be seen that the LCP is solvable in worst-case
polynomial time for the case of symmetric positive-semi-definite M by
formulating it as the following convex quadratic program:


::

    minimize:   f(z) = zᵀw = zᵀ(Mz + q)
    subject to: z ≥ 0
                Mz + q ≥ 0

Note that this quadratic program's (QP) objective function at the
minimum z cannot be less than zero, and the LCP is only solved if the
objective function at the minimum is equal to zero. Since the seminal
result of Karmarkar, it has been known that convex QPs are solvable in
polynomial time [Karmarkar 1984].

The difficulty of solving an LCP is characterized by the properties of
its particular matrix, namely the class of matrices it belongs to.
Classes include, for example, Q, Q₀, P, P₀, copositive, and Z
matrices. [Cottle 1992] and [Murty 1998] (see pp. 224-230 in the
latter) describe relevant matrix classes in more detail.

* [Cottle 1992]     R. Cottle, J.-S. Pang, and R. Stone. The Linear
                    Complementarity Problem. Academic Press, 1992.
* [Karmarkar 1984]  N. Karmarkar. A New Polynomial-Time Algorithm for
                    Linear Programming. Combinatorica, 4(4), pp. 373-395.
* [Murty 1988]      K. Murty. Linear Complementarity, Linear and Nonlinear
                    Programming. Heldermann Verlag, 1988.)""";
        // Symbol: drake::solvers::MobyLCPSolver::ComputeZeroTolerance
        struct /* ComputeZeroTolerance */ {
          // Source: drake/solvers/moby_lcp_solver.h:82
          const char* doc =
R"""(Calculates the zero tolerance that the solver would compute if the
user does not specify a tolerance.)""";
        } ComputeZeroTolerance;
        // Symbol: drake::solvers::MobyLCPSolver::MobyLCPSolver<T>
        struct /* ctor */ {
          // Source: drake/solvers/moby_lcp_solver.h:72
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::solvers::MobyLCPSolver::ProgramAttributesSatisfied
        struct /* ProgramAttributesSatisfied */ {
          // Source: drake/solvers/moby_lcp_solver.h:281
          const char* doc = R"""()""";
        } ProgramAttributesSatisfied;
        // Symbol: drake::solvers::MobyLCPSolver::SetLoggingEnabled
        struct /* SetLoggingEnabled */ {
          // Source: drake/solvers/moby_lcp_solver.h:77
          const char* doc = R"""()""";
        } SetLoggingEnabled;
        // Symbol: drake::solvers::MobyLCPSolver::SolveLcpFast
        struct /* SolveLcpFast */ {
          // Source: drake/solvers/moby_lcp_solver.h:125
          const char* doc =
R"""(Fast pivoting algorithm for LCPs of the form M = PAPᵀ, q = Pb, where b
∈ ℝᵐ, P ∈ ℝⁿˣᵐ, and A ∈ ℝᵐˣᵐ (where A is positive definite).
Therefore, q is in the range of P and M is positive semi-definite. An
LCP of this form is also guaranteed to have a solution [Cottle 1992].

This particular implementation focuses on the case where the solution
requires few nonzero nonbasic variables, meaning that few z variables
need be nonzero to find a solution to Mz + q = w. This algorithm,
which is based off of Dantzig's Principle Pivoting Method I [Cottle
1992] is described in [Drumwright 2015]. This algorithm is able to use
"warm" starting- a solution to a "nearby" LCP can be used to find the
solution to a given LCP more quickly.

Although this solver is theoretically guaranteed to give a solution to
the LCPs described above, accumulated floating point error from
pivoting operations could cause the solver to fail. Additionally, the
solver can be applied with some success to problems outside of its
guaranteed matrix class. For these reasons, the solver returns a flag
indicating success/failure.

Parameter ``M``:
    the LCP matrix.

Parameter ``q``:
    the LCP vector.

Parameter ``z``:
    the solution to the LCP on return (if the solver succeeds). If the
    length of z is equal to the length of q, the solver will attempt
    to use z's value as a starting solution. If the solver fails
    (returns ``False``), `z` will be set to the zero vector.

Parameter ``zero_tol``:
    The tolerance for testing against zero. If the tolerance is
    negative (default) the solver will determine a generally
    reasonable tolerance.

Raises:
    RuntimeError if M is non-square or M's dimensions do not equal q's
    dimension.

Returns:
    ``True`` if the solver succeeded and ``False`` otherwise.

* [Cottle 1992]      R. Cottle, J.-S. Pang, and R. Stone. The Linear
                     Complementarity Problem. Academic Press, 1992.
* [Drumwright 2015]  E. Drumwright. Rapidly computable viscous friction
                     and no-slip rigid contact models. arXiv:
                     1504.00719v1. 2015.)""";
        } SolveLcpFast;
        // Symbol: drake::solvers::MobyLCPSolver::SolveLcpFastRegularized
        struct /* SolveLcpFastRegularized */ {
          // Source: drake/solvers/moby_lcp_solver.h:179
          const char* doc =
R"""(Regularized version of the fast pivoting algorithm for LCPs of the
form M = PAPᵀ, q = Pb, where b ∈ ℝᵐ, P ∈ ℝⁿˣᵐ, and A ∈ ℝᵐˣᵐ (where A
is positive definite). Therefore, q is in the range of P and M is
positive semi-definite. Please see SolveLcpFast() for more
documentation about the particular algorithm.

This implementation wraps that algorithm with a Tikhonov-type
regularization approach. Specifically, this implementation repeatedly
attempts to solve the LCP:


::

    (M + Iα)z + q = w
    z ≥ 0
    w ≥ 0
    zᵀw = 0

where I is the identity matrix and α ≪ 1, using geometrically
increasing values of α, until the LCP is solved. Cottle et al.
describe how, for sufficiently large α, the LCP will always be
solvable [Cottle 1992], p. 493.

Although this solver is theoretically guaranteed to give a solution to
the LCPs described above, accumulated floating point error from
pivoting operations could cause the solver to fail. Additionally, the
solver can be applied with some success to problems outside of its
guaranteed matrix class. For these reasons, the solver returns a flag
indicating success/failure.

Parameter ``M``:
    the LCP matrix.

Parameter ``q``:
    the LCP vector.

Parameter ``z``:
    the solution to the LCP on return (if the solver succeeds). If the
    length of z is equal to the length of q, the solver will attempt
    to use z's value as a starting solution.

Parameter ``min_exp``:
    The minimum exponent for computing α over [10ᵝ, 10ᵞ] in steps of
    10ᵟ, where β is the minimum exponent, γ is the maximum exponent,
    and δ is the stepping exponent.

Parameter ``step_exp``:
    The stepping exponent for computing α over [10ᵝ, 10ᵞ] in steps of
    10ᵟ, where β is the minimum exponent, γ is the maximum exponent,
    and δ is the stepping exponent.

Parameter ``max_exp``:
    The maximum exponent for computing α over [10ᵝ, 10ᵞ] in steps of
    10ᵟ, where β is the minimum exponent, γ is the maximum exponent,
    and δ is the stepping exponent.

Parameter ``zero_tol``:
    The tolerance for testing against zero. If the tolerance is
    negative (default) the solver will determine a generally
    reasonable tolerance.

Raises:
    RuntimeError if M is non-square or M's dimensions do not equal q's
    dimension.

Returns:
    ``True`` if the solver succeeded and ``False`` if the solver did
    not find a solution for α = 10ᵞ.

See also:
    SolveLcpFast()

* [Cottle, 1992]     R. Cottle, J.-S. Pang, and R. Stone. The Linear
                     Complementarity Problem. Academic Press, 1992.)""";
        } SolveLcpFastRegularized;
        // Symbol: drake::solvers::MobyLCPSolver::SolveLcpLemke
        struct /* SolveLcpLemke */ {
          // Source: drake/solvers/moby_lcp_solver.h:227
          const char* doc =
R"""(Lemke's Algorithm for solving LCPs in the matrix class E, which
contains all strictly semimonotone matrices, all P-matrices, and all
strictly copositive matrices. Lemke's Algorithm is described in
[Cottle 1992], Section 4.4. This implementation was adapted from the
LEMKE Library [LEMKE] for Matlab; this particular implementation fixes
a bug in LEMKE that could occur when multiple indices passed the
minimum ratio test.

Although this solver is theoretically guaranteed to give a solution to
the LCPs described above, accumulated floating point error from
pivoting operations could cause the solver to fail. Additionally, the
solver can be applied with some success to problems outside of its
guaranteed matrix classes. For these reasons, the solver returns a
flag indicating success/failure.

Parameter ``M``:
    the LCP matrix.

Parameter ``q``:
    the LCP vector.

Parameter ``z``:
    the solution to the LCP on return (if the solver succeeds). If the
    length of z is equal to the length of q, the solver will attempt
    to use z's value as a starting solution. **This warmstarting is
    generally not recommended**: it has a predisposition to lead to a
    failing pivoting sequence. If the solver fails (returns
    ``False``), `z` will be set to the zero vector.

Parameter ``zero_tol``:
    The tolerance for testing against zero. If the tolerance is
    negative (default) the solver will determine a generally
    reasonable tolerance.

Parameter ``piv_tol``:
    The tolerance for testing against zero, specifically used for the
    purpose of finding variables for pivoting. If the tolerance is
    negative (default) the solver will determine a generally
    reasonable tolerance.

Returns:
    ``True`` if the solver **believes** it has computed a solution
    (which it determines by the ability to "pivot out" the
    "artificial" variable (see [Cottle 1992]) and ``False`` otherwise.

Warning:
    The caller should verify that the algorithm has solved the LCP to
    the desired tolerances on returns indicating success.

Raises:
    RuntimeError if M is not square or the dimensions of M do not
    match the length of q.

* [Cottle 1992]      R. Cottle, J.-S. Pang, and R. Stone. The Linear
                     Complementarity Problem. Academic Press, 1992.
* [LEMKE]          P. Fackler and M. Miranda. LEMKE.
                   http://people.sc.fsu.edu/~burkardt/m\_src/lemke/lemke.m)""";
        } SolveLcpLemke;
        // Symbol: drake::solvers::MobyLCPSolver::SolveLcpLemkeRegularized
        struct /* SolveLcpLemkeRegularized */ {
          // Source: drake/solvers/moby_lcp_solver.h:263
          const char* doc =
R"""(Lemke's Algorithm for solving LCPs in the matrix class E, which
contains all strictly semimonotone matrices, all P-matrices, and all
strictly copositive matrices. Lemke's Algorithm is described in
[Cottle 1992], Section 4.4.

This implementation wraps that algorithm with a Tikhonov-type
regularization approach. Specifically, this implementation repeatedly
attempts to solve the LCP:


::

    (M + Iα)z + q = w
    z ≥ 0
    w ≥ 0
    zᵀw = 0

where I is the identity matrix and α ≪ 1, using geometrically
increasing values of α, until the LCP is solved. See
SolveLcpFastRegularized() for description of the regularization
process and the function parameters, which are identical. See
SolveLcpLemke() for a description of Lemke's Algorithm. See
SolveLcpFastRegularized() for a description of all calling parameters
other than ``z``, which apply equally well to this function.

Parameter ``z``:
    the solution to the LCP on return (if the solver succeeds). If the
    length of z is equal to the length of q, the solver will attempt
    to use z's value as a starting solution. **This warmstarting is
    generally not recommended**: it has a predisposition to lead to a
    failing pivoting sequence.

See also:
    SolveLcpFastRegularized()

See also:
    SolveLcpLemke()

* [Cottle 1992]      R. Cottle, J.-S. Pang, and R. Stone. The Linear
                     Complementarity Problem. Academic Press, 1992.)""";
        } SolveLcpLemkeRegularized;
        // Symbol: drake::solvers::MobyLCPSolver::get_num_pivots
        struct /* get_num_pivots */ {
          // Source: drake/solvers/moby_lcp_solver.h:270
          const char* doc =
R"""(Returns the number of pivoting operations made by the last LCP solve.)""";
        } get_num_pivots;
        // Symbol: drake::solvers::MobyLCPSolver::id
        struct /* id */ {
          // Source: drake/solvers/moby_lcp_solver.h:278
          const char* doc = R"""()""";
        } id;
        // Symbol: drake::solvers::MobyLCPSolver::is_available
        struct /* is_available */ {
          // Source: drake/solvers/moby_lcp_solver.h:279
          const char* doc = R"""()""";
        } is_available;
        // Symbol: drake::solvers::MobyLCPSolver::is_enabled
        struct /* is_enabled */ {
          // Source: drake/solvers/moby_lcp_solver.h:280
          const char* doc = R"""()""";
        } is_enabled;
        // Symbol: drake::solvers::MobyLCPSolver::reset_num_pivots
        struct /* reset_num_pivots */ {
          // Source: drake/solvers/moby_lcp_solver.h:274
          const char* doc =
R"""(Resets the number of pivoting operations made by the last LCP solver
to zero.)""";
        } reset_num_pivots;
      } MobyLCPSolver;
      // Symbol: drake::solvers::MobyLcpSolverId
      struct /* MobyLcpSolverId */ {
        // Source: drake/solvers/moby_lcp_solver.h:24
        const char* doc =
R"""(Non-template class for MobyLcpSolver<T> constants.)""";
        // Symbol: drake::solvers::MobyLcpSolverId::MobyLcpSolverId
        struct /* ctor */ {
          // Source: drake/solvers/moby_lcp_solver.h:26
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::solvers::MobyLcpSolverId::id
        struct /* id */ {
          // Source: drake/solvers/moby_lcp_solver.h:30
          const char* doc =
R"""(Returns:
    same as SolverInterface::solver_id())""";
        } id;
      } MobyLcpSolverId;
      // Symbol: drake::solvers::MosekSolver
      struct /* MosekSolver */ {
        // Source: drake/solvers/mosek_solver.h:44
        const char* doc =
R"""(Note:
    Mosek only cares about the initial guess of integer variables. The
    initial guess of continuous variables are not passed to MOSEK. If
    all the integer variables are set to some integer values, then
    MOSEK will be forced to compute the remaining continuous variable
    values as the initial guess. (Mosek might change the values of the
    integer/binary variables in the subsequent iterations.) If the
    specified integer solution is infeasible or incomplete, MOSEK will
    simply ignore it. For more details, check
    https://docs.mosek.com/9.2/capi/tutorial-mio-shared.html?highlight=initial)""";
        // Symbol: drake::solvers::MosekSolver::AcquireLicense
        struct /* AcquireLicense */ {
          // Source: drake/solvers/mosek_solver.h:86
          const char* doc =
R"""(This acquires a MOSEK license environment shared among all MosekSolver
instances; the environment will stay valid as long as at least one
shared_ptr returned by this function is alive. Call this ONLY if you
must use different MathematicalProgram instances at different
instances in time, and repeatedly acquiring the license is costly
(e.g., requires contacting a license server).

Returns:
    A shared pointer to a license environment that will stay valid as
    long as any shared_ptr returned by this function is alive. If
    MOSEK is not available in your build, this will return a null
    (empty) shared_ptr.

Raises:
    RuntimeError if MOSEK is available but a license cannot be
    obtained.)""";
        } AcquireLicense;
        // Symbol: drake::solvers::MosekSolver::Details
        struct /* Details */ {
          // Source: drake/solvers/mosek_solver.h:49
          const char* doc =
R"""(Type of details stored in MathematicalProgramResult.)""";
        } Details;
        // Symbol: drake::solvers::MosekSolver::MosekSolver
        struct /* ctor */ {
          // Source: drake/solvers/mosek_solver.h:46
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::solvers::MosekSolver::ProgramAttributesSatisfied
        struct /* ProgramAttributesSatisfied */ {
          // Source: drake/solvers/mosek_solver.h:95
          const char* doc = R"""()""";
        } ProgramAttributesSatisfied;
        // Symbol: drake::solvers::MosekSolver::id
        struct /* id */ {
          // Source: drake/solvers/mosek_solver.h:90
          const char* doc = R"""()""";
        } id;
        // Symbol: drake::solvers::MosekSolver::is_available
        struct /* is_available */ {
          // Source: drake/solvers/mosek_solver.h:91
          const char* doc = R"""()""";
        } is_available;
        // Symbol: drake::solvers::MosekSolver::is_enabled
        struct /* is_enabled */ {
          // Source: drake/solvers/mosek_solver.h:94
          const char* doc =
R"""(Returns true iff the environment variable MOSEKLM_LICENSE_FILE has
been set to a non-empty value.)""";
        } is_enabled;
        // Symbol: drake::solvers::MosekSolver::set_stream_logging
        struct /* set_stream_logging */ {
          // Source: drake/solvers/mosek_solver.h:62
          const char* doc =
R"""(Control stream logging. Refer to
https://docs.mosek.com/9.2/capi/solver-io.html for more details.

Parameter ``flag``:
    Set to true if the user want to turn on stream logging.

Parameter ``log_file``:
    If the user wants to output the logging to a file, then set
    ``log_file`` to the name of that file. If the user wants to output
    the logging to the console, then set log_file to empty string.)""";
        } set_stream_logging;
      } MosekSolver;
      // Symbol: drake::solvers::MosekSolverDetails
      struct /* MosekSolverDetails */ {
        // Source: drake/solvers/mosek_solver.h:19
        const char* doc =
R"""(The Mosek solver details after calling Solve() function. The user can
call MathematicalProgramResult::get_solver_details<MosekSolver>() to
obtain the details.)""";
        // Symbol: drake::solvers::MosekSolverDetails::optimizer_time
        struct /* optimizer_time */ {
          // Source: drake/solvers/mosek_solver.h:22
          const char* doc =
R"""(The mosek optimization time. Please refer to MSK_DINF_OPTIMIZER_TIME
in
https://docs.mosek.com/9.2/capi/constants.html?highlight=msk_dinf_optimizer_time)""";
        } optimizer_time;
        // Symbol: drake::solvers::MosekSolverDetails::rescode
        struct /* rescode */ {
          // Source: drake/solvers/mosek_solver.h:26
          const char* doc =
R"""(The response code returned from mosek solver. Check
https://docs.mosek.com/9.2/capi/response-codes.html for the meaning on
the response code.)""";
        } rescode;
        // Symbol: drake::solvers::MosekSolverDetails::solution_status
        struct /* solution_status */ {
          // Source: drake/solvers/mosek_solver.h:31
          const char* doc =
R"""(The solution status after solving the problem. Check
https://docs.mosek.com/9.2/capi/accessing-solution.html and
https://docs.mosek.com/9.2/capi/constants.html#mosek.solsta for the
meaning on the solution status.)""";
        } solution_status;
      } MosekSolverDetails;
      // Symbol: drake::solvers::NewRotationMatrixVars
      struct /* NewRotationMatrixVars */ {
        // Source: drake/solvers/rotation_constraint.h:45
        const char* doc =
R"""(Allocates a 3x3 matrix of decision variables with the trivial bounding
box constraint ensuring all elements are [-1,1], and the linear
constraint imposing -1 <= trace(R) <= 3.)""";
      } NewRotationMatrixVars;
      // Symbol: drake::solvers::NewSymmetricVariableNames
      struct /* NewSymmetricVariableNames */ {
        // Source: drake/solvers/mathematical_program.h:65
        const char* doc = R"""()""";
      } NewSymmetricVariableNames;
      // Symbol: drake::solvers::NewVariableNames
      struct /* NewVariableNames */ {
        // Source: drake/solvers/mathematical_program.h:43
        const char* doc = R"""()""";
        // Symbol: drake::solvers::NewVariableNames::type
        struct /* type */ {
          // Source: drake/solvers/mathematical_program.h:57
          const char* doc = R"""()""";
        } type;
      } NewVariableNames;
      // Symbol: drake::solvers::NloptSolver
      struct /* NloptSolver */ {
        // Source: drake/solvers/nlopt_solver.h:21
        const char* doc = R"""()""";
        // Symbol: drake::solvers::NloptSolver::ConstraintToleranceName
        struct /* ConstraintToleranceName */ {
          // Source: drake/solvers/nlopt_solver.h:32
          const char* doc =
R"""(The key name for the double-valued constraint tolerance.)""";
        } ConstraintToleranceName;
        // Symbol: drake::solvers::NloptSolver::Details
        struct /* Details */ {
          // Source: drake/solvers/nlopt_solver.h:26
          const char* doc =
R"""(Type of details stored in MathematicalProgramResult.)""";
        } Details;
        // Symbol: drake::solvers::NloptSolver::MaxEvalName
        struct /* MaxEvalName */ {
          // Source: drake/solvers/nlopt_solver.h:41
          const char* doc =
R"""(The key name for int-valued maximum number of evaluations.)""";
        } MaxEvalName;
        // Symbol: drake::solvers::NloptSolver::NloptSolver
        struct /* ctor */ {
          // Source: drake/solvers/nlopt_solver.h:23
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::solvers::NloptSolver::ProgramAttributesSatisfied
        struct /* ProgramAttributesSatisfied */ {
          // Source: drake/solvers/nlopt_solver.h:48
          const char* doc = R"""()""";
        } ProgramAttributesSatisfied;
        // Symbol: drake::solvers::NloptSolver::XAbsoluteToleranceName
        struct /* XAbsoluteToleranceName */ {
          // Source: drake/solvers/nlopt_solver.h:38
          const char* doc =
R"""(The key name for double-valued x absolute tolerance.)""";
        } XAbsoluteToleranceName;
        // Symbol: drake::solvers::NloptSolver::XRelativeToleranceName
        struct /* XRelativeToleranceName */ {
          // Source: drake/solvers/nlopt_solver.h:35
          const char* doc =
R"""(The key name for double-valued x relative tolerance.)""";
        } XRelativeToleranceName;
        // Symbol: drake::solvers::NloptSolver::id
        struct /* id */ {
          // Source: drake/solvers/nlopt_solver.h:45
          const char* doc = R"""()""";
        } id;
        // Symbol: drake::solvers::NloptSolver::is_available
        struct /* is_available */ {
          // Source: drake/solvers/nlopt_solver.h:46
          const char* doc = R"""()""";
        } is_available;
        // Symbol: drake::solvers::NloptSolver::is_enabled
        struct /* is_enabled */ {
          // Source: drake/solvers/nlopt_solver.h:47
          const char* doc = R"""()""";
        } is_enabled;
      } NloptSolver;
      // Symbol: drake::solvers::NloptSolverDetails
      struct /* NloptSolverDetails */ {
        // Source: drake/solvers/nlopt_solver.h:15
        const char* doc =
R"""(The NLopt solver details after calling Solve() function. The user can
call MathematicalProgramResult::get_solver_details<NloptSolver>() to
obtain the details.)""";
        // Symbol: drake::solvers::NloptSolverDetails::status
        struct /* status */ {
          // Source: drake/solvers/nlopt_solver.h:18
          const char* doc =
R"""(The return status of NLopt solver. Please refer to
https://nlopt.readthedocs.io/en/latest/NLopt_Reference/#return-values.)""";
        } status;
      } NloptSolverDetails;
      // Symbol: drake::solvers::OsqpSolver
      struct /* OsqpSolver */ {
        // Source: drake/solvers/osqp_solver.h:38
        const char* doc = R"""()""";
        // Symbol: drake::solvers::OsqpSolver::Details
        struct /* Details */ {
          // Source: drake/solvers/osqp_solver.h:43
          const char* doc =
R"""(Type of details stored in MathematicalProgramResult.)""";
        } Details;
        // Symbol: drake::solvers::OsqpSolver::OsqpSolver
        struct /* ctor */ {
          // Source: drake/solvers/osqp_solver.h:40
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::solvers::OsqpSolver::ProgramAttributesSatisfied
        struct /* ProgramAttributesSatisfied */ {
          // Source: drake/solvers/osqp_solver.h:53
          const char* doc = R"""()""";
        } ProgramAttributesSatisfied;
        // Symbol: drake::solvers::OsqpSolver::id
        struct /* id */ {
          // Source: drake/solvers/osqp_solver.h:50
          const char* doc = R"""()""";
        } id;
        // Symbol: drake::solvers::OsqpSolver::is_available
        struct /* is_available */ {
          // Source: drake/solvers/osqp_solver.h:51
          const char* doc = R"""()""";
        } is_available;
        // Symbol: drake::solvers::OsqpSolver::is_enabled
        struct /* is_enabled */ {
          // Source: drake/solvers/osqp_solver.h:52
          const char* doc = R"""()""";
        } is_enabled;
      } OsqpSolver;
      // Symbol: drake::solvers::OsqpSolverDetails
      struct /* OsqpSolverDetails */ {
        // Source: drake/solvers/osqp_solver.h:13
        const char* doc =
R"""(The OSQP solver details after calling Solve() function. The user can
call MathematicalProgramResult::get_solver_details<OsqpSolver>() to
obtain the details.)""";
        // Symbol: drake::solvers::OsqpSolverDetails::dual_res
        struct /* dual_res */ {
          // Source: drake/solvers/osqp_solver.h:22
          const char* doc = R"""(Norm of dual residue.)""";
        } dual_res;
        // Symbol: drake::solvers::OsqpSolverDetails::iter
        struct /* iter */ {
          // Source: drake/solvers/osqp_solver.h:15
          const char* doc = R"""(Number of iterations taken.)""";
        } iter;
        // Symbol: drake::solvers::OsqpSolverDetails::polish_time
        struct /* polish_time */ {
          // Source: drake/solvers/osqp_solver.h:28
          const char* doc = R"""(Time taken for polish phase (seconds).)""";
        } polish_time;
        // Symbol: drake::solvers::OsqpSolverDetails::primal_res
        struct /* primal_res */ {
          // Source: drake/solvers/osqp_solver.h:20
          const char* doc = R"""(Norm of primal residue.)""";
        } primal_res;
        // Symbol: drake::solvers::OsqpSolverDetails::run_time
        struct /* run_time */ {
          // Source: drake/solvers/osqp_solver.h:30
          const char* doc = R"""(Total OSQP time (seconds).)""";
        } run_time;
        // Symbol: drake::solvers::OsqpSolverDetails::setup_time
        struct /* setup_time */ {
          // Source: drake/solvers/osqp_solver.h:24
          const char* doc = R"""(Time taken for setup phase (seconds).)""";
        } setup_time;
        // Symbol: drake::solvers::OsqpSolverDetails::solve_time
        struct /* solve_time */ {
          // Source: drake/solvers/osqp_solver.h:26
          const char* doc = R"""(Time taken for solve phase (seconds).)""";
        } solve_time;
        // Symbol: drake::solvers::OsqpSolverDetails::status_val
        struct /* status_val */ {
          // Source: drake/solvers/osqp_solver.h:18
          const char* doc =
R"""(Status of the solver at termination. Please refer to
https://github.com/oxfordcontrol/osqp/blob/master/include/constants.h)""";
        } status_val;
        // Symbol: drake::solvers::OsqpSolverDetails::y
        struct /* y */ {
          // Source: drake/solvers/osqp_solver.h:35
          const char* doc =
R"""(y contains the solution for the Lagrangian multiplier associated with
l <= Ax <= u. The Lagrangian multiplier is set only when OSQP solves
the problem. Notice that the order of the linear constraints are
linear inequality first, and then linear equality constraints.)""";
        } y;
      } OsqpSolverDetails;
      // Symbol: drake::solvers::PolynomialConstraint
      struct /* PolynomialConstraint */ {
        // Source: drake/solvers/constraint.h:469
        const char* doc =
R"""(A constraint on the values of multivariate polynomials.

lb[i] <= P[i](x, y...) <= ub[i], where each P[i] is a multivariate
polynomial in x, y...

The Polynomial class uses a different variable naming scheme; thus the
caller must provide a list of Polynomial::VarType variables that
correspond to the members of the MathematicalProgram::Binding (the
individual scalar elements of the given VariableList).)""";
        // Symbol: drake::solvers::PolynomialConstraint::PolynomialConstraint
        struct /* ctor */ {
          // Source: drake/solvers/constraint.h:480
          const char* doc =
R"""(Constructs a polynomial constraint

Parameter ``polynomials``:
    Polynomial vector, a ``num_constraints`` x 1 vector.

Parameter ``poly_vars``:
    Polynomial variables, a ``num_vars`` x 1 vector.

Parameter ``lb``:
    Lower bounds, a ``num_constraints`` x 1 vector.

Parameter ``ub``:
    Upper bounds, a ``num_constraints`` x 1 vector.)""";
        } ctor;
        // Symbol: drake::solvers::PolynomialConstraint::poly_vars
        struct /* poly_vars */ {
          // Source: drake/solvers/constraint.h:491
          const char* doc = R"""()""";
        } poly_vars;
        // Symbol: drake::solvers::PolynomialConstraint::polynomials
        struct /* polynomials */ {
          // Source: drake/solvers/constraint.h:489
          const char* doc = R"""()""";
        } polynomials;
      } PolynomialConstraint;
      // Symbol: drake::solvers::PolynomialCost
      struct /* PolynomialCost */ {
        // Source: drake/solvers/cost.h:234
        const char* doc =
R"""(Implements a cost of the form P(x, y...) where P is a multivariate
polynomial in x, y, ...

The Polynomial class uses a different variable naming scheme; thus the
caller must provide a list of Polynomial::VarType variables that
correspond to the members of the Binding<> (the individual scalar
elements of the given VariableList).)""";
        // Symbol: drake::solvers::PolynomialCost::PolynomialCost
        struct /* ctor */ {
          // Source: drake/solvers/cost.h:243
          const char* doc =
R"""(Constructs a polynomial cost

Parameter ``polynomials``:
    Polynomial vector, a 1 x 1 vector.

Parameter ``poly_vars``:
    Polynomial variables, a ``num_vars`` x 1 vector.)""";
        } ctor;
        // Symbol: drake::solvers::PolynomialCost::poly_vars
        struct /* poly_vars */ {
          // Source: drake/solvers/cost.h:250
          const char* doc = R"""()""";
        } poly_vars;
        // Symbol: drake::solvers::PolynomialCost::polynomials
        struct /* polynomials */ {
          // Source: drake/solvers/cost.h:248
          const char* doc = R"""()""";
        } polynomials;
      } PolynomialCost;
      // Symbol: drake::solvers::PolynomialEvaluator
      struct /* PolynomialEvaluator */ {
        // Source: drake/solvers/evaluator_base.h:228
        const char* doc =
R"""(Implements an evaluator of the form P(x, y...) where P is a
multivariate polynomial in x, y, ...

The Polynomial class uses a different variable naming scheme; thus the
caller must provide a list of Polynomial::VarType variables that
correspond to the members of the Binding<> (the individual scalar
elements of the given VariableList).)""";
        // Symbol: drake::solvers::PolynomialEvaluator::PolynomialEvaluator
        struct /* ctor */ {
          // Source: drake/solvers/evaluator_base.h:238
          const char* doc =
R"""(Constructs a polynomial evaluator given a set of polynomials and the
corresponding variables.

Parameter ``polynomials``:
    Polynomial vector, a ``num_outputs`` x 1 vector.

Parameter ``poly_vars``:
    Polynomial variables, a ``num_vars`` x 1 vector.)""";
        } ctor;
        // Symbol: drake::solvers::PolynomialEvaluator::poly_vars
        struct /* poly_vars */ {
          // Source: drake/solvers/evaluator_base.h:246
          const char* doc = R"""()""";
        } poly_vars;
        // Symbol: drake::solvers::PolynomialEvaluator::polynomials
        struct /* polynomials */ {
          // Source: drake/solvers/evaluator_base.h:244
          const char* doc = R"""()""";
        } polynomials;
      } PolynomialEvaluator;
      // Symbol: drake::solvers::PositiveSemidefiniteConstraint
      struct /* PositiveSemidefiniteConstraint */ {
        // Source: drake/solvers/constraint.h:732
        const char* doc =
R"""(Implements a positive semidefinite constraint on a symmetric matrix S

.. math:: \text{
    S is p.s.d
}

namely, all eigen values of S are non-negative.)""";
        // Symbol: drake::solvers::PositiveSemidefiniteConstraint::DoEval
        struct /* DoEval */ {
          // Source: drake/solvers/constraint.h:803
          const char* doc_was_unable_to_choose_unambiguous_names =
R"""(Evaluate the eigen values of the symmetric matrix.

Parameter ``x``:
    The stacked columns of the symmetric matrix.)""";
        } DoEval;
        // Symbol: drake::solvers::PositiveSemidefiniteConstraint::PositiveSemidefiniteConstraint
        struct /* ctor */ {
          // Source: drake/solvers/constraint.h:788
          const char* doc =
R"""(Impose the constraint that a symmetric matrix with size ``rows`` x
``rows`` is positive semidefinite.

See also:
    MathematicalProgram::AddPositiveSemidefiniteConstraint() for how
    to use this constraint on some decision variables. We currently
    use this constraint as a place holder in MathematicalProgram, to
    indicate the positive semidefiniteness of some decision variables.

Parameter ``rows``:
    The number of rows (and columns) of the symmetric matrix.

Example:


::

    // Create a MathematicalProgram object.
    auto prog = MathematicalProgram();
    
    // Add a 2 x 2 symmetric matrix S to optimization program as new decision
    // variables.
    auto S = prog.NewSymmetricContinuousVariables<2>("S");
    
    // Impose a positive semidefinite constraint on S.
    std::shared_ptr<PositiveSemidefiniteConstraint> psd_constraint =
        prog.AddPositiveSemidefiniteConstraint(S);
    
    /////////////////////////////////////////////////////////////
    // Add more constraints to make the program more interesting,
    // but this is not needed.
    
    // Add the constraint that S(1, 0) = 1.
    prog.AddBoundingBoxConstraint(1, 1, S(1, 0));
    
    // Minimize S(0, 0) + S(1, 1).
    prog.AddLinearCost(Eigen::RowVector2d(1, 1), {S.diagonal()});
    
    /////////////////////////////////////////////////////////////
    
    // Now solve the program.
    auto result = Solve(prog);
    
    // Retrieve the solution of matrix S.
    auto S_value = GetSolution(S, result);
    
    // Compute the eigen values of the solution, to see if they are
    // all non-negative.
    Eigen::Vector4d S_stacked;
    S_stacked << S_value.col(0), S_value.col(1);
    
    Eigen::VectorXd S_eigen_values;
    psd_constraint->Eval(S_stacked, S_eigen_values);
    
    std::cout<<"S solution is: " << S << std::endl;
    std::cout<<"The eigen value of S is " << S_eigen_values << std::endl;)""";
        } ctor;
        // Symbol: drake::solvers::PositiveSemidefiniteConstraint::matrix_rows
        struct /* matrix_rows */ {
          // Source: drake/solvers/constraint.h:796
          const char* doc = R"""()""";
        } matrix_rows;
      } PositiveSemidefiniteConstraint;
      // Symbol: drake::solvers::ProgramAttribute
      struct /* ProgramAttribute */ {
        // Source: drake/solvers/program_attribute.h:11
        const char* doc = R"""()""";
        // Symbol: drake::solvers::ProgramAttribute::kBinaryVariable
        struct /* kBinaryVariable */ {
          // Source: drake/solvers/program_attribute.h:34
          const char* doc = R"""(An exponential cone constraint.)""";
        } kBinaryVariable;
        // Symbol: drake::solvers::ProgramAttribute::kCallback
        struct /* kCallback */ {
          // Source: drake/solvers/program_attribute.h:36
          const char* doc = R"""(variable taking binary value {0, 1}.)""";
        } kCallback;
        // Symbol: drake::solvers::ProgramAttribute::kExponentialConeConstraint
        struct /* kExponentialConeConstraint */ {
          // Source: drake/solvers/program_attribute.h:32
          const char* doc = R"""(A positive semidefinite constraint.)""";
        } kExponentialConeConstraint;
        // Symbol: drake::solvers::ProgramAttribute::kGenericConstraint
        struct /* kGenericConstraint */ {
          // Source: drake/solvers/program_attribute.h:14
          const char* doc =
R"""(A generic constraint, doesn't belong to any specific)""";
        } kGenericConstraint;
        // Symbol: drake::solvers::ProgramAttribute::kGenericCost
        struct /* kGenericCost */ {
          // Source: drake/solvers/program_attribute.h:12
          const char* doc =
R"""(A generic cost, doesn't belong to any specific cost type)""";
        } kGenericCost;
        // Symbol: drake::solvers::ProgramAttribute::kLinearComplementarityConstraint
        struct /* kLinearComplementarityConstraint */ {
          // Source: drake/solvers/program_attribute.h:24
          const char* doc = R"""(A linear complementarity constraint in)""";
        } kLinearComplementarityConstraint;
        // Symbol: drake::solvers::ProgramAttribute::kLinearConstraint
        struct /* kLinearConstraint */ {
          // Source: drake/solvers/program_attribute.h:21
          const char* doc = R"""(A constraint on a linear function.)""";
        } kLinearConstraint;
        // Symbol: drake::solvers::ProgramAttribute::kLinearCost
        struct /* kLinearCost */ {
          // Source: drake/solvers/program_attribute.h:20
          const char* doc = R"""(A linear function as the cost.)""";
        } kLinearCost;
        // Symbol: drake::solvers::ProgramAttribute::kLinearEqualityConstraint
        struct /* kLinearEqualityConstraint */ {
          // Source: drake/solvers/program_attribute.h:22
          const char* doc =
R"""(An equality constraint on a linear function.)""";
        } kLinearEqualityConstraint;
        // Symbol: drake::solvers::ProgramAttribute::kLorentzConeConstraint
        struct /* kLorentzConeConstraint */ {
          // Source: drake/solvers/program_attribute.h:27
          const char* doc = R"""(A Lorentz cone constraint.)""";
        } kLorentzConeConstraint;
        // Symbol: drake::solvers::ProgramAttribute::kPositiveSemidefiniteConstraint
        struct /* kPositiveSemidefiniteConstraint */ {
          // Source: drake/solvers/program_attribute.h:30
          const char* doc = R"""()""";
        } kPositiveSemidefiniteConstraint;
        // Symbol: drake::solvers::ProgramAttribute::kQuadraticConstraint
        struct /* kQuadraticConstraint */ {
          // Source: drake/solvers/program_attribute.h:18
          const char* doc = R"""(A constraint on a quadratic function.)""";
        } kQuadraticConstraint;
        // Symbol: drake::solvers::ProgramAttribute::kQuadraticCost
        struct /* kQuadraticCost */ {
          // Source: drake/solvers/program_attribute.h:17
          const char* doc = R"""(A quadratic function as the cost.)""";
        } kQuadraticCost;
        // Symbol: drake::solvers::ProgramAttribute::kRotatedLorentzConeConstraint
        struct /* kRotatedLorentzConeConstraint */ {
          // Source: drake/solvers/program_attribute.h:28
          const char* doc = R"""(A rotated Lorentz cone constraint.)""";
        } kRotatedLorentzConeConstraint;
      } ProgramAttribute;
      // Symbol: drake::solvers::ProgramAttributes
      struct /* ProgramAttributes */ {
        // Source: drake/solvers/program_attribute.h:39
        const char* doc = R"""()""";
      } ProgramAttributes;
      // Symbol: drake::solvers::QuadraticConstraint
      struct /* QuadraticConstraint */ {
        // Source: drake/solvers/constraint.h:186
        const char* doc =
R"""(lb ≤ .5 xᵀQx + bᵀx ≤ ub Without loss of generality, the class stores a
symmetric matrix Q. For a non-symmetric matrix Q₀, we can define Q =
(Q₀ + Q₀ᵀ) / 2, since xᵀQ₀x = xᵀQ₀ᵀx = xᵀ*(Q₀+Q₀ᵀ)/2 *x. The first
equality holds because the transpose of a scalar is the scalar itself.
Hence we can always convert a non-symmetric matrix Q₀ to a symmetric
matrix Q.)""";
        // Symbol: drake::solvers::QuadraticConstraint::Q
        struct /* Q */ {
          // Source: drake/solvers/constraint.h:217
          const char* doc =
R"""(The symmetric matrix Q, being the Hessian of this constraint.)""";
        } Q;
        // Symbol: drake::solvers::QuadraticConstraint::QuadraticConstraint
        struct /* ctor */ {
          // Source: drake/solvers/constraint.h:202
          const char* doc =
R"""(Construct a quadratic constraint.

Template parameter ``DerivedQ``:
    The type for Q.

Template parameter ``Derivedb``:
    The type for b.

Parameter ``Q0``:
    The square matrix. Notice that Q₀ does not have to be symmetric.

Parameter ``b``:
    The linear coefficient.

Parameter ``lb``:
    The lower bound.

Parameter ``ub``:
    The upper bound.)""";
        } ctor;
        // Symbol: drake::solvers::QuadraticConstraint::UpdateCoefficients
        struct /* UpdateCoefficients */ {
          // Source: drake/solvers/constraint.h:228
          const char* doc =
R"""(Updates the quadratic and linear term of the constraint. The new
matrices need to have the same dimension as before.

Parameter ``new_Q``:
    new quadratic term

Parameter ``new_b``:
    new linear term)""";
        } UpdateCoefficients;
        // Symbol: drake::solvers::QuadraticConstraint::b
        struct /* b */ {
          // Source: drake/solvers/constraint.h:219
          const char* doc = R"""()""";
        } b;
      } QuadraticConstraint;
      // Symbol: drake::solvers::QuadraticCost
      struct /* QuadraticCost */ {
        // Source: drake/solvers/cost.h:103
        const char* doc =
R"""(Implements a cost of the form

.. math:: .5 x'Qx + b'x + c

.)""";
        // Symbol: drake::solvers::QuadraticCost::Q
        struct /* Q */ {
          // Source: drake/solvers/cost.h:124
          const char* doc =
R"""(Returns the symmetric matrix Q, as the Hessian of the cost.)""";
        } Q;
        // Symbol: drake::solvers::QuadraticCost::QuadraticCost
        struct /* ctor */ {
          // Source: drake/solvers/cost.h:114
          const char* doc =
R"""(Constructs a cost of the form

.. math:: .5 x'Qx + b'x + c

.

Parameter ``Q``:
    Quadratic term.

Parameter ``b``:
    Linear term.

Parameter ``c``:
    (optional) Constant term.)""";
        } ctor;
        // Symbol: drake::solvers::QuadraticCost::UpdateCoefficients
        struct /* UpdateCoefficients */ {
          // Source: drake/solvers/cost.h:138
          const char* doc =
R"""(Updates the quadratic and linear term of the constraint. The new
matrices need to have the same dimension as before.

Parameter ``new_Q``:
    New quadratic term.

Parameter ``new_b``:
    New linear term.

Parameter ``new_c``:
    (optional) New constant term.)""";
        } UpdateCoefficients;
        // Symbol: drake::solvers::QuadraticCost::b
        struct /* b */ {
          // Source: drake/solvers/cost.h:126
          const char* doc = R"""()""";
        } b;
        // Symbol: drake::solvers::QuadraticCost::c
        struct /* c */ {
          // Source: drake/solvers/cost.h:128
          const char* doc = R"""()""";
        } c;
      } QuadraticCost;
      // Symbol: drake::solvers::QuadraticallySmoothedHingeLoss
      struct /* QuadraticallySmoothedHingeLoss */ {
        // Source: drake/solvers/minimum_value_constraint.h:47
        const char* doc =
R"""(A linear hinge loss, smoothed with a quadratic loss near the origin.
The formulation is in equation (6) of [1]. The penalty is <pre
class="unicode-art"> ⎧ 0 if x ≥ 0 φ(x) = ⎨ x²/2 if -1 < x < 0 ⎩ -0.5 -
x if x ≤ -1. </pre> [1] "Loss Functions for Preference Levels:
Regression with Discrete Ordered Labels." by Jason Rennie and Nathan
Srebro, Proceedings of IJCAI multidisciplinary workshop on Advances in
preference handling.)""";
      } QuadraticallySmoothedHingeLoss;
      // Symbol: drake::solvers::RemoveFreeVariableMethod
      struct /* RemoveFreeVariableMethod */ {
        // Source: drake/solvers/sdpa_free_format.h:461
        const char* doc =
R"""(SDPA format doesn't accept free variables, namely the problem it
solves is in this form P1

max tr(C * X) s.t tr(Aᵢ*X) = aᵢ X ≽ 0.

Notice that the decision variable X has to be in the proper cone X ≽
0, and it doesn't accept free variable (without the conic constraint).
On the other hand, most real-world applications require free
variables, namely problems in this form P2

max tr(C * X) + dᵀs s.t tr(Aᵢ*X) + bᵢᵀs = aᵢ X ≽ 0 s is free.

In order to remove the free variables, we consider three approaches.
1. Replace a free variable s with two variables s = p - q, p ≥ 0, q ≥
0. 2. First write the dual of the problem P2 as D2

min aᵀy s.t ∑ᵢ yᵢAᵢ - C = Z Z ≽ 0 Bᵀ * y = d,

where bᵢᵀ is the i'th row of B. The last constraint Bᵀ * y = d means y
= ŷ + Nt, where Bᵀ * ŷ = d, and N is the null space of Bᵀ. Hence, D2
is equivalent to the following problem, D3

min aᵀNt + aᵀŷ s.t ∑ᵢ tᵢFᵢ - (C -∑ᵢ ŷᵢAᵢ) = Z Z ≽ 0,

where Fᵢ = ∑ⱼ NⱼᵢAⱼ. D3 is the dual of the following primal problem P3
without free variables

max tr((C-∑ᵢ ŷᵢAᵢ)*X̂) + aᵀŷ s.t tr(FᵢX̂) = (Nᵀa)(i) X̂ ≽ 0.

Then (X, s) = (X̂, B⁻¹(a - tr(Aᵢ X̂))) is the solution to the original
problem P2. 3. Add a slack variable t, with the Lorentz cone
constraint t ≥ sqrt(sᵀs).)""";
        // Symbol: drake::solvers::RemoveFreeVariableMethod::kLorentzConeSlack
        struct /* kLorentzConeSlack */ {
          // Source: drake/solvers/sdpa_free_format.h:466
          const char* doc =
R"""(Approach 3, add a slack variable t with the lorentz cone constraint t
≥ sqrt(sᵀs).)""";
        } kLorentzConeSlack;
        // Symbol: drake::solvers::RemoveFreeVariableMethod::kNullspace
        struct /* kNullspace */ {
          // Source: drake/solvers/sdpa_free_format.h:464
          const char* doc =
R"""(Approach 2, reformulate the dual problem by considering the nullspace
of the linear constraint in the dual.)""";
        } kNullspace;
        // Symbol: drake::solvers::RemoveFreeVariableMethod::kTwoSlackVariables
        struct /* kTwoSlackVariables */ {
          // Source: drake/solvers/sdpa_free_format.h:462
          const char* doc =
R"""(Approach 1, replace a free variable s as s = y⁺ - y⁻, y⁺ ≥ 0, y⁻ ≥ 0.)""";
        } kTwoSlackVariables;
      } RemoveFreeVariableMethod;
      // Symbol: drake::solvers::ReplaceBilinearTerms
      struct /* ReplaceBilinearTerms */ {
        // Source: drake/solvers/bilinear_product_util.h:32
        const char* doc =
R"""(Replaces all the bilinear product terms in the expression ``e``, with
the corresponding terms in ``W``, where ``W`` represents the matrix x
* yᵀ, such that after replacement, ``e`` does not have bilinear terms
involving ``x`` and ``y``. For example, if e = x(0)*y(0) + 2 *
x(0)*y(1) + x(1) * y(1) + 3 * x(1), ``e`` has bilinear terms
x(0)*y(0), x(0) * y(1) and x(2) * y(1), if we call
ReplaceBilinearTerms(e, x, y, W) where W(i, j) represent the term x(i)
* y(j), then this function returns W(0, 0) + 2 * W(0, 1) + W(1, 1) + 3
* x(1).

Parameter ``e``:
    An expression potentially contains bilinear products between x and
    y.

Parameter ``x``:
    The bilinear product between ``x`` and ``y`` will be replaced by
    the corresponding term in ``W``.

Raises:
    RuntimeError if ``x`` contains duplicate entries.

Parameter ``y``:
    The bilinear product between ``x`` and ``y`` will be replaced by
    the corresponding term in ``W.

Raises:
    RuntimeError if `y`` contains duplicate entries.

Parameter ``W``:
    Bilinear product term x(i) * y(j) will be replaced by W(i, j). If
    W(i,j) is not a single variable, but an expression, then this
    expression cannot contain a variable in either x or y.

Raises:
    RuntimeError, if W(i, j) is not a single variable, and also
    contains a variable in x or y.

Returns:
    The symbolic expression after replacing x(i) * y(j) with W(i, j).)""";
      } ReplaceBilinearTerms;
      // Symbol: drake::solvers::RollPitchYawLimitOptions
      struct /* RollPitchYawLimitOptions */ {
        // Source: drake/solvers/rotation_constraint.h:48
        const char* doc = R"""()""";
        // Symbol: drake::solvers::RollPitchYawLimitOptions::kNoLimits
        struct /* kNoLimits */ {
          // Source: drake/solvers/rotation_constraint.h:49
          const char* doc = R"""()""";
        } kNoLimits;
        // Symbol: drake::solvers::RollPitchYawLimitOptions::kPitch_0_to_PI
        struct /* kPitch_0_to_PI */ {
          // Source: drake/solvers/rotation_constraint.h:54
          const char* doc = R"""()""";
        } kPitch_0_to_PI;
        // Symbol: drake::solvers::RollPitchYawLimitOptions::kPitch_0_to_PI_2
        struct /* kPitch_0_to_PI_2 */ {
          // Source: drake/solvers/rotation_constraint.h:58
          const char* doc = R"""()""";
        } kPitch_0_to_PI_2;
        // Symbol: drake::solvers::RollPitchYawLimitOptions::kPitch_NegPI_2_to_PI_2
        struct /* kPitch_NegPI_2_to_PI_2 */ {
          // Source: drake/solvers/rotation_constraint.h:53
          const char* doc = R"""()""";
        } kPitch_NegPI_2_to_PI_2;
        // Symbol: drake::solvers::RollPitchYawLimitOptions::kRPYError
        struct /* kRPYError */ {
          // Source: drake/solvers/rotation_constraint.h:50
          const char* doc = R"""(Do not use, to avoid & vs. && typos.)""";
        } kRPYError;
        // Symbol: drake::solvers::RollPitchYawLimitOptions::kRoll_0_to_PI
        struct /* kRoll_0_to_PI */ {
          // Source: drake/solvers/rotation_constraint.h:52
          const char* doc = R"""()""";
        } kRoll_0_to_PI;
        // Symbol: drake::solvers::RollPitchYawLimitOptions::kRoll_0_to_PI_2
        struct /* kRoll_0_to_PI_2 */ {
          // Source: drake/solvers/rotation_constraint.h:57
          const char* doc = R"""()""";
        } kRoll_0_to_PI_2;
        // Symbol: drake::solvers::RollPitchYawLimitOptions::kRoll_NegPI_2_to_PI_2
        struct /* kRoll_NegPI_2_to_PI_2 */ {
          // Source: drake/solvers/rotation_constraint.h:51
          const char* doc = R"""()""";
        } kRoll_NegPI_2_to_PI_2;
        // Symbol: drake::solvers::RollPitchYawLimitOptions::kYaw_0_to_PI
        struct /* kYaw_0_to_PI */ {
          // Source: drake/solvers/rotation_constraint.h:56
          const char* doc = R"""()""";
        } kYaw_0_to_PI;
        // Symbol: drake::solvers::RollPitchYawLimitOptions::kYaw_0_to_PI_2
        struct /* kYaw_0_to_PI_2 */ {
          // Source: drake/solvers/rotation_constraint.h:59
          const char* doc = R"""()""";
        } kYaw_0_to_PI_2;
        // Symbol: drake::solvers::RollPitchYawLimitOptions::kYaw_NegPI_2_to_PI_2
        struct /* kYaw_NegPI_2_to_PI_2 */ {
          // Source: drake/solvers/rotation_constraint.h:55
          const char* doc = R"""()""";
        } kYaw_NegPI_2_to_PI_2;
      } RollPitchYawLimitOptions;
      // Symbol: drake::solvers::RollPitchYawLimits
      struct /* RollPitchYawLimits */ {
        // Source: drake/solvers/rotation_constraint.h:61
        const char* doc = R"""()""";
      } RollPitchYawLimits;
      // Symbol: drake::solvers::RotatedLorentzConeConstraint
      struct /* RotatedLorentzConeConstraint */ {
        // Source: drake/solvers/constraint.h:361
        const char* doc =
R"""(Constraining that the linear expression :math:`z=Ax+b` lies within
rotated Lorentz cone. A vector z ∈ ℝ ⁿ lies within rotated Lorentz
cone, if

.. math:: z_0 \ge 0\
z_1 \ge 0\
z_0  z_1 \ge z_2^2 + z_3^2 + ... + z_{n-1}^2

where A ∈ ℝ ⁿˣᵐ, b ∈ ℝ ⁿ are given matrices.

For more information and visualization, please refer to
https://inst.eecs.berkeley.edu/~ee127a/book/login/l_socp_soc.html)""";
        // Symbol: drake::solvers::RotatedLorentzConeConstraint::A
        struct /* A */ {
          // Source: drake/solvers/constraint.h:378
          const char* doc = R"""(Getter for A.)""";
        } A;
        // Symbol: drake::solvers::RotatedLorentzConeConstraint::A_dense
        struct /* A_dense */ {
          // Source: drake/solvers/constraint.h:381
          const char* doc = R"""(Getter for dense version of A.)""";
        } A_dense;
        // Symbol: drake::solvers::RotatedLorentzConeConstraint::RotatedLorentzConeConstraint
        struct /* ctor */ {
          // Source: drake/solvers/constraint.h:363
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::solvers::RotatedLorentzConeConstraint::b
        struct /* b */ {
          // Source: drake/solvers/constraint.h:384
          const char* doc = R"""(Getter for b.)""";
        } b;
      } RotatedLorentzConeConstraint;
      // Symbol: drake::solvers::ScsSolver
      struct /* ScsSolver */ {
        // Source: drake/solvers/scs_solver.h:57
        const char* doc = R"""()""";
        // Symbol: drake::solvers::ScsSolver::Details
        struct /* Details */ {
          // Source: drake/solvers/scs_solver.h:62
          const char* doc =
R"""(Type of details stored in MathematicalProgramResult.)""";
        } Details;
        // Symbol: drake::solvers::ScsSolver::ProgramAttributesSatisfied
        struct /* ProgramAttributesSatisfied */ {
          // Source: drake/solvers/scs_solver.h:75
          const char* doc = R"""()""";
        } ProgramAttributesSatisfied;
        // Symbol: drake::solvers::ScsSolver::ScsSolver
        struct /* ctor */ {
          // Source: drake/solvers/scs_solver.h:59
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::solvers::ScsSolver::id
        struct /* id */ {
          // Source: drake/solvers/scs_solver.h:72
          const char* doc = R"""()""";
        } id;
        // Symbol: drake::solvers::ScsSolver::is_available
        struct /* is_available */ {
          // Source: drake/solvers/scs_solver.h:73
          const char* doc = R"""()""";
        } is_available;
        // Symbol: drake::solvers::ScsSolver::is_enabled
        struct /* is_enabled */ {
          // Source: drake/solvers/scs_solver.h:74
          const char* doc = R"""()""";
        } is_enabled;
      } ScsSolver;
      // Symbol: drake::solvers::ScsSolverDetails
      struct /* ScsSolverDetails */ {
        // Source: drake/solvers/scs_solver.h:13
        const char* doc =
R"""(The SCS solver details after calling Solve() function. The user can
call MathematicalProgramResult::get_solver_details<ScsSolver>() to
obtain the details.)""";
        // Symbol: drake::solvers::ScsSolverDetails::dual_objective
        struct /* dual_objective */ {
          // Source: drake/solvers/scs_solver.h:30
          const char* doc =
R"""(Dual objective value at termination. Equal to SCS_INFO.dobj)""";
        } dual_objective;
        // Symbol: drake::solvers::ScsSolverDetails::iter
        struct /* iter */ {
          // Source: drake/solvers/scs_solver.h:24
          const char* doc =
R"""(These are the information returned by SCS at termination, please refer
to "SCS_INFO" struct in
https://github.com/cvxgrp/scs/blob/master/include/scs.h Number of
iterations taken at termination. Equal to SCS_INFO.iter)""";
        } iter;
        // Symbol: drake::solvers::ScsSolverDetails::primal_objective
        struct /* primal_objective */ {
          // Source: drake/solvers/scs_solver.h:27
          const char* doc =
R"""(Primal objective value at termination. Equal to SCS_INFO.pobj)""";
        } primal_objective;
        // Symbol: drake::solvers::ScsSolverDetails::primal_residue
        struct /* primal_residue */ {
          // Source: drake/solvers/scs_solver.h:33
          const char* doc =
R"""(Primal equality residue. Equal to SCS_INFO.res_pri)""";
        } primal_residue;
        // Symbol: drake::solvers::ScsSolverDetails::relative_duality_gap
        struct /* relative_duality_gap */ {
          // Source: drake/solvers/scs_solver.h:42
          const char* doc =
R"""(relative duality gap. Equal to SCS_INFO.rel_gap.)""";
        } relative_duality_gap;
        // Symbol: drake::solvers::ScsSolverDetails::residue_infeasibility
        struct /* residue_infeasibility */ {
          // Source: drake/solvers/scs_solver.h:36
          const char* doc =
R"""(infeasibility certificate residue. Equal to SCS_INFO.res_infeas)""";
        } residue_infeasibility;
        // Symbol: drake::solvers::ScsSolverDetails::residue_unbounded
        struct /* residue_unbounded */ {
          // Source: drake/solvers/scs_solver.h:39
          const char* doc =
R"""(unbounded certificate residue. Equal to SCS_INFO.res_unbdd)""";
        } residue_unbounded;
        // Symbol: drake::solvers::ScsSolverDetails::s
        struct /* s */ {
          // Source: drake/solvers/scs_solver.h:54
          const char* doc =
R"""(The primal equality constraint slack, namely Ax + s = b where x is the
primal variable.)""";
        } s;
        // Symbol: drake::solvers::ScsSolverDetails::scs_setup_time
        struct /* scs_setup_time */ {
          // Source: drake/solvers/scs_solver.h:45
          const char* doc =
R"""(Time taken for SCS to setup in milliseconds. Equal to
SCS_INFO.setup_time.)""";
        } scs_setup_time;
        // Symbol: drake::solvers::ScsSolverDetails::scs_solve_time
        struct /* scs_solve_time */ {
          // Source: drake/solvers/scs_solver.h:48
          const char* doc =
R"""(Time taken for SCS to solve in millisecond. Equal to
SCS_INFO.solve_time.)""";
        } scs_solve_time;
        // Symbol: drake::solvers::ScsSolverDetails::scs_status
        struct /* scs_status */ {
          // Source: drake/solvers/scs_solver.h:18
          const char* doc =
R"""(The status of the solver at termination. Please refer to
https://github.com/cvxgrp/scs/blob/master/include/glbopts.h Note that
the SCS code on github master might be slightly more up-to-date than
the version used in Drake.)""";
        } scs_status;
        // Symbol: drake::solvers::ScsSolverDetails::y
        struct /* y */ {
          // Source: drake/solvers/scs_solver.h:51
          const char* doc =
R"""(The dual variable values at termination.)""";
        } y;
      } ScsSolverDetails;
      // Symbol: drake::solvers::SnoptSolver
      struct /* SnoptSolver */ {
        // Source: drake/solvers/snopt_solver.h:38
        const char* doc = R"""()""";
        // Symbol: drake::solvers::SnoptSolver::Details
        struct /* Details */ {
          // Source: drake/solvers/snopt_solver.h:43
          const char* doc =
R"""(Type of details stored in MathematicalProgramResult.)""";
        } Details;
        // Symbol: drake::solvers::SnoptSolver::ProgramAttributesSatisfied
        struct /* ProgramAttributesSatisfied */ {
          // Source: drake/solvers/snopt_solver.h:56
          const char* doc = R"""()""";
        } ProgramAttributesSatisfied;
        // Symbol: drake::solvers::SnoptSolver::SnoptSolver
        struct /* ctor */ {
          // Source: drake/solvers/snopt_solver.h:40
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::solvers::SnoptSolver::id
        struct /* id */ {
          // Source: drake/solvers/snopt_solver.h:53
          const char* doc = R"""()""";
        } id;
        // Symbol: drake::solvers::SnoptSolver::is_available
        struct /* is_available */ {
          // Source: drake/solvers/snopt_solver.h:54
          const char* doc = R"""()""";
        } is_available;
        // Symbol: drake::solvers::SnoptSolver::is_bounded_lp_broken
        struct /* is_bounded_lp_broken */ {
          // Source: drake/solvers/snopt_solver.h:49
          const char* doc =
R"""(For some reason, SNOPT 7.4 fails to detect a simple LP being
unbounded.)""";
        } is_bounded_lp_broken;
        // Symbol: drake::solvers::SnoptSolver::is_enabled
        struct /* is_enabled */ {
          // Source: drake/solvers/snopt_solver.h:55
          const char* doc = R"""()""";
        } is_enabled;
      } SnoptSolver;
      // Symbol: drake::solvers::SnoptSolverDetails
      struct /* SnoptSolverDetails */ {
        // Source: drake/solvers/snopt_solver.h:17
        const char* doc =
R"""(The SNOPT solver details after calling Solve() function. The user can
call MathematicalProgramResult::get_solver_details<SnoptSolver>() to
obtain the details.)""";
        // Symbol: drake::solvers::SnoptSolverDetails::F
        struct /* F */ {
          // Source: drake/solvers/snopt_solver.h:31
          const char* doc =
R"""(The final value of the vector of problem functions F(x).)""";
        } F;
        // Symbol: drake::solvers::SnoptSolverDetails::Fmul
        struct /* Fmul */ {
          // Source: drake/solvers/snopt_solver.h:35
          const char* doc =
R"""(The final value of the dual variables (Lagrange multipliers) for the
general constraints F_lower <= F(x) <= F_upper.)""";
        } Fmul;
        // Symbol: drake::solvers::SnoptSolverDetails::info
        struct /* info */ {
          // Source: drake/solvers/snopt_solver.h:23
          const char* doc =
R"""(The exit condition of the solver. Please refer to section "EXIT
conditions" in "User's Guide for SNOPT Version 7: Software for
Large-Scale Nonlinear Programming" by Philip E. Gill to interpret the
exit condition.)""";
        } info;
        // Symbol: drake::solvers::SnoptSolverDetails::xmul
        struct /* xmul */ {
          // Source: drake/solvers/snopt_solver.h:28
          const char* doc =
R"""(The final value of the dual variables for the bound constraint x_lower
<= x <= x_upper.)""";
        } xmul;
      } SnoptSolverDetails;
      // Symbol: drake::solvers::SolutionResult
      struct /* SolutionResult */ {
        // Source: drake/solvers/solution_result.h:8
        const char* doc = R"""()""";
        // Symbol: drake::solvers::SolutionResult::kDualInfeasible
        struct /* kDualInfeasible */ {
          // Source: drake/solvers/solution_result.h:17
          const char* doc =
R"""(Dual problem is infeasible. In this case we cannot)""";
        } kDualInfeasible;
        // Symbol: drake::solvers::SolutionResult::kInfeasibleConstraints
        struct /* kInfeasibleConstraints */ {
          // Source: drake/solvers/solution_result.h:11
          const char* doc = R"""(The primal is infeasible.)""";
        } kInfeasibleConstraints;
        // Symbol: drake::solvers::SolutionResult::kInfeasible_Or_Unbounded
        struct /* kInfeasible_Or_Unbounded */ {
          // Source: drake/solvers/solution_result.h:14
          const char* doc = R"""()""";
        } kInfeasible_Or_Unbounded;
        // Symbol: drake::solvers::SolutionResult::kInvalidInput
        struct /* kInvalidInput */ {
          // Source: drake/solvers/solution_result.h:10
          const char* doc = R"""(Invalid input.)""";
        } kInvalidInput;
        // Symbol: drake::solvers::SolutionResult::kIterationLimit
        struct /* kIterationLimit */ {
          // Source: drake/solvers/solution_result.h:16
          const char* doc = R"""(Reaches the iteration limits.)""";
        } kIterationLimit;
        // Symbol: drake::solvers::SolutionResult::kSolutionFound
        struct /* kSolutionFound */ {
          // Source: drake/solvers/solution_result.h:9
          const char* doc = R"""(Found the optimal solution.)""";
        } kSolutionFound;
        // Symbol: drake::solvers::SolutionResult::kUnbounded
        struct /* kUnbounded */ {
          // Source: drake/solvers/solution_result.h:12
          const char* doc = R"""(The primal is unbounded.)""";
        } kUnbounded;
        // Symbol: drake::solvers::SolutionResult::kUnknownError
        struct /* kUnknownError */ {
          // Source: drake/solvers/solution_result.h:13
          const char* doc = R"""(Unknown error.)""";
        } kUnknownError;
      } SolutionResult;
      // Symbol: drake::solvers::Solve
      struct /* Solve */ {
        // Source: drake/solvers/solve.h:24
        const char* doc_3args =
R"""(Solves an optimization program, with optional initial guess and solver
options. This function first chooses the best solver depending on the
availability of the solver and the program formulation; it then
constructs that solver and call the Solve function of that solver. The
optimization result is stored in the return argument.

Parameter ``prog``:
    Contains the formulation of the program, and possibly solver
    options.

Parameter ``initial_guess``:
    The initial guess for the decision variables.

Parameter ``solver_options``:
    The options in addition to those stored in ``prog``.

Returns:
    result The result of solving the program through the solver.)""";
        // Source: drake/solvers/solve.h:32
        const char* doc_2args =
R"""(Solves an optimization program with a given initial guess.)""";
      } Solve;
      // Symbol: drake::solvers::SolverBase
      struct /* SolverBase */ {
        // Source: drake/solvers/solver_base.h:19
        const char* doc =
R"""(Abstract base class used by implementations of individual solvers.)""";
        // Symbol: drake::solvers::SolverBase::AreProgramAttributesSatisfied
        struct /* AreProgramAttributesSatisfied */ {
          // Source: drake/solvers/solver_base.h:39
          const char* doc = R"""()""";
        } AreProgramAttributesSatisfied;
        // Symbol: drake::solvers::SolverBase::DoSolve
        struct /* DoSolve */ {
          // Source: drake/solvers/solver_base.h:60
          const char* doc =
R"""(Hook for subclasses to implement Solve. Prior to the SolverBase's call
to this method, the solver's availability and capabilities vs the
program attributes have already been checked, and the result's
set_solver_id() and set_decision_variable_index() have already been
set. The options and initial guess are already merged, i.e., the
DoSolve implementation should ignore prog's solver options and prog's
initial guess.)""";
        } DoSolve;
        // Symbol: drake::solvers::SolverBase::Solve
        struct /* Solve */ {
          // Source: drake/solvers/solver_base.h:27
          const char* doc =
R"""(Like SolverInterface::Solve(), but the result is a return value
instead of an output argument.)""";
        } Solve;
        // Symbol: drake::solvers::SolverBase::SolverBase
        struct /* ctor */ {
          // Source: drake/solvers/solver_base.h:48
          const char* doc =
R"""(Constructs a SolverBase with the given default implementations of the
solver_id(), available(), enabled(), and
AreProgramAttributesSatisfied() methods. (Typically, the subclass will
just pass the address of its static method, e.g. ``&id``, for these
functors.) Any of the functors can be nullptr, in which case the
subclass should override the virtual method instead.)""";
        } ctor;
        // Symbol: drake::solvers::SolverBase::available
        struct /* available */ {
          // Source: drake/solvers/solver_base.h:36
          const char* doc = R"""()""";
        } available;
        // Symbol: drake::solvers::SolverBase::enabled
        struct /* enabled */ {
          // Source: drake/solvers/solver_base.h:37
          const char* doc = R"""()""";
        } enabled;
        // Symbol: drake::solvers::SolverBase::solver_id
        struct /* solver_id */ {
          // Source: drake/solvers/solver_base.h:38
          const char* doc = R"""()""";
        } solver_id;
      } SolverBase;
      // Symbol: drake::solvers::SolverId
      struct /* SolverId */ {
        // Source: drake/solvers/solver_id.h:18
        const char* doc =
R"""(Identifies a SolverInterface implementation.

A moved-from instance is guaranteed to be empty and will not compare
equal to any non-empty ID.)""";
        // Symbol: drake::solvers::SolverId::SolverId
        struct /* ctor */ {
          // Source: drake/solvers/solver_id.h:28
          const char* doc =
R"""(Constructs a specific, known solver type. Internally, a hidden
identifier is allocated and assigned to this instance; all instances
that share an identifier (including copies of this instance) are
considered equal. The solver names are not enforced to be unique,
though we recommend that they remain so in practice.)""";
        } ctor;
        // Symbol: drake::solvers::SolverId::name
        struct /* name */ {
          // Source: drake/solvers/solver_id.h:30
          const char* doc = R"""()""";
        } name;
      } SolverId;
      // Symbol: drake::solvers::SolverInterface
      struct /* SolverInterface */ {
        // Source: drake/solvers/solver_interface.h:18
        const char* doc =
R"""(Interface used by implementations of individual solvers.)""";
        // Symbol: drake::solvers::SolverInterface::AreProgramAttributesSatisfied
        struct /* AreProgramAttributesSatisfied */ {
          // Source: drake/solvers/solver_interface.h:49
          const char* doc =
R"""(Returns true if the program attributes are satisfied by the solver's
capability.)""";
        } AreProgramAttributesSatisfied;
        // Symbol: drake::solvers::SolverInterface::Solve
        struct /* Solve */ {
          // Source: drake/solvers/solver_interface.h:39
          const char* doc =
R"""(Solves an optimization program with optional initial guess and solver
options. Note that these initial guess and solver options are not
written to ``prog``. If the ``prog`` has set an option for a solver,
and ``solver_options`` contains a different value for the same option
on the same solver, then ``solver_options`` takes priority.)""";
        } Solve;
        // Symbol: drake::solvers::SolverInterface::SolverInterface
        struct /* ctor */ {
          // Source: drake/solvers/solver_interface.h:20
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::solvers::SolverInterface::available
        struct /* available */ {
          // Source: drake/solvers/solver_interface.h:26
          const char* doc =
R"""(Returns true iff this solver was enabled at compile-time. Certain
solvers may be excluded at compile-time due to licensing or linking
restrictions. When this method returns false, the Solve method will
throw.)""";
        } available;
        // Symbol: drake::solvers::SolverInterface::enabled
        struct /* enabled */ {
          // Source: drake/solvers/solver_interface.h:31
          const char* doc =
R"""(Returns true iff this solver is enabled at runtime. The toggle
mechanism is specific to the solver in question, but typically uses an
environment variable. When this method returns false, the Solve method
will throw.)""";
        } enabled;
        // Symbol: drake::solvers::SolverInterface::solver_id
        struct /* solver_id */ {
          // Source: drake/solvers/solver_interface.h:45
          const char* doc = R"""(Returns the identifier of this solver.)""";
        } solver_id;
      } SolverInterface;
      // Symbol: drake::solvers::SolverOptions
      struct /* SolverOptions */ {
        // Source: drake/solvers/solver_options.h:47
        const char* doc =
R"""(Stores options for multiple solvers. This interface does not do any
verification of solver parameters. It does not even verify that the
specified solver exists. Use this only when you have particular
knowledge of what solver is being invoked, and exactly what tuning is
required.

Supported solver names/options:

"SNOPT" -- Parameter names and values as specified in SNOPT User's
Guide section 7.7 "Description of the optional parameters", used as
described in section 7.5 for snSet(). The SNOPT user guide can be
obtained from https://web.stanford.edu/group/SOL/guides/sndoc7.pdf

"IPOPT" -- Parameter names and values as specified in IPOPT users
guide section "Options Reference"
http://www.coin-or.org/Ipopt/documentation/node40.html

"GUROBI" -- Parameter name and values as specified in Gurobi Reference
Manual, section 10.2 "Parameter Descriptions"
https://www.gurobi.com/documentation/9.0/refman/parameters.html

"SCS" -- Parameter name and values as specified in the struct
SCS_SETTINGS in SCS header file
https://github.com/cvxgrp/scs/blob/master/include/scs.h Note that the
SCS code on github master might be more up-to-date than the version
used in Drake.

"MOSEK" -- Parameter name and values as specified in Mosek Reference
https://docs.mosek.com/9.2/capi/parameters.html)""";
        // Symbol: drake::solvers::SolverOptions::CheckOptionKeysForSolver
        struct /* CheckOptionKeysForSolver */ {
          // Source: drake/solvers/solver_options.h:132
          const char* doc =
R"""(Check if for a given solver_id, the option keys are included in
double_keys, int_keys and str_keys.

Parameter ``solver_id``:
    If this SolverOptions has set options for this solver_id, then we
    check if the option keys are a subset of ``double_keys``,
    `int_keys` and ``str_keys``.

Parameter ``double_keys``:
    The set of allowable keys for double options.

Parameter ``int_keys``:
    The set of allowable keys for int options.

Parameter ``str_keys``:
    The set of allowable keys for string options.

Raises:
    invalid_argument if the solver contains un-allowed options.)""";
        } CheckOptionKeysForSolver;
        // Symbol: drake::solvers::SolverOptions::GetOptions
        struct /* GetOptions */ {
          // Source: drake/solvers/solver_options.h:88
          const char* doc = R"""()""";
        } GetOptions;
        // Symbol: drake::solvers::SolverOptions::GetOptionsDouble
        struct /* GetOptionsDouble */ {
          // Source: drake/solvers/solver_options.h:68
          const char* doc = R"""()""";
        } GetOptionsDouble;
        // Symbol: drake::solvers::SolverOptions::GetOptionsInt
        struct /* GetOptionsInt */ {
          // Source: drake/solvers/solver_options.h:71
          const char* doc = R"""()""";
        } GetOptionsInt;
        // Symbol: drake::solvers::SolverOptions::GetOptionsStr
        struct /* GetOptionsStr */ {
          // Source: drake/solvers/solver_options.h:74
          const char* doc = R"""()""";
        } GetOptionsStr;
        // Symbol: drake::solvers::SolverOptions::GetSolverIds
        struct /* GetSolverIds */ {
          // Source: drake/solvers/solver_options.h:101
          const char* doc =
R"""(Returns the IDs that have any option set.)""";
        } GetSolverIds;
        // Symbol: drake::solvers::SolverOptions::Merge
        struct /* Merge */ {
          // Source: drake/solvers/solver_options.h:108
          const char* doc =
R"""(Merges the other solver options into this. If ``other`` and ``this``
option both define the same option for the same solver, we ignore then
one from ``other`` and keep the one from ``this``.)""";
        } Merge;
        // Symbol: drake::solvers::SolverOptions::SetOption
        struct /* SetOption */ {
          // Source: drake/solvers/solver_options.h:65
          const char* doc =
R"""(Set common options for all solvers supporting that option (for
example, printing the progress in each iteration). If the solver
doesn't support the option, the option is ignored.)""";
        } SetOption;
        // Symbol: drake::solvers::SolverOptions::SolverOptions
        struct /* ctor */ {
          // Source: drake/solvers/solver_options.h:49
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::solvers::SolverOptions::common_solver_options
        struct /* common_solver_options */ {
          // Source: drake/solvers/solver_options.h:83
          const char* doc =
R"""(Gets the common options for all solvers. Refer to CommonSolverOption
for more details.)""";
        } common_solver_options;
        // Symbol: drake::solvers::SolverOptions::operator!=
        struct /* operator_ne */ {
          // Source: drake/solvers/solver_options.h:119
          const char* doc = R"""(Negate operator==.)""";
        } operator_ne;
      } SolverOptions;
      // Symbol: drake::solvers::SolverType
      struct /* SolverType */ {
        // Source: drake/solvers/solver_type.h:6
        const char* doc = R"""()""";
        // Symbol: drake::solvers::SolverType::kCsdp
        struct /* kCsdp */ {
          // Source: drake/solvers/solver_type.h:7
          const char* doc = R"""()""";
        } kCsdp;
        // Symbol: drake::solvers::SolverType::kDReal
        struct /* kDReal */ {
          // Source: drake/solvers/solver_type.h:8
          const char* doc = R"""()""";
        } kDReal;
        // Symbol: drake::solvers::SolverType::kEqualityConstrainedQP
        struct /* kEqualityConstrainedQP */ {
          // Source: drake/solvers/solver_type.h:9
          const char* doc = R"""()""";
        } kEqualityConstrainedQP;
        // Symbol: drake::solvers::SolverType::kGurobi
        struct /* kGurobi */ {
          // Source: drake/solvers/solver_type.h:10
          const char* doc = R"""()""";
        } kGurobi;
        // Symbol: drake::solvers::SolverType::kIpopt
        struct /* kIpopt */ {
          // Source: drake/solvers/solver_type.h:11
          const char* doc = R"""()""";
        } kIpopt;
        // Symbol: drake::solvers::SolverType::kLinearSystem
        struct /* kLinearSystem */ {
          // Source: drake/solvers/solver_type.h:12
          const char* doc = R"""()""";
        } kLinearSystem;
        // Symbol: drake::solvers::SolverType::kMobyLCP
        struct /* kMobyLCP */ {
          // Source: drake/solvers/solver_type.h:13
          const char* doc = R"""()""";
        } kMobyLCP;
        // Symbol: drake::solvers::SolverType::kMosek
        struct /* kMosek */ {
          // Source: drake/solvers/solver_type.h:14
          const char* doc = R"""()""";
        } kMosek;
        // Symbol: drake::solvers::SolverType::kNlopt
        struct /* kNlopt */ {
          // Source: drake/solvers/solver_type.h:15
          const char* doc = R"""()""";
        } kNlopt;
        // Symbol: drake::solvers::SolverType::kOsqp
        struct /* kOsqp */ {
          // Source: drake/solvers/solver_type.h:16
          const char* doc = R"""()""";
        } kOsqp;
        // Symbol: drake::solvers::SolverType::kScs
        struct /* kScs */ {
          // Source: drake/solvers/solver_type.h:18
          const char* doc = R"""()""";
        } kScs;
        // Symbol: drake::solvers::SolverType::kSnopt
        struct /* kSnopt */ {
          // Source: drake/solvers/solver_type.h:17
          const char* doc = R"""()""";
        } kSnopt;
        // Symbol: drake::solvers::SolverType::kUnrevisedLemke
        struct /* kUnrevisedLemke */ {
          // Source: drake/solvers/solver_type.h:19
          const char* doc = R"""()""";
        } kUnrevisedLemke;
      } SolverType;
      // Symbol: drake::solvers::SolverTypeConverter
      struct /* SolverTypeConverter */ {
        // Source: drake/solvers/solver_type_converter.h:13
        const char* doc =
R"""(Converts between SolverType and SolverId.)""";
        // Symbol: drake::solvers::SolverTypeConverter::IdToType
        struct /* IdToType */ {
          // Source: drake/solvers/solver_type_converter.h:24
          const char* doc =
R"""(Converts the given ID to its matching type, iff the type matches one
of SolverType's known values.)""";
        } IdToType;
        // Symbol: drake::solvers::SolverTypeConverter::SolverTypeConverter
        struct /* ctor */ {
          // Source: drake/solvers/solver_type_converter.h:15
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::solvers::SolverTypeConverter::TypeToId
        struct /* TypeToId */ {
          // Source: drake/solvers/solver_type_converter.h:20
          const char* doc =
R"""(Converts the given type to its matching ID.)""";
        } TypeToId;
      } SolverTypeConverter;
      // Symbol: drake::solvers::SystemIdentification
      struct /* SystemIdentification */ {
        // Source: drake/solvers/system_identification.h:41
        const char* doc =
R"""(Utility functions for system identification.

This class is a holder for templated utility methods. It should not be
constructed. It must be template-instantiated (in its cpp file) for
each supported variant of Polynomial (currently only
Polynomial<double>).

For the purposes of system identification we require here that the set
of variables in a polynomial can be divided into two groups:

* "Parameter variables" are unchanged through many evaluations of the
Polynomial and so may be factored and renamed (lumped) at will. In
effect parameter variables are treated as constants.

* "Active variables" are those that may vary between evaluations of
the Polynomial, for instance because they are inputs or state
variables of the system.

Note:
    The term "system identification" used throughout here refers to
    the process of simplifying the equations defining a physical
    system to a minimum number of "lumped" parameters and then
    estimating the values of those parameters based on empirical data.)""";
        // Symbol: drake::solvers::SystemIdentification::EstimateParameters
        struct /* EstimateParameters */ {
          // Source: drake/solvers/system_identification.h:109
          const char* doc =
R"""(Estimate some parameters of a polynomial based on empirical data.

Given one or more polynomial equations P[i](a, b, ... x, y, ...) = 0,
and measured values of some its arguments (x, y, ..., referred to as
the "active variables"), estimate values for the remaining arguments
(a, b, ..., referred to as the "parameters").

Measured x, y, ... is provided in a list of maps, active_var_values.

The return value is a pair, {estimates, error}, where: * estimates is
a map of polynomial VarTypes (a, b, ...) to their estimated values,
suitable as input for Polynomial::evaluatePartial. * error is the
root-mean-square error of the estimates.)""";
        } EstimateParameters;
        // Symbol: drake::solvers::SystemIdentification::GetLumpedParametersFromPolynomial
        struct /* GetLumpedParametersFromPolynomial */ {
          // Source: drake/solvers/system_identification.h:68
          const char* doc =
R"""(Extract lumped parameters from a given polynomial.

Given a Polynomial, poly, and a set of variables of poly that should
be treated as parameters (that is, variables eligible to be lumped),
obtain all of the unique expressions by which combinations of the
remaining active variables are multiplied to form the monomials of the
Polynomial.

For instance, if we have the polynomial: a*x + b*x + a*c*y + a*c*y**2
And our parameters are a, b, and c, then our lumped parameters are:
lump1 == a+b ; lump2 == a*c and we return: { (a + b) ->
VarType("lump", 1); (a * c) -> VarType("lump", 2) }

Note however that this function provides no guarantees of the lumped
parameter names generated except that they are unique -- "lump1" and
"lump2" here are examples.)""";
        } GetLumpedParametersFromPolynomial;
        // Symbol: drake::solvers::SystemIdentification::GetLumpedParametersFromPolynomials
        struct /* GetLumpedParametersFromPolynomials */ {
          // Source: drake/solvers/system_identification.h:78
          const char* doc =
R"""(Same as GetLumpedParametersFromPolynomial but for multiple
Polynomials.

It is preferable to use this if you have multiple Polynomials as it
saves you from having to union the resulting LumpingMapType results
together.)""";
        } GetLumpedParametersFromPolynomials;
        // Symbol: drake::solvers::SystemIdentification::LumpedSystemIdentification
        struct /* LumpedSystemIdentification */ {
          // Source: drake/solvers/system_identification.h:148
          const char* doc =
R"""(Performs full lumped-parameter identification of a system of
TrigPolys.

This is a convenience method meant to capture what is expected to be
the most common usage pattern of system ID.

Given one or more TrigPoly expressions to be set equal to zero, and a
list of observed values for a subset of the variables, lumps up the
remaining variables into lumped parameters and estimates a value for
each of those. This is broadly equivalent to calling the following
methods in sequence:

* GetLumpedParametersFromPolynomials *
RewritePolynomialWithLumpedParameters * EstimateParameters)""";
        } LumpedSystemIdentification;
        // Symbol: drake::solvers::SystemIdentification::LumpingMapType
        struct /* LumpingMapType */ {
          // Source: drake/solvers/system_identification.h:47
          const char* doc = R"""()""";
        } LumpingMapType;
        // Symbol: drake::solvers::SystemIdentification::MonomialType
        struct /* MonomialType */ {
          // Source: drake/solvers/system_identification.h:44
          const char* doc = R"""()""";
        } MonomialType;
        // Symbol: drake::solvers::SystemIdentification::PartialEvalType
        struct /* PartialEvalType */ {
          // Source: drake/solvers/system_identification.h:48
          const char* doc = R"""()""";
        } PartialEvalType;
        // Symbol: drake::solvers::SystemIdentification::PolyType
        struct /* PolyType */ {
          // Source: drake/solvers/system_identification.h:43
          const char* doc = R"""()""";
        } PolyType;
        // Symbol: drake::solvers::SystemIdentification::RewritePolynomialWithLumpedParameters
        struct /* RewritePolynomialWithLumpedParameters */ {
          // Source: drake/solvers/system_identification.h:91
          const char* doc =
R"""(Rewrite a Polynomial in terms of lumped parameters.

For instance, if we have the polynomial: a*x + b*x + a*c*y + a*c*y**2
And our lumped parameters are: lump1 == a+b ; lump2 == a*c And our
polynomial is now: lump1*x + lump2*y + lump2*y**2)""";
        } RewritePolynomialWithLumpedParameters;
        // Symbol: drake::solvers::SystemIdentification::SystemIdentificationResult
        struct /* SystemIdentificationResult */ {
          // Source: drake/solvers/system_identification.h:114
          const char* doc =
R"""(A helper struct to hold System ID results)""";
          // Symbol: drake::solvers::SystemIdentification::SystemIdentificationResult::lumped_parameter_values
          struct /* lumped_parameter_values */ {
            // Source: drake/solvers/system_identification.h:123
            const char* doc =
R"""(The estimated value for each lumped parameter.)""";
          } lumped_parameter_values;
          // Symbol: drake::solvers::SystemIdentification::SystemIdentificationResult::lumped_parameters
          struct /* lumped_parameters */ {
            // Source: drake/solvers/system_identification.h:116
            const char* doc =
R"""(The lumped parameters that were used in system ID.)""";
          } lumped_parameters;
          // Symbol: drake::solvers::SystemIdentification::SystemIdentificationResult::lumped_polys
          struct /* lumped_polys */ {
            // Source: drake/solvers/system_identification.h:120
            const char* doc =
R"""(The input polynomials, rewritten using the lumped parameters so that
only active variable and first-order lumped variable terms remain.)""";
          } lumped_polys;
          // Symbol: drake::solvers::SystemIdentification::SystemIdentificationResult::partially_evaluated_polys
          struct /* partially_evaluated_polys */ {
            // Source: drake/solvers/system_identification.h:127
            const char* doc =
R"""(The input polynomials, with all estimates substituted in so that only
active variables remain.)""";
          } partially_evaluated_polys;
          // Symbol: drake::solvers::SystemIdentification::SystemIdentificationResult::rms_error
          struct /* rms_error */ {
            // Source: drake/solvers/system_identification.h:130
            const char* doc =
R"""(The root-mean-square error of the estimation step.)""";
          } rms_error;
        } SystemIdentificationResult;
        // Symbol: drake::solvers::SystemIdentification::TermType
        struct /* TermType */ {
          // Source: drake/solvers/system_identification.h:45
          const char* doc = R"""()""";
        } TermType;
        // Symbol: drake::solvers::SystemIdentification::VarType
        struct /* VarType */ {
          // Source: drake/solvers/system_identification.h:46
          const char* doc = R"""()""";
        } VarType;
      } SystemIdentification;
      // Symbol: drake::solvers::UnrevisedLemkeSolver
      struct /* UnrevisedLemkeSolver */ {
        // Source: drake/solvers/unrevised_lemke_solver.h:37
        const char* doc =
R"""(A class for the Unrevised Implementation of Lemke Algorithm's for
solving Linear Complementarity Problems (LCPs). See MobyLcpSolver for
a description of LCPs. This code makes extensive use of the following
document: [Dai 2018] Dai, H. and Drumwright, E. Computing the
Principal Pivoting Transform for Solving Linear Complementarity
Problems with Lemke's Algorithm. (2018, located in
doc/pivot_column.pdf).)""";
        // Symbol: drake::solvers::UnrevisedLemkeSolver::ComputeZeroTolerance
        struct /* ComputeZeroTolerance */ {
          // Source: drake/solvers/unrevised_lemke_solver.h:47
          const char* doc =
R"""(Calculates the zero tolerance that the solver would compute if the
user does not specify a tolerance.)""";
        } ComputeZeroTolerance;
        // Symbol: drake::solvers::UnrevisedLemkeSolver::IsSolution
        struct /* IsSolution */ {
          // Source: drake/solvers/unrevised_lemke_solver.h:55
          const char* doc =
R"""(Checks whether a given candidate solution to the LCP Mz + q = w, z ≥
0, w ≥ 0, zᵀw = 0 is satisfied to a given tolerance. If the tolerance
is non-positive, this method computes a reasonable tolerance using M.)""";
        } IsSolution;
        // Symbol: drake::solvers::UnrevisedLemkeSolver::ProgramAttributesSatisfied
        struct /* ProgramAttributesSatisfied */ {
          // Source: drake/solvers/unrevised_lemke_solver.h:97
          const char* doc = R"""()""";
        } ProgramAttributesSatisfied;
        // Symbol: drake::solvers::UnrevisedLemkeSolver::SolveLcpLemke
        struct /* SolveLcpLemke */ {
          // Source: drake/solvers/unrevised_lemke_solver.h:88
          const char* doc =
R"""(Lemke's Algorithm for solving LCPs in the matrix class E, which
contains all strictly semimonotone matrices, all P-matrices, and all
strictly copositive matrices. The solver can be applied with
occasional success to problems outside of its guaranteed matrix
classes. Lemke's Algorithm is described in [Cottle 1992], Section 4.4.

The solver will denote failure on return if it exceeds a problem-size
dependent number of iterations.

Parameter ``M``:
    the LCP matrix.

Parameter ``q``:
    the LCP vector.

Parameter ``z``:
    the solution to the LCP on return (if the solver succeeds). If the
    length of z is equal to the length of q, the solver will attempt
    to use the basis from the last solution. This strategy can prove
    exceptionally fast if solutions differ little between successive
    calls. If the solver fails (returns ``False``), `z` will be set to
    the zero vector on return.

Parameter ``num_pivots``:
    the number of pivots used, on return.

Parameter ``zero_tol``:
    The tolerance for testing against zero. If the tolerance is
    negative (default) the solver will determine a generally
    reasonable tolerance.

Returns:
    ``True`` if the solver computes a solution to floating point
    tolerances (i.e., if IsSolution() returns ``True`` on the problem)
    and ``False`` otherwise.

Raises:
    RuntimeError if M is not square or the dimensions of M do not
    match the length of q.

* [Cottle 1992]      R. Cottle, J.-S. Pang, and R. Stone. The Linear
                     Complementarity Problem. Academic Press, 1992.)""";
        } SolveLcpLemke;
        // Symbol: drake::solvers::UnrevisedLemkeSolver::UnrevisedLemkeSolver<T>
        struct /* ctor */ {
          // Source: drake/solvers/unrevised_lemke_solver.h:39
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::solvers::UnrevisedLemkeSolver::id
        struct /* id */ {
          // Source: drake/solvers/unrevised_lemke_solver.h:94
          const char* doc = R"""()""";
        } id;
        // Symbol: drake::solvers::UnrevisedLemkeSolver::is_available
        struct /* is_available */ {
          // Source: drake/solvers/unrevised_lemke_solver.h:95
          const char* doc = R"""()""";
        } is_available;
        // Symbol: drake::solvers::UnrevisedLemkeSolver::is_enabled
        struct /* is_enabled */ {
          // Source: drake/solvers/unrevised_lemke_solver.h:96
          const char* doc = R"""()""";
        } is_enabled;
      } UnrevisedLemkeSolver;
      // Symbol: drake::solvers::UnrevisedLemkeSolverId
      struct /* UnrevisedLemkeSolverId */ {
        // Source: drake/solvers/unrevised_lemke_solver.h:21
        const char* doc =
R"""(Non-template class for UnrevisedLemkeSolver<T> constants.)""";
        // Symbol: drake::solvers::UnrevisedLemkeSolverId::UnrevisedLemkeSolverId
        struct /* ctor */ {
          // Source: drake/solvers/unrevised_lemke_solver.h:23
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::solvers::UnrevisedLemkeSolverId::id
        struct /* id */ {
          // Source: drake/solvers/unrevised_lemke_solver.h:27
          const char* doc =
R"""(Returns:
    same as SolverInterface::solver_id())""";
        } id;
      } UnrevisedLemkeSolverId;
      // Symbol: drake::solvers::VariableRefList
      struct /* VariableRefList */ {
        // Source: drake/solvers/decision_variable.h:22
        const char* doc = R"""()""";
      } VariableRefList;
      // Symbol: drake::solvers::VectorXDecisionVariable
      struct /* VectorXDecisionVariable */ {
        // Source: drake/solvers/decision_variable.h:20
        const char* doc = R"""()""";
      } VectorXDecisionVariable;
      // Symbol: drake::solvers::VectorXIndeterminate
      struct /* VectorXIndeterminate */ {
        // Source: drake/solvers/indeterminate.h:42
        const char* doc =
R"""(VectorXIndeterminate is used as an alias for
Eigen::Matrix<symbolic::Variable, Eigen::Dynamic, 1>.

See also:
    MatrixIndeterminate<int, int>)""";
      } VectorXIndeterminate;
      // Symbol: drake::solvers::VisualizationCallback
      struct /* VisualizationCallback */ {
        // Source: drake/solvers/evaluator_base.h:346
        const char* doc =
R"""(Defines a simple evaluator with no outputs that takes a callback
function pointer. This is intended for debugging / visualization of
intermediate results during an optimization (for solvers that support
it).)""";
        // Symbol: drake::solvers::VisualizationCallback::CallbackFunction
        struct /* CallbackFunction */ {
          // Source: drake/solvers/evaluator_base.h:351
          const char* doc = R"""()""";
        } CallbackFunction;
        // Symbol: drake::solvers::VisualizationCallback::EvalCallback
        struct /* EvalCallback */ {
          // Source: drake/solvers/evaluator_base.h:357
          const char* doc = R"""()""";
        } EvalCallback;
        // Symbol: drake::solvers::VisualizationCallback::VisualizationCallback
        struct /* ctor */ {
          // Source: drake/solvers/evaluator_base.h:348
          const char* doc = R"""()""";
        } ctor;
      } VisualizationCallback;
      // Symbol: drake::solvers::fbstab
      struct /* fbstab */ {
        // Symbol: drake::solvers::fbstab::DenseData
        struct /* DenseData */ {
          // Source: drake/solvers/fbstab/components/dense_data.h:19
          const char* doc =
R"""(Represents data for quadratic programming problems of the following
type (1):

min. 1/2 z'Hz + f'z s.t. Az <= b

where H is symmetric and positive semidefinite.)""";
          // Symbol: drake::solvers::fbstab::DenseData::A
          struct /* A */ {
            // Source: drake/solvers/fbstab/components/dense_data.h:44
            const char* doc = R"""(Read only accessor for the A matrix.)""";
          } A;
          // Symbol: drake::solvers::fbstab::DenseData::DenseData
          struct /* ctor */ {
            // Source: drake/solvers/fbstab/components/dense_data.h:34
            const char* doc =
R"""(Stores the problem data and performs input validation. This class
assumes that the pointers to the data remain valid.

Parameter ``H``:
    Hessian matrix

Parameter ``f``:
    Linear term

Parameter ``A``:
    Constraint matrix

Parameter ``b``:
    Constraint vector

Throws a runtime exception if any of the inputs are null or if the
sizes of the inputs are inconsistent.)""";
          } ctor;
          // Symbol: drake::solvers::fbstab::DenseData::H
          struct /* H */ {
            // Source: drake/solvers/fbstab/components/dense_data.h:38
            const char* doc = R"""(Read only accessor for the H matrix.)""";
          } H;
          // Symbol: drake::solvers::fbstab::DenseData::b
          struct /* b */ {
            // Source: drake/solvers/fbstab/components/dense_data.h:47
            const char* doc = R"""(Read only accessor for the b vector.)""";
          } b;
          // Symbol: drake::solvers::fbstab::DenseData::f
          struct /* f */ {
            // Source: drake/solvers/fbstab/components/dense_data.h:41
            const char* doc = R"""(Read only accessor for the f vector.)""";
          } f;
          // Symbol: drake::solvers::fbstab::DenseData::num_constraints
          struct /* num_constraints */ {
            // Source: drake/solvers/fbstab/components/dense_data.h:56
            const char* doc =
R"""(Returns:
    number of inequality constraints)""";
          } num_constraints;
          // Symbol: drake::solvers::fbstab::DenseData::num_variables
          struct /* num_variables */ {
            // Source: drake/solvers/fbstab/components/dense_data.h:52
            const char* doc =
R"""(Returns:
    number of decision variables (i.e., dimension of z))""";
          } num_variables;
        } DenseData;
        // Symbol: drake::solvers::fbstab::DenseFeasibility
        struct /* DenseFeasibility */ {
          // Source: drake/solvers/fbstab/components/dense_feasibility.h:20
          const char* doc =
R"""(This class detects infeasibility in quadratic programs, see
dense_data.h for a description of the QPs. It contains methods for
determining if a primal-dual variable is a certificate of primal
and/or dual infeasibility. It implements Algorithm 3 of
https://arxiv.org/pdf/1901.04046.pdf.)""";
          // Symbol: drake::solvers::fbstab::DenseFeasibility::ComputeFeasibility
          struct /* ComputeFeasibility */ {
            // Source: drake/solvers/fbstab/components/dense_feasibility.h:44
            const char* doc =
R"""(Checks if the primal-dual variable x is a certificate of infeasibility
and stores the results internally. It uses the results from
Proposition 4 of https://arxiv.org/pdf/1901.04046.pdf.

Parameter ``x``:
    Variable to check

Parameter ``tol``:
    Numerical tolerance

Throws a runtime_error if tol isn't positive.)""";
          } ComputeFeasibility;
          // Symbol: drake::solvers::fbstab::DenseFeasibility::DenseFeasibility
          struct /* ctor */ {
            // Source: drake/solvers/fbstab/components/dense_feasibility.h:30
            const char* doc =
R"""(Allocates workspace memory.

Parameter ``nz``:
    number of decision variables

Parameter ``nv``:
    number of inequality constraints

Throws a runtime_error is any inputs are non-positive.)""";
          } ctor;
          // Symbol: drake::solvers::fbstab::DenseFeasibility::IsDualFeasible
          struct /* IsDualFeasible */ {
            // Source: drake/solvers/fbstab/components/dense_feasibility.h:51
            const char* doc =
R"""(Returns the results of ComputeFeasibility

Returns:
    false if the last point checked certifies that the dual QP is
    infeasible, true otherwise)""";
          } IsDualFeasible;
          // Symbol: drake::solvers::fbstab::DenseFeasibility::IsPrimalFeasible
          struct /* IsPrimalFeasible */ {
            // Source: drake/solvers/fbstab/components/dense_feasibility.h:58
            const char* doc =
R"""(Returns the results of ComputeFeasibility

Returns:
    false if the last point checked certifies that the QP is
    infeasible, true otherwise)""";
          } IsPrimalFeasible;
        } DenseFeasibility;
        // Symbol: drake::solvers::fbstab::DenseLinearSolver
        struct /* DenseLinearSolver */ {
          // Source: drake/solvers/fbstab/components/dense_linear_solver.h:43
          const char* doc =
R"""(A class for computing the search directions used by the FBstab QP
Solver. It solves systems of linear equations of the form

[Hs A'] dz = rz <==> V*dx = r [-CA D ] dv rv

using a Schur complement approach as described in (28) and (29) of
https://arxiv.org/pdf/1901.04046.pdf. Note that this code doesn't have
equality constraints so is a simplification of (28) and (29).

This class allocates its own workspace memory and splits step
computation into solve and factor steps to allow for solving with
multiple right hand sides.

This class has mutable fields and is thus not thread safe.

Usage:


::

    DenseLinearSolver solver(2,2);
    solver.Factor(x,xbar,sigma);
    solver.Solve(r,&dx,sigma);)""";
          // Symbol: drake::solvers::fbstab::DenseLinearSolver::DenseLinearSolver
          struct /* ctor */ {
            // Source: drake/solvers/fbstab/components/dense_linear_solver.h:51
            const char* doc =
R"""(Allocates workspace memory. @param [nz] Number of decision variables.
@param [nv] Number of inequality constraints.)""";
          } ctor;
          // Symbol: drake::solvers::fbstab::DenseLinearSolver::Initialize
          struct /* Initialize */ {
            // Source: drake/solvers/fbstab/components/dense_linear_solver.h:69
            const char* doc =
R"""(Factors the matrix V(x,xbar,sigma) using a Schur complement approach
followed by a Cholesky factorization and stores the factorization
internally.

The matrix V is computed as described in Algorithm 4 of
https://arxiv.org/pdf/1901.04046.pdf.

Parameter ``x``:
    Inner loop iterate

Parameter ``xbar``:
    Outer loop iterate

Parameter ``sigma``:
    Regularization strength

Returns:
    true if factorization succeeds false otherwise.

Throws a runtime_error if x and xbar aren't the correct size, sigma is
negative or the problem data isn't linked.)""";
          } Initialize;
          // Symbol: drake::solvers::fbstab::DenseLinearSolver::SetAlpha
          struct /* SetAlpha */ {
            // Source: drake/solvers/fbstab/components/dense_linear_solver.h:90
            const char* doc =
R"""(Sets the alpha parameter defined in (19) of
https://arxiv.org/pdf/1901.04046.pdf.)""";
          } SetAlpha;
          // Symbol: drake::solvers::fbstab::DenseLinearSolver::Solve
          struct /* Solve */ {
            // Source: drake/solvers/fbstab/components/dense_linear_solver.h:84
            const char* doc =
R"""(Solves the system V*x = r and stores the result in x. This method
assumes that the Factor routine was run to compute then factor the
matrix V.

Parameter ``r``:
    The right hand side vector

Parameter ``x``:
    Overwritten with the solution

Returns:
    true if successful, false otherwise

Throws a runtime_error if x and r aren't the correct sizes, if x is
null or if the problem data isn't linked.)""";
          } Solve;
        } DenseLinearSolver;
        // Symbol: drake::solvers::fbstab::DenseResidual
        struct /* DenseResidual */ {
          // Source: drake/solvers/fbstab/components/dense_residual.h:23
          const char* doc =
R"""(This class computes and stores residuals for inequality constrained
dense QPs. See dense_data.h for a description of the QP.

Residuals have 2 components: - z: Stationarity residual - v:
Complementarity residual)""";
          // Symbol: drake::solvers::fbstab::DenseResidual::DenseResidual
          struct /* ctor */ {
            // Source: drake/solvers/fbstab/components/dense_residual.h:36
            const char* doc =
R"""(Allocates memory for computing and storing residual vectors. Uses
alpha = 0.95 (see (19) in https://arxiv.org/pdf/1901.04046.pdf) by
default.

Parameter ``nz``:
    Number of decision variables

Parameter ``nv``:
    Number of inequality constraints

Throws an exception if any inputs aren't positive.)""";
          } ctor;
          // Symbol: drake::solvers::fbstab::DenseResidual::Fill
          struct /* Fill */ {
            // Source: drake/solvers/fbstab/components/dense_residual.h:93
            const char* doc =
R"""(Fills the storage with a i.e., r <- a*ones.

Parameter ``a``:)""";
          } Fill;
          // Symbol: drake::solvers::fbstab::DenseResidual::InnerResidual
          struct /* InnerResidual */ {
            // Source: drake/solvers/fbstab/components/dense_residual.h:61
            const char* doc =
R"""(Computes R(x,xbar,sigma), the residual of a proximal subproblem and
stores the result internally. R(x,xbar,sigma) = 0 if and only if x =
P(xbar,sigma) where P is the proximal operator.

See (11) and (20) in https://arxiv.org/pdf/1901.04046.pdf for a
mathematical description.

Parameter ``x``:
    Inner loop variable

Parameter ``xbar``:
    Outer loop variable

Parameter ``sigma``:
    Regularization strength > 0

Throws a runtime_error if problem data isn't linked, sigma isn't
positive, or if x and xbar aren't the same size.)""";
          } InnerResidual;
          // Symbol: drake::solvers::fbstab::DenseResidual::Merit
          struct /* Merit */ {
            // Source: drake/solvers/fbstab/components/dense_residual.h:105
            const char* doc =
R"""(Computes the merit function of the current stored residuals.

Returns:
    0.5*(|z|^2 + |v|^2))""";
          } Merit;
          // Symbol: drake::solvers::fbstab::DenseResidual::NaturalResidual
          struct /* NaturalResidual */ {
            // Source: drake/solvers/fbstab/components/dense_residual.h:74
            const char* doc =
R"""(Computes π(x): the natural residual of the QP at the primal-dual point
x and stores the result internally. See (17) in
https://arxiv.org/pdf/1901.04046.pdf for a mathematical definition.

Parameter ``x``:
    Evaluation point.

Throws a runtime_error if problem data isn't linked.)""";
          } NaturalResidual;
          // Symbol: drake::solvers::fbstab::DenseResidual::Negate
          struct /* Negate */ {
            // Source: drake/solvers/fbstab/components/dense_residual.h:42
            const char* doc =
R"""(Performs the operation y <- -1*y (y is this object).)""";
          } Negate;
          // Symbol: drake::solvers::fbstab::DenseResidual::Norm
          struct /* Norm */ {
            // Source: drake/solvers/fbstab/components/dense_residual.h:99
            const char* doc =
R"""(Computes the Euclidean norm of the current stored residuals.

Returns:
    sqrt(|z|^2 + |v|^2))""";
          } Norm;
          // Symbol: drake::solvers::fbstab::DenseResidual::PenalizedNaturalResidual
          struct /* PenalizedNaturalResidual */ {
            // Source: drake/solvers/fbstab/components/dense_residual.h:86
            const char* doc =
R"""(Computes the natural residual function augmented with penalty terms,
it is analogous to (18) in https://arxiv.org/pdf/1901.04046.pdf, and
stores the result internally.

Parameter ``x``:
    Evaluation point.

Throws a runtime_error if problem data isn't linked.)""";
          } PenalizedNaturalResidual;
          // Symbol: drake::solvers::fbstab::DenseResidual::SetAlpha
          struct /* SetAlpha */ {
            // Source: drake/solvers/fbstab/components/dense_residual.h:121
            const char* doc =
R"""(Sets the alpha parameter defined in (19) of
https://arxiv.org/pdf/1901.04046.pdf.)""";
          } SetAlpha;
          // Symbol: drake::solvers::fbstab::DenseResidual::l_norm
          struct /* l_norm */ {
            // Source: drake/solvers/fbstab/components/dense_residual.h:133
            const char* doc =
R"""(The dense QP we consider has no equality constraints so this methods
returns 0. It's needed by the printing routines of the FBstabAlgorithm
class.)""";
          } l_norm;
          // Symbol: drake::solvers::fbstab::DenseResidual::v
          struct /* v */ {
            // Source: drake/solvers/fbstab/components/dense_residual.h:113
            const char* doc = R"""(Accessor for complementarity residual.)""";
          } v;
          // Symbol: drake::solvers::fbstab::DenseResidual::v_norm
          struct /* v_norm */ {
            // Source: drake/solvers/fbstab/components/dense_residual.h:126
            const char* doc = R"""(Norm of the complementarity residual.)""";
          } v_norm;
          // Symbol: drake::solvers::fbstab::DenseResidual::z
          struct /* z */ {
            // Source: drake/solvers/fbstab/components/dense_residual.h:108
            const char* doc = R"""(Accessor for stationarity residual.)""";
          } z;
          // Symbol: drake::solvers::fbstab::DenseResidual::z_norm
          struct /* z_norm */ {
            // Source: drake/solvers/fbstab/components/dense_residual.h:124
            const char* doc = R"""(Norm of the stationarity residual.)""";
          } z_norm;
        } DenseResidual;
        // Symbol: drake::solvers::fbstab::DenseVariable
        struct /* DenseVariable */ {
          // Source: drake/solvers/fbstab/components/dense_variable.h:30
          const char* doc =
R"""(Implements primal-dual variables for inequality constrained QPs, see
dense_data.h for a mathematical description. This class stores
variables and defines methods implementing useful operations.

Primal-dual variables have 3 components: - z: Decision variables - v:
Inequality duals - y: Inequality margins

where length(z) = nz length(v) = nv length(y) = nv)""";
          // Symbol: drake::solvers::fbstab::DenseVariable::Copy
          struct /* Copy */ {
            // Source: drake/solvers/fbstab/components/dense_variable.h:95
            const char* doc =
R"""(Performs a deep copy operation.

Parameter ``x``:
    variable to be copied

Throws an exception if sizes are mismatched.)""";
          } Copy;
          // Symbol: drake::solvers::fbstab::DenseVariable::DenseVariable
          struct /* ctor */ {
            // Source: drake/solvers/fbstab/components/dense_variable.h:40
            const char* doc_2args =
R"""(Allocates memory for a primal-dual variables.

Parameter ``nz``:
    Number of decision variables > 0

Parameter ``nv``:
    Number of inequality constraints > 0)""";
            // Source: drake/solvers/fbstab/components/dense_variable.h:50
            const char* doc_3args =
R"""(Creates a primal-dual variable using preallocated memory.

Parameter ``z``:
    A vector to store the decision variables.

Parameter ``v``:
    A vector to store the dual variables.

Parameter ``y``:
    A vector to store the inequality margin.

Throws an exception if any inputs are null or have mismatched or zero
size.)""";
          } ctor;
          // Symbol: drake::solvers::fbstab::DenseVariable::Fill
          struct /* Fill */ {
            // Source: drake/solvers/fbstab/components/dense_variable.h:66
            const char* doc =
R"""(Fills the variable with one value, i.e., x <- a * ones.

Parameter ``a``:
    Throws an exception if problem data has not been linked.)""";
          } Fill;
          // Symbol: drake::solvers::fbstab::DenseVariable::InitializeConstraintMargin
          struct /* InitializeConstraintMargin */ {
            // Source: drake/solvers/fbstab/components/dense_variable.h:72
            const char* doc =
R"""(Sets the field x.y = b - A* x.z. Throws an exception if problem data
has not been linked.)""";
          } InitializeConstraintMargin;
          // Symbol: drake::solvers::fbstab::DenseVariable::LinkData
          struct /* LinkData */ {
            // Source: drake/solvers/fbstab/components/dense_variable.h:57
            const char* doc =
R"""(Links to problem data needed to perform calculations, Calculations
cannot be performed until a data object is provided.

Parameter ``data``:
    Pointer to the problem data)""";
          } LinkData;
          // Symbol: drake::solvers::fbstab::DenseVariable::Norm
          struct /* Norm */ {
            // Source: drake/solvers/fbstab/components/dense_variable.h:107
            const char* doc =
R"""(Computes the Euclidean norm.

Returns:
    sqrt(|z|^2 + |v|^2))""";
          } Norm;
          // Symbol: drake::solvers::fbstab::DenseVariable::ProjectDuals
          struct /* ProjectDuals */ {
            // Source: drake/solvers/fbstab/components/dense_variable.h:101
            const char* doc =
R"""(Projects the inequality duals onto the non-negative orthant, i.e., v
<- max(0,v).)""";
          } ProjectDuals;
          // Symbol: drake::solvers::fbstab::DenseVariable::axpy
          struct /* axpy */ {
            // Source: drake/solvers/fbstab/components/dense_variable.h:87
            const char* doc =
R"""(Performs the operation *this <- a*x + *this (where u is this object).
This is a level 1 BLAS operation for this object; see
http://www.netlib.org/blas/blasqr.pdf.

Parameter ``a``:
    scalar

Parameter ``x``:
    vector

Note that this handles the constraint margin correctly, i.e., after
the operation u.y = b - A*(u.z + a*x.z). Throws an exception if
problem data has not been linked.)""";
          } axpy;
          // Symbol: drake::solvers::fbstab::DenseVariable::num_constraints
          struct /* num_constraints */ {
            // Source: drake/solvers/fbstab/components/dense_variable.h:127
            const char* doc = R"""()""";
          } num_constraints;
          // Symbol: drake::solvers::fbstab::DenseVariable::num_variables
          struct /* num_variables */ {
            // Source: drake/solvers/fbstab/components/dense_variable.h:128
            const char* doc = R"""()""";
          } num_variables;
          // Symbol: drake::solvers::fbstab::DenseVariable::v
          struct /* v */ {
            // Source: drake/solvers/fbstab/components/dense_variable.h:113
            const char* doc = R"""(Accessor for the dual variable.)""";
          } v;
          // Symbol: drake::solvers::fbstab::DenseVariable::y
          struct /* y */ {
            // Source: drake/solvers/fbstab/components/dense_variable.h:116
            const char* doc = R"""(Accessor for the constraint margin.)""";
          } y;
          // Symbol: drake::solvers::fbstab::DenseVariable::z
          struct /* z */ {
            // Source: drake/solvers/fbstab/components/dense_variable.h:110
            const char* doc = R"""(Accessor for the primal variable.)""";
          } z;
        } DenseVariable;
        // Symbol: drake::solvers::fbstab::ExitFlag
        struct /* ExitFlag */ {
          // Source: drake/solvers/fbstab/fbstab_algorithm.h:19
          const char* doc = R"""()""";
          // Symbol: drake::solvers::fbstab::ExitFlag::DIVERGENCE
          struct /* DIVERGENCE */ {
            // Source: drake/solvers/fbstab/fbstab_algorithm.h:21
            const char* doc = R"""()""";
          } DIVERGENCE;
          // Symbol: drake::solvers::fbstab::ExitFlag::DUAL_INFEASIBLE
          struct /* DUAL_INFEASIBLE */ {
            // Source: drake/solvers/fbstab/fbstab_algorithm.h:24
            const char* doc = R"""()""";
          } DUAL_INFEASIBLE;
          // Symbol: drake::solvers::fbstab::ExitFlag::MAXITERATIONS
          struct /* MAXITERATIONS */ {
            // Source: drake/solvers/fbstab/fbstab_algorithm.h:22
            const char* doc = R"""()""";
          } MAXITERATIONS;
          // Symbol: drake::solvers::fbstab::ExitFlag::PRIMAL_DUAL_INFEASIBLE
          struct /* PRIMAL_DUAL_INFEASIBLE */ {
            // Source: drake/solvers/fbstab/fbstab_algorithm.h:25
            const char* doc = R"""()""";
          } PRIMAL_DUAL_INFEASIBLE;
          // Symbol: drake::solvers::fbstab::ExitFlag::PRIMAL_INFEASIBLE
          struct /* PRIMAL_INFEASIBLE */ {
            // Source: drake/solvers/fbstab/fbstab_algorithm.h:23
            const char* doc = R"""()""";
          } PRIMAL_INFEASIBLE;
          // Symbol: drake::solvers::fbstab::ExitFlag::SUCCESS
          struct /* SUCCESS */ {
            // Source: drake/solvers/fbstab/fbstab_algorithm.h:20
            const char* doc = R"""()""";
          } SUCCESS;
        } ExitFlag;
        // Symbol: drake::solvers::fbstab::FBstabAlgoDense
        struct /* FBstabAlgoDense */ {
          // Source: drake/solvers/fbstab/fbstab_dense.h:20
          const char* doc =
R"""(Convenience type for the templated dense version of the algorithm.)""";
        } FBstabAlgoDense;
        // Symbol: drake::solvers::fbstab::FBstabAlgoMpc
        struct /* FBstabAlgoMpc */ {
          // Source: drake/solvers/fbstab/fbstab_mpc.h:21
          const char* doc =
R"""(Convenience typedef for the templated version of the algorithm.)""";
        } FBstabAlgoMpc;
        // Symbol: drake::solvers::fbstab::FBstabAlgorithm
        struct /* FBstabAlgorithm */ {
          // Source: drake/solvers/fbstab/fbstab_algorithm.h:73
          const char* doc =
R"""(This class implements the FBstab solver for convex quadratic programs,
see https://arxiv.org/pdf/1901.04046.pdf for more details.

FBstab tries to solve instances of the following convex QP:

min. 1/2 z'*H*z + f'*z

s.t. Gz = h Az <= b

The algorithm is implemented using to abstract objects representing
variables, residuals etc. These are template parameters for the class
and should be written so as to be efficient for specific classes of
QPs, e.g., model predictive control QPs or sparse QPs.

The algorithm exits when: ||π(x)|| <= abs_tol + ||π(x0)|| rel_tol
where π is the natural residual function, (17) in
https://arxiv.org/pdf/1901.04046.pdf.

Template parameter ``Variable:``:
    storage and methods for primal-dual variables

Template parameter ``Residual:``:
    storage and methods for QP residuals

Template parameter ``Data:``:
    QP specific data storage and operations

Template parameter ``LinearSolver:``:
    solves Newton step systems

Template parameter ``Feasibility:``:
    checks for primal-dual infeasibility)""";
          // Symbol: drake::solvers::fbstab::FBstabAlgorithm::Display
          struct /* Display */ {
            // Source: drake/solvers/fbstab/fbstab_algorithm.h:76
            const char* doc = R"""(Display settings)""";
            // Symbol: drake::solvers::fbstab::FBstabAlgorithm::Display::FINAL
            struct /* FINAL */ {
              // Source: drake/solvers/fbstab/fbstab_algorithm.h:78
              const char* doc = R"""(prints message upon completion)""";
            } FINAL;
            // Symbol: drake::solvers::fbstab::FBstabAlgorithm::Display::ITER
            struct /* ITER */ {
              // Source: drake/solvers/fbstab/fbstab_algorithm.h:79
              const char* doc =
R"""(basic information at each outer loop iteration)""";
            } ITER;
            // Symbol: drake::solvers::fbstab::FBstabAlgorithm::Display::ITER_DETAILED
            struct /* ITER_DETAILED */ {
              // Source: drake/solvers/fbstab/fbstab_algorithm.h:80
              const char* doc = R"""(print detailed inner loop information)""";
            } ITER_DETAILED;
            // Symbol: drake::solvers::fbstab::FBstabAlgorithm::Display::OFF
            struct /* OFF */ {
              // Source: drake/solvers/fbstab/fbstab_algorithm.h:77
              const char* doc = R"""(no display)""";
            } OFF;
          } Display;
          // Symbol: drake::solvers::fbstab::FBstabAlgorithm::FBstabAlgorithm<Variable, Residual, Data, LinearSolver, Feasibility>
          struct /* ctor */ {
            // Source: drake/solvers/fbstab/fbstab_algorithm.h:91
            const char* doc =
R"""(Saves the components objects needed by the solver.

Parameter ``x1``:
    ,x2,x3,x4 Variable objects used by the solver

Parameter ``r1``:
    ,r2 Residual objects used by the solver

Parameter ``lin_sol``:
    Linear solver used by the solver

Parameter ``fcheck``:
    Feasibility checker used by the solver)""";
          } ctor;
          // Symbol: drake::solvers::fbstab::FBstabAlgorithm::Solve
          struct /* Solve */ {
            // Source: drake/solvers/fbstab/fbstab_algorithm.h:133
            const char* doc =
R"""(Attempts to solve the QP for the given data starting from the supplied
initial guess.

Parameter ``qp_data``:
    problem data

Parameter ``x0``:
    initial primal-dual guess, overwritten with the solution

Returns:
    Details on the solver output)""";
          } Solve;
          // Symbol: drake::solvers::fbstab::FBstabAlgorithm::UpdateOption
          struct /* UpdateOption */ {
            // Source: drake/solvers/fbstab/fbstab_algorithm.h:164
            const char* doc =
R"""(Allows setting of algorithm options.

Parameter ``option``:
    option name

Parameter ``value``:
    new value

Possible options and default parameters are: - sigma0{1e-8}: Initial
stabilization parameter - alpha{0.95}: Penalized FB function parameter
- beta{0.7}: Backtracking linesearch parameter - eta{1e-8}: Sufficient
decrease parameter - inner_tol_multiplier{0.2}: Reduction factor for
subproblem tolerance

- abs_tol{1e-6}: Absolute tolerance
- rel_tol{1e-12}: Relative tolerance
- stall_tol{1e-10}: Tolerance on ||dx||
- infeas_tol{1e-8}: Relative tolerance used in feasibility checking

- inner_tol_max{1.0}: Maximum value for the subproblem tolerance
- inner_tol_min{1e-12}: Minimum value for the subproblem tolerance

- max_newton_iters{200}: Maximum number of Newton iterations before timeout
- max_prox_iters{30}: Maximum number of proximal iterations before timeout
- max_inner_iters{50}: Maximum number of iterations that can be applied
to a single subproblem
- max_linesearch_iters{20}: Maximum number of backtracking linesearch steps

- check_feasibility{true}: Enables or disables the feasibility checker,
if the problem is known to be feasible then it can be disabled for speed.)""";
          } UpdateOption;
          // Symbol: drake::solvers::fbstab::FBstabAlgorithm::get_display_level
          struct /* get_display_level */ {
            // Source: drake/solvers/fbstab/fbstab_algorithm.h:216
            const char* doc = R"""(Getter for display_level_)""";
          } get_display_level;
          // Symbol: drake::solvers::fbstab::FBstabAlgorithm::set_display_level
          struct /* set_display_level */ {
            // Source: drake/solvers/fbstab/fbstab_algorithm.h:218
            const char* doc = R"""(Setter for display_level_)""";
          } set_display_level;
        } FBstabAlgorithm;
        // Symbol: drake::solvers::fbstab::FBstabDense
        struct /* FBstabDense */ {
          // Source: drake/solvers/fbstab/fbstab_dense.h:77
          const char* doc =
R"""(FBstabDense implements the Proximally Stabilized Semismooth Algorithm
for solving convex quadratic programs of the following form (1):

min. 1/2 z'Hz + f'z s.t. Az <= b

where H is symmetric and positive semidefinite and its dual

min. 1/2 z'Hz + b'v s.t. Hz + f + A'v = 0 v >= 0.

Or equivalently for solving its KKT system

Hz + f + A' v = 0 Az <= b, v >= 0 (b - Az)' v = 0

where v is a dual variable.

The algorithm is described in https://arxiv.org/pdf/1901.04046.pdf.
Aside from convexity there are no assumptions made about the problem.
This method can detect unboundedness/infeasibility and accepts
arbitrary initial guesses.

The problem is of size (nz,nv) where: - nz > 0 is the number of
decision variables - nv > 0 is the number of inequality constraints

Usage example:


::

    MatrixXd H(2,2);
    MatrixXd A(1,2);
    VectorXd f(2);
    VectorXd b(1);
    
    H << 1,0,1,0;
    A << 1,0;
    f << 1,-1;
    b << 0;
    
    FBstabDense::QPData data = {&H, &A, &f, &b};
    
    VectorXd x0 = VectorXd::Zero(2);
    VectorXd v0 = VectorXd::Zero(1);
    VectorXd y0 = VectorXd::Zero(1);
    
    FBstabDense::QPVariable x = {&x0, &v0, &y0};
    
    FBstabDense solver(2,1);
    solver.Solve(data,x); // x is used as an initial guess then overwritten)""";
          // Symbol: drake::solvers::fbstab::FBstabDense::FBstabDense
          struct /* ctor */ {
            // Source: drake/solvers/fbstab/fbstab_dense.h:112
            const char* doc =
R"""(Allocates needed workspace given the dimensions of the QPs to be
solved. Throws a runtime_error if any inputs are non-positive.

Parameter ``num_variables``:
    $Parameter ``num_constraints``:)""";
          } ctor;
          // Symbol: drake::solvers::fbstab::FBstabDense::QPData
          struct /* QPData */ {
            // Source: drake/solvers/fbstab/fbstab_dense.h:81
            const char* doc = R"""(Structure to hold the problem data.)""";
            // Symbol: drake::solvers::fbstab::FBstabDense::QPData::A
            struct /* A */ {
              // Source: drake/solvers/fbstab/fbstab_dense.h:85
              const char* doc = R"""(nv x nz real constraint Jacobian.)""";
            } A;
            // Symbol: drake::solvers::fbstab::FBstabDense::QPData::H
            struct /* H */ {
              // Source: drake/solvers/fbstab/fbstab_dense.h:83
              const char* doc =
R"""(nz x nz real positive semidefinite Hessian matrix.)""";
            } H;
            // Symbol: drake::solvers::fbstab::FBstabDense::QPData::b
            struct /* b */ {
              // Source: drake/solvers/fbstab/fbstab_dense.h:89
              const char* doc = R"""(nv real constraint rhs.)""";
            } b;
            // Symbol: drake::solvers::fbstab::FBstabDense::QPData::f
            struct /* f */ {
              // Source: drake/solvers/fbstab/fbstab_dense.h:87
              const char* doc = R"""(nz real linear cost.)""";
            } f;
          } QPData;
          // Symbol: drake::solvers::fbstab::FBstabDense::QPVariable
          struct /* QPVariable */ {
            // Source: drake/solvers/fbstab/fbstab_dense.h:97
            const char* doc =
R"""(Structure to hold the initial guess. The vectors pointed to by z, v,
and y WILL BE OVERWRITTEN with the solution.)""";
            // Symbol: drake::solvers::fbstab::FBstabDense::QPVariable::v
            struct /* v */ {
              // Source: drake/solvers/fbstab/fbstab_dense.h:101
              const char* doc = R"""(Inequality duals in \reals^nv.)""";
            } v;
            // Symbol: drake::solvers::fbstab::FBstabDense::QPVariable::y
            struct /* y */ {
              // Source: drake/solvers/fbstab/fbstab_dense.h:103
              const char* doc =
R"""(Constraint margin, i.e., y = b-Az, in \reals^nv.)""";
            } y;
            // Symbol: drake::solvers::fbstab::FBstabDense::QPVariable::z
            struct /* z */ {
              // Source: drake/solvers/fbstab/fbstab_dense.h:99
              const char* doc = R"""(Decision variables in \reals^nz.)""";
            } z;
          } QPVariable;
          // Symbol: drake::solvers::fbstab::FBstabDense::SetDisplayLevel
          struct /* SetDisplayLevel */ {
            // Source: drake/solvers/fbstab/fbstab_dense.h:144
            const char* doc =
R"""(Controls the verbosity of the algorithm. See fbstab_algorithm.h for
details.

Parameter ``level``:
    new display level)""";
          } SetDisplayLevel;
          // Symbol: drake::solvers::fbstab::FBstabDense::Solve
          struct /* Solve */ {
            // Source: drake/solvers/fbstab/fbstab_dense.h:126
            const char* doc =
R"""(Solves an instance of (1)

Parameter ``qp``:
    problem data

Parameter ``x``:
    initial guess, overwritten with the solution

Parameter ``use_initial_guess``:
    if false the solver is initialized at the origin.

Returns:
    Summary of the optimizer output, see fbstab_algorithm.h.)""";
          } Solve;
          // Symbol: drake::solvers::fbstab::FBstabDense::UpdateOption
          struct /* UpdateOption */ {
            // Source: drake/solvers/fbstab/fbstab_dense.h:135
            const char* doc =
R"""(Allows for setting of solver options. See fbstab_algorithm.h for a
list of adjustable options.

Parameter ``option``:
    Option name

Parameter ``value``:
    New value)""";
          } UpdateOption;
        } FBstabDense;
        // Symbol: drake::solvers::fbstab::FBstabMpc
        struct /* FBstabMpc */ {
          // Source: drake/solvers/fbstab/fbstab_mpc.h:62
          const char* doc =
R"""(FBstabMpc implements the Proximally Stabilized Semismooth Method for
solving the following quadratic programming problem (1):

min. \sum_{i=0}^N 1/2 [x(i)]' * [Q(i) S(i)'] [x(i)] + [q(i)]'*[x(i)]
[u(i)] [S(i) R(i) ] [u(i)] [r(i)] [u(i)]

s.t. x(i+1) = A(i)*x(i) + B(i) u(i) + c(i), i = 0 ... N-1 x(0) = x0
E(i)*x(i) + L(i)*u(i) + d(i) <= 0, i = 0 ... N

Where [ Q(i),S(i)'] [ S(i),R(i) ]

is positive semidefinite for all i \in [0,N]. See also (29) in
https://arxiv.org/pdf/1901.04046.pdf.

The problem is of size (N,nx,nu,nc) where: - N > 0 is the horizon
length - nx > 0 is the number of states - nu > 0 is the number of
control inputs - nc > 0 is the number of constraints per stage

This is a specialization of the general form (2),

min. 1/2 z'Hz + f'z

s.t. Gz = h Az <= b

which has dimensions nz = (nx + nu) * (N + 1), nl = nx * (N + 1), and
nv = nc * (N + 1).

Aside from convexity there are no assumptions made about the problem.
This method can detect unboundedness/infeasibility and exploit
arbitrary initial guesses.)""";
          // Symbol: drake::solvers::fbstab::FBstabMpc::FBstabMpc
          struct /* ctor */ {
            // Source: drake/solvers/fbstab/fbstab_mpc.h:122
            const char* doc =
R"""(Allocates workspaces needed when solving (1).

Parameter ``N``:
    Horizon length

Parameter ``nx``:
    number of states

Parameter ``nu``:
    number of control input

Parameter ``nc``:
    number of constraints per timestep

Throws a runtime_error if any inputs are nonpositive.)""";
          } ctor;
          // Symbol: drake::solvers::fbstab::FBstabMpc::QPData
          struct /* QPData */ {
            // Source: drake/solvers/fbstab/fbstab_mpc.h:70
            const char* doc =
R"""(Structure to hold the problem data. See the class documentation or
(29) in https://arxiv.org/pdf/1901.04046.pdf for more details.)""";
            // Symbol: drake::solvers::fbstab::FBstabMpc::QPData::A
            struct /* A */ {
              // Source: drake/solvers/fbstab/fbstab_mpc.h:82
              const char* doc = R"""(N vector of nx x nx matrices)""";
            } A;
            // Symbol: drake::solvers::fbstab::FBstabMpc::QPData::B
            struct /* B */ {
              // Source: drake/solvers/fbstab/fbstab_mpc.h:84
              const char* doc = R"""(N vector of nx x nu matrices)""";
            } B;
            // Symbol: drake::solvers::fbstab::FBstabMpc::QPData::E
            struct /* E */ {
              // Source: drake/solvers/fbstab/fbstab_mpc.h:88
              const char* doc = R"""(N + 1 vector of nc x nx matrices)""";
            } E;
            // Symbol: drake::solvers::fbstab::FBstabMpc::QPData::L
            struct /* L */ {
              // Source: drake/solvers/fbstab/fbstab_mpc.h:90
              const char* doc = R"""(N + 1 vector of nc x nu matrices)""";
            } L;
            // Symbol: drake::solvers::fbstab::FBstabMpc::QPData::Q
            struct /* Q */ {
              // Source: drake/solvers/fbstab/fbstab_mpc.h:72
              const char* doc = R"""(N + 1 vector of nx x nx matrices)""";
            } Q;
            // Symbol: drake::solvers::fbstab::FBstabMpc::QPData::R
            struct /* R */ {
              // Source: drake/solvers/fbstab/fbstab_mpc.h:74
              const char* doc = R"""(N + 1 vector of nu x nu matrices)""";
            } R;
            // Symbol: drake::solvers::fbstab::FBstabMpc::QPData::S
            struct /* S */ {
              // Source: drake/solvers/fbstab/fbstab_mpc.h:76
              const char* doc = R"""(N + 1 vector of nu x nx matrices)""";
            } S;
            // Symbol: drake::solvers::fbstab::FBstabMpc::QPData::c
            struct /* c */ {
              // Source: drake/solvers/fbstab/fbstab_mpc.h:86
              const char* doc = R"""(N vector of nx vectors)""";
            } c;
            // Symbol: drake::solvers::fbstab::FBstabMpc::QPData::d
            struct /* d */ {
              // Source: drake/solvers/fbstab/fbstab_mpc.h:92
              const char* doc = R"""(N + 1 vector of nc x 1 vectors)""";
            } d;
            // Symbol: drake::solvers::fbstab::FBstabMpc::QPData::q
            struct /* q */ {
              // Source: drake/solvers/fbstab/fbstab_mpc.h:78
              const char* doc = R"""(N + 1 vector of nx x 1 vectors)""";
            } q;
            // Symbol: drake::solvers::fbstab::FBstabMpc::QPData::r
            struct /* r */ {
              // Source: drake/solvers/fbstab/fbstab_mpc.h:80
              const char* doc = R"""(N + 1 vector of nu x 1 vectors)""";
            } r;
            // Symbol: drake::solvers::fbstab::FBstabMpc::QPData::x0
            struct /* x0 */ {
              // Source: drake/solvers/fbstab/fbstab_mpc.h:94
              const char* doc = R"""(nx x 1 vector)""";
            } x0;
          } QPData;
          // Symbol: drake::solvers::fbstab::FBstabMpc::QPVariable
          struct /* QPVariable */ {
            // Source: drake/solvers/fbstab/fbstab_mpc.h:101
            const char* doc =
R"""(Structure to hold the initial guess and solution. These vectors will
be overwritten by the solve routine.)""";
            // Symbol: drake::solvers::fbstab::FBstabMpc::QPVariable::l
            struct /* l */ {
              // Source: drake/solvers/fbstab/fbstab_mpc.h:105
              const char* doc = R"""(equality duals/costates in \reals^nl)""";
            } l;
            // Symbol: drake::solvers::fbstab::FBstabMpc::QPVariable::v
            struct /* v */ {
              // Source: drake/solvers/fbstab/fbstab_mpc.h:107
              const char* doc = R"""(inequality duals in \reals^nv)""";
            } v;
            // Symbol: drake::solvers::fbstab::FBstabMpc::QPVariable::y
            struct /* y */ {
              // Source: drake/solvers/fbstab/fbstab_mpc.h:109
              const char* doc =
R"""(constraint margin, i.e., y = b-Az, in \reals^nv)""";
            } y;
            // Symbol: drake::solvers::fbstab::FBstabMpc::QPVariable::z
            struct /* z */ {
              // Source: drake/solvers/fbstab/fbstab_mpc.h:103
              const char* doc = R"""(decision variables in \reals^nz)""";
            } z;
          } QPVariable;
          // Symbol: drake::solvers::fbstab::FBstabMpc::SetDisplayLevel
          struct /* SetDisplayLevel */ {
            // Source: drake/solvers/fbstab/fbstab_mpc.h:150
            const char* doc =
R"""(Controls the verbosity of the algorithm, see fbstab_algorithm.h for
details.

Parameter ``level``:
    new display level)""";
          } SetDisplayLevel;
          // Symbol: drake::solvers::fbstab::FBstabMpc::Solve
          struct /* Solve */ {
            // Source: drake/solvers/fbstab/fbstab_mpc.h:133
            const char* doc =
R"""(Solves an instance of (1).

Parameter ``qp``:
    problem data

Parameter ``x``:
    initial guess, overwritten with the solution

Parameter ``use_initial_guess``:
    if false the solver is initialized at the origin

Returns:
    Summary of the optimizer output, see fbstab_algorithm.h.)""";
          } Solve;
          // Symbol: drake::solvers::fbstab::FBstabMpc::UpdateOption
          struct /* UpdateOption */ {
            // Source: drake/solvers/fbstab/fbstab_mpc.h:141
            const char* doc =
R"""(Allows for setting of solver options, see fbstab_algorithm.h for a
list.

Parameter ``option``:
    Option name

Parameter ``value``:
    New value)""";
          } UpdateOption;
        } FBstabMpc;
        // Symbol: drake::solvers::fbstab::MpcData
        struct /* MpcData */ {
          // Source: drake/solvers/fbstab/components/mpc_data.h:44
          const char* doc =
R"""(This class represents data for quadratic programming problems of the
following type (1):

min. \sum_{i=0}^N 1/2 [x(i)]' * [Q(i) S(i)'] [x(i)] + [q(i)]'*[x(i)]
[u(i)] [S(i) R(i) ] [u(i)] [r(i)] [u(i)] s.t. x(i+1) = A(i)*x(i) +
B(i) u(i) + c(i), i = 0 ... N-1 x(0) = x0, E(i)*x(i) + L(i)*u(i) +
d(i) <= 0, i = 0 ... N

The horizon length is N, the dimension of x(i) is nx, of u(i) is nu,
and the number of constraints per stage is nc.

This is a specialization of the general form (2),

min. 1/2 z'Hz + f'z

s.t. Gz = h Az <= b

which has dimensions nz = (nx + nu) * (N + 1), nl = nx * (N + 1), and
nv = nc * (N + 1).

This class contains storage and methods for implicitly working with
the compact representation (2) in an efficient manner.)""";
          // Symbol: drake::solvers::fbstab::MpcData::MpcData
          struct /* ctor */ {
            // Source: drake/solvers/fbstab/components/mpc_data.h:56
            const char* doc =
R"""(Creates problem data and performs input validation. Throws a
runtime_error if the problem data aren't consistently sized.

This class assumes that the pointers to the data remain valid.

All arguments are inputs and point to data defining a linear-quadratic
optimal control problem, see the class comment.)""";
          } ctor;
          // Symbol: drake::solvers::fbstab::MpcData::axpyb
          struct /* axpyb */ {
            // Source: drake/solvers/fbstab/components/mpc_data.h:170
            const char* doc =
R"""(Computes y <- a*b + y without forming b explicitly. This implements a
BLAS operation, see http://www.netlib.org/blas/blasqr.pdf.

Parameter ``a``:
    Scaling factor

Parameter ``y``:
    Output vector, length(y) = nc*(N+1)

Throws a runtime_error if sizes aren't consistent or y is null.)""";
          } axpyb;
          // Symbol: drake::solvers::fbstab::MpcData::axpyf
          struct /* axpyf */ {
            // Source: drake/solvers/fbstab/components/mpc_data.h:148
            const char* doc =
R"""(Computes y <- a*f + y without forming f explicitly. This implements a
BLAS operation, see http://www.netlib.org/blas/blasqr.pdf.

Parameter ``a``:
    Scaling factor

Parameter ``y``:
    Output vector, length(y) = (nx+nu)*(N+1)

Throws a runtime_error if sizes aren't consistent or y is null.)""";
          } axpyf;
          // Symbol: drake::solvers::fbstab::MpcData::axpyh
          struct /* axpyh */ {
            // Source: drake/solvers/fbstab/components/mpc_data.h:159
            const char* doc =
R"""(Computes y <- a*h + y without forming h explicitly. This implements a
BLAS operation, see http://www.netlib.org/blas/blasqr.pdf.

Parameter ``a``:
    Scaling factor

Parameter ``y``:
    Output vector, length(y) = nx*(N+1)

Throws a runtime_error if sizes aren't consistent or y is null.)""";
          } axpyh;
          // Symbol: drake::solvers::fbstab::MpcData::gemvA
          struct /* gemvA */ {
            // Source: drake/solvers/fbstab/components/mpc_data.h:94
            const char* doc =
R"""(Computes y <- a*A*x + b*y without forming A explicitly. This
implements a BLAS operation, see
http://www.netlib.org/blas/blasqr.pdf.

Parameter ``x``:
    Input vector, length(x) = (nx+nu)*(N+1)

Parameter ``a``:
    Input scaling

Parameter ``b``:
    Scaling

Parameter ``y``:
    Output vector, length(y) = nc*(N+1)

Throws a runtime_error if sizes aren't consistent or y is null.)""";
          } gemvA;
          // Symbol: drake::solvers::fbstab::MpcData::gemvAT
          struct /* gemvAT */ {
            // Source: drake/solvers/fbstab/components/mpc_data.h:122
            const char* doc =
R"""(Computes y <- a*A'*x + b*y without forming A explicitly This
implements a BLAS operation, see
http://www.netlib.org/blas/blasqr.pdf.

Parameter ``x``:
    Input vector, length(x) = nc*(N+1)

Parameter ``a``:
    Input scaling

Parameter ``b``:
    Scaling

Parameter ``y``:
    Output vector, length(y) = (nx+nu)*(N+1)

Throws a runtime_error if sizes aren't consistent or y is null.)""";
          } gemvAT;
          // Symbol: drake::solvers::fbstab::MpcData::gemvG
          struct /* gemvG */ {
            // Source: drake/solvers/fbstab/components/mpc_data.h:108
            const char* doc =
R"""(Computes y <- a*G*x + b*y without forming G explicitly This implements
a BLAS operation, see http://www.netlib.org/blas/blasqr.pdf.

Parameter ``x``:
    Input vector, length(x) = (nx+nu)*(N+1)

Parameter ``a``:
    Input scaling

Parameter ``b``:
    Scaling

Parameter ``y``:
    Output vector, length(y) = nx*(N+1)

Throws a runtime_error if sizes aren't consistent or y is null.)""";
          } gemvG;
          // Symbol: drake::solvers::fbstab::MpcData::gemvGT
          struct /* gemvGT */ {
            // Source: drake/solvers/fbstab/components/mpc_data.h:136
            const char* doc =
R"""(Computes y <- a*G'*x + b*y without forming G explicitly This
implements a BLAS operation, see
http://www.netlib.org/blas/blasqr.pdf.

Parameter ``x``:
    Input vector, length(x) = (nx)*(N+1)

Parameter ``a``:
    Input scaling

Parameter ``b``:
    Scaling

Parameter ``y``:
    Output vector, length(y) = (nx+nu)*(N+1)

Throws a runtime_error if sizes aren't consistent or y is null.)""";
          } gemvGT;
          // Symbol: drake::solvers::fbstab::MpcData::gemvH
          struct /* gemvH */ {
            // Source: drake/solvers/fbstab/components/mpc_data.h:80
            const char* doc =
R"""(Computes the operation y <- a*H*x + b*y without forming H explicitly.
This implements a BLAS operation, see
http://www.netlib.org/blas/blasqr.pdf.

Parameter ``x``:
    Input vector, length(x) = (nx+nu)*(N+1)

Parameter ``a``:
    Input scaling

Parameter ``b``:
    Scaling

Parameter ``y``:
    Output vector, length(y) = (nx+nu)*(N+1)

Throws a runtime_error if sizes aren't consistent or y is null.)""";
          } gemvH;
        } MpcData;
        // Symbol: drake::solvers::fbstab::MpcFeasibility
        struct /* MpcFeasibility */ {
          // Source: drake/solvers/fbstab/components/mpc_feasibility.h:21
          const char* doc =
R"""(This class detects infeasibility in quadratic programs, see mpc_data.h
for a description of the QPs. It contains methods for determining if a
primal-dual variable is a certificate of either unboundedness (dual
infeasibility) or primal infeasibility. It implements Algorithm 3 of
https://arxiv.org/pdf/1901.04046.pdf.)""";
          // Symbol: drake::solvers::fbstab::MpcFeasibility::ComputeFeasibility
          struct /* ComputeFeasibility */ {
            // Source: drake/solvers/fbstab/components/mpc_feasibility.h:45
            const char* doc =
R"""(Checks to see if x is an infeasibility certificate for the QP and
stores the result internally.

Parameter ``x``:
    infeasibility certificate candidate

Parameter ``tol``:
    numerical tolerance

Throws a runtime_error if x and *this aren't the same size or if the
problem data hasn't been linked.)""";
          } ComputeFeasibility;
          // Symbol: drake::solvers::fbstab::MpcFeasibility::IsDualFeasible
          struct /* IsDualFeasible */ {
            // Source: drake/solvers/fbstab/components/mpc_feasibility.h:51
            const char* doc =
R"""(Retrieves the result of the last infeasibility check.

Returns:
    false if a dual infeasibility certificate was found, true
    otherwise)""";
          } IsDualFeasible;
          // Symbol: drake::solvers::fbstab::MpcFeasibility::IsPrimalFeasible
          struct /* IsPrimalFeasible */ {
            // Source: drake/solvers/fbstab/components/mpc_feasibility.h:58
            const char* doc =
R"""(Retrieves the result of the last infeasibility check.

Returns:
    false if a primal infeasibility certificate was found, true
    otherwise)""";
          } IsPrimalFeasible;
          // Symbol: drake::solvers::fbstab::MpcFeasibility::MpcFeasibility
          struct /* ctor */ {
            // Source: drake/solvers/fbstab/components/mpc_feasibility.h:34
            const char* doc =
R"""(Allocates workspace memory.

Parameter ``N``:
    horizon length

Parameter ``nx``:
    number of states

Parameter ``nu``:
    number of control input

Parameter ``nc``:
    number of constraints per stage

Throws a runtime_error if any inputs are non-positive.)""";
          } ctor;
        } MpcFeasibility;
        // Symbol: drake::solvers::fbstab::MpcResidual
        struct /* MpcResidual */ {
          // Source: drake/solvers/fbstab/components/mpc_residual.h:27
          const char* doc =
R"""(This class computes and stores residuals for MPC QPs. See mpc_data.h
for the mathematical description.

Residuals have 3 components: - z: Stationarity residual - l: Equality
residual - v: Inequality/complimentarity residual)""";
          // Symbol: drake::solvers::fbstab::MpcResidual::Fill
          struct /* Fill */ {
            // Source: drake/solvers/fbstab/components/mpc_residual.h:54
            const char* doc =
R"""(Fills the storage with all a.

Parameter ``a``:)""";
          } Fill;
          // Symbol: drake::solvers::fbstab::MpcResidual::InnerResidual
          struct /* InnerResidual */ {
            // Source: drake/solvers/fbstab/components/mpc_residual.h:87
            const char* doc =
R"""(Computes R(x,xbar,sigma), the residual of a proximal subproblem and
stores the result internally. R(x,xbar,sigma) = 0 if and only if x =
P(xbar,sigma) where P is the proximal operator.

See (11) and (20) in https://arxiv.org/pdf/1901.04046.pdf for a
mathematical description.

Parameter ``x``:
    Inner loop variable

Parameter ``xbar``:
    Outer loop variable

Parameter ``sigma``:
    Regularization strength > 0

Throws a runtime_error if sigma isn't positive, or if x and xbar
aren't the same size.)""";
          } InnerResidual;
          // Symbol: drake::solvers::fbstab::MpcResidual::Merit
          struct /* Merit */ {
            // Source: drake/solvers/fbstab/components/mpc_residual.h:69
            const char* doc =
R"""(Returns:
    0.5*Norm()^2)""";
          } Merit;
          // Symbol: drake::solvers::fbstab::MpcResidual::MpcResidual
          struct /* ctor */ {
            // Source: drake/solvers/fbstab/components/mpc_residual.h:41
            const char* doc =
R"""(Allocates memory for the residual.

Parameter ``N``:
    horizon length

Parameter ``nx``:
    number of states

Parameter ``nu``:
    number of control input

Parameter ``nc``:
    number of constraints per stage

Throws a runtime_error if any of the inputs are non-positive.)""";
          } ctor;
          // Symbol: drake::solvers::fbstab::MpcResidual::NaturalResidual
          struct /* NaturalResidual */ {
            // Source: drake/solvers/fbstab/components/mpc_residual.h:98
            const char* doc =
R"""(Computes π(x): the natural residual of the QP at the primal-dual point
x and stores the result internally. See (17) in
https://arxiv.org/pdf/1901.04046.pdf for a mathematical definition.

Parameter ``x``:
    Evaluation point.)""";
          } NaturalResidual;
          // Symbol: drake::solvers::fbstab::MpcResidual::Negate
          struct /* Negate */ {
            // Source: drake/solvers/fbstab/components/mpc_residual.h:59
            const char* doc = R"""(Sets *this <- -1* *this.)""";
          } Negate;
          // Symbol: drake::solvers::fbstab::MpcResidual::Norm
          struct /* Norm */ {
            // Source: drake/solvers/fbstab/components/mpc_residual.h:64
            const char* doc =
R"""(Returns:
    Euclidean norm of the residual.)""";
          } Norm;
          // Symbol: drake::solvers::fbstab::MpcResidual::PenalizedNaturalResidual
          struct /* PenalizedNaturalResidual */ {
            // Source: drake/solvers/fbstab/components/mpc_residual.h:108
            const char* doc =
R"""(Computes the natural residual function augmented with penalty terms,
it is analogous to (18) in https://arxiv.org/pdf/1901.04046.pdf, and
stores the result internally.

Parameter ``x``:
    Evaluation point.)""";
          } PenalizedNaturalResidual;
          // Symbol: drake::solvers::fbstab::MpcResidual::SetAlpha
          struct /* SetAlpha */ {
            // Source: drake/solvers/fbstab/components/mpc_residual.h:48
            const char* doc =
R"""(Sets the value of alpha used in residual computations, see (19) in
https://arxiv.org/pdf/1901.04046.pdf.

Parameter ``alpha``:)""";
          } SetAlpha;
          // Symbol: drake::solvers::fbstab::MpcResidual::l
          struct /* l */ {
            // Source: drake/solvers/fbstab/components/mpc_residual.h:116
            const char* doc = R"""(Accessor for the equality residual.)""";
          } l;
          // Symbol: drake::solvers::fbstab::MpcResidual::l_norm
          struct /* l_norm */ {
            // Source: drake/solvers/fbstab/components/mpc_residual.h:128
            const char* doc = R"""(Norm of the equality residual.)""";
          } l_norm;
          // Symbol: drake::solvers::fbstab::MpcResidual::v
          struct /* v */ {
            // Source: drake/solvers/fbstab/components/mpc_residual.h:121
            const char* doc = R"""(Accessor for complementarity residual.)""";
          } v;
          // Symbol: drake::solvers::fbstab::MpcResidual::v_norm
          struct /* v_norm */ {
            // Source: drake/solvers/fbstab/components/mpc_residual.h:130
            const char* doc = R"""(Norm of the complementarity residual.)""";
          } v_norm;
          // Symbol: drake::solvers::fbstab::MpcResidual::z
          struct /* z */ {
            // Source: drake/solvers/fbstab/components/mpc_residual.h:111
            const char* doc = R"""(Accessor for stationarity residual.)""";
          } z;
          // Symbol: drake::solvers::fbstab::MpcResidual::z_norm
          struct /* z_norm */ {
            // Source: drake/solvers/fbstab/components/mpc_residual.h:126
            const char* doc = R"""(Norm of the stationarity residual.)""";
          } z_norm;
        } MpcResidual;
        // Symbol: drake::solvers::fbstab::MpcVariable
        struct /* MpcVariable */ {
          // Source: drake/solvers/fbstab/components/mpc_variable.h:35
          const char* doc =
R"""(This class implements primal-dual variables for model predictive
control QPs. See mpc_data.h for the mathematical description. Stores
variables and defines methods implementing useful operations.

Primal-dual variables have 4 fields: - z: Decision variables
(x0,u0,x1,u1, ... xN,uN) - l: Co-states/equality duals (l0, ... ,lN) -
v: Inequality duals (v0, ..., vN) - y: Inequality margins (y0, ...,
yN)

length(z) = nz = (nx*nu)*(N+1) length(l) = nl = nx*(N+1) length(v) =
nv = nc*(N+1) length(y) = nv = nc*(N+1))""";
          // Symbol: drake::solvers::fbstab::MpcVariable::Copy
          struct /* Copy */ {
            // Source: drake/solvers/fbstab/components/mpc_variable.h:102
            const char* doc =
R"""(Deep copies x into this.

Parameter ``x``:
    variable to be copied.)""";
          } Copy;
          // Symbol: drake::solvers::fbstab::MpcVariable::Fill
          struct /* Fill */ {
            // Source: drake/solvers/fbstab/components/mpc_variable.h:75
            const char* doc =
R"""(Fills the variable with one value.

Parameter ``a``:)""";
          } Fill;
          // Symbol: drake::solvers::fbstab::MpcVariable::InitializeConstraintMargin
          struct /* InitializeConstraintMargin */ {
            // Source: drake/solvers/fbstab/components/mpc_variable.h:81
            const char* doc =
R"""(Sets the constraint margin to y = b - Az. Throws a runtime_error if
problem data hasn't been provided.)""";
          } InitializeConstraintMargin;
          // Symbol: drake::solvers::fbstab::MpcVariable::LinkData
          struct /* LinkData */ {
            // Source: drake/solvers/fbstab/components/mpc_variable.h:69
            const char* doc =
R"""(Links to problem data needed to perform calculations. Calculations
cannot be performed until a data object is provided.

Parameter ``data``:
    pointer to the problem data)""";
          } LinkData;
          // Symbol: drake::solvers::fbstab::MpcVariable::MpcVariable
          struct /* ctor */ {
            // Source: drake/solvers/fbstab/components/mpc_variable.h:48
            const char* doc_4args_N_nx_nu_nc =
R"""(Allocates memory for a primal-dual variable.

Parameter ``N``:
    horizon length

Parameter ``nx``:
    number of states

Parameter ``nu``:
    number of control input

Parameter ``nc``:
    number of constraints per stage

Throws a runtime_error if any of the inputs are non-positive.)""";
            // Source: drake/solvers/fbstab/components/mpc_variable.h:61
            const char* doc_4args_z_l_v_y =
R"""(Creates a primal-dual variable using preallocated memory.

Parameter ``z``:
    A vector to store the decision variables.

Parameter ``l``:
    A vector to store the co-states/equality duals.

Parameter ``v``:
    A vector to store the dual variables.

Parameter ``y``:
    A vector to store the inequality margin.

Throws a runtime_error if sizes are mismatched or if any of the inputs
are null.)""";
          } ctor;
          // Symbol: drake::solvers::fbstab::MpcVariable::Norm
          struct /* Norm */ {
            // Source: drake/solvers/fbstab/components/mpc_variable.h:114
            const char* doc =
R"""(Computes the Euclidean norm.

Returns:
    sqrt(|z|^2 + |l|^2 + |v|^2))""";
          } Norm;
          // Symbol: drake::solvers::fbstab::MpcVariable::ProjectDuals
          struct /* ProjectDuals */ {
            // Source: drake/solvers/fbstab/components/mpc_variable.h:108
            const char* doc =
R"""(Projects the inequality duals onto the non-negative orthant, i.e., v
<- max(0,v).)""";
          } ProjectDuals;
          // Symbol: drake::solvers::fbstab::MpcVariable::SameSize
          struct /* SameSize */ {
            // Source: drake/solvers/fbstab/components/mpc_variable.h:117
            const char* doc =
R"""(Returns true if x and y have the same dimensions.)""";
          } SameSize;
          // Symbol: drake::solvers::fbstab::MpcVariable::axpy
          struct /* axpy */ {
            // Source: drake/solvers/fbstab/components/mpc_variable.h:96
            const char* doc =
R"""(Performs the operation *this <- a*x + *this. This is a level 1 BLAS
operation for this object; see http://www.netlib.org/blas/blasqr.pdf.

Parameter ``a``:
    scalar

Parameter ``x``:
    vector

Note that this handles the constraint margin correctly, i.e., after
the operation u.y = b - A*(u.z + a*x.z).

Throws a runtime_error if problem data hasn't been provided.)""";
          } axpy;
          // Symbol: drake::solvers::fbstab::MpcVariable::l
          struct /* l */ {
            // Source: drake/solvers/fbstab/components/mpc_variable.h:122
            const char* doc = R"""(Accessor for the co-state.)""";
          } l;
          // Symbol: drake::solvers::fbstab::MpcVariable::v
          struct /* v */ {
            // Source: drake/solvers/fbstab/components/mpc_variable.h:124
            const char* doc = R"""(Accessor for the dual variable.)""";
          } v;
          // Symbol: drake::solvers::fbstab::MpcVariable::y
          struct /* y */ {
            // Source: drake/solvers/fbstab/components/mpc_variable.h:126
            const char* doc = R"""(Accessor for the inequality margin.)""";
          } y;
          // Symbol: drake::solvers::fbstab::MpcVariable::z
          struct /* z */ {
            // Source: drake/solvers/fbstab/components/mpc_variable.h:120
            const char* doc = R"""(Accessor for the decision variable.)""";
          } z;
        } MpcVariable;
        // Symbol: drake::solvers::fbstab::RiccatiLinearSolver
        struct /* RiccatiLinearSolver */ {
          // Source: drake/solvers/fbstab/components/riccati_linear_solver.h:52
          const char* doc =
R"""(Implements a Riccati recursion based method for solving linear systems
of equations that arise when solving MPC form QPs (see mpc_data.h)
using FBstab. The equations are of the form

[Hs G' A'][dz] = [rz] [-G sI 0 ][dl] = [rl] [-CA 0 D ][dv] = [rv]

where s = sigma, C = diag(gamma), D = diag(mu + sigma*gamma). The
vectors gamma and mu are defined in (24) of
https://arxiv.org/pdf/1901.04046.pdf.

In compact form:

V(x,xbar,sigma)*dx = r.

The Riccati recursion used by this class is based on the one in:

Rao, Christopher V., Stephen J. Wright, and James B. Rawlings.
"Application of interior-point methods to model predictive control."
Journal of optimization theory and applications 99.3 (1998): 723-757.

and is used to perform the factorization efficiently. This class also
contains workspace memory and methods for setting up and solving the
linear systems.

There is an error on page 744 of the paper in the \Delta x_k equation,
It's missing a residual term. This class contains mutable members as
is thus not thread safe.)""";
          // Symbol: drake::solvers::fbstab::RiccatiLinearSolver::Initialize
          struct /* Initialize */ {
            // Source: drake/solvers/fbstab/components/riccati_linear_solver.h:89
            const char* doc =
R"""(Computes then factors the matrix V(x,xbar,sigma) using a Riccati
recursion.

The matrix V is computed as described in Algorithm 4 of
https://arxiv.org/pdf/1901.04046.pdf.

Parameter ``x``:
    Inner loop iterate

Parameter ``xbar``:
    Outer loop iterate

Parameter ``sigma``:
    Regularization strength

Returns:
    true if factorization succeeds false otherwise.

Throws a runtime_error if x and xbar aren't the correct size, sigma is
negative or the problem data isn't linked.)""";
          } Initialize;
          // Symbol: drake::solvers::fbstab::RiccatiLinearSolver::RiccatiLinearSolver
          struct /* ctor */ {
            // Source: drake/solvers/fbstab/components/riccati_linear_solver.h:65
            const char* doc =
R"""(Allocates workspace memory.

Parameter ``N``:
    horizon length

Parameter ``nx``:
    number of states

Parameter ``nu``:
    number of control input

Parameter ``nc``:
    number of constraints per stage

Throws a runtime_error if any of the inputs are non-positive.)""";
          } ctor;
          // Symbol: drake::solvers::fbstab::RiccatiLinearSolver::SetAlpha
          struct /* SetAlpha */ {
            // Source: drake/solvers/fbstab/components/riccati_linear_solver.h:72
            const char* doc =
R"""(Sets a parameter used in the algorithm, see (19) in
https://arxiv.org/pdf/1901.04046.pdf.

Parameter ``alpha``:)""";
          } SetAlpha;
          // Symbol: drake::solvers::fbstab::RiccatiLinearSolver::Solve
          struct /* Solve */ {
            // Source: drake/solvers/fbstab/components/riccati_linear_solver.h:103
            const char* doc =
R"""(Solves the system V*x = r and stores the result in x. This method
assumes that the Factor routine was run to compute then factor the
matrix V.

Parameter ``r``:
    The right hand side vector

Parameter ``x``:
    Overwritten with the solution

Returns:
    true if the solve succeeds, false otherwise

Throws a runtime_error if x and r aren't the correct sizes, if x is
null or if the problem data isn't linked.)""";
          } Solve;
        } RiccatiLinearSolver;
        // Symbol: drake::solvers::fbstab::SolverOut
        struct /* SolverOut */ {
          // Source: drake/solvers/fbstab/fbstab_algorithm.h:34
          const char* doc =
R"""(Packages the exit flag, overall residual, solve time, and iteration
counts.

A negative valuve for solve_time indicates that no timing data is
available.)""";
          // Symbol: drake::solvers::fbstab::SolverOut::eflag
          struct /* eflag */ {
            // Source: drake/solvers/fbstab/fbstab_algorithm.h:35
            const char* doc = R"""()""";
          } eflag;
          // Symbol: drake::solvers::fbstab::SolverOut::newton_iters
          struct /* newton_iters */ {
            // Source: drake/solvers/fbstab/fbstab_algorithm.h:37
            const char* doc = R"""()""";
          } newton_iters;
          // Symbol: drake::solvers::fbstab::SolverOut::prox_iters
          struct /* prox_iters */ {
            // Source: drake/solvers/fbstab/fbstab_algorithm.h:38
            const char* doc = R"""()""";
          } prox_iters;
          // Symbol: drake::solvers::fbstab::SolverOut::residual
          struct /* residual */ {
            // Source: drake/solvers/fbstab/fbstab_algorithm.h:36
            const char* doc = R"""()""";
          } residual;
          // Symbol: drake::solvers::fbstab::SolverOut::solve_time
          struct /* solve_time */ {
            // Source: drake/solvers/fbstab/fbstab_algorithm.h:39
            const char* doc = R"""()""";
          } solve_time;
        } SolverOut;
        // Symbol: drake::solvers::fbstab::clock
        struct /* clock */ {
          // Source: drake/solvers/fbstab/fbstab_algorithm.h:42
          const char* doc = R"""()""";
        } clock;
        // Symbol: drake::solvers::fbstab::test
        struct /* test */ {
        } test;
      } fbstab;
      // Symbol: drake::solvers::operator!=
      struct /* operator_ne */ {
        // Source: drake/solvers/solver_id.h:52
        const char* doc = R"""()""";
      } operator_ne;
      // Symbol: drake::solvers::to_string
      struct /* to_string */ {
        // Source: drake/solvers/mixed_integer_optimization_util.h:179
        const char* doc = R"""()""";
      } to_string;
    } solvers;
    // Symbol: drake::static_pointer_cast
    struct /* static_pointer_cast */ {
      // Source: drake/common/pointer_cast.h:20
      const char* doc =
R"""(Casts the object owned by the std::unique_ptr ``other`` from type
``U`` to ``T``; no runtime type checking is performed.

This method is analogous to the built-in std::static_pointer_cast that
operates on a std::shared_ptr.

Note that this function only supports default deleters.)""";
    } static_pointer_cast;
    // Symbol: drake::symbolic
    struct /* symbolic */ {
      // Symbol: drake::symbolic::BasisElementGradedReverseLexOrder
      struct /* BasisElementGradedReverseLexOrder */ {
        // Source: drake/common/symbolic_polynomial_basis_element.h:188
        const char* doc =
R"""(Implements Graded reverse lexicographic order.

Template parameter ``VariableOrder``:
    VariableOrder{}(v1, v2) is true if v1 < v2.

Template parameter ``BasisElement``:
    A derived class of PolynomialBasisElement.

We first compare the total degree of the PolynomialBasisElement; if
there is a tie, then we use the graded reverse lexicographical order
as the tie breaker.

Take monomials with variables {x, y, z} and total degree<=2 as an
example, with the order x > y > z. To get the graded reverse
lexicographical order, we take the following steps:

First find all the monomials using the total degree. The monomials
with degree 2 are {x², y², z², xy, xz, yz}. The monomials with degree
1 are {x, y, z}, and the monomials with degree 0 is {1}. To break the
tie between monomials with the same total degree, first sort them in
the reverse lexicographical order, namely x < y < z. The
lexicographical order compares two monomials by first comparing the
exponent of the largest variable, if there is a tie then go forth to
the second largest variable. Thus z² > zy >zx > y² > yx > x². Finally
reverse the order as x² > xy > y² > xz > yz > z² > x > y > z.

There is an introduction to monomial order in
https://en.wikipedia.org/wiki/Monomial_order, and an introduction to
graded reverse lexicographical order in
https://en.wikipedia.org/wiki/Monomial_order#Graded_reverse_lexicographic_order)""";
        // Symbol: drake::symbolic::BasisElementGradedReverseLexOrder::operator()
        struct /* operator_call */ {
          // Source: drake/common/symbolic_polynomial_basis_element.h:190
          const char* doc =
R"""(Returns true if m1 < m2 under the Graded reverse lexicographic order.)""";
        } operator_call;
      } BasisElementGradedReverseLexOrder;
      // Symbol: drake::symbolic::BinaryExpressionCell
      struct /* BinaryExpressionCell */ {
        // Source: drake/common/symbolic_expression_cell.h:164
        const char* doc =
R"""(Represents the base class for binary expressions.)""";
        // Symbol: drake::symbolic::BinaryExpressionCell::BinaryExpressionCell
        struct /* ctor */ {
          // Source: drake/common/symbolic_expression_cell.h:177
          const char* doc_0args = R"""(Default constructor (DELETED).)""";
          // Source: drake/common/symbolic_expression_cell.h:187
          const char* doc_move = R"""(Move-constructs from an rvalue.)""";
          // Source: drake/common/symbolic_expression_cell.h:189
          const char* doc_copy = R"""(Copy-constructs from an lvalue.)""";
          // Source: drake/common/symbolic_expression_cell.h:193
          const char* doc_5args =
R"""(Constructs BinaryExpressionCell of kind ``k`` with ``e1``, ``e2``,
``is_poly``, and ``is_expanded``.)""";
        } ctor;
        // Symbol: drake::symbolic::BinaryExpressionCell::DoEvaluate
        struct /* DoEvaluate */ {
          // Source: drake/common/symbolic_expression_cell.h:196
          const char* doc =
R"""(Returns the evaluation result f(``v1``, ``v2`` ).)""";
        } DoEvaluate;
        // Symbol: drake::symbolic::BinaryExpressionCell::EqualTo
        struct /* EqualTo */ {
          // Source: drake/common/symbolic_expression_cell.h:168
          const char* doc = R"""()""";
        } EqualTo;
        // Symbol: drake::symbolic::BinaryExpressionCell::Evaluate
        struct /* Evaluate */ {
          // Source: drake/common/symbolic_expression_cell.h:170
          const char* doc = R"""()""";
        } Evaluate;
        // Symbol: drake::symbolic::BinaryExpressionCell::GetVariables
        struct /* GetVariables */ {
          // Source: drake/common/symbolic_expression_cell.h:167
          const char* doc = R"""()""";
        } GetVariables;
        // Symbol: drake::symbolic::BinaryExpressionCell::HashAppendDetail
        struct /* HashAppendDetail */ {
          // Source: drake/common/symbolic_expression_cell.h:166
          const char* doc = R"""()""";
        } HashAppendDetail;
        // Symbol: drake::symbolic::BinaryExpressionCell::Less
        struct /* Less */ {
          // Source: drake/common/symbolic_expression_cell.h:169
          const char* doc = R"""()""";
        } Less;
        // Symbol: drake::symbolic::BinaryExpressionCell::get_first_argument
        struct /* get_first_argument */ {
          // Source: drake/common/symbolic_expression_cell.h:172
          const char* doc = R"""(Returns the first argument.)""";
        } get_first_argument;
        // Symbol: drake::symbolic::BinaryExpressionCell::get_second_argument
        struct /* get_second_argument */ {
          // Source: drake/common/symbolic_expression_cell.h:174
          const char* doc = R"""(Returns the second argument.)""";
        } get_second_argument;
      } BinaryExpressionCell;
      // Symbol: drake::symbolic::ChebyshevBasisElement
      struct /* ChebyshevBasisElement */ {
        // Source: drake/common/symbolic_chebyshev_basis_element.h:22
        const char* doc =
R"""(ChebyshevBasisElement represents an element of Chebyshev polynomial
basis, written as the product of Chebyshev polynomials, in the form
Tₚ₀(x₀)Tₚ₁(x₁)...Tₚₙ(xₙ), where each Tₚᵢ(xᵢ) is a (univariate)
Chebyshev polynomial of degree pᵢ.)""";
        // Symbol: drake::symbolic::ChebyshevBasisElement::ChebyshevBasisElement
        struct /* ctor */ {
          // Source: drake/common/symbolic_chebyshev_basis_element.h:27
          const char* doc_0args =
R"""(Constructs a ChebyshevBasisElement equals to 1.)""";
          // Source: drake/common/symbolic_chebyshev_basis_element.h:33
          const char* doc_1args_var =
R"""(Constructs a Chebyshev polynomial T₁(var).)""";
          // Source: drake/common/symbolic_chebyshev_basis_element.h:36
          const char* doc_2args_var_degree =
R"""(Constructs a Chebyshev polynomial Tₙ(var) where n = degree.)""";
          // Source: drake/common/symbolic_chebyshev_basis_element.h:41
          const char* doc_1args_stdnullptrt =
R"""(Constructs a default value 1. This overload is used by Eigen when
EIGEN_INITIALIZE_MATRICES_BY_ZERO is enabled.)""";
        } ctor;
        // Symbol: drake::symbolic::ChebyshevBasisElement::Differentiate
        struct /* Differentiate */ {
          // Source: drake/common/symbolic_chebyshev_basis_element.h:67
          const char* doc =
R"""(Differentiates the ChebyshevBasisElement with respect to a variable.
We use the fact that - If n is even dTₙ(x)/dx = 2n ∑ⱼ Tⱼ(x), j is odd
and 1 <= j <= n-1 - If n is odd dTₙ(x)/dx = 2n ∑ⱼ Tⱼ(x) - n, j is even
and 0 <= j <= n-1 We return ``result``, a map from
ChebyshevBasisElement to double, such that sum(result.key() *
result[key]) is the differentiation of ``this`` w.r.t the variable.
For example if n is even, dTₙ(x)Tₘ(y)/dx = 2n∑ⱼ Tⱼ(x)Tₘ(y), j is odd
and 1 <= j <= n-1, then the returned result is {T₁(x)Tₘ(y), 2n},
{T₃(x)Tₘ(y), 2n}, ..., {T₂ₙ₋₁(x)Tₘ(y), 2n}. A special case is that
``var`` is not a variable in ``this``, then we return an empty map.

Parameter ``var``:
    A variable to differentiate with.)""";
        } Differentiate;
        // Symbol: drake::symbolic::ChebyshevBasisElement::EvaluatePartial
        struct /* EvaluatePartial */ {
          // Source: drake/common/symbolic_chebyshev_basis_element.h:103
          const char* doc =
R"""(Partially evaluates using a given environment ``env``. The evaluation
result is of type pair<double, ChebyshevBasisElement>. The first
component (: double) represents the coefficient part while the second
component represents the remaining parts of the ChebyshevBasisElement
which was not evaluated, the product of the first and the second
component is the result of the partial evaluation. For example, if
this ChebyshevBasisElement is T₂(x)T₃(y)T₁(z), and ``env`` stores x→
3, y→ 2, then the partial evaluation is T₂(3)*T₃(2)*T₁(z) = 17 * 26 *
T₁(z) = 442*T₁(z), then we return the pair (442, T₁(z)).)""";
        } EvaluatePartial;
        // Symbol: drake::symbolic::ChebyshevBasisElement::Integrate
        struct /* Integrate */ {
          // Source: drake/common/symbolic_chebyshev_basis_element.h:81
          const char* doc =
R"""(Integrates a ChebyshevBasisElement for a variable. We use the fact
that ∫ Tₙ(x)dx = 1/(2n+2)Tₙ₊₁(x) − 1/(2n−2)Tₙ₋₁(x) A special case is ∫
T₀(x)dx = T₁(x)

Parameter ``var``:
    The variable to integrate. If

Parameter ``var``:
    is not a variable in this ChebyshevBasisElement, then the
    integration result is *this * T₁(var).

Returns ``result``:
    sum(key * result[key]) is the integration result. For example, ∫
    T₂(x)T₃(y)dx = 1/6*T₃(x)T₃(y) − 1/2 * T₁(x)T₃(y), then the result
    is the map containing {T₃(x)T₃(y), 1/6} and {T₁(x)T₃(y), -1/2}.)""";
        } Integrate;
        // Symbol: drake::symbolic::ChebyshevBasisElement::MergeBasisElementInPlace
        struct /* MergeBasisElementInPlace */ {
          // Source: drake/common/symbolic_chebyshev_basis_element.h:91
          const char* doc =
R"""(Merges this Chebyshev basis element with another Chebyshev basis
element ``other`` by merging their var_to_degree_map. After merging,
the degree of each variable is raised to the sum of the degree in each
basis element (if a variable does not show up in either one of the
basis element, we regard its degree to be 0). For example, merging
T₁(x)T₃(y) and T₂(x)T₄(z) gets T₃(x)T₃(y)T₄(z).)""";
        } MergeBasisElementInPlace;
        // Symbol: drake::symbolic::ChebyshevBasisElement::operator<
        struct /* operator_lt */ {
          // Source: drake/common/symbolic_chebyshev_basis_element.h:51
          const char* doc =
R"""(Compares two ChebyshevBasisElement in lexicographic order.)""";
        } operator_lt;
      } ChebyshevBasisElement;
      // Symbol: drake::symbolic::ChebyshevPolynomial
      struct /* ChebyshevPolynomial */ {
        // Source: drake/common/symbolic_chebyshev_polynomial.h:28
        const char* doc =
R"""(Represents the Chebyshev polynomial of the first kind Tₙ(x). One
definition of Chebyshev polynomial of the first kind is Tₙ(cos(θ)) =
cos(nθ) It can also be defined recursively as

T₀(x) = 1 T₁(x) = x Tₙ₊₁(x) = 2xTₙ(x) − Tₙ₋₁(x))""";
        // Symbol: drake::symbolic::ChebyshevPolynomial::ChebyshevPolynomial
        struct /* ctor */ {
          // Source: drake/common/symbolic_chebyshev_polynomial.h:38
          const char* doc =
R"""(Constructs a Chebyshev polynomial Tₙ(x)

Parameter ``var``:
    The variable x

Parameter ``degree``:
    The Chebyshev polynomial is of degree n.

Precondition:
    degree >= 0.)""";
        } ctor;
        // Symbol: drake::symbolic::ChebyshevPolynomial::Differentiate
        struct /* Differentiate */ {
          // Source: drake/common/symbolic_chebyshev_polynomial.h:100
          const char* doc =
R"""(Computes the differentiation of a Chebyshev polynomial dTₙ(x)/dx =
nUₙ₋₁(x) where Uₙ₋₁(x) is a Chebyshev polynomial of the second kind.
Uₙ₋₁(x) can be written as a summation of Chebyshev polynomials of the
first kind with lower degrees. - If n is even dTₙ(x)/dx = 2n ∑ⱼ Tⱼ(x),
j is odd and j <= n-1 - If n is odd dTₙ(x)/dx = 2n ∑ⱼ Tⱼ(x) - n, j is
even and j <= n-1 - A special case is that dT₀(x)/dx = 0.

Returns ``chebyshev_coeff_pairs``:
    . sum(chebyshev_coeff_pairs[j].first *
    chebyshev_coeff_pairs[j].second) is the differentiation dTₙ(x)/dx.
    If n is even, then chebyshev_coeff_pairs[j] = (T₂ⱼ₋₁(x), 2n). If n
    is odd, then chebyshev_coeff_pairs[j] = (T₂ⱼ(x), 2n) for j >= 1,
    and chebyshev_coeff_pairs[0] = (T₀(x), n). For the special case
    when degree() == 0, we return an empty vector.)""";
        } Differentiate;
        // Symbol: drake::symbolic::ChebyshevPolynomial::Evaluate
        struct /* Evaluate */ {
          // Source: drake/common/symbolic_chebyshev_polynomial.h:54
          const char* doc =
R"""(Evaluates this Chebyshev polynomial at ``var_val``.)""";
        } Evaluate;
        // Symbol: drake::symbolic::ChebyshevPolynomial::ToPolynomial
        struct /* ToPolynomial */ {
          // Source: drake/common/symbolic_chebyshev_polynomial.h:49
          const char* doc =
R"""(Converts this Chebyshev polynomial to a polynomial with monomial
basis.)""";
        } ToPolynomial;
        // Symbol: drake::symbolic::ChebyshevPolynomial::degree
        struct /* degree */ {
          // Source: drake/common/symbolic_chebyshev_polynomial.h:44
          const char* doc =
R"""(Getter for the degree of the Chebyshev polynomial.)""";
        } degree;
        // Symbol: drake::symbolic::ChebyshevPolynomial::operator!=
        struct /* operator_ne */ {
          // Source: drake/common/symbolic_chebyshev_polynomial.h:66
          const char* doc =
R"""(Checks if this and ``other`` do not represent the same Chebyshev
polynomial.)""";
        } operator_ne;
        // Symbol: drake::symbolic::ChebyshevPolynomial::operator<
        struct /* operator_lt */ {
          // Source: drake/common/symbolic_chebyshev_polynomial.h:81
          const char* doc =
R"""(Compare this to another Chebyshev polynomial, returns True if this is
regarded as less than the other, otherwise returns false.

If this.var() < other.var(), return True. If this.var() > other.var(),
return False. If this.var() == other.var(), then return this.degree()
< other.degree().

A special case is when this.degree() == 0 or other.degree() == 0. In
this case the variable doesn't matter, and we return this.degree() <
other.degree().)""";
        } operator_lt;
        // Symbol: drake::symbolic::ChebyshevPolynomial::var
        struct /* var */ {
          // Source: drake/common/symbolic_chebyshev_polynomial.h:41
          const char* doc = R"""(Getter for the variable.)""";
        } var;
      } ChebyshevPolynomial;
      // Symbol: drake::symbolic::CheckStructuralEquality
      struct /* CheckStructuralEquality */ {
        // Source: drake/common/symbolic_expression.h:1451
        const char* doc_was_unable_to_choose_unambiguous_names =
R"""(Checks if two Eigen::Matrix<Expression> ``m1`` and ``m2`` are
structurally equal. That is, it returns true if and only if ``m1(i,
j)`` is structurally equal to ``m2(i, j)`` for all ``i``, `j`.)""";
      } CheckStructuralEquality;
      // Symbol: drake::symbolic::CodeGen
      struct /* CodeGen */ {
        // Source: drake/common/symbolic_codegen.h:115
        const char* doc_3args_function_name_parameters_e =
R"""(For a given symbolic expression ``e``, generates two C functions,
``<function_name>`` and ``<function_name>_meta``. The generated
``<function_name>`` function takes an array of doubles for parameters
and returns an evaluation result. ``<function_name>_meta`` returns a
nested struct from which a caller can obtain the following
information: - ``.p.size``: the size of input parameters.

Parameter ``function_name``:
    Name of the generated C function.

Parameter ``parameters``:
    Vector of variables provide the ordering of symbolic variables.

Parameter ``e``:
    Symbolic expression to codegen.

For example, ``Codegen("f", {x, y}, 1 + sin(x) + cos(y))`` generates
the following string.


::

    double f(const double* p) {
        return (1 + sin(p[0]) + cos(p[1]));
    }
    typedef struct {
        /* p: input, vector 
        struct { int size; } p;
    } f_meta_t;
    f_meta_t f_meta() { return {{2}}; }

Note that in this example ``x`` and ``y`` are mapped to ``p[0]`` and
``p[1]`` respectively because we passed ``{x, y}`` to ``Codegen``.)""";
        // Source: drake/common/symbolic_codegen.h:202
        const char* doc_3args_conststdstring_conststdvector_constEigenPlainObjectBase =
R"""(For a given symbolic dense matrix ``M``, generates two C functions,
``<function_name>`` and ``<function_name>_meta``. The generated
``<function_name>`` takes two parameters:

- const double* p : An array of doubles for input parameters. -
double* m : An array of doubles to store the evaluation result.

``<function_name>_meta()`` returns a nested struct from which a caller
can obtain the following information: - ``.p.size``: the size of input
parameters. - ``.m.rows``: the number of rows in the matrix. -
``.m.cols``: the number of columns in the matrix.

Please consider the following example:


::

    Eigen::Matrix<symbolic::Expression, 2, 2, Eigen::ColMajor> M;
    M(0, 0) = 1.0;
    M(1, 0) = 3 + x + y;
    M(0, 1) = 4 * y;
    M(1, 1) = sin(x);
    CodeGen("f", {x, y}, M);

When executed, the last line of the above example generates the
following code:


::

    void f(const double* p, double* m) {
      m[0] = 1.000000;
      m[1] = (3 + p[0] + p[1]);
      m[2] = (4 * p[1]);
      m[3] = sin(p[0]);
    }
    typedef struct {
      /* p: input, vector 
      struct {
        int size;
      } p;
      /* m: output, matrix 
      struct {
        int rows;
        int cols;
      } m;
    } f_meta_t;
    f_meta_t f_meta() { return {{2}, {2, 2}}; }

Note that in this example, the matrix ``M`` is stored in column-major
order and the ``CodeGen`` function respects the storage order in the
generated code. If ``M`` were stored in row-major order, ``CodeGen``
would return the following:


::

    void f(const double* p, double* m) {
        m[0] = 1.000000;
        m[1] = (4 * p[1]);
        m[2] = (3 + p[0] + p[1]);
        m[3] = sin(p[0]);
    })""";
        // Source: drake/common/symbolic_codegen.h:329
        const char* doc_3args_function_name_parameters_M =
R"""(Please consider the following example which generates code for a 3x6
sparse matrix.


::

    Eigen::SparseMatrix<Expression, Eigen::ColMajor> m(3, 6);
    m.insert(0, 0) = x;
    m.insert(0, 4) = z;
    m.insert(1, 2) = y;
    m.insert(2, 3) = y;
    m.insert(2, 5) = y;
    m.makeCompressed();
    // | x  0  0  0  z  0|
    // | 0  0  y  0  0  0|
    // | 0  0  0  y  0  y|
    CodeGen("f", {x, y, z}, m);

When executed, the last line of the above example generates the
following code:


::

    void f(const double* p,
           int* outer_indices,
           int* inner_indices,
           double* values) {
        outer_indices[0] = 0;
        outer_indices[1] = 1;
        outer_indices[2] = 1;
        outer_indices[3] = 2;
        outer_indices[4] = 3;
        outer_indices[5] = 4;
        outer_indices[6] = 5;
    
        inner_indices[0] = 0;
        inner_indices[1] = 1;
        inner_indices[2] = 2;
        inner_indices[3] = 0;
        inner_indices[4] = 2;
    
        values[0] = p[0];
        values[1] = p[1];
        values[2] = p[1];
        values[3] = p[2];
        values[4] = p[1];
    }
    
    typedef struct {
        /* p: input, vector 
        struct { int size; } p;
        /* m: output, matrix 
        struct {
            int rows;
            int cols;
            int non_zeros;
        } m;
    } f_meta_t;
    f_meta_t f_meta() { return {{3}, {3, 6, 5}}; }

In the following example, we show how to use the generated function to
evaluate the symbolic matrix and construct a sparse matrix of double
using ``Eigen::Map``.


::

    // set up param, outer_indices, inner_indices, and values.
    f_meta_t meta = f_meta();
    const Eigen::Vector3d param{1 /* x */, 2 /* y */, 3 /* z */};
    std::vector<int> outer_indices(meta.m.cols + 1);
    std::vector<int> inner_indices(meta.m.non_zeros);
    std::vector<double> values(meta.m.non_zeros);
    
    // call f to fill outer_indices, inner_indices, and values.
    f(param.data(), outer_indices.data(), inner_indices.data(), values.data());
    
    // use Eigen::Map to turn (outer_indices, inner_indices, values) into a
    // sparse matrix.
    Eigen::Map<Eigen::SparseMatrix<double, Eigen::ColMajor>> map_sp(
        meta.m.rows, meta.m.cols, meta.m.non_zeros, outer_indices.data(),
        inner_indices.data(), values.data());
    const Eigen::SparseMatrix<double> m_double{map_sp.eval()};)""";
      } CodeGen;
      // Symbol: drake::symbolic::CodeGenVisitor
      struct /* CodeGenVisitor */ {
        // Source: drake/common/symbolic_codegen.h:18
        const char* doc = R"""(Visitor class for code generation.)""";
        // Symbol: drake::symbolic::CodeGenVisitor::CodeGen
        struct /* CodeGen */ {
          // Source: drake/common/symbolic_codegen.h:32
          const char* doc =
R"""(Generates C expression for the expression ``e``.)""";
        } CodeGen;
        // Symbol: drake::symbolic::CodeGenVisitor::CodeGenVisitor
        struct /* ctor */ {
          // Source: drake/common/symbolic_codegen.h:29
          const char* doc =
R"""(Constructs an instance of this visitor class using the vector of
variables, ``parameters``. This visitor will map a symbolic variable
``var`` into ``p[n]`` where ``n`` is the index of the variable ``var``
in the given ``parameters``.)""";
        } ctor;
        // Symbol: drake::symbolic::CodeGenVisitor::IdToIndexMap
        struct /* IdToIndexMap */ {
          // Source: drake/common/symbolic_codegen.h:20
          const char* doc = R"""()""";
        } IdToIndexMap;
      } CodeGenVisitor;
      // Symbol: drake::symbolic::ComputePolynomialBasisUpToDegree
      struct /* ComputePolynomialBasisUpToDegree */ {
        // Source: drake/common/symbolic_polynomial_basis.h:119
        const char* doc =
R"""(Returns all polynomial basis elements up to a given degree under the
graded reverse lexicographic order.

Template parameter ``rows``:
    Number of rows or Eigen::Dynamic.

Template parameter ``BasisElement``:
    A derived class of PolynomialBasisElement.

Parameter ``vars``:
    The variables appearing in the polynomial basis.

Parameter ``degree``:
    The highest total degree of the polynomial basis elements.

Parameter ``degree_type``:
    If degree_type is kAny, then the polynomial basis elements'
    degrees are no larger than ``degree``. If degree_type is kEven,
    then the elements' degrees are even numbers no larger than
    ``degree``. If degree_type is kOdd, then the elements' degrees are
    odd numbers no larger than ``degree``. TODO(hongkai.dai): this
    will replace ComputeMonomialBasis in symbolic_monomial_util.h)""";
      } ComputePolynomialBasisUpToDegree;
      // Symbol: drake::symbolic::DecomposeAffineExpression
      struct /* DecomposeAffineExpression */ {
        // Source: drake/common/symbolic_decompose.h:118
        const char* doc = R"""()""";
      } DecomposeAffineExpression;
      // Symbol: drake::symbolic::DecomposeAffineExpressions
      struct /* DecomposeAffineExpressions */ {
        // Source: drake/common/symbolic_decompose.h:30
        const char* doc =
R"""(Decomposes ``expressions`` into ``M`` * ``vars`` + ``v``.

Raises:
    RuntimeError if ``expressions`` is not affine in ``vars``.

Precondition:
    M.rows() == expressions.rows() && M.cols() == vars.rows().

Precondition:
    v.rows() == expressions.rows().)""";
      } DecomposeAffineExpressions;
      // Symbol: drake::symbolic::DecomposeLinearExpressions
      struct /* DecomposeLinearExpressions */ {
        // Source: drake/common/symbolic_decompose.h:20
        const char* doc =
R"""(Decomposes ``expressions`` into ``M`` * ``vars``.

Raises:
    RuntimeError if ``expressions`` is not linear in ``vars``.

Precondition:
    M.rows() == expressions.rows() && M.cols() == vars.rows().)""";
      } DecomposeLinearExpressions;
      // Symbol: drake::symbolic::DecomposeQuadraticPolynomial
      struct /* DecomposeQuadraticPolynomial */ {
        // Source: drake/common/symbolic_decompose.h:73
        const char* doc = R"""()""";
      } DecomposeQuadraticPolynomial;
      // Symbol: drake::symbolic::Environment
      struct /* Environment */ {
        // Source: drake/common/symbolic_environment.h:57
        const char* doc =
R"""(Represents a symbolic environment (mapping from a variable to a
value).

This class is used when we evaluate symbolic expressions or formulas
which include unquantified (free) variables. Here are examples:


::

    const Variable var_x{"x"};
      const Variable var_y{"y"};
      const Expression x{var_x};
      const Expression y{var_x};
      const Expression e1{x + y};
      const Expression e2{x - y};
      const Formula f{e1 > e2};
    
      // env maps var_x to 2.0 and var_y to 3.0
      const Environment env{{var_x, 2.0}, {var_y, 3.0}};
    
      const double res1 = e1.Evaluate(env);  // x + y => 2.0 + 3.0 =>  5.0
      const double res2 = e2.Evaluate(env);  // x - y => 2.0 - 3.0 => -1.0
      const bool res = f.Evaluate(env);  // x + y > x - y => 5.0 >= -1.0 => True

Note that it is not allowed to have a dummy variable in an
environment. It throws RuntimeError for the attempts to create an
environment with a dummy variable, to insert a dummy variable to an
existing environment, or to take a reference to a value mapped to a
dummy variable. See the following examples.


::

    Variable    var_dummy{};           // OK to have a dummy variable
      Environment e1{var_dummy};         // throws RuntimeError exception
      Environment e2{{var_dummy, 1.0}};  // throws RuntimeError exception
      Environment e{};
      e.insert(var_dummy, 1.0);          // throws RuntimeError exception
      e[var_dummy] = 3.0;                // throws RuntimeError exception)""";
        // Symbol: drake::symbolic::Environment::Environment
        struct /* ctor */ {
          // Source: drake/common/symbolic_environment.h:70
          const char* doc_0args = R"""(Default constructor.)""";
          // Source: drake/common/symbolic_environment.h:78
          const char* doc_1args_init =
R"""(List constructor. Constructs an environment from a list of (Variable *
double).

Raises:
    RuntimeError if ``init`` include a dummy variable or a NaN value.)""";
          // Source: drake/common/symbolic_environment.h:85
          const char* doc_1args_vars =
R"""(List constructor. Constructs an environment from a list of Variable.
Initializes the variables with 0.0.

Raises:
    RuntimeError if ``vars`` include a dummy variable.)""";
          // Source: drake/common/symbolic_environment.h:92
          const char* doc_1args_m =
R"""(Constructs an environment from ``m`` (of ``map`` type, which is
``std::unordered_map``).

Raises:
    RuntimeError if ``m`` include a dummy variable or a NaN value.)""";
        } ctor;
        // Symbol: drake::symbolic::Environment::begin
        struct /* begin */ {
          // Source: drake/common/symbolic_environment.h:95
          const char* doc_0args_nonconst = R"""(Returns an iterator to the beginning.)""";
          // Source: drake/common/symbolic_environment.h:99
          const char* doc_0args_const =
R"""(Returns a const iterator to the beginning.)""";
        } begin;
        // Symbol: drake::symbolic::Environment::cbegin
        struct /* cbegin */ {
          // Source: drake/common/symbolic_environment.h:103
          const char* doc =
R"""(Returns a const iterator to the beginning.)""";
        } cbegin;
        // Symbol: drake::symbolic::Environment::cend
        struct /* cend */ {
          // Source: drake/common/symbolic_environment.h:105
          const char* doc = R"""(Returns a const iterator to the end.)""";
        } cend;
        // Symbol: drake::symbolic::Environment::const_iterator
        struct /* const_iterator */ {
          // Source: drake/common/symbolic_environment.h:67
          const char* doc = R"""()""";
        } const_iterator;
        // Symbol: drake::symbolic::Environment::domain
        struct /* domain */ {
          // Source: drake/common/symbolic_environment.h:133
          const char* doc = R"""(Returns the domain of this environment.)""";
        } domain;
        // Symbol: drake::symbolic::Environment::empty
        struct /* empty */ {
          // Source: drake/common/symbolic_environment.h:121
          const char* doc = R"""(Checks whether the container is empty.)""";
        } empty;
        // Symbol: drake::symbolic::Environment::end
        struct /* end */ {
          // Source: drake/common/symbolic_environment.h:97
          const char* doc_0args_nonconst = R"""(Returns an iterator to the end.)""";
          // Source: drake/common/symbolic_environment.h:101
          const char* doc_0args_const = R"""(Returns a const iterator to the end.)""";
        } end;
        // Symbol: drake::symbolic::Environment::find
        struct /* find */ {
          // Source: drake/common/symbolic_environment.h:126
          const char* doc = R"""(Finds element with specific key.)""";
        } find;
        // Symbol: drake::symbolic::Environment::insert
        struct /* insert */ {
          // Source: drake/common/symbolic_environment.h:108
          const char* doc_2args_key_elem = R"""(Inserts a pair (``key``, ``elem)``.)""";
          // Source: drake/common/symbolic_environment.h:117
          const char* doc_2args_keys_elements =
R"""(Given a matrix of symbolic variables ``keys`` and a matrix of values
``elements``, inserts each pair (keys(i, j), elements(i, j)) into the
environment.

Raises:
    RuntimeError if the size of ``keys`` is different from the size of
    ``elements``.)""";
        } insert;
        // Symbol: drake::symbolic::Environment::iterator
        struct /* iterator */ {
          // Source: drake/common/symbolic_environment.h:66
          const char* doc = R"""()""";
        } iterator;
        // Symbol: drake::symbolic::Environment::key_type
        struct /* key_type */ {
          // Source: drake/common/symbolic_environment.h:61
          const char* doc = R"""()""";
        } key_type;
        // Symbol: drake::symbolic::Environment::map
        struct /* map */ {
          // Source: drake/common/symbolic_environment.h:63
          const char* doc = R"""()""";
        } map;
        // Symbol: drake::symbolic::Environment::mapped_type
        struct /* mapped_type */ {
          // Source: drake/common/symbolic_environment.h:62
          const char* doc = R"""()""";
        } mapped_type;
        // Symbol: drake::symbolic::Environment::operator[]
        struct /* operator_array */ {
          // Source: drake/common/symbolic_environment.h:141
          const char* doc_1args_key_nonconst =
R"""(Returns a reference to the value that is mapped to a key equivalent to
``key``, performing an insertion if such key does not already exist.)""";
          // Source: drake/common/symbolic_environment.h:145
          const char* doc_1args_key_const =
R"""(As above, but returns a constref and does not perform an insertion
(throwing a runtime error instead) if the key does not exist.)""";
        } operator_array;
        // Symbol: drake::symbolic::Environment::size
        struct /* size */ {
          // Source: drake/common/symbolic_environment.h:123
          const char* doc = R"""(Returns the number of elements.)""";
        } size;
        // Symbol: drake::symbolic::Environment::to_string
        struct /* to_string */ {
          // Source: drake/common/symbolic_environment.h:136
          const char* doc = R"""(Returns string representation.)""";
        } to_string;
        // Symbol: drake::symbolic::Environment::value_type
        struct /* value_type */ {
          // Source: drake/common/symbolic_environment.h:65
          const char* doc = R"""(std::pair<key_type, mapped_type>)""";
        } value_type;
      } Environment;
      // Symbol: drake::symbolic::Evaluate
      struct /* Evaluate */ {
        // Source: drake/common/symbolic_expression.h:1337
        const char* doc_expression =
R"""(Evaluates a symbolic matrix ``m`` using ``env`` and
``random_generator``.

If there is a random variable in ``m`` which is unassigned in ``env``,
this function uses ``random_generator`` to sample a value and use the
value to substitute all occurrences of the random variable in ``m``.

Returns:
    a matrix of double whose size is the size of ``m``.

Raises:
    RuntimeError if NaN is detected during evaluation.

Raises:
    RuntimeError if ``m`` includes unassigned random variables but
    ``random_generator`` is ``nullptr``.)""";
        // Source: drake/common/symbolic_expression.h:1362
        const char* doc =
R"""(Evaluates ``m`` using a given environment (by default, an empty
environment).

Raises:
    RuntimeError if there exists a variable in ``m`` whose value is
    not provided by ``env``.

Raises:
    RuntimeError if NaN is detected during evaluation.)""";
        // Source: drake/common/symbolic_polynomial.h:472
        const char* doc_polynomial =
R"""(Evaluates a matrix ``m`` of symbolic polynomials using ``env``.

Returns:
    a matrix of double whose size is the size of ``m``.

Raises:
    RuntimeError if NaN is detected during evaluation.)""";
      } Evaluate;
      // Symbol: drake::symbolic::EvaluateChebyshevPolynomial
      struct /* EvaluateChebyshevPolynomial */ {
        // Source: drake/common/symbolic_chebyshev_polynomial.h:125
        const char* doc =
R"""(Evaluates a Chebyshev polynomial at a given value.

Parameter ``var_val``:
    The value of the variable.

Parameter ``degree``:
    The degree of the Chebyshev polynomial.)""";
      } EvaluateChebyshevPolynomial;
      // Symbol: drake::symbolic::EvenDegreeMonomialBasis
      struct /* EvenDegreeMonomialBasis */ {
        // Source: drake/common/symbolic_monomial_util.h:230
        const char* doc =
R"""(Returns all even degree monomials up to a given degree under the
graded reverse lexicographic order. A monomial has an even degree if
its total degree is even. So xy is an even degree monomial (degree 2)
while x²y is not (degree 3). Note that graded reverse lexicographic
order uses the total order among Variable which is based on a
variable's unique ID. For example, for a given variable ordering x > y
> z, ``EvenDegreeMonomialBasis({x, y, z}, 2)`` returns a column vector
``[x², xy, y², xz, yz, z², 1]``.

Precondition:
    ``vars`` is a non-empty set.

Precondition:
    ``degree`` is a non-negative integer.)""";
      } EvenDegreeMonomialBasis;
      // Symbol: drake::symbolic::Expression
      struct /* Expression */ {
        // Source: drake/common/symbolic_expression.h:194
        const char* doc =
R"""(Represents a symbolic form of an expression.

Its syntax tree is as follows:


::

    E := Var | Constant | E + ... + E | E * ... * E | E / E | log(E)
    | abs(E) | exp(E) | sqrt(E) | pow(E, E) | sin(E) | cos(E) | tan(E)
    | asin(E) | acos(E) | atan(E) | atan2(E, E) | sinh(E) | cosh(E) | tanh(E)
    | min(E, E) | max(E, E) | ceil(E) | floor(E) | if_then_else(F, E, E)
    | NaN | uninterpreted_function(name, {v_1, ..., v_n})

In the implementation, Expression is a simple wrapper including a
shared pointer to ExpressionCell class which is a super-class of
different kinds of symbolic expressions (i.e. ExpressionAdd,
ExpressionMul, ExpressionLog, ExpressionSin). Note that it includes a
shared pointer, not a unique pointer, to allow sharing
sub-expressions.

Note:
    The sharing of sub-expressions is not yet implemented.

Note:
    -E is represented as -1 * E internally.

Note:
    A subtraction E1 - E2 is represented as E1 + (-1 * E2) internally.

The following simple simplifications are implemented:


::

    E + 0             ->  E
    0 + E             ->  E
    E - 0             ->  E
    E - E             ->  0
    E * 1             ->  E
    1 * E             ->  E
    E * 0             ->  0
    0 * E             ->  0
    E / 1             ->  E
    E / E             ->  1
    pow(E, 0)         ->  1
    pow(E, 1)         ->  E
    E * E             ->  E^2 (= pow(E, 2))
    sqrt(E * E)       ->  |E| (= abs(E))
    sqrt(E) * sqrt(E) -> E

Constant folding is implemented:


::

    E(c1) + E(c2)  ->  E(c1 + c2)    // c1, c2 are constants
    E(c1) - E(c2)  ->  E(c1 - c2)
    E(c1) * E(c2)  ->  E(c1 * c2)
    E(c1) / E(c2)  ->  E(c1 / c2)
    f(E(c))        ->  E(f(c))       // c is a constant, f is a math function

For the math functions which are only defined over a restricted domain
(namely, log, sqrt, pow, asin, acos), we check the domain of
argument(s), and throw ValueError exception if a function is not
well-defined for a given argument(s).

Relational operators over expressions (==, !=, <, >, <=, >=) return
symbolic::Formula instead of bool. Those operations are declared in
symbolic_formula.h file. To check structural equality between two
expressions a separate function, Expression::EqualTo, is provided.

Regarding NaN, we have the following rules: 1. NaN values are
extremely rare during typical computations. Because they are difficult
to handle symbolically, we will round that up to "must never occur".
We allow the user to form ExpressionNaN cells in a symbolic tree. For
example, the user can initialize an Expression to NaN and then
overwrite it later. However, evaluating a tree that has NaN in its
evaluated sub-trees is an error (see rule (3) below). 2. It's still
valid for code to check ``isnan`` in order to fail-fast. So we provide
isnan(const Expression&) for the common case of non-NaN value
returning False. This way, code can fail-fast with double yet still
compile with Expression. 3. If there are expressions that embed
separate cases (``if_then_else``), some of the sub-expressions may be
not used in evaluation when they are in the not-taken case (for NaN
reasons or any other reason). Bad values within those not-taken
branches does not cause exceptions. 4. The isnan check is different
than if_then_else. In the latter, the ExpressionNaN is within a dead
sub-expression branch. In the former, it appears in an evaluated
trunk. That goes against rule (1) where a NaN anywhere in a
computation (other than dead code) is an error.

symbolic::Expression can be used as a scalar type of Eigen types.)""";
        // Symbol: drake::symbolic::Expression::Differentiate
        struct /* Differentiate */ {
          // Source: drake/common/symbolic_expression.h:325
          const char* doc =
R"""(Differentiates this symbolic expression with respect to the variable
``var``.

Raises:
    RuntimeError if it is not differentiable.)""";
        } Differentiate;
        // Symbol: drake::symbolic::Expression::E
        struct /* E */ {
          // Source: drake/common/symbolic_expression.h:344
          const char* doc =
R"""(Return e, the base of natural logarithms.)""";
        } E;
        // Symbol: drake::symbolic::Expression::EqualTo
        struct /* EqualTo */ {
          // Source: drake/common/symbolic_expression.h:242
          const char* doc =
R"""(Checks structural equality.

Two expressions e1 and e2 are structurally equal when they have the
same internal AST(abstract-syntax tree) representation. Please note
that we can have two computationally (or extensionally) equivalent
expressions which are not structurally equal. For example, consider:

e1 = 2 * (x + y) e2 = 2x + 2y

Obviously, we know that e1 and e2 are evaluated to the same value for
all assignments to x and y. However, e1 and e2 are not structurally
equal by the definition. Note that e1 is a multiplication expression
(is_multiplication(e1) is true) while e2 is an addition expression
(is_addition(e2) is true).

One main reason we use structural equality in EqualTo is due to
Richardson's Theorem. It states that checking ∀x. E(x) = F(x) is
undecidable when we allow sin, asin, log, exp in E and F. Read
https://en.wikipedia.org/wiki/Richardson%27s_theorem for details.

Note that for polynomial cases, you can use Expand method and check if
two polynomial expressions p1 and p2 are computationally equal. To do
so, you check the following:

(p1.Expand() - p2.Expand()).EqualTo(0).)""";
        } EqualTo;
        // Symbol: drake::symbolic::Expression::Evaluate
        struct /* Evaluate */ {
          // Source: drake/common/symbolic_expression.h:265
          const char* doc_2args =
R"""(Evaluates using a given environment (by default, an empty environment)
and a random number generator. If there is a random variable in this
expression which is unassigned in ``env``, this method uses
``random_generator`` to sample a value and use the value to substitute
all occurrences of the variable in this expression.

Raises:
    RuntimeError if there exists a non-random variable in this
    expression whose assignment is not provided by ``env``.

Raises:
    RuntimeError if an unassigned random variable is detected while
    ``random_generator`` is ``nullptr``.

Raises:
    RuntimeError if NaN is detected during evaluation.)""";
          // Source: drake/common/symbolic_expression.h:274
          const char* doc_1args =
R"""(Evaluates using an empty environment and a random number generator. It
uses ``random_generator`` to sample values for the random variables in
this expression.

See the above overload for the exceptions that it might throw.)""";
        } Evaluate;
        // Symbol: drake::symbolic::Expression::EvaluatePartial
        struct /* EvaluatePartial */ {
          // Source: drake/common/symbolic_expression.h:282
          const char* doc =
R"""(Partially evaluates this expression using an environment ``env``.
Internally, this method promotes ``env`` into a substitution (Variable
→ Expression) and call Evaluate::Substitute with it.

Raises:
    RuntimeError if NaN is detected during evaluation.)""";
        } EvaluatePartial;
        // Symbol: drake::symbolic::Expression::Expand
        struct /* Expand */ {
          // Source: drake/common/symbolic_expression.h:304
          const char* doc =
R"""(Expands out products and positive integer powers in expression. For
example, ``(x + 1) * (x - 1)`` is expanded to ``x^2 - 1`` and ``(x +
y)^2`` is expanded to ``x^2 + 2xy + y^2``. Note that Expand applies
recursively to sub-expressions. For instance, ``sin(2 * (x + y))`` is
expanded to ``sin(2x + 2y)``. It also simplifies "division by
constant" cases. See "drake/common/test/symbolic_expansion_test.cc" to
find the examples.

Raises:
    RuntimeError if NaN is detected during expansion.)""";
        } Expand;
        // Symbol: drake::symbolic::Expression::Expression
        struct /* ctor */ {
          // Source: drake/common/symbolic_expression.h:200
          const char* doc_0args =
R"""(Default constructor. It constructs Zero().)""";
          // Source: drake/common/symbolic_expression.h:204
          const char* doc_1args_d = R"""(Constructs a constant.)""";
          // Source: drake/common/symbolic_expression.h:209
          const char* doc_1args_var =
R"""(Constructs an expression from ``var``.

Precondition:
    ``var`` is neither a dummy nor a BOOLEAN variable.)""";
        } ctor;
        // Symbol: drake::symbolic::Expression::GetVariables
        struct /* GetVariables */ {
          // Source: drake/common/symbolic_expression.h:213
          const char* doc = R"""(Collects variables in expression.)""";
        } GetVariables;
        // Symbol: drake::symbolic::Expression::Jacobian
        struct /* Jacobian */ {
          // Source: drake/common/symbolic_expression.h:331
          const char* doc =
R"""(Let ``f`` be this Expression, computes a row vector of derivatives,
``[∂f/∂vars(0), ... , ∂f/∂vars(n-1)]`` with respect to the variables
``vars``.)""";
        } Jacobian;
        // Symbol: drake::symbolic::Expression::Less
        struct /* Less */ {
          // Source: drake/common/symbolic_expression.h:247
          const char* doc =
R"""(Provides lexicographical ordering between expressions. This function
is used as a compare function in map<Expression> and set<Expression>
via std::less<drake::symbolic::Expression>.)""";
        } Less;
        // Symbol: drake::symbolic::Expression::NaN
        struct /* NaN */ {
          // Source: drake/common/symbolic_expression.h:346
          const char* doc = R"""(Returns NaN (Not-a-Number).)""";
        } NaN;
        // Symbol: drake::symbolic::Expression::One
        struct /* One */ {
          // Source: drake/common/symbolic_expression.h:340
          const char* doc = R"""(Returns one.)""";
        } One;
        // Symbol: drake::symbolic::Expression::Pi
        struct /* Pi */ {
          // Source: drake/common/symbolic_expression.h:342
          const char* doc =
R"""(Returns Pi, the ratio of a circle’s circumference to its diameter.)""";
        } Pi;
        // Symbol: drake::symbolic::Expression::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_expression.h:310
          const char* doc_2args =
R"""(Returns a copy of this expression replacing all occurrences of ``var``
with ``e``.

Raises:
    RuntimeError if NaN is detected during substitution.)""";
          // Source: drake/common/symbolic_expression.h:319
          const char* doc_1args =
R"""(Returns a copy of this expression replacing all occurrences of the
variables in ``s`` with corresponding expressions in ``s``. Note that
the substitutions occur simultaneously. For example, (x /
y).Substitute({{x, y}, {y, x}}) gets (y / x).

Raises:
    RuntimeError if NaN is detected during substitution.)""";
        } Substitute;
        // Symbol: drake::symbolic::Expression::Zero
        struct /* Zero */ {
          // Source: drake/common/symbolic_expression.h:338
          const char* doc = R"""(Returns zero.)""";
        } Zero;
        // Symbol: drake::symbolic::Expression::get_kind
        struct /* get_kind */ {
          // Source: drake/common/symbolic_expression.h:211
          const char* doc = R"""(Returns expression kind.)""";
        } get_kind;
        // Symbol: drake::symbolic::Expression::is_expanded
        struct /* is_expanded */ {
          // Source: drake/common/symbolic_expression.h:293
          const char* doc =
R"""(Returns true if this symbolic expression is already expanded.
Expression::Expand() uses this flag to avoid calling
ExpressionCell::Expand() on an pre-expanded expressions.
Expression::Expand() also sets this flag before returning the result.

Note:
    This check is conservative in that ``False`` does not always
    indicate that the expression is not expanded. This is because
    exact checks can be costly and we want to avoid the exact check at
    the construction time.)""";
        } is_expanded;
        // Symbol: drake::symbolic::Expression::is_polynomial
        struct /* is_polynomial */ {
          // Source: drake/common/symbolic_expression.h:250
          const char* doc =
R"""(Checks if this symbolic expression is convertible to Polynomial.)""";
        } is_polynomial;
        // Symbol: drake::symbolic::Expression::operator++
        struct /* operator_inc */ {
          // Source: drake/common/symbolic_expression.h:364
          const char* doc_0args =
R"""(Provides prefix increment operator (i.e. ++x).)""";
          // Source: drake/common/symbolic_expression.h:366
          const char* doc_1args =
R"""(Provides postfix increment operator (i.e. x++).)""";
        } operator_inc;
        // Symbol: drake::symbolic::Expression::operator--
        struct /* operator_dec */ {
          // Source: drake/common/symbolic_expression.h:377
          const char* doc_0args =
R"""(Provides prefix decrement operator (i.e. --x).)""";
          // Source: drake/common/symbolic_expression.h:379
          const char* doc_1args =
R"""(Provides postfix decrement operator (i.e. x--).)""";
        } operator_dec;
        // Symbol: drake::symbolic::Expression::to_string
        struct /* to_string */ {
          // Source: drake/common/symbolic_expression.h:335
          const char* doc =
R"""(Returns string representation of Expression.)""";
        } to_string;
      } Expression;
      // Symbol: drake::symbolic::ExpressionAbs
      struct /* ExpressionAbs */ {
        // Source: drake/common/symbolic_expression_cell.h:499
        const char* doc =
R"""(Symbolic expression representing absolute value function.)""";
        // Symbol: drake::symbolic::ExpressionAbs::Differentiate
        struct /* Differentiate */ {
          // Source: drake/common/symbolic_expression_cell.h:504
          const char* doc = R"""()""";
        } Differentiate;
        // Symbol: drake::symbolic::ExpressionAbs::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_expression_cell.h:505
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::ExpressionAbs::Expand
        struct /* Expand */ {
          // Source: drake/common/symbolic_expression_cell.h:502
          const char* doc = R"""()""";
        } Expand;
        // Symbol: drake::symbolic::ExpressionAbs::ExpressionAbs
        struct /* ctor */ {
          // Source: drake/common/symbolic_expression_cell.h:501
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::symbolic::ExpressionAbs::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_expression_cell.h:503
          const char* doc = R"""()""";
        } Substitute;
      } ExpressionAbs;
      // Symbol: drake::symbolic::ExpressionAcos
      struct /* ExpressionAcos */ {
        // Source: drake/common/symbolic_expression_cell.h:619
        const char* doc =
R"""(Symbolic expression representing arccosine function.)""";
        // Symbol: drake::symbolic::ExpressionAcos::Differentiate
        struct /* Differentiate */ {
          // Source: drake/common/symbolic_expression_cell.h:624
          const char* doc = R"""()""";
        } Differentiate;
        // Symbol: drake::symbolic::ExpressionAcos::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_expression_cell.h:625
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::ExpressionAcos::Expand
        struct /* Expand */ {
          // Source: drake/common/symbolic_expression_cell.h:622
          const char* doc = R"""()""";
        } Expand;
        // Symbol: drake::symbolic::ExpressionAcos::ExpressionAcos
        struct /* ctor */ {
          // Source: drake/common/symbolic_expression_cell.h:621
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::symbolic::ExpressionAcos::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_expression_cell.h:623
          const char* doc = R"""()""";
        } Substitute;
      } ExpressionAcos;
      // Symbol: drake::symbolic::ExpressionAdd
      struct /* ExpressionAdd */ {
        // Source: drake/common/symbolic_expression_cell.h:272
        const char* doc =
R"""(Symbolic expression representing an addition which is a sum of
products.

.. math:: c_0 + \sum c_i * e_i

where :math:`c_i` is a constant and :math:`e_i` is a symbolic
expression.

Internally this class maintains a member variable ``constant_`` to
represent :math:`c_0` and another member variable
``expr_to_coeff_map_`` to represent a mapping from an expression
:math:`e_i` to its coefficient :math:`c_i` of double.)""";
        // Symbol: drake::symbolic::ExpressionAdd::Differentiate
        struct /* Differentiate */ {
          // Source: drake/common/symbolic_expression_cell.h:285
          const char* doc = R"""()""";
        } Differentiate;
        // Symbol: drake::symbolic::ExpressionAdd::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_expression_cell.h:286
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::ExpressionAdd::EqualTo
        struct /* EqualTo */ {
          // Source: drake/common/symbolic_expression_cell.h:280
          const char* doc = R"""()""";
        } EqualTo;
        // Symbol: drake::symbolic::ExpressionAdd::Evaluate
        struct /* Evaluate */ {
          // Source: drake/common/symbolic_expression_cell.h:282
          const char* doc = R"""()""";
        } Evaluate;
        // Symbol: drake::symbolic::ExpressionAdd::Expand
        struct /* Expand */ {
          // Source: drake/common/symbolic_expression_cell.h:283
          const char* doc = R"""()""";
        } Expand;
        // Symbol: drake::symbolic::ExpressionAdd::ExpressionAdd
        struct /* ctor */ {
          // Source: drake/common/symbolic_expression_cell.h:276
          const char* doc =
R"""(Constructs ExpressionAdd from ``constant_term`` and
``term_to_coeff_map``.)""";
        } ctor;
        // Symbol: drake::symbolic::ExpressionAdd::GetVariables
        struct /* GetVariables */ {
          // Source: drake/common/symbolic_expression_cell.h:279
          const char* doc = R"""()""";
        } GetVariables;
        // Symbol: drake::symbolic::ExpressionAdd::HashAppendDetail
        struct /* HashAppendDetail */ {
          // Source: drake/common/symbolic_expression_cell.h:278
          const char* doc = R"""()""";
        } HashAppendDetail;
        // Symbol: drake::symbolic::ExpressionAdd::Less
        struct /* Less */ {
          // Source: drake/common/symbolic_expression_cell.h:281
          const char* doc = R"""()""";
        } Less;
        // Symbol: drake::symbolic::ExpressionAdd::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_expression_cell.h:284
          const char* doc = R"""()""";
        } Substitute;
        // Symbol: drake::symbolic::ExpressionAdd::get_constant
        struct /* get_constant */ {
          // Source: drake/common/symbolic_expression_cell.h:288
          const char* doc = R"""(Returns the constant.)""";
        } get_constant;
        // Symbol: drake::symbolic::ExpressionAdd::get_expr_to_coeff_map
        struct /* get_expr_to_coeff_map */ {
          // Source: drake/common/symbolic_expression_cell.h:290
          const char* doc =
R"""(Returns map from an expression to its coefficient.)""";
        } get_expr_to_coeff_map;
      } ExpressionAdd;
      // Symbol: drake::symbolic::ExpressionAddFactory
      struct /* ExpressionAddFactory */ {
        // Source: drake/common/symbolic_expression_cell.h:304
        const char* doc =
R"""(Factory class to help build ExpressionAdd expressions.)""";
        // Symbol: drake::symbolic::ExpressionAddFactory::Add
        struct /* Add */ {
          // Source: drake/common/symbolic_expression_cell.h:323
          const char* doc =
R"""(Adds ExpressionAdd pointed by ``ptr`` to this factory.)""";
        } Add;
        // Symbol: drake::symbolic::ExpressionAddFactory::AddExpression
        struct /* AddExpression */ {
          // Source: drake/common/symbolic_expression_cell.h:321
          const char* doc = R"""(Adds ``e`` to this factory.)""";
        } AddExpression;
        // Symbol: drake::symbolic::ExpressionAddFactory::ExpressionAddFactory
        struct /* ctor */ {
          // Source: drake/common/symbolic_expression_cell.h:309
          const char* doc_0args = R"""(Default constructor.)""";
          // Source: drake/common/symbolic_expression_cell.h:313
          const char* doc_2args =
R"""(Constructs ExpressionAddFactory with ``constant`` and
``expr_to_coeff_map``.)""";
          // Source: drake/common/symbolic_expression_cell.h:317
          const char* doc_1args =
R"""(Constructs ExpressionAddFactory from ``ptr``.)""";
        } ctor;
        // Symbol: drake::symbolic::ExpressionAddFactory::GetExpression
        struct /* GetExpression */ {
          // Source: drake/common/symbolic_expression_cell.h:335
          const char* doc = R"""(Returns a symbolic expression.)""";
        } GetExpression;
        // Symbol: drake::symbolic::ExpressionAddFactory::Negate
        struct /* Negate */ {
          // Source: drake/common/symbolic_expression_cell.h:333
          const char* doc =
R"""(Negates the expressions in factory. If it represents c0 + c1 * t1 +
... + * cn * tn, this method flips it into -c0 - c1 * t1 - ... - cn *
tn.

Returns:
    *this.)""";
        } Negate;
      } ExpressionAddFactory;
      // Symbol: drake::symbolic::ExpressionAsin
      struct /* ExpressionAsin */ {
        // Source: drake/common/symbolic_expression_cell.h:602
        const char* doc =
R"""(Symbolic expression representing arcsine function.)""";
        // Symbol: drake::symbolic::ExpressionAsin::Differentiate
        struct /* Differentiate */ {
          // Source: drake/common/symbolic_expression_cell.h:607
          const char* doc = R"""()""";
        } Differentiate;
        // Symbol: drake::symbolic::ExpressionAsin::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_expression_cell.h:608
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::ExpressionAsin::Expand
        struct /* Expand */ {
          // Source: drake/common/symbolic_expression_cell.h:605
          const char* doc = R"""()""";
        } Expand;
        // Symbol: drake::symbolic::ExpressionAsin::ExpressionAsin
        struct /* ctor */ {
          // Source: drake/common/symbolic_expression_cell.h:604
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::symbolic::ExpressionAsin::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_expression_cell.h:606
          const char* doc = R"""()""";
        } Substitute;
      } ExpressionAsin;
      // Symbol: drake::symbolic::ExpressionAtan
      struct /* ExpressionAtan */ {
        // Source: drake/common/symbolic_expression_cell.h:636
        const char* doc =
R"""(Symbolic expression representing arctangent function.)""";
        // Symbol: drake::symbolic::ExpressionAtan::Differentiate
        struct /* Differentiate */ {
          // Source: drake/common/symbolic_expression_cell.h:641
          const char* doc = R"""()""";
        } Differentiate;
        // Symbol: drake::symbolic::ExpressionAtan::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_expression_cell.h:642
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::ExpressionAtan::Expand
        struct /* Expand */ {
          // Source: drake/common/symbolic_expression_cell.h:639
          const char* doc = R"""()""";
        } Expand;
        // Symbol: drake::symbolic::ExpressionAtan::ExpressionAtan
        struct /* ctor */ {
          // Source: drake/common/symbolic_expression_cell.h:638
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::symbolic::ExpressionAtan::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_expression_cell.h:640
          const char* doc = R"""()""";
        } Substitute;
      } ExpressionAtan;
      // Symbol: drake::symbolic::ExpressionAtan2
      struct /* ExpressionAtan2 */ {
        // Source: drake/common/symbolic_expression_cell.h:650
        const char* doc =
R"""(Symbolic expression representing atan2 function (arctangent function
with two arguments). atan2(y, x) is defined as atan(y/x).)""";
        // Symbol: drake::symbolic::ExpressionAtan2::Differentiate
        struct /* Differentiate */ {
          // Source: drake/common/symbolic_expression_cell.h:655
          const char* doc = R"""()""";
        } Differentiate;
        // Symbol: drake::symbolic::ExpressionAtan2::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_expression_cell.h:656
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::ExpressionAtan2::Expand
        struct /* Expand */ {
          // Source: drake/common/symbolic_expression_cell.h:653
          const char* doc = R"""()""";
        } Expand;
        // Symbol: drake::symbolic::ExpressionAtan2::ExpressionAtan2
        struct /* ctor */ {
          // Source: drake/common/symbolic_expression_cell.h:652
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::symbolic::ExpressionAtan2::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_expression_cell.h:654
          const char* doc = R"""()""";
        } Substitute;
      } ExpressionAtan2;
      // Symbol: drake::symbolic::ExpressionCeiling
      struct /* ExpressionCeiling */ {
        // Source: drake/common/symbolic_expression_cell.h:728
        const char* doc =
R"""(Symbolic expression representing ceil function.)""";
        // Symbol: drake::symbolic::ExpressionCeiling::Differentiate
        struct /* Differentiate */ {
          // Source: drake/common/symbolic_expression_cell.h:733
          const char* doc = R"""()""";
        } Differentiate;
        // Symbol: drake::symbolic::ExpressionCeiling::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_expression_cell.h:734
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::ExpressionCeiling::Expand
        struct /* Expand */ {
          // Source: drake/common/symbolic_expression_cell.h:731
          const char* doc = R"""()""";
        } Expand;
        // Symbol: drake::symbolic::ExpressionCeiling::ExpressionCeiling
        struct /* ctor */ {
          // Source: drake/common/symbolic_expression_cell.h:730
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::symbolic::ExpressionCeiling::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_expression_cell.h:732
          const char* doc = R"""()""";
        } Substitute;
      } ExpressionCeiling;
      // Symbol: drake::symbolic::ExpressionCell
      struct /* ExpressionCell */ {
        // Source: drake/common/symbolic_expression_cell.h:46
        const char* doc =
R"""(Represents an abstract class which is the base of concrete
symbolic-expression classes.

Note:
    It provides virtual function, ExpressionCell::Display, because
    operator<< is not allowed to be a virtual function.)""";
        // Symbol: drake::symbolic::ExpressionCell::Differentiate
        struct /* Differentiate */ {
          // Source: drake/common/symbolic_expression_cell.h:96
          const char* doc =
R"""(Differentiates this symbolic expression with respect to the variable
``var``.

Raises:
    RuntimeError if it is not differentiable.)""";
        } Differentiate;
        // Symbol: drake::symbolic::ExpressionCell::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_expression_cell.h:99
          const char* doc =
R"""(Outputs string representation of expression into output stream ``os``.)""";
        } Display;
        // Symbol: drake::symbolic::ExpressionCell::EqualTo
        struct /* EqualTo */ {
          // Source: drake/common/symbolic_expression_cell.h:61
          const char* doc = R"""(Checks structural equality.)""";
        } EqualTo;
        // Symbol: drake::symbolic::ExpressionCell::Evaluate
        struct /* Evaluate */ {
          // Source: drake/common/symbolic_expression_cell.h:78
          const char* doc =
R"""(Evaluates under a given environment (by default, an empty
environment).

Raises:
    RuntimeError if NaN is detected during evaluation.)""";
        } Evaluate;
        // Symbol: drake::symbolic::ExpressionCell::Expand
        struct /* Expand */ {
          // Source: drake/common/symbolic_expression_cell.h:83
          const char* doc =
R"""(Expands out products and positive integer powers in expression.

Raises:
    RuntimeError if NaN is detected during expansion.)""";
        } Expand;
        // Symbol: drake::symbolic::ExpressionCell::ExpressionCell
        struct /* ctor */ {
          // Source: drake/common/symbolic_expression_cell.h:109
          const char* doc_0args = R"""(Default constructor.)""";
          // Source: drake/common/symbolic_expression_cell.h:111
          const char* doc_move =
R"""(Move-constructs an ExpressionCell from an rvalue.)""";
          // Source: drake/common/symbolic_expression_cell.h:113
          const char* doc_copy =
R"""(Copy-constructs an ExpressionCell from an lvalue.)""";
          // Source: drake/common/symbolic_expression_cell.h:116
          const char* doc_3args =
R"""(Constructs ExpressionCell of kind ``k`` with ``is_poly`` and
``is_expanded``.)""";
        } ctor;
        // Symbol: drake::symbolic::ExpressionCell::GetVariables
        struct /* GetVariables */ {
          // Source: drake/common/symbolic_expression_cell.h:58
          const char* doc = R"""(Collects variables in expression.)""";
        } GetVariables;
        // Symbol: drake::symbolic::ExpressionCell::HashAppendDetail
        struct /* HashAppendDetail */ {
          // Source: drake/common/symbolic_expression_cell.h:55
          const char* doc =
R"""(Sends all hash-relevant bytes for this ExpressionCell type into the
given hasher, per the hash_append concept -- except for get_kind(),
because Expression already sends that.)""";
        } HashAppendDetail;
        // Symbol: drake::symbolic::ExpressionCell::Less
        struct /* Less */ {
          // Source: drake/common/symbolic_expression_cell.h:64
          const char* doc =
R"""(Provides lexicographical ordering between expressions.)""";
        } Less;
        // Symbol: drake::symbolic::ExpressionCell::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_expression_cell.h:90
          const char* doc =
R"""(Returns an Expression obtained by replacing all occurrences of the
variables in ``s`` in the current expression cell with the
corresponding expressions in ``s``.

Raises:
    RuntimeError if NaN is detected during substitution.)""";
        } Substitute;
        // Symbol: drake::symbolic::ExpressionCell::get_kind
        struct /* get_kind */ {
          // Source: drake/common/symbolic_expression_cell.h:49
          const char* doc = R"""(Returns expression kind.)""";
        } get_kind;
        // Symbol: drake::symbolic::ExpressionCell::is_expanded
        struct /* is_expanded */ {
          // Source: drake/common/symbolic_expression_cell.h:70
          const char* doc =
R"""(Checks if this symbolic expression is already expanded.)""";
        } is_expanded;
        // Symbol: drake::symbolic::ExpressionCell::is_polynomial
        struct /* is_polynomial */ {
          // Source: drake/common/symbolic_expression_cell.h:67
          const char* doc =
R"""(Checks if this symbolic expression is convertible to Polynomial.)""";
        } is_polynomial;
        // Symbol: drake::symbolic::ExpressionCell::set_expanded
        struct /* set_expanded */ {
          // Source: drake/common/symbolic_expression_cell.h:73
          const char* doc =
R"""(Sets this symbolic expression as already expanded.)""";
        } set_expanded;
      } ExpressionCell;
      // Symbol: drake::symbolic::ExpressionConstant
      struct /* ExpressionConstant */ {
        // Source: drake/common/symbolic_expression_cell.h:226
        const char* doc =
R"""(Symbolic expression representing a constant.)""";
        // Symbol: drake::symbolic::ExpressionConstant::Differentiate
        struct /* Differentiate */ {
          // Source: drake/common/symbolic_expression_cell.h:237
          const char* doc = R"""()""";
        } Differentiate;
        // Symbol: drake::symbolic::ExpressionConstant::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_expression_cell.h:238
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::ExpressionConstant::EqualTo
        struct /* EqualTo */ {
          // Source: drake/common/symbolic_expression_cell.h:232
          const char* doc = R"""()""";
        } EqualTo;
        // Symbol: drake::symbolic::ExpressionConstant::Evaluate
        struct /* Evaluate */ {
          // Source: drake/common/symbolic_expression_cell.h:234
          const char* doc = R"""()""";
        } Evaluate;
        // Symbol: drake::symbolic::ExpressionConstant::Expand
        struct /* Expand */ {
          // Source: drake/common/symbolic_expression_cell.h:235
          const char* doc = R"""()""";
        } Expand;
        // Symbol: drake::symbolic::ExpressionConstant::ExpressionConstant
        struct /* ctor */ {
          // Source: drake/common/symbolic_expression_cell.h:228
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::symbolic::ExpressionConstant::GetVariables
        struct /* GetVariables */ {
          // Source: drake/common/symbolic_expression_cell.h:231
          const char* doc = R"""()""";
        } GetVariables;
        // Symbol: drake::symbolic::ExpressionConstant::HashAppendDetail
        struct /* HashAppendDetail */ {
          // Source: drake/common/symbolic_expression_cell.h:230
          const char* doc = R"""()""";
        } HashAppendDetail;
        // Symbol: drake::symbolic::ExpressionConstant::Less
        struct /* Less */ {
          // Source: drake/common/symbolic_expression_cell.h:233
          const char* doc = R"""()""";
        } Less;
        // Symbol: drake::symbolic::ExpressionConstant::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_expression_cell.h:236
          const char* doc = R"""()""";
        } Substitute;
        // Symbol: drake::symbolic::ExpressionConstant::get_value
        struct /* get_value */ {
          // Source: drake/common/symbolic_expression_cell.h:229
          const char* doc = R"""()""";
        } get_value;
      } ExpressionConstant;
      // Symbol: drake::symbolic::ExpressionCos
      struct /* ExpressionCos */ {
        // Source: drake/common/symbolic_expression_cell.h:576
        const char* doc =
R"""(Symbolic expression representing cosine function.)""";
        // Symbol: drake::symbolic::ExpressionCos::Differentiate
        struct /* Differentiate */ {
          // Source: drake/common/symbolic_expression_cell.h:581
          const char* doc = R"""()""";
        } Differentiate;
        // Symbol: drake::symbolic::ExpressionCos::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_expression_cell.h:582
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::ExpressionCos::Expand
        struct /* Expand */ {
          // Source: drake/common/symbolic_expression_cell.h:579
          const char* doc = R"""()""";
        } Expand;
        // Symbol: drake::symbolic::ExpressionCos::ExpressionCos
        struct /* ctor */ {
          // Source: drake/common/symbolic_expression_cell.h:578
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::symbolic::ExpressionCos::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_expression_cell.h:580
          const char* doc = R"""()""";
        } Substitute;
      } ExpressionCos;
      // Symbol: drake::symbolic::ExpressionCosh
      struct /* ExpressionCosh */ {
        // Source: drake/common/symbolic_expression_cell.h:676
        const char* doc =
R"""(Symbolic expression representing hyperbolic cosine function.)""";
        // Symbol: drake::symbolic::ExpressionCosh::Differentiate
        struct /* Differentiate */ {
          // Source: drake/common/symbolic_expression_cell.h:681
          const char* doc = R"""()""";
        } Differentiate;
        // Symbol: drake::symbolic::ExpressionCosh::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_expression_cell.h:682
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::ExpressionCosh::Expand
        struct /* Expand */ {
          // Source: drake/common/symbolic_expression_cell.h:679
          const char* doc = R"""()""";
        } Expand;
        // Symbol: drake::symbolic::ExpressionCosh::ExpressionCosh
        struct /* ctor */ {
          // Source: drake/common/symbolic_expression_cell.h:678
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::symbolic::ExpressionCosh::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_expression_cell.h:680
          const char* doc = R"""()""";
        } Substitute;
      } ExpressionCosh;
      // Symbol: drake::symbolic::ExpressionDiv
      struct /* ExpressionDiv */ {
        // Source: drake/common/symbolic_expression_cell.h:469
        const char* doc =
R"""(Symbolic expression representing division.)""";
        // Symbol: drake::symbolic::ExpressionDiv::Differentiate
        struct /* Differentiate */ {
          // Source: drake/common/symbolic_expression_cell.h:474
          const char* doc = R"""()""";
        } Differentiate;
        // Symbol: drake::symbolic::ExpressionDiv::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_expression_cell.h:475
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::ExpressionDiv::Expand
        struct /* Expand */ {
          // Source: drake/common/symbolic_expression_cell.h:472
          const char* doc = R"""()""";
        } Expand;
        // Symbol: drake::symbolic::ExpressionDiv::ExpressionDiv
        struct /* ctor */ {
          // Source: drake/common/symbolic_expression_cell.h:471
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::symbolic::ExpressionDiv::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_expression_cell.h:473
          const char* doc = R"""()""";
        } Substitute;
      } ExpressionDiv;
      // Symbol: drake::symbolic::ExpressionExp
      struct /* ExpressionExp */ {
        // Source: drake/common/symbolic_expression_cell.h:515
        const char* doc =
R"""(Symbolic expression representing exponentiation using the base of
natural logarithms.)""";
        // Symbol: drake::symbolic::ExpressionExp::Differentiate
        struct /* Differentiate */ {
          // Source: drake/common/symbolic_expression_cell.h:520
          const char* doc = R"""()""";
        } Differentiate;
        // Symbol: drake::symbolic::ExpressionExp::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_expression_cell.h:521
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::ExpressionExp::Expand
        struct /* Expand */ {
          // Source: drake/common/symbolic_expression_cell.h:518
          const char* doc = R"""()""";
        } Expand;
        // Symbol: drake::symbolic::ExpressionExp::ExpressionExp
        struct /* ctor */ {
          // Source: drake/common/symbolic_expression_cell.h:517
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::symbolic::ExpressionExp::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_expression_cell.h:519
          const char* doc = R"""()""";
        } Substitute;
      } ExpressionExp;
      // Symbol: drake::symbolic::ExpressionFloor
      struct /* ExpressionFloor */ {
        // Source: drake/common/symbolic_expression_cell.h:741
        const char* doc =
R"""(Symbolic expression representing floor function.)""";
        // Symbol: drake::symbolic::ExpressionFloor::Differentiate
        struct /* Differentiate */ {
          // Source: drake/common/symbolic_expression_cell.h:746
          const char* doc = R"""()""";
        } Differentiate;
        // Symbol: drake::symbolic::ExpressionFloor::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_expression_cell.h:747
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::ExpressionFloor::Expand
        struct /* Expand */ {
          // Source: drake/common/symbolic_expression_cell.h:744
          const char* doc = R"""()""";
        } Expand;
        // Symbol: drake::symbolic::ExpressionFloor::ExpressionFloor
        struct /* ctor */ {
          // Source: drake/common/symbolic_expression_cell.h:743
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::symbolic::ExpressionFloor::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_expression_cell.h:745
          const char* doc = R"""()""";
        } Substitute;
      } ExpressionFloor;
      // Symbol: drake::symbolic::ExpressionIfThenElse
      struct /* ExpressionIfThenElse */ {
        // Source: drake/common/symbolic_expression_cell.h:754
        const char* doc =
R"""(Symbolic expression representing if-then-else expression.)""";
        // Symbol: drake::symbolic::ExpressionIfThenElse::Differentiate
        struct /* Differentiate */ {
          // Source: drake/common/symbolic_expression_cell.h:766
          const char* doc = R"""()""";
        } Differentiate;
        // Symbol: drake::symbolic::ExpressionIfThenElse::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_expression_cell.h:767
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::ExpressionIfThenElse::EqualTo
        struct /* EqualTo */ {
          // Source: drake/common/symbolic_expression_cell.h:761
          const char* doc = R"""()""";
        } EqualTo;
        // Symbol: drake::symbolic::ExpressionIfThenElse::Evaluate
        struct /* Evaluate */ {
          // Source: drake/common/symbolic_expression_cell.h:763
          const char* doc = R"""()""";
        } Evaluate;
        // Symbol: drake::symbolic::ExpressionIfThenElse::Expand
        struct /* Expand */ {
          // Source: drake/common/symbolic_expression_cell.h:764
          const char* doc = R"""()""";
        } Expand;
        // Symbol: drake::symbolic::ExpressionIfThenElse::ExpressionIfThenElse
        struct /* ctor */ {
          // Source: drake/common/symbolic_expression_cell.h:758
          const char* doc =
R"""(Constructs if-then-else expression from ``f_cond``, ``e_then``, and
``e_else``.)""";
        } ctor;
        // Symbol: drake::symbolic::ExpressionIfThenElse::GetVariables
        struct /* GetVariables */ {
          // Source: drake/common/symbolic_expression_cell.h:760
          const char* doc = R"""()""";
        } GetVariables;
        // Symbol: drake::symbolic::ExpressionIfThenElse::HashAppendDetail
        struct /* HashAppendDetail */ {
          // Source: drake/common/symbolic_expression_cell.h:759
          const char* doc = R"""()""";
        } HashAppendDetail;
        // Symbol: drake::symbolic::ExpressionIfThenElse::Less
        struct /* Less */ {
          // Source: drake/common/symbolic_expression_cell.h:762
          const char* doc = R"""()""";
        } Less;
        // Symbol: drake::symbolic::ExpressionIfThenElse::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_expression_cell.h:765
          const char* doc = R"""()""";
        } Substitute;
        // Symbol: drake::symbolic::ExpressionIfThenElse::get_conditional_formula
        struct /* get_conditional_formula */ {
          // Source: drake/common/symbolic_expression_cell.h:770
          const char* doc = R"""(Returns the conditional formula.)""";
        } get_conditional_formula;
        // Symbol: drake::symbolic::ExpressionIfThenElse::get_else_expression
        struct /* get_else_expression */ {
          // Source: drake/common/symbolic_expression_cell.h:778
          const char* doc = R"""(Returns the 'else' expression.)""";
        } get_else_expression;
        // Symbol: drake::symbolic::ExpressionIfThenElse::get_then_expression
        struct /* get_then_expression */ {
          // Source: drake/common/symbolic_expression_cell.h:774
          const char* doc = R"""(Returns the 'then' expression.)""";
        } get_then_expression;
      } ExpressionIfThenElse;
      // Symbol: drake::symbolic::ExpressionKind
      struct /* ExpressionKind */ {
        // Source: drake/common/symbolic_expression.h:40
        const char* doc = R"""(Kinds of symbolic expressions.)""";
        // Symbol: drake::symbolic::ExpressionKind::Abs
        struct /* Abs */ {
          // Source: drake/common/symbolic_expression.h:47
          const char* doc = R"""(absolute value function)""";
        } Abs;
        // Symbol: drake::symbolic::ExpressionKind::Acos
        struct /* Acos */ {
          // Source: drake/common/symbolic_expression.h:55
          const char* doc = R"""(arccosine)""";
        } Acos;
        // Symbol: drake::symbolic::ExpressionKind::Add
        struct /* Add */ {
          // Source: drake/common/symbolic_expression.h:43
          const char* doc = R"""(addition (+))""";
        } Add;
        // Symbol: drake::symbolic::ExpressionKind::Asin
        struct /* Asin */ {
          // Source: drake/common/symbolic_expression.h:54
          const char* doc = R"""(arcsine)""";
        } Asin;
        // Symbol: drake::symbolic::ExpressionKind::Atan
        struct /* Atan */ {
          // Source: drake/common/symbolic_expression.h:56
          const char* doc = R"""(arctangent)""";
        } Atan;
        // Symbol: drake::symbolic::ExpressionKind::Atan2
        struct /* Atan2 */ {
          // Source: drake/common/symbolic_expression.h:57
          const char* doc = R"""(arctangent2 (atan2(y,x) = atan(y/x)))""";
        } Atan2;
        // Symbol: drake::symbolic::ExpressionKind::Ceil
        struct /* Ceil */ {
          // Source: drake/common/symbolic_expression.h:63
          const char* doc = R"""(ceil)""";
        } Ceil;
        // Symbol: drake::symbolic::ExpressionKind::Constant
        struct /* Constant */ {
          // Source: drake/common/symbolic_expression.h:41
          const char* doc = R"""(constant (double))""";
        } Constant;
        // Symbol: drake::symbolic::ExpressionKind::Cos
        struct /* Cos */ {
          // Source: drake/common/symbolic_expression.h:52
          const char* doc = R"""(cosine)""";
        } Cos;
        // Symbol: drake::symbolic::ExpressionKind::Cosh
        struct /* Cosh */ {
          // Source: drake/common/symbolic_expression.h:59
          const char* doc = R"""(hyperbolic cosine)""";
        } Cosh;
        // Symbol: drake::symbolic::ExpressionKind::Div
        struct /* Div */ {
          // Source: drake/common/symbolic_expression.h:45
          const char* doc = R"""(division (/))""";
        } Div;
        // Symbol: drake::symbolic::ExpressionKind::Exp
        struct /* Exp */ {
          // Source: drake/common/symbolic_expression.h:48
          const char* doc = R"""(exponentiation)""";
        } Exp;
        // Symbol: drake::symbolic::ExpressionKind::Floor
        struct /* Floor */ {
          // Source: drake/common/symbolic_expression.h:64
          const char* doc = R"""(floor)""";
        } Floor;
        // Symbol: drake::symbolic::ExpressionKind::IfThenElse
        struct /* IfThenElse */ {
          // Source: drake/common/symbolic_expression.h:65
          const char* doc = R"""(if then else)""";
        } IfThenElse;
        // Symbol: drake::symbolic::ExpressionKind::Log
        struct /* Log */ {
          // Source: drake/common/symbolic_expression.h:46
          const char* doc = R"""(logarithms)""";
        } Log;
        // Symbol: drake::symbolic::ExpressionKind::Max
        struct /* Max */ {
          // Source: drake/common/symbolic_expression.h:62
          const char* doc = R"""(max)""";
        } Max;
        // Symbol: drake::symbolic::ExpressionKind::Min
        struct /* Min */ {
          // Source: drake/common/symbolic_expression.h:61
          const char* doc = R"""(min)""";
        } Min;
        // Symbol: drake::symbolic::ExpressionKind::Mul
        struct /* Mul */ {
          // Source: drake/common/symbolic_expression.h:44
          const char* doc = R"""(multiplication (*))""";
        } Mul;
        // Symbol: drake::symbolic::ExpressionKind::NaN
        struct /* NaN */ {
          // Source: drake/common/symbolic_expression.h:66
          const char* doc = R"""(NaN)""";
        } NaN;
        // Symbol: drake::symbolic::ExpressionKind::Pow
        struct /* Pow */ {
          // Source: drake/common/symbolic_expression.h:50
          const char* doc = R"""(power function)""";
        } Pow;
        // Symbol: drake::symbolic::ExpressionKind::Sin
        struct /* Sin */ {
          // Source: drake/common/symbolic_expression.h:51
          const char* doc = R"""(sine)""";
        } Sin;
        // Symbol: drake::symbolic::ExpressionKind::Sinh
        struct /* Sinh */ {
          // Source: drake/common/symbolic_expression.h:58
          const char* doc = R"""(hyperbolic sine)""";
        } Sinh;
        // Symbol: drake::symbolic::ExpressionKind::Sqrt
        struct /* Sqrt */ {
          // Source: drake/common/symbolic_expression.h:49
          const char* doc = R"""(square root)""";
        } Sqrt;
        // Symbol: drake::symbolic::ExpressionKind::Tan
        struct /* Tan */ {
          // Source: drake/common/symbolic_expression.h:53
          const char* doc = R"""(tangent)""";
        } Tan;
        // Symbol: drake::symbolic::ExpressionKind::Tanh
        struct /* Tanh */ {
          // Source: drake/common/symbolic_expression.h:60
          const char* doc = R"""(hyperbolic tangent)""";
        } Tanh;
        // Symbol: drake::symbolic::ExpressionKind::UninterpretedFunction
        struct /* UninterpretedFunction */ {
          // Source: drake/common/symbolic_expression.h:67
          const char* doc = R"""(Uninterpreted function)""";
        } UninterpretedFunction;
        // Symbol: drake::symbolic::ExpressionKind::Var
        struct /* Var */ {
          // Source: drake/common/symbolic_expression.h:42
          const char* doc = R"""(variable)""";
        } Var;
      } ExpressionKind;
      // Symbol: drake::symbolic::ExpressionLog
      struct /* ExpressionLog */ {
        // Source: drake/common/symbolic_expression_cell.h:482
        const char* doc =
R"""(Symbolic expression representing logarithms.)""";
        // Symbol: drake::symbolic::ExpressionLog::Differentiate
        struct /* Differentiate */ {
          // Source: drake/common/symbolic_expression_cell.h:487
          const char* doc = R"""()""";
        } Differentiate;
        // Symbol: drake::symbolic::ExpressionLog::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_expression_cell.h:488
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::ExpressionLog::Expand
        struct /* Expand */ {
          // Source: drake/common/symbolic_expression_cell.h:485
          const char* doc = R"""()""";
        } Expand;
        // Symbol: drake::symbolic::ExpressionLog::ExpressionLog
        struct /* ctor */ {
          // Source: drake/common/symbolic_expression_cell.h:484
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::symbolic::ExpressionLog::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_expression_cell.h:486
          const char* doc = R"""()""";
        } Substitute;
      } ExpressionLog;
      // Symbol: drake::symbolic::ExpressionMax
      struct /* ExpressionMax */ {
        // Source: drake/common/symbolic_expression_cell.h:715
        const char* doc =
R"""(Symbolic expression representing max function.)""";
        // Symbol: drake::symbolic::ExpressionMax::Differentiate
        struct /* Differentiate */ {
          // Source: drake/common/symbolic_expression_cell.h:720
          const char* doc = R"""()""";
        } Differentiate;
        // Symbol: drake::symbolic::ExpressionMax::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_expression_cell.h:721
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::ExpressionMax::Expand
        struct /* Expand */ {
          // Source: drake/common/symbolic_expression_cell.h:718
          const char* doc = R"""()""";
        } Expand;
        // Symbol: drake::symbolic::ExpressionMax::ExpressionMax
        struct /* ctor */ {
          // Source: drake/common/symbolic_expression_cell.h:717
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::symbolic::ExpressionMax::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_expression_cell.h:719
          const char* doc = R"""()""";
        } Substitute;
      } ExpressionMax;
      // Symbol: drake::symbolic::ExpressionMin
      struct /* ExpressionMin */ {
        // Source: drake/common/symbolic_expression_cell.h:702
        const char* doc =
R"""(Symbolic expression representing min function.)""";
        // Symbol: drake::symbolic::ExpressionMin::Differentiate
        struct /* Differentiate */ {
          // Source: drake/common/symbolic_expression_cell.h:707
          const char* doc = R"""()""";
        } Differentiate;
        // Symbol: drake::symbolic::ExpressionMin::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_expression_cell.h:708
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::ExpressionMin::Expand
        struct /* Expand */ {
          // Source: drake/common/symbolic_expression_cell.h:705
          const char* doc = R"""()""";
        } Expand;
        // Symbol: drake::symbolic::ExpressionMin::ExpressionMin
        struct /* ctor */ {
          // Source: drake/common/symbolic_expression_cell.h:704
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::symbolic::ExpressionMin::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_expression_cell.h:706
          const char* doc = R"""()""";
        } Substitute;
      } ExpressionMin;
      // Symbol: drake::symbolic::ExpressionMul
      struct /* ExpressionMul */ {
        // Source: drake/common/symbolic_expression_cell.h:376
        const char* doc =
R"""(Symbolic expression representing a multiplication of powers.

.. math:: c_0 \cdot \prod b_i^{e_i}

where :math:`c_0` is a constant and :math:`b_i` and :math:`e_i` are
symbolic expressions.

Internally this class maintains a member variable ``constant_``
representing :math:`c_0` and another member variable
``base_to_exponent_map_`` representing a mapping from a base,
:math:`b_i` to its exponentiation :math:`e_i`.)""";
        // Symbol: drake::symbolic::ExpressionMul::Differentiate
        struct /* Differentiate */ {
          // Source: drake/common/symbolic_expression_cell.h:388
          const char* doc = R"""()""";
        } Differentiate;
        // Symbol: drake::symbolic::ExpressionMul::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_expression_cell.h:389
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::ExpressionMul::EqualTo
        struct /* EqualTo */ {
          // Source: drake/common/symbolic_expression_cell.h:383
          const char* doc = R"""()""";
        } EqualTo;
        // Symbol: drake::symbolic::ExpressionMul::Evaluate
        struct /* Evaluate */ {
          // Source: drake/common/symbolic_expression_cell.h:385
          const char* doc = R"""()""";
        } Evaluate;
        // Symbol: drake::symbolic::ExpressionMul::Expand
        struct /* Expand */ {
          // Source: drake/common/symbolic_expression_cell.h:386
          const char* doc = R"""()""";
        } Expand;
        // Symbol: drake::symbolic::ExpressionMul::ExpressionMul
        struct /* ctor */ {
          // Source: drake/common/symbolic_expression_cell.h:379
          const char* doc =
R"""(Constructs ExpressionMul from ``constant`` and
``base_to_exponent_map``.)""";
        } ctor;
        // Symbol: drake::symbolic::ExpressionMul::GetVariables
        struct /* GetVariables */ {
          // Source: drake/common/symbolic_expression_cell.h:382
          const char* doc = R"""()""";
        } GetVariables;
        // Symbol: drake::symbolic::ExpressionMul::HashAppendDetail
        struct /* HashAppendDetail */ {
          // Source: drake/common/symbolic_expression_cell.h:381
          const char* doc = R"""()""";
        } HashAppendDetail;
        // Symbol: drake::symbolic::ExpressionMul::Less
        struct /* Less */ {
          // Source: drake/common/symbolic_expression_cell.h:384
          const char* doc = R"""()""";
        } Less;
        // Symbol: drake::symbolic::ExpressionMul::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_expression_cell.h:387
          const char* doc = R"""()""";
        } Substitute;
        // Symbol: drake::symbolic::ExpressionMul::get_base_to_exponent_map
        struct /* get_base_to_exponent_map */ {
          // Source: drake/common/symbolic_expression_cell.h:394
          const char* doc =
R"""(Returns map from a term to its coefficient.)""";
        } get_base_to_exponent_map;
        // Symbol: drake::symbolic::ExpressionMul::get_constant
        struct /* get_constant */ {
          // Source: drake/common/symbolic_expression_cell.h:391
          const char* doc = R"""(Returns constant term.)""";
        } get_constant;
      } ExpressionMul;
      // Symbol: drake::symbolic::ExpressionMulFactory
      struct /* ExpressionMulFactory */ {
        // Source: drake/common/symbolic_expression_cell.h:408
        const char* doc =
R"""(Factory class to help build ExpressionMul expressions.)""";
        // Symbol: drake::symbolic::ExpressionMulFactory::Add
        struct /* Add */ {
          // Source: drake/common/symbolic_expression_cell.h:427
          const char* doc =
R"""(Adds ExpressionMul pointed by ``ptr`` to this factory.)""";
        } Add;
        // Symbol: drake::symbolic::ExpressionMulFactory::AddExpression
        struct /* AddExpression */ {
          // Source: drake/common/symbolic_expression_cell.h:425
          const char* doc = R"""(Adds ``e`` to this factory.)""";
        } AddExpression;
        // Symbol: drake::symbolic::ExpressionMulFactory::ExpressionMulFactory
        struct /* ctor */ {
          // Source: drake/common/symbolic_expression_cell.h:413
          const char* doc_0args = R"""(Default constructor. It constructs.)""";
          // Source: drake/common/symbolic_expression_cell.h:417
          const char* doc_2args =
R"""(Constructs ExpressionMulFactory with ``constant`` and
``base_to_exponent_map``.)""";
          // Source: drake/common/symbolic_expression_cell.h:421
          const char* doc_1args =
R"""(Constructs ExpressionMulFactory from ``ptr``.)""";
        } ctor;
        // Symbol: drake::symbolic::ExpressionMulFactory::GetExpression
        struct /* GetExpression */ {
          // Source: drake/common/symbolic_expression_cell.h:438
          const char* doc = R"""(Returns a symbolic expression.)""";
        } GetExpression;
        // Symbol: drake::symbolic::ExpressionMulFactory::Negate
        struct /* Negate */ {
          // Source: drake/common/symbolic_expression_cell.h:436
          const char* doc =
R"""(Negates the expressions in factory. If it represents c0 * p1 * ... *
pn, this method flips it into -c0 * p1 * ... * pn.

Returns:
    *this.)""";
        } Negate;
      } ExpressionMulFactory;
      // Symbol: drake::symbolic::ExpressionNaN
      struct /* ExpressionNaN */ {
        // Source: drake/common/symbolic_expression_cell.h:245
        const char* doc =
R"""(Symbolic expression representing NaN (not-a-number).)""";
        // Symbol: drake::symbolic::ExpressionNaN::Differentiate
        struct /* Differentiate */ {
          // Source: drake/common/symbolic_expression_cell.h:255
          const char* doc = R"""()""";
        } Differentiate;
        // Symbol: drake::symbolic::ExpressionNaN::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_expression_cell.h:256
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::ExpressionNaN::EqualTo
        struct /* EqualTo */ {
          // Source: drake/common/symbolic_expression_cell.h:250
          const char* doc = R"""()""";
        } EqualTo;
        // Symbol: drake::symbolic::ExpressionNaN::Evaluate
        struct /* Evaluate */ {
          // Source: drake/common/symbolic_expression_cell.h:252
          const char* doc = R"""()""";
        } Evaluate;
        // Symbol: drake::symbolic::ExpressionNaN::Expand
        struct /* Expand */ {
          // Source: drake/common/symbolic_expression_cell.h:253
          const char* doc = R"""()""";
        } Expand;
        // Symbol: drake::symbolic::ExpressionNaN::ExpressionNaN
        struct /* ctor */ {
          // Source: drake/common/symbolic_expression_cell.h:247
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::symbolic::ExpressionNaN::GetVariables
        struct /* GetVariables */ {
          // Source: drake/common/symbolic_expression_cell.h:249
          const char* doc = R"""()""";
        } GetVariables;
        // Symbol: drake::symbolic::ExpressionNaN::HashAppendDetail
        struct /* HashAppendDetail */ {
          // Source: drake/common/symbolic_expression_cell.h:248
          const char* doc = R"""()""";
        } HashAppendDetail;
        // Symbol: drake::symbolic::ExpressionNaN::Less
        struct /* Less */ {
          // Source: drake/common/symbolic_expression_cell.h:251
          const char* doc = R"""()""";
        } Less;
        // Symbol: drake::symbolic::ExpressionNaN::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_expression_cell.h:254
          const char* doc = R"""()""";
        } Substitute;
      } ExpressionNaN;
      // Symbol: drake::symbolic::ExpressionPow
      struct /* ExpressionPow */ {
        // Source: drake/common/symbolic_expression_cell.h:545
        const char* doc =
R"""(Symbolic expression representing power function.)""";
        // Symbol: drake::symbolic::ExpressionPow::Differentiate
        struct /* Differentiate */ {
          // Source: drake/common/symbolic_expression_cell.h:550
          const char* doc = R"""()""";
        } Differentiate;
        // Symbol: drake::symbolic::ExpressionPow::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_expression_cell.h:551
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::ExpressionPow::Expand
        struct /* Expand */ {
          // Source: drake/common/symbolic_expression_cell.h:548
          const char* doc = R"""()""";
        } Expand;
        // Symbol: drake::symbolic::ExpressionPow::ExpressionPow
        struct /* ctor */ {
          // Source: drake/common/symbolic_expression_cell.h:547
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::symbolic::ExpressionPow::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_expression_cell.h:549
          const char* doc = R"""()""";
        } Substitute;
      } ExpressionPow;
      // Symbol: drake::symbolic::ExpressionSin
      struct /* ExpressionSin */ {
        // Source: drake/common/symbolic_expression_cell.h:563
        const char* doc =
R"""(Symbolic expression representing sine function.)""";
        // Symbol: drake::symbolic::ExpressionSin::Differentiate
        struct /* Differentiate */ {
          // Source: drake/common/symbolic_expression_cell.h:568
          const char* doc = R"""()""";
        } Differentiate;
        // Symbol: drake::symbolic::ExpressionSin::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_expression_cell.h:569
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::ExpressionSin::Expand
        struct /* Expand */ {
          // Source: drake/common/symbolic_expression_cell.h:566
          const char* doc = R"""()""";
        } Expand;
        // Symbol: drake::symbolic::ExpressionSin::ExpressionSin
        struct /* ctor */ {
          // Source: drake/common/symbolic_expression_cell.h:565
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::symbolic::ExpressionSin::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_expression_cell.h:567
          const char* doc = R"""()""";
        } Substitute;
      } ExpressionSin;
      // Symbol: drake::symbolic::ExpressionSinh
      struct /* ExpressionSinh */ {
        // Source: drake/common/symbolic_expression_cell.h:663
        const char* doc =
R"""(Symbolic expression representing hyperbolic sine function.)""";
        // Symbol: drake::symbolic::ExpressionSinh::Differentiate
        struct /* Differentiate */ {
          // Source: drake/common/symbolic_expression_cell.h:668
          const char* doc = R"""()""";
        } Differentiate;
        // Symbol: drake::symbolic::ExpressionSinh::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_expression_cell.h:669
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::ExpressionSinh::Expand
        struct /* Expand */ {
          // Source: drake/common/symbolic_expression_cell.h:666
          const char* doc = R"""()""";
        } Expand;
        // Symbol: drake::symbolic::ExpressionSinh::ExpressionSinh
        struct /* ctor */ {
          // Source: drake/common/symbolic_expression_cell.h:665
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::symbolic::ExpressionSinh::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_expression_cell.h:667
          const char* doc = R"""()""";
        } Substitute;
      } ExpressionSinh;
      // Symbol: drake::symbolic::ExpressionSqrt
      struct /* ExpressionSqrt */ {
        // Source: drake/common/symbolic_expression_cell.h:528
        const char* doc =
R"""(Symbolic expression representing square-root.)""";
        // Symbol: drake::symbolic::ExpressionSqrt::Differentiate
        struct /* Differentiate */ {
          // Source: drake/common/symbolic_expression_cell.h:533
          const char* doc = R"""()""";
        } Differentiate;
        // Symbol: drake::symbolic::ExpressionSqrt::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_expression_cell.h:534
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::ExpressionSqrt::Expand
        struct /* Expand */ {
          // Source: drake/common/symbolic_expression_cell.h:531
          const char* doc = R"""()""";
        } Expand;
        // Symbol: drake::symbolic::ExpressionSqrt::ExpressionSqrt
        struct /* ctor */ {
          // Source: drake/common/symbolic_expression_cell.h:530
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::symbolic::ExpressionSqrt::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_expression_cell.h:532
          const char* doc = R"""()""";
        } Substitute;
      } ExpressionSqrt;
      // Symbol: drake::symbolic::ExpressionTan
      struct /* ExpressionTan */ {
        // Source: drake/common/symbolic_expression_cell.h:589
        const char* doc =
R"""(Symbolic expression representing tangent function.)""";
        // Symbol: drake::symbolic::ExpressionTan::Differentiate
        struct /* Differentiate */ {
          // Source: drake/common/symbolic_expression_cell.h:594
          const char* doc = R"""()""";
        } Differentiate;
        // Symbol: drake::symbolic::ExpressionTan::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_expression_cell.h:595
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::ExpressionTan::Expand
        struct /* Expand */ {
          // Source: drake/common/symbolic_expression_cell.h:592
          const char* doc = R"""()""";
        } Expand;
        // Symbol: drake::symbolic::ExpressionTan::ExpressionTan
        struct /* ctor */ {
          // Source: drake/common/symbolic_expression_cell.h:591
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::symbolic::ExpressionTan::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_expression_cell.h:593
          const char* doc = R"""()""";
        } Substitute;
      } ExpressionTan;
      // Symbol: drake::symbolic::ExpressionTanh
      struct /* ExpressionTanh */ {
        // Source: drake/common/symbolic_expression_cell.h:689
        const char* doc =
R"""(Symbolic expression representing hyperbolic tangent function.)""";
        // Symbol: drake::symbolic::ExpressionTanh::Differentiate
        struct /* Differentiate */ {
          // Source: drake/common/symbolic_expression_cell.h:694
          const char* doc = R"""()""";
        } Differentiate;
        // Symbol: drake::symbolic::ExpressionTanh::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_expression_cell.h:695
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::ExpressionTanh::Expand
        struct /* Expand */ {
          // Source: drake/common/symbolic_expression_cell.h:692
          const char* doc = R"""()""";
        } Expand;
        // Symbol: drake::symbolic::ExpressionTanh::ExpressionTanh
        struct /* ctor */ {
          // Source: drake/common/symbolic_expression_cell.h:691
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::symbolic::ExpressionTanh::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_expression_cell.h:693
          const char* doc = R"""()""";
        } Substitute;
      } ExpressionTanh;
      // Symbol: drake::symbolic::ExpressionUninterpretedFunction
      struct /* ExpressionUninterpretedFunction */ {
        // Source: drake/common/symbolic_expression_cell.h:789
        const char* doc =
R"""(Symbolic expression representing an uninterpreted function.)""";
        // Symbol: drake::symbolic::ExpressionUninterpretedFunction::Differentiate
        struct /* Differentiate */ {
          // Source: drake/common/symbolic_expression_cell.h:803
          const char* doc = R"""()""";
        } Differentiate;
        // Symbol: drake::symbolic::ExpressionUninterpretedFunction::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_expression_cell.h:804
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::ExpressionUninterpretedFunction::EqualTo
        struct /* EqualTo */ {
          // Source: drake/common/symbolic_expression_cell.h:798
          const char* doc = R"""()""";
        } EqualTo;
        // Symbol: drake::symbolic::ExpressionUninterpretedFunction::Evaluate
        struct /* Evaluate */ {
          // Source: drake/common/symbolic_expression_cell.h:800
          const char* doc = R"""()""";
        } Evaluate;
        // Symbol: drake::symbolic::ExpressionUninterpretedFunction::Expand
        struct /* Expand */ {
          // Source: drake/common/symbolic_expression_cell.h:801
          const char* doc = R"""()""";
        } Expand;
        // Symbol: drake::symbolic::ExpressionUninterpretedFunction::ExpressionUninterpretedFunction
        struct /* ctor */ {
          // Source: drake/common/symbolic_expression_cell.h:794
          const char* doc =
R"""(Constructs an uninterpreted-function expression from ``name`` and
``arguments``.)""";
        } ctor;
        // Symbol: drake::symbolic::ExpressionUninterpretedFunction::GetVariables
        struct /* GetVariables */ {
          // Source: drake/common/symbolic_expression_cell.h:797
          const char* doc = R"""()""";
        } GetVariables;
        // Symbol: drake::symbolic::ExpressionUninterpretedFunction::HashAppendDetail
        struct /* HashAppendDetail */ {
          // Source: drake/common/symbolic_expression_cell.h:796
          const char* doc = R"""()""";
        } HashAppendDetail;
        // Symbol: drake::symbolic::ExpressionUninterpretedFunction::Less
        struct /* Less */ {
          // Source: drake/common/symbolic_expression_cell.h:799
          const char* doc = R"""()""";
        } Less;
        // Symbol: drake::symbolic::ExpressionUninterpretedFunction::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_expression_cell.h:802
          const char* doc = R"""()""";
        } Substitute;
        // Symbol: drake::symbolic::ExpressionUninterpretedFunction::get_arguments
        struct /* get_arguments */ {
          // Source: drake/common/symbolic_expression_cell.h:810
          const char* doc =
R"""(Returns the arguments of this expression.)""";
        } get_arguments;
        // Symbol: drake::symbolic::ExpressionUninterpretedFunction::get_name
        struct /* get_name */ {
          // Source: drake/common/symbolic_expression_cell.h:807
          const char* doc = R"""(Returns the name of this expression.)""";
        } get_name;
      } ExpressionUninterpretedFunction;
      // Symbol: drake::symbolic::ExpressionVar
      struct /* ExpressionVar */ {
        // Source: drake/common/symbolic_expression_cell.h:204
        const char* doc =
R"""(Symbolic expression representing a variable.)""";
        // Symbol: drake::symbolic::ExpressionVar::Differentiate
        struct /* Differentiate */ {
          // Source: drake/common/symbolic_expression_cell.h:218
          const char* doc = R"""()""";
        } Differentiate;
        // Symbol: drake::symbolic::ExpressionVar::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_expression_cell.h:219
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::ExpressionVar::EqualTo
        struct /* EqualTo */ {
          // Source: drake/common/symbolic_expression_cell.h:213
          const char* doc = R"""()""";
        } EqualTo;
        // Symbol: drake::symbolic::ExpressionVar::Evaluate
        struct /* Evaluate */ {
          // Source: drake/common/symbolic_expression_cell.h:215
          const char* doc = R"""()""";
        } Evaluate;
        // Symbol: drake::symbolic::ExpressionVar::Expand
        struct /* Expand */ {
          // Source: drake/common/symbolic_expression_cell.h:216
          const char* doc = R"""()""";
        } Expand;
        // Symbol: drake::symbolic::ExpressionVar::ExpressionVar
        struct /* ctor */ {
          // Source: drake/common/symbolic_expression_cell.h:210
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::symbolic::ExpressionVar::GetVariables
        struct /* GetVariables */ {
          // Source: drake/common/symbolic_expression_cell.h:212
          const char* doc = R"""()""";
        } GetVariables;
        // Symbol: drake::symbolic::ExpressionVar::HashAppendDetail
        struct /* HashAppendDetail */ {
          // Source: drake/common/symbolic_expression_cell.h:209
          const char* doc =
R"""(Constructs an expression from ``var``.

Precondition:
    ``var`` is neither a dummy nor a BOOLEAN variable.)""";
        } HashAppendDetail;
        // Symbol: drake::symbolic::ExpressionVar::Less
        struct /* Less */ {
          // Source: drake/common/symbolic_expression_cell.h:214
          const char* doc = R"""()""";
        } Less;
        // Symbol: drake::symbolic::ExpressionVar::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_expression_cell.h:217
          const char* doc = R"""()""";
        } Substitute;
        // Symbol: drake::symbolic::ExpressionVar::get_variable
        struct /* get_variable */ {
          // Source: drake/common/symbolic_expression_cell.h:211
          const char* doc = R"""()""";
        } get_variable;
      } ExpressionVar;
      // Symbol: drake::symbolic::ExtractAndAppendVariablesFromExpression
      struct /* ExtractAndAppendVariablesFromExpression */ {
        // Source: drake/common/symbolic_decompose.h:46
        const char* doc = R"""()""";
      } ExtractAndAppendVariablesFromExpression;
      // Symbol: drake::symbolic::ExtractVariablesFromExpression
      struct /* ExtractVariablesFromExpression */ {
        // Source: drake/common/symbolic_decompose.h:58
        const char* doc = R"""()""";
      } ExtractVariablesFromExpression;
      // Symbol: drake::symbolic::Formula
      struct /* Formula */ {
        // Source: drake/common/symbolic_formula.h:114
        const char* doc =
R"""(Represents a symbolic form of a first-order logic formula.

It has the following grammar:


::

    F := ⊥ | ⊤ | Var | E = E | E ≠ E | E > E | E ≥ E | E < E | E ≤ E
    | E ∧ ... ∧ E | E ∨ ... ∨ E | ¬F | ∀ x₁, ..., xn. F

In the implementation, Formula is a simple wrapper including a shared
pointer to FormulaCell class which is a super-class of different kinds
of symbolic formulas (i.e. FormulaAnd, FormulaOr, FormulaEq). Note
that it includes a shared pointer, not a unique pointer, to allow
sharing sub-expressions.

Note:
    The sharing of sub-expressions is not yet implemented.

The following simple simplifications are implemented:


::

    E1 = E2        ->  True    (if E1 and E2 are structurally equal)
    E1 ≠ E2        ->  False   (if E1 and E2 are structurally equal)
    E1 > E2        ->  False   (if E1 and E2 are structurally equal)
    E1 ≥ E2        ->  True    (if E1 and E2 are structurally equal)
    E1 < E2        ->  False   (if E1 and E2 are structurally equal)
    E1 ≤ E2        ->  True    (if E1 and E2 are structurally equal)
    F1 ∧ F2        ->  False   (if either F1 or F2 is False)
    F1 ∨ F2        ->  True    (if either F1 or F2 is True)
    ¬(¬(F))        ->  F

We flatten nested conjunctions (or disjunctions) at the construction.
A conjunction (resp. disjunction) takes a set of conjuncts (resp.
disjuncts). Note that any duplicated conjunct/disjunct is removed. For
example, both of ``f1 && (f2 && f1)`` and ``(f1 && f2) && f1`` are
flattened to ``f1 && f2 && f1`` and simplified into ``f1 && f2``. As a
result, the two are identified as the same formula.

Note:
    Formula class has an explicit conversion operator to bool. It
    evaluates a symbolic formula under an empty environment. If a
    symbolic formula includes variables, the conversion operator
    throws an exception. This operator is only intended for
    third-party code doing things like ``(imag(SymbolicExpression(0))
    == SymbolicExpression(0)) { ... };`` that we found in Eigen3
    codebase. In general, a user of this class should explicitly call
    ``Evaluate`` from within Drake for readability.)""";
        // Symbol: drake::symbolic::Formula::EqualTo
        struct /* EqualTo */ {
          // Source: drake/common/symbolic_formula.h:139
          const char* doc = R"""(Checks structural equality.)""";
        } EqualTo;
        // Symbol: drake::symbolic::Formula::Evaluate
        struct /* Evaluate */ {
          // Source: drake/common/symbolic_formula.h:175
          const char* doc_2args =
R"""(Evaluates using a given environment (by default, an empty environment)
and a random number generator. If there is a random variable in this
formula which is unassigned in ``env``, it uses ``random_generator``
to sample a value and use it to substitute all occurrences of the
random variable in this formula.

Raises:
    RuntimeError if a variable ``v`` is needed for an evaluation but
    not provided by ``env``.

Raises:
    RuntimeError if an unassigned random variable is detected while
    ``random_generator`` is ``nullptr``.)""";
          // Source: drake/common/symbolic_formula.h:182
          const char* doc_1args =
R"""(Evaluates using an empty environment and a random number generator.

See the above overload for the exceptions that it might throw.)""";
        } Evaluate;
        // Symbol: drake::symbolic::Formula::False
        struct /* False */ {
          // Source: drake/common/symbolic_formula.h:203
          const char* doc = R"""()""";
        } False;
        // Symbol: drake::symbolic::Formula::Formula
        struct /* ctor */ {
          // Source: drake/common/symbolic_formula.h:121
          const char* doc_0args =
R"""(Default constructor. Sets the value to Formula::False, to be
consistent with value-initialized `bool`s.)""";
          // Source: drake/common/symbolic_formula.h:126
          const char* doc_1args_value =
R"""(Constructs from a ``bool``. This overload is also used by Eigen when
EIGEN_INITIALIZE_MATRICES_BY_ZERO is enabled.)""";
          // Source: drake/common/symbolic_formula.h:133
          const char* doc_1args_var =
R"""(Constructs a formula from ``var``.

Precondition:
    ``var`` is of BOOLEAN type and not a dummy variable.)""";
        } ctor;
        // Symbol: drake::symbolic::Formula::GetFreeVariables
        struct /* GetFreeVariables */ {
          // Source: drake/common/symbolic_formula.h:137
          const char* doc =
R"""(Gets free variables (unquantified variables).)""";
        } GetFreeVariables;
        // Symbol: drake::symbolic::Formula::Less
        struct /* Less */ {
          // Source: drake/common/symbolic_formula.h:162
          const char* doc =
R"""(Checks lexicographical ordering between this and ``e``.

If the two formulas f1 and f2 have different kinds k1 and k2
respectively, f1.Less(f2) is equal to k1 < k2. If f1 and f2 are
expressions of the same kind, we check the ordering between f1 and f2
by comparing their elements lexicographically.

For example, in case of And, let f1 and f2 be

f1 = f_1,1 ∧ ... ∧ f_1,n f2 = f_2,1 ∧ ... ∧ f_2,m

f1.Less(f2) is true if there exists an index i (<= n, m) such that for
all j < i, we have

¬(f_1_j.Less(f_2_j)) ∧ ¬(f_2_j.Less(f_1_j))

and f_1_i.Less(f_2_i) holds.

This function is used as a compare function in
std::map<symbolic::Formula> and std::set<symbolic::Formula> via
std::less<symbolic::Formula>.)""";
        } Less;
        // Symbol: drake::symbolic::Formula::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_formula.h:188
          const char* doc_2args =
R"""(Returns a copy of this formula replacing all occurrences of ``var``
with ``e``.

Raises:
    RuntimeError if NaN is detected during substitution.)""";
          // Source: drake/common/symbolic_formula.h:197
          const char* doc_1args =
R"""(Returns a copy of this formula replacing all occurrences of the
variables in ``s`` with corresponding expressions in ``s``. Note that
the substitutions occur simultaneously. For example, (x / y >
0).Substitute({{x, y}, {y, x}}) gets (y / x > 0).

Raises:
    RuntimeError if NaN is detected during substitution.)""";
        } Substitute;
        // Symbol: drake::symbolic::Formula::True
        struct /* True */ {
          // Source: drake/common/symbolic_formula.h:202
          const char* doc = R"""()""";
        } True;
        // Symbol: drake::symbolic::Formula::get_kind
        struct /* get_kind */ {
          // Source: drake/common/symbolic_formula.h:135
          const char* doc = R"""()""";
        } get_kind;
        // Symbol: drake::symbolic::Formula::operator bool
        struct /* operator_bool */ {
          // Source: drake/common/symbolic_formula.h:206
          const char* doc = R"""(Conversion to bool.)""";
        } operator_bool;
        // Symbol: drake::symbolic::Formula::to_string
        struct /* to_string */ {
          // Source: drake/common/symbolic_formula.h:200
          const char* doc =
R"""(Returns string representation of Formula.)""";
        } to_string;
      } Formula;
      // Symbol: drake::symbolic::FormulaAnd
      struct /* FormulaAnd */ {
        // Source: drake/common/symbolic_formula_cell.h:256
        const char* doc =
R"""(Symbolic formula representing conjunctions (f1 ∧ ... ∧ fn).)""";
        // Symbol: drake::symbolic::FormulaAnd::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_formula_cell.h:264
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::FormulaAnd::Evaluate
        struct /* Evaluate */ {
          // Source: drake/common/symbolic_formula_cell.h:262
          const char* doc = R"""()""";
        } Evaluate;
        // Symbol: drake::symbolic::FormulaAnd::FormulaAnd
        struct /* ctor */ {
          // Source: drake/common/symbolic_formula_cell.h:259
          const char* doc_1args = R"""(Constructs from ``formulas``.)""";
          // Source: drake/common/symbolic_formula_cell.h:261
          const char* doc_2args = R"""(Constructs ``f1`` ∧ ``f2``.)""";
        } ctor;
        // Symbol: drake::symbolic::FormulaAnd::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_formula_cell.h:263
          const char* doc = R"""()""";
        } Substitute;
      } FormulaAnd;
      // Symbol: drake::symbolic::FormulaCell
      struct /* FormulaCell */ {
        // Source: drake/common/symbolic_formula_cell.h:33
        const char* doc =
R"""(Represents an abstract class which is the base of concrete
symbolic-formula classes (i.e. symbolic::FormulaAnd,
symbolic::FormulaEq).

Note:
    It provides virtual function, FormulaCell::Display, because
    operator<< is not allowed to be a virtual function.)""";
        // Symbol: drake::symbolic::FormulaCell::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_formula_cell.h:56
          const char* doc =
R"""(Outputs string representation of formula into output stream ``os``.)""";
        } Display;
        // Symbol: drake::symbolic::FormulaCell::EqualTo
        struct /* EqualTo */ {
          // Source: drake/common/symbolic_formula_cell.h:45
          const char* doc = R"""(Checks structural equality.)""";
        } EqualTo;
        // Symbol: drake::symbolic::FormulaCell::Evaluate
        struct /* Evaluate */ {
          // Source: drake/common/symbolic_formula_cell.h:49
          const char* doc = R"""(Evaluates under a given environment.)""";
        } Evaluate;
        // Symbol: drake::symbolic::FormulaCell::FormulaCell
        struct /* ctor */ {
          // Source: drake/common/symbolic_formula_cell.h:59
          const char* doc_0args = R"""(Default constructor (deleted).)""";
          // Source: drake/common/symbolic_formula_cell.h:69
          const char* doc_move =
R"""(Move-construct a formula from an rvalue.)""";
          // Source: drake/common/symbolic_formula_cell.h:71
          const char* doc_copy =
R"""(Copy-construct a formula from an lvalue.)""";
          // Source: drake/common/symbolic_formula_cell.h:73
          const char* doc_1args = R"""(Construct FormulaCell of kind ``k``.)""";
        } ctor;
        // Symbol: drake::symbolic::FormulaCell::GetFreeVariables
        struct /* GetFreeVariables */ {
          // Source: drake/common/symbolic_formula_cell.h:43
          const char* doc =
R"""(Returns set of free variables in formula.)""";
        } GetFreeVariables;
        // Symbol: drake::symbolic::FormulaCell::HashAppendDetail
        struct /* HashAppendDetail */ {
          // Source: drake/common/symbolic_formula_cell.h:41
          const char* doc =
R"""(Sends all hash-relevant bytes for this FormulaCell type into the given
hasher, per the hash_append concept -- except for get_kind(), because
Formula already sends that.)""";
        } HashAppendDetail;
        // Symbol: drake::symbolic::FormulaCell::Less
        struct /* Less */ {
          // Source: drake/common/symbolic_formula_cell.h:47
          const char* doc = R"""(Checks ordering.)""";
        } Less;
        // Symbol: drake::symbolic::FormulaCell::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_formula_cell.h:54
          const char* doc =
R"""(Returns a Formula obtained by replacing all occurrences of the
variables in ``s`` in the current formula cell with the corresponding
expressions in ``s``.)""";
        } Substitute;
        // Symbol: drake::symbolic::FormulaCell::get_kind
        struct /* get_kind */ {
          // Source: drake/common/symbolic_formula_cell.h:36
          const char* doc = R"""(Returns kind of formula.)""";
        } get_kind;
      } FormulaCell;
      // Symbol: drake::symbolic::FormulaEq
      struct /* FormulaEq */ {
        // Source: drake/common/symbolic_formula_cell.h:196
        const char* doc =
R"""(Symbolic formula representing equality (e1 = e2).)""";
        // Symbol: drake::symbolic::FormulaEq::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_formula_cell.h:202
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::FormulaEq::Evaluate
        struct /* Evaluate */ {
          // Source: drake/common/symbolic_formula_cell.h:200
          const char* doc = R"""()""";
        } Evaluate;
        // Symbol: drake::symbolic::FormulaEq::FormulaEq
        struct /* ctor */ {
          // Source: drake/common/symbolic_formula_cell.h:199
          const char* doc = R"""(Constructs from ``e1`` and ``e2``.)""";
        } ctor;
        // Symbol: drake::symbolic::FormulaEq::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_formula_cell.h:201
          const char* doc = R"""()""";
        } Substitute;
      } FormulaEq;
      // Symbol: drake::symbolic::FormulaFalse
      struct /* FormulaFalse */ {
        // Source: drake/common/symbolic_formula_cell.h:162
        const char* doc = R"""(Symbolic formula representing false.)""";
        // Symbol: drake::symbolic::FormulaFalse::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_formula_cell.h:172
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::FormulaFalse::EqualTo
        struct /* EqualTo */ {
          // Source: drake/common/symbolic_formula_cell.h:168
          const char* doc = R"""()""";
        } EqualTo;
        // Symbol: drake::symbolic::FormulaFalse::Evaluate
        struct /* Evaluate */ {
          // Source: drake/common/symbolic_formula_cell.h:170
          const char* doc = R"""()""";
        } Evaluate;
        // Symbol: drake::symbolic::FormulaFalse::FormulaFalse
        struct /* ctor */ {
          // Source: drake/common/symbolic_formula_cell.h:165
          const char* doc = R"""(Default Constructor.)""";
        } ctor;
        // Symbol: drake::symbolic::FormulaFalse::GetFreeVariables
        struct /* GetFreeVariables */ {
          // Source: drake/common/symbolic_formula_cell.h:167
          const char* doc = R"""()""";
        } GetFreeVariables;
        // Symbol: drake::symbolic::FormulaFalse::HashAppendDetail
        struct /* HashAppendDetail */ {
          // Source: drake/common/symbolic_formula_cell.h:166
          const char* doc = R"""()""";
        } HashAppendDetail;
        // Symbol: drake::symbolic::FormulaFalse::Less
        struct /* Less */ {
          // Source: drake/common/symbolic_formula_cell.h:169
          const char* doc = R"""()""";
        } Less;
        // Symbol: drake::symbolic::FormulaFalse::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_formula_cell.h:171
          const char* doc = R"""()""";
        } Substitute;
      } FormulaFalse;
      // Symbol: drake::symbolic::FormulaForall
      struct /* FormulaForall */ {
        // Source: drake/common/symbolic_formula_cell.h:301
        const char* doc =
R"""(Symbolic formula representing universal quantifications (∀ x₁, ..., *
xn. F).)""";
        // Symbol: drake::symbolic::FormulaForall::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_formula_cell.h:311
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::FormulaForall::EqualTo
        struct /* EqualTo */ {
          // Source: drake/common/symbolic_formula_cell.h:307
          const char* doc = R"""()""";
        } EqualTo;
        // Symbol: drake::symbolic::FormulaForall::Evaluate
        struct /* Evaluate */ {
          // Source: drake/common/symbolic_formula_cell.h:309
          const char* doc = R"""()""";
        } Evaluate;
        // Symbol: drake::symbolic::FormulaForall::FormulaForall
        struct /* ctor */ {
          // Source: drake/common/symbolic_formula_cell.h:304
          const char* doc = R"""(Constructs from ``vars`` and ``f``.)""";
        } ctor;
        // Symbol: drake::symbolic::FormulaForall::GetFreeVariables
        struct /* GetFreeVariables */ {
          // Source: drake/common/symbolic_formula_cell.h:306
          const char* doc = R"""()""";
        } GetFreeVariables;
        // Symbol: drake::symbolic::FormulaForall::HashAppendDetail
        struct /* HashAppendDetail */ {
          // Source: drake/common/symbolic_formula_cell.h:305
          const char* doc = R"""()""";
        } HashAppendDetail;
        // Symbol: drake::symbolic::FormulaForall::Less
        struct /* Less */ {
          // Source: drake/common/symbolic_formula_cell.h:308
          const char* doc = R"""()""";
        } Less;
        // Symbol: drake::symbolic::FormulaForall::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_formula_cell.h:310
          const char* doc = R"""()""";
        } Substitute;
        // Symbol: drake::symbolic::FormulaForall::get_quantified_formula
        struct /* get_quantified_formula */ {
          // Source: drake/common/symbolic_formula_cell.h:317
          const char* doc = R"""(Returns the quantified formula.)""";
        } get_quantified_formula;
        // Symbol: drake::symbolic::FormulaForall::get_quantified_variables
        struct /* get_quantified_variables */ {
          // Source: drake/common/symbolic_formula_cell.h:313
          const char* doc = R"""(Returns the quantified variables.)""";
        } get_quantified_variables;
      } FormulaForall;
      // Symbol: drake::symbolic::FormulaGeq
      struct /* FormulaGeq */ {
        // Source: drake/common/symbolic_formula_cell.h:226
        const char* doc =
R"""(Symbolic formula representing 'greater-than-or-equal-to' (e1 ≥ e2).)""";
        // Symbol: drake::symbolic::FormulaGeq::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_formula_cell.h:232
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::FormulaGeq::Evaluate
        struct /* Evaluate */ {
          // Source: drake/common/symbolic_formula_cell.h:230
          const char* doc = R"""()""";
        } Evaluate;
        // Symbol: drake::symbolic::FormulaGeq::FormulaGeq
        struct /* ctor */ {
          // Source: drake/common/symbolic_formula_cell.h:229
          const char* doc = R"""(Constructs from ``e1`` and ``e2``.)""";
        } ctor;
        // Symbol: drake::symbolic::FormulaGeq::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_formula_cell.h:231
          const char* doc = R"""()""";
        } Substitute;
      } FormulaGeq;
      // Symbol: drake::symbolic::FormulaGt
      struct /* FormulaGt */ {
        // Source: drake/common/symbolic_formula_cell.h:216
        const char* doc =
R"""(Symbolic formula representing 'greater-than' (e1 > e2).)""";
        // Symbol: drake::symbolic::FormulaGt::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_formula_cell.h:222
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::FormulaGt::Evaluate
        struct /* Evaluate */ {
          // Source: drake/common/symbolic_formula_cell.h:220
          const char* doc = R"""()""";
        } Evaluate;
        // Symbol: drake::symbolic::FormulaGt::FormulaGt
        struct /* ctor */ {
          // Source: drake/common/symbolic_formula_cell.h:219
          const char* doc = R"""(Constructs from ``e1`` and ``e2``.)""";
        } ctor;
        // Symbol: drake::symbolic::FormulaGt::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_formula_cell.h:221
          const char* doc = R"""()""";
        } Substitute;
      } FormulaGt;
      // Symbol: drake::symbolic::FormulaIsnan
      struct /* FormulaIsnan */ {
        // Source: drake/common/symbolic_formula_cell.h:325
        const char* doc =
R"""(Symbolic formula representing isnan predicate.)""";
        // Symbol: drake::symbolic::FormulaIsnan::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_formula_cell.h:334
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::FormulaIsnan::EqualTo
        struct /* EqualTo */ {
          // Source: drake/common/symbolic_formula_cell.h:330
          const char* doc = R"""()""";
        } EqualTo;
        // Symbol: drake::symbolic::FormulaIsnan::Evaluate
        struct /* Evaluate */ {
          // Source: drake/common/symbolic_formula_cell.h:332
          const char* doc = R"""()""";
        } Evaluate;
        // Symbol: drake::symbolic::FormulaIsnan::FormulaIsnan
        struct /* ctor */ {
          // Source: drake/common/symbolic_formula_cell.h:327
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::symbolic::FormulaIsnan::GetFreeVariables
        struct /* GetFreeVariables */ {
          // Source: drake/common/symbolic_formula_cell.h:329
          const char* doc = R"""()""";
        } GetFreeVariables;
        // Symbol: drake::symbolic::FormulaIsnan::HashAppendDetail
        struct /* HashAppendDetail */ {
          // Source: drake/common/symbolic_formula_cell.h:328
          const char* doc = R"""()""";
        } HashAppendDetail;
        // Symbol: drake::symbolic::FormulaIsnan::Less
        struct /* Less */ {
          // Source: drake/common/symbolic_formula_cell.h:331
          const char* doc = R"""()""";
        } Less;
        // Symbol: drake::symbolic::FormulaIsnan::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_formula_cell.h:333
          const char* doc = R"""()""";
        } Substitute;
      } FormulaIsnan;
      // Symbol: drake::symbolic::FormulaKind
      struct /* FormulaKind */ {
        // Source: drake/common/symbolic_formula.h:28
        const char* doc = R"""(Kinds of symbolic formulas.)""";
        // Symbol: drake::symbolic::FormulaKind::And
        struct /* And */ {
          // Source: drake/common/symbolic_formula.h:38
          const char* doc = R"""(Conjunction (∧))""";
        } And;
        // Symbol: drake::symbolic::FormulaKind::Eq
        struct /* Eq */ {
          // Source: drake/common/symbolic_formula.h:32
          const char* doc = R"""(=)""";
        } Eq;
        // Symbol: drake::symbolic::FormulaKind::False
        struct /* False */ {
          // Source: drake/common/symbolic_formula.h:29
          const char* doc = R"""(⊥)""";
        } False;
        // Symbol: drake::symbolic::FormulaKind::Forall
        struct /* Forall */ {
          // Source: drake/common/symbolic_formula.h:41
          const char* doc = R"""(Universal quantification (∀))""";
        } Forall;
        // Symbol: drake::symbolic::FormulaKind::Geq
        struct /* Geq */ {
          // Source: drake/common/symbolic_formula.h:35
          const char* doc = R"""(>=)""";
        } Geq;
        // Symbol: drake::symbolic::FormulaKind::Gt
        struct /* Gt */ {
          // Source: drake/common/symbolic_formula.h:34
          const char* doc = R"""(>)""";
        } Gt;
        // Symbol: drake::symbolic::FormulaKind::Isnan
        struct /* Isnan */ {
          // Source: drake/common/symbolic_formula.h:42
          const char* doc = R"""(NaN check predicate)""";
        } Isnan;
        // Symbol: drake::symbolic::FormulaKind::Leq
        struct /* Leq */ {
          // Source: drake/common/symbolic_formula.h:37
          const char* doc = R"""(<=)""";
        } Leq;
        // Symbol: drake::symbolic::FormulaKind::Lt
        struct /* Lt */ {
          // Source: drake/common/symbolic_formula.h:36
          const char* doc = R"""(<)""";
        } Lt;
        // Symbol: drake::symbolic::FormulaKind::Neq
        struct /* Neq */ {
          // Source: drake/common/symbolic_formula.h:33
          const char* doc = R"""(!=)""";
        } Neq;
        // Symbol: drake::symbolic::FormulaKind::Not
        struct /* Not */ {
          // Source: drake/common/symbolic_formula.h:40
          const char* doc = R"""(Negation (¬))""";
        } Not;
        // Symbol: drake::symbolic::FormulaKind::Or
        struct /* Or */ {
          // Source: drake/common/symbolic_formula.h:39
          const char* doc = R"""(Disjunction (∨))""";
        } Or;
        // Symbol: drake::symbolic::FormulaKind::PositiveSemidefinite
        struct /* PositiveSemidefinite */ {
          // Source: drake/common/symbolic_formula.h:43
          const char* doc = R"""(Positive semidefinite matrix)""";
        } PositiveSemidefinite;
        // Symbol: drake::symbolic::FormulaKind::True
        struct /* True */ {
          // Source: drake/common/symbolic_formula.h:30
          const char* doc = R"""(⊤)""";
        } True;
        // Symbol: drake::symbolic::FormulaKind::Var
        struct /* Var */ {
          // Source: drake/common/symbolic_formula.h:31
          const char* doc = R"""(Boolean Variable)""";
        } Var;
      } FormulaKind;
      // Symbol: drake::symbolic::FormulaLeq
      struct /* FormulaLeq */ {
        // Source: drake/common/symbolic_formula_cell.h:246
        const char* doc =
R"""(Symbolic formula representing 'less-than-or-equal-to' (e1 ≤ e2).)""";
        // Symbol: drake::symbolic::FormulaLeq::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_formula_cell.h:252
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::FormulaLeq::Evaluate
        struct /* Evaluate */ {
          // Source: drake/common/symbolic_formula_cell.h:250
          const char* doc = R"""()""";
        } Evaluate;
        // Symbol: drake::symbolic::FormulaLeq::FormulaLeq
        struct /* ctor */ {
          // Source: drake/common/symbolic_formula_cell.h:249
          const char* doc = R"""(Constructs from ``e1`` and ``e2``.)""";
        } ctor;
        // Symbol: drake::symbolic::FormulaLeq::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_formula_cell.h:251
          const char* doc = R"""()""";
        } Substitute;
      } FormulaLeq;
      // Symbol: drake::symbolic::FormulaLt
      struct /* FormulaLt */ {
        // Source: drake/common/symbolic_formula_cell.h:236
        const char* doc =
R"""(Symbolic formula representing 'less-than' (e1 < e2).)""";
        // Symbol: drake::symbolic::FormulaLt::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_formula_cell.h:242
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::FormulaLt::Evaluate
        struct /* Evaluate */ {
          // Source: drake/common/symbolic_formula_cell.h:240
          const char* doc = R"""()""";
        } Evaluate;
        // Symbol: drake::symbolic::FormulaLt::FormulaLt
        struct /* ctor */ {
          // Source: drake/common/symbolic_formula_cell.h:239
          const char* doc = R"""(Constructs from ``e1`` and ``e2``.)""";
        } ctor;
        // Symbol: drake::symbolic::FormulaLt::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_formula_cell.h:241
          const char* doc = R"""()""";
        } Substitute;
      } FormulaLt;
      // Symbol: drake::symbolic::FormulaNeq
      struct /* FormulaNeq */ {
        // Source: drake/common/symbolic_formula_cell.h:206
        const char* doc =
R"""(Symbolic formula representing disequality (e1 ≠ e2).)""";
        // Symbol: drake::symbolic::FormulaNeq::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_formula_cell.h:212
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::FormulaNeq::Evaluate
        struct /* Evaluate */ {
          // Source: drake/common/symbolic_formula_cell.h:210
          const char* doc = R"""()""";
        } Evaluate;
        // Symbol: drake::symbolic::FormulaNeq::FormulaNeq
        struct /* ctor */ {
          // Source: drake/common/symbolic_formula_cell.h:209
          const char* doc = R"""(Constructs from ``e1`` and ``e2``.)""";
        } ctor;
        // Symbol: drake::symbolic::FormulaNeq::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_formula_cell.h:211
          const char* doc = R"""()""";
        } Substitute;
      } FormulaNeq;
      // Symbol: drake::symbolic::FormulaNot
      struct /* FormulaNot */ {
        // Source: drake/common/symbolic_formula_cell.h:280
        const char* doc =
R"""(Symbolic formula representing negations (¬f).)""";
        // Symbol: drake::symbolic::FormulaNot::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_formula_cell.h:290
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::FormulaNot::EqualTo
        struct /* EqualTo */ {
          // Source: drake/common/symbolic_formula_cell.h:286
          const char* doc = R"""()""";
        } EqualTo;
        // Symbol: drake::symbolic::FormulaNot::Evaluate
        struct /* Evaluate */ {
          // Source: drake/common/symbolic_formula_cell.h:288
          const char* doc = R"""()""";
        } Evaluate;
        // Symbol: drake::symbolic::FormulaNot::FormulaNot
        struct /* ctor */ {
          // Source: drake/common/symbolic_formula_cell.h:283
          const char* doc = R"""(Constructs from ``f``.)""";
        } ctor;
        // Symbol: drake::symbolic::FormulaNot::GetFreeVariables
        struct /* GetFreeVariables */ {
          // Source: drake/common/symbolic_formula_cell.h:285
          const char* doc = R"""()""";
        } GetFreeVariables;
        // Symbol: drake::symbolic::FormulaNot::HashAppendDetail
        struct /* HashAppendDetail */ {
          // Source: drake/common/symbolic_formula_cell.h:284
          const char* doc = R"""()""";
        } HashAppendDetail;
        // Symbol: drake::symbolic::FormulaNot::Less
        struct /* Less */ {
          // Source: drake/common/symbolic_formula_cell.h:287
          const char* doc = R"""()""";
        } Less;
        // Symbol: drake::symbolic::FormulaNot::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_formula_cell.h:289
          const char* doc = R"""()""";
        } Substitute;
        // Symbol: drake::symbolic::FormulaNot::get_operand
        struct /* get_operand */ {
          // Source: drake/common/symbolic_formula_cell.h:292
          const char* doc = R"""(Returns the operand.)""";
        } get_operand;
      } FormulaNot;
      // Symbol: drake::symbolic::FormulaOr
      struct /* FormulaOr */ {
        // Source: drake/common/symbolic_formula_cell.h:268
        const char* doc =
R"""(Symbolic formula representing disjunctions (f1 ∨ ... ∨ fn).)""";
        // Symbol: drake::symbolic::FormulaOr::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_formula_cell.h:276
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::FormulaOr::Evaluate
        struct /* Evaluate */ {
          // Source: drake/common/symbolic_formula_cell.h:274
          const char* doc = R"""()""";
        } Evaluate;
        // Symbol: drake::symbolic::FormulaOr::FormulaOr
        struct /* ctor */ {
          // Source: drake/common/symbolic_formula_cell.h:271
          const char* doc_1args = R"""(Constructs from ``formulas``.)""";
          // Source: drake/common/symbolic_formula_cell.h:273
          const char* doc_2args = R"""(Constructs ``f1`` ∨ ``f2``.)""";
        } ctor;
        // Symbol: drake::symbolic::FormulaOr::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_formula_cell.h:275
          const char* doc = R"""()""";
        } Substitute;
      } FormulaOr;
      // Symbol: drake::symbolic::FormulaPositiveSemidefinite
      struct /* FormulaPositiveSemidefinite */ {
        // Source: drake/common/symbolic_formula_cell.h:341
        const char* doc =
R"""(Symbolic formula representing positive-semidefinite (PSD) constraint.)""";
        // Symbol: drake::symbolic::FormulaPositiveSemidefinite::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_formula_cell.h:404
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::FormulaPositiveSemidefinite::EqualTo
        struct /* EqualTo */ {
          // Source: drake/common/symbolic_formula_cell.h:372
          const char* doc = R"""()""";
        } EqualTo;
        // Symbol: drake::symbolic::FormulaPositiveSemidefinite::Evaluate
        struct /* Evaluate */ {
          // Source: drake/common/symbolic_formula_cell.h:402
          const char* doc = R"""()""";
        } Evaluate;
        // Symbol: drake::symbolic::FormulaPositiveSemidefinite::FormulaPositiveSemidefinite
        struct /* ctor */ {
          // Source: drake/common/symbolic_formula_cell.h:349
          const char* doc_was_unable_to_choose_unambiguous_names =
R"""(Constructs a positive-semidefinite formula from a symmetric matrix
``m``.

Raises:
    RuntimeError if ``m`` is not symmetric.

Note:
    This constructor checks if ``m`` is symmetric, which can be
    costly.)""";
        } ctor;
        // Symbol: drake::symbolic::FormulaPositiveSemidefinite::GetFreeVariables
        struct /* GetFreeVariables */ {
          // Source: drake/common/symbolic_formula_cell.h:371
          const char* doc = R"""()""";
        } GetFreeVariables;
        // Symbol: drake::symbolic::FormulaPositiveSemidefinite::HashAppendDetail
        struct /* HashAppendDetail */ {
          // Source: drake/common/symbolic_formula_cell.h:370
          const char* doc = R"""()""";
        } HashAppendDetail;
        // Symbol: drake::symbolic::FormulaPositiveSemidefinite::Less
        struct /* Less */ {
          // Source: drake/common/symbolic_formula_cell.h:401
          const char* doc =
R"""(Checks ordering between this PSD formula and ``f``. The ordering
between two PSD formulas ``psd1`` and ``psd2`` are determined by the
ordering between the two matrices ``m1`` in ``psd1`` and ``m2`` in
``psd2``.

First, we compare the size of ``m1`` and ``m2``:

- If ``m1`` is smaller than ``m2``, `psd1.Less(psd2)` is true.
- If ``m2`` is smaller than ``m1``, `psd1.Less(psd2)` is false.

If ``m1`` and ``m2`` are of the same size, we perform element-wise
comparison by following column-major order. See the following example:


::

    m1 << x + y, -3.14,
          -3.14,     y;
    m2 << x + y,  3.14,
           3.14,     y;
    const Formula psd1{positive_semidefinite(m1)};
    const Formula psd2{positive_semidefinite(m2)};
    
    EXPECT_TRUE(psd1.Less(psd2));

Note:
    In the code above, ``psd1.Less(psd2)`` holds because we have

- m1 in column-major ordering : (x + y) -3.14 -3.14 y_ - m2 in
column-major ordering : (x + y) 3.14 3.14 y_.)""";
        } Less;
        // Symbol: drake::symbolic::FormulaPositiveSemidefinite::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_formula_cell.h:403
          const char* doc = R"""()""";
        } Substitute;
        // Symbol: drake::symbolic::FormulaPositiveSemidefinite::get_matrix
        struct /* get_matrix */ {
          // Source: drake/common/symbolic_formula_cell.h:406
          const char* doc =
R"""(Returns the corresponding matrix in this PSD formula.)""";
        } get_matrix;
      } FormulaPositiveSemidefinite;
      // Symbol: drake::symbolic::FormulaTrue
      struct /* FormulaTrue */ {
        // Source: drake/common/symbolic_formula_cell.h:148
        const char* doc = R"""(Symbolic formula representing true.)""";
        // Symbol: drake::symbolic::FormulaTrue::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_formula_cell.h:158
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::FormulaTrue::EqualTo
        struct /* EqualTo */ {
          // Source: drake/common/symbolic_formula_cell.h:154
          const char* doc = R"""()""";
        } EqualTo;
        // Symbol: drake::symbolic::FormulaTrue::Evaluate
        struct /* Evaluate */ {
          // Source: drake/common/symbolic_formula_cell.h:156
          const char* doc = R"""()""";
        } Evaluate;
        // Symbol: drake::symbolic::FormulaTrue::FormulaTrue
        struct /* ctor */ {
          // Source: drake/common/symbolic_formula_cell.h:151
          const char* doc = R"""(Default Constructor.)""";
        } ctor;
        // Symbol: drake::symbolic::FormulaTrue::GetFreeVariables
        struct /* GetFreeVariables */ {
          // Source: drake/common/symbolic_formula_cell.h:153
          const char* doc = R"""()""";
        } GetFreeVariables;
        // Symbol: drake::symbolic::FormulaTrue::HashAppendDetail
        struct /* HashAppendDetail */ {
          // Source: drake/common/symbolic_formula_cell.h:152
          const char* doc = R"""()""";
        } HashAppendDetail;
        // Symbol: drake::symbolic::FormulaTrue::Less
        struct /* Less */ {
          // Source: drake/common/symbolic_formula_cell.h:155
          const char* doc = R"""()""";
        } Less;
        // Symbol: drake::symbolic::FormulaTrue::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_formula_cell.h:157
          const char* doc = R"""()""";
        } Substitute;
      } FormulaTrue;
      // Symbol: drake::symbolic::FormulaVar
      struct /* FormulaVar */ {
        // Source: drake/common/symbolic_formula_cell.h:176
        const char* doc =
R"""(Symbolic formula representing a Boolean variable.)""";
        // Symbol: drake::symbolic::FormulaVar::Display
        struct /* Display */ {
          // Source: drake/common/symbolic_formula_cell.h:188
          const char* doc = R"""()""";
        } Display;
        // Symbol: drake::symbolic::FormulaVar::EqualTo
        struct /* EqualTo */ {
          // Source: drake/common/symbolic_formula_cell.h:184
          const char* doc = R"""()""";
        } EqualTo;
        // Symbol: drake::symbolic::FormulaVar::Evaluate
        struct /* Evaluate */ {
          // Source: drake/common/symbolic_formula_cell.h:186
          const char* doc = R"""()""";
        } Evaluate;
        // Symbol: drake::symbolic::FormulaVar::FormulaVar
        struct /* ctor */ {
          // Source: drake/common/symbolic_formula_cell.h:181
          const char* doc =
R"""(Constructs a formula from ``var``.

Precondition:
    ``var`` is of BOOLEAN type and not a dummy variable.)""";
        } ctor;
        // Symbol: drake::symbolic::FormulaVar::GetFreeVariables
        struct /* GetFreeVariables */ {
          // Source: drake/common/symbolic_formula_cell.h:183
          const char* doc = R"""()""";
        } GetFreeVariables;
        // Symbol: drake::symbolic::FormulaVar::HashAppendDetail
        struct /* HashAppendDetail */ {
          // Source: drake/common/symbolic_formula_cell.h:182
          const char* doc = R"""()""";
        } HashAppendDetail;
        // Symbol: drake::symbolic::FormulaVar::Less
        struct /* Less */ {
          // Source: drake/common/symbolic_formula_cell.h:185
          const char* doc = R"""()""";
        } Less;
        // Symbol: drake::symbolic::FormulaVar::Substitute
        struct /* Substitute */ {
          // Source: drake/common/symbolic_formula_cell.h:187
          const char* doc = R"""()""";
        } Substitute;
        // Symbol: drake::symbolic::FormulaVar::get_variable
        struct /* get_variable */ {
          // Source: drake/common/symbolic_formula_cell.h:189
          const char* doc = R"""()""";
        } get_variable;
      } FormulaVar;
      // Symbol: drake::symbolic::GenericPolynomial
      struct /* GenericPolynomial */ {
        // Source: drake/common/symbolic_generic_polynomial.h:35
        const char* doc =
R"""(Represents symbolic generic polynomials using a given basis (for
example, monomial basis, Chebyshev basis, etc). A generic symbolic
polynomial keeps a mapping from a basis element of indeterminates to
its coefficient in a symbolic expression. A generic polynomial ``p``
has to satisfy an invariant such that ``p.decision_variables() ∩
p.indeterminates() = ∅``. We have CheckInvariant() method to check the
invariant. For polynomials using different basis, you could refer to
section 3.1.5 of Semidefinite Optimization and Convex Algebraic
Geometry on the pros/cons of each basis.

We provide two instantiations of this template - BasisElement =
MonomialBasisElement - BasisElement = ChebyshevBasisElement

Template parameter ``BasisElement``:
    Must be a subclass of PolynomialBasisElement.)""";
        // Symbol: drake::symbolic::GenericPolynomial::AddProduct
        struct /* AddProduct */ {
          // Source: drake/common/symbolic_generic_polynomial.h:196
          const char* doc =
R"""(Adds ``coeff`` * ``m`` to this generic polynomial.)""";
        } AddProduct;
        // Symbol: drake::symbolic::GenericPolynomial::CoefficientsAlmostEqual
        struct /* CoefficientsAlmostEqual */ {
          // Source: drake/common/symbolic_generic_polynomial.h:244
          const char* doc =
R"""(Returns true if this polynomial and ``p`` are almost equal (the
difference in the corresponding coefficients are all less than
``tol)``, after expanding the coefficients.)""";
        } CoefficientsAlmostEqual;
        // Symbol: drake::symbolic::GenericPolynomial::Degree
        struct /* Degree */ {
          // Source: drake/common/symbolic_generic_polynomial.h:133
          const char* doc =
R"""(Returns the highest degree of this generic polynomial in an
indeterminate ``v``.)""";
        } Degree;
        // Symbol: drake::symbolic::GenericPolynomial::Differentiate
        struct /* Differentiate */ {
          // Source: drake/common/symbolic_generic_polynomial.h:146
          const char* doc =
R"""(Differentiates this generic polynomial with respect to the variable
``x``. Note that a variable ``x`` can be either a decision variable or
an indeterminate.)""";
        } Differentiate;
        // Symbol: drake::symbolic::GenericPolynomial::EqualTo
        struct /* EqualTo */ {
          // Source: drake/common/symbolic_generic_polynomial.h:233
          const char* doc =
R"""(Returns true if this and ``p`` are structurally equal.)""";
        } EqualTo;
        // Symbol: drake::symbolic::GenericPolynomial::EqualToAfterExpansion
        struct /* EqualToAfterExpansion */ {
          // Source: drake/common/symbolic_generic_polynomial.h:237
          const char* doc =
R"""(Returns true if this generic polynomial and ``p`` are equal after
expanding the coefficients.)""";
        } EqualToAfterExpansion;
        // Symbol: drake::symbolic::GenericPolynomial::Evaluate
        struct /* Evaluate */ {
          // Source: drake/common/symbolic_generic_polynomial.h:177
          const char* doc =
R"""(Evaluates this generic polynomial under a given environment ``env``.

Raises:
    ValueError if there is a variable in this generic polynomial whose
    assignment is not provided by ``env``.)""";
        } Evaluate;
        // Symbol: drake::symbolic::GenericPolynomial::EvaluatePartial
        struct /* EvaluatePartial */ {
          // Source: drake/common/symbolic_generic_polynomial.h:183
          const char* doc_1args =
R"""(Partially evaluates this generic polynomial using an environment
``env``.

Raises:
    RuntimeError if NaN is detected during evaluation.)""";
          // Source: drake/common/symbolic_generic_polynomial.h:192
          const char* doc_2args =
R"""(Partially evaluates this generic polynomial by substituting ``var``
with ``c``.

Raises:
    RuntimeError if NaN is detected at any point during evaluation.)""";
        } EvaluatePartial;
        // Symbol: drake::symbolic::GenericPolynomial::GenericPolynomial<BasisElement>
        struct /* ctor */ {
          // Source: drake/common/symbolic_generic_polynomial.h:44
          const char* doc_0args = R"""(Constructs a zero polynomial.)""";
          // Source: drake/common/symbolic_generic_polynomial.h:51
          const char* doc_1args_stdnullptrt =
R"""(Constructs a default value. This overload is used by Eigen when
EIGEN_INITIALIZE_MATRICES_BY_ZERO is enabled.)""";
          // Source: drake/common/symbolic_generic_polynomial.h:61
          const char* doc_1args_init =
R"""(Constructs a generic polynomial from a map, basis_element →
coefficient. For example


::

    {cc}
    GenericPolynomial<MonomialBasiElement>(
      {{MonomialBasisElement(x, 2), a}, {MonomialBasisElement(x, 3), a+b}})

constructs a polynomial ax²+(a+b)x³.)""";
          // Source: drake/common/symbolic_generic_polynomial.h:71
          const char* doc_1args_m =
R"""(Constructs a generic polynomial from a single basis element ``m``.

Note:
    that all variables in ``m`` are considered as indeterminates.
    Namely the constructed generic polynomial contains the map with a
    single key ``m``, with the coefficient being 1.)""";
          // Source: drake/common/symbolic_generic_polynomial.h:78
          const char* doc_1args_e =
R"""(Constructs a polynomial from an expression ``e``. Note that all
variables in ``e`` are considered as indeterminates.

Raises:
    RuntimeError if ``e`` is not a polynomial.)""";
          // Source: drake/common/symbolic_generic_polynomial.h:91
          const char* doc_2args_e_indeterminates =
R"""(Constructs a polynomial from an expression ``e`` by decomposing it
with respect to ``indeterminates``.

Note:
    The indeterminates for the polynomial are ``indeterminates``. Even
    if a variable in ``indeterminates`` does not show up in ``e``,
    that variable is still registered as an indeterminate in this
    polynomial, as this->indeterminates() be the same as
    ``indeterminates``.

Raises:
    RuntimeError if ``e`` is not a polynomial in ``indeterminates``.)""";
        } ctor;
        // Symbol: drake::symbolic::GenericPolynomial::Jacobian
        struct /* Jacobian */ {
          // Source: drake/common/symbolic_generic_polynomial.h:155
          const char* doc =
R"""(Computes the Jacobian matrix J of the generic polynomial with respect
to ``vars``. J(0,i) contains ∂f/∂vars(i). ``vars`` should be an Eigen
column vector of symbolic variables.)""";
        } Jacobian;
        // Symbol: drake::symbolic::GenericPolynomial::MapType
        struct /* MapType */ {
          // Source: drake/common/symbolic_generic_polynomial.h:41
          const char* doc =
R"""(Type of mapping from basis element to coefficient)""";
        } MapType;
        // Symbol: drake::symbolic::GenericPolynomial::RemoveTermsWithSmallCoefficients
        struct /* RemoveTermsWithSmallCoefficients */ {
          // Source: drake/common/symbolic_generic_polynomial.h:209
          const char* doc =
R"""(Removes the terms whose absolute value of the coefficients are smaller
than or equal to ``coefficient_tol``. For example, if the generic
polynomial is 2x² + 3xy + 10⁻⁴x - 10⁻⁵, then after calling
RemoveTermsWithSmallCoefficients(1e-3), the returned polynomial
becomes 2x² + 3xy.

Parameter ``coefficient_tol``:
    A positive scalar.

Returns ``polynomial_cleaned``:
    A generic polynomial whose terms with small coefficients are
    removed.)""";
        } RemoveTermsWithSmallCoefficients;
        // Symbol: drake::symbolic::GenericPolynomial::SetIndeterminates
        struct /* SetIndeterminates */ {
          // Source: drake/common/symbolic_generic_polynomial.h:124
          const char* doc =
R"""(Sets the indeterminates to ``new_indeterminates``.

Changing the indeterminates will change
``basis_element_to_coefficient_map()``, and also potentially the
degree of the polynomial. Here is an example.


::

    // p is a quadratic polynomial with x being the only indeterminate.
    symbolic::GenericPolynomial<MonomialBasisElement> p(a * x * x + b * x + c,
    {x});
    // p.basis_element_to_coefficient_map() contains {1: c, x: b, x*x:a}.
    std::cout << p.TotalDegree(); // prints 2.
    // Now set (a, b, c) to the indeterminates. p becomes a linear
    // polynomial of a, b, c.
    p.SetIndeterminates({a, b, c});
    // p.basis_element_to_coefficient_map() now is {a: x * x, b: x, c: 1}.
    std::cout << p.TotalDegree(); // prints 1.

This function can be expensive, as it potentially reconstructs the
polynomial (using the new indeterminates) from the expression.)""";
        } SetIndeterminates;
        // Symbol: drake::symbolic::GenericPolynomial::ToExpression
        struct /* ToExpression */ {
          // Source: drake/common/symbolic_generic_polynomial.h:139
          const char* doc =
R"""(Returns an equivalent symbolic expression of this generic polynomial.)""";
        } ToExpression;
        // Symbol: drake::symbolic::GenericPolynomial::TotalDegree
        struct /* TotalDegree */ {
          // Source: drake/common/symbolic_generic_polynomial.h:136
          const char* doc =
R"""(Returns the total degree of this generic polynomial.)""";
        } TotalDegree;
        // Symbol: drake::symbolic::GenericPolynomial::basis_element_to_coefficient_map
        struct /* basis_element_to_coefficient_map */ {
          // Source: drake/common/symbolic_generic_polynomial.h:127
          const char* doc =
R"""(Returns the map from each basis element to its coefficient.)""";
        } basis_element_to_coefficient_map;
        // Symbol: drake::symbolic::GenericPolynomial::decision_variables
        struct /* decision_variables */ {
          // Source: drake/common/symbolic_generic_polynomial.h:99
          const char* doc =
R"""(Returns the decision variables of this generic polynomial.)""";
        } decision_variables;
        // Symbol: drake::symbolic::GenericPolynomial::indeterminates
        struct /* indeterminates */ {
          // Source: drake/common/symbolic_generic_polynomial.h:94
          const char* doc =
R"""(Returns the indeterminates of this generic polynomial.)""";
        } indeterminates;
        // Symbol: drake::symbolic::GenericPolynomial::operator!=
        struct /* operator_ne */ {
          // Source: drake/common/symbolic_generic_polynomial.h:255
          const char* doc =
R"""(Returns a symbolic formula representing the condition where this
polynomial and ``p`` are not the same.)""";
        } operator_ne;
        // Symbol: drake::symbolic::GenericPolynomial::operator*=
        struct /* operator_imul */ {
          // Source: drake/common/symbolic_generic_polynomial.h:223
          const char* doc = R"""()""";
        } operator_imul;
        // Symbol: drake::symbolic::GenericPolynomial::operator+=
        struct /* operator_iadd */ {
          // Source: drake/common/symbolic_generic_polynomial.h:211
          const char* doc = R"""()""";
        } operator_iadd;
        // Symbol: drake::symbolic::GenericPolynomial::operator-=
        struct /* operator_isub */ {
          // Source: drake/common/symbolic_generic_polynomial.h:217
          const char* doc = R"""()""";
        } operator_isub;
        // Symbol: drake::symbolic::GenericPolynomial::operator/=
        struct /* operator_idiv */ {
          // Source: drake/common/symbolic_generic_polynomial.h:229
          const char* doc = R"""()""";
        } operator_idiv;
      } GenericPolynomial;
      // Symbol: drake::symbolic::GetDistinctVariables
      struct /* GetDistinctVariables */ {
        // Source: drake/common/symbolic_expression.h:1439
        const char* doc =
R"""(Returns the distinct variables in the matrix of expressions.)""";
      } GetDistinctVariables;
      // Symbol: drake::symbolic::GetVariableVector
      struct /* GetVariableVector */ {
        // Source: drake/common/symbolic_expression.h:1403
        const char* doc =
R"""(Constructs a vector of variables from the vector of variable
expressions.

Raises:
    RuntimeError if there is an expression in ``vec`` which is not a
    variable.)""";
      } GetVariableVector;
      // Symbol: drake::symbolic::GradedReverseLexOrder
      struct /* GradedReverseLexOrder */ {
        // Source: drake/common/symbolic_monomial_util.h:50
        const char* doc =
R"""(Implements Graded reverse lexicographic order.

Template parameter ``VariableOrder``:
    VariableOrder{}(v1, v2) is true if v1 < v2.

We first compare the total degree of the monomial; if there is a tie,
then we use the lexicographical order as the tie breaker, but a
monomial with higher order in lexicographical order is considered
lower order in graded reverse lexicographical order.

Take MonomialBasis({x, y, z}, 2) as an example, with the order x > y >
z. To get the graded reverse lexicographical order, we take the
following steps:

First find all the monomials using the total degree. The monomials
with degree 2 are {x^2, y^2, z^2, xy, xz, yz}. The monomials with
degree 1 are {x, y, z}, and the monomials with degree 0 is {1}. To
break the tie between monomials with the same total degree, first sort
them in the reverse lexicographical order, namely x < y < z in the
reverse lexicographical order. The lexicographical order compares two
monomial by first comparing the exponent of the largest variable, if
there is a tie then go forth to the second largest variable. Thus z^2
> zy >zx > y^2 > yx > x^2. Finally reverse the order as x^2 > xy > y^2
> xz > yz > z^2.

There is an introduction to monomial order in
https://en.wikipedia.org/wiki/Monomial_order, and an introduction to
graded reverse lexicographical order in
https://en.wikipedia.org/wiki/Monomial_order#Graded_reverse_lexicographic_order)""";
        // Symbol: drake::symbolic::GradedReverseLexOrder::operator()
        struct /* operator_call */ {
          // Source: drake/common/symbolic_monomial_util.h:52
          const char* doc =
R"""(Returns true if m1 > m2 under the Graded reverse lexicographic order.)""";
        } operator_call;
      } GradedReverseLexOrder;
      // Symbol: drake::symbolic::IsAffine
      struct /* IsAffine */ {
        // Source: drake/common/symbolic_expression.h:1431
        const char* doc_2args =
R"""(Checks if every element in ``m`` is affine in ``vars``.

Note:
    If ``m`` is an empty matrix, it returns true.)""";
        // Source: drake/common/symbolic_expression.h:1436
        const char* doc_1args =
R"""(Checks if every element in ``m`` is affine.

Note:
    If ``m`` is an empty matrix, it returns true.)""";
      } IsAffine;
      // Symbol: drake::symbolic::Jacobian
      struct /* Jacobian */ {
        // Source: drake/common/symbolic_expression.h:1418
        const char* doc =
R"""(Computes the Jacobian matrix J of the vector function ``f`` with
respect to ``vars``. J(i,j) contains ∂f(i)/∂vars(j).

For example, Jacobian([x * cos(y), x * sin(y), x^2], {x, y}) returns
the following 3x2 matrix:


::

    = |cos(y)   -x * sin(y)|
       |sin(y)    x * cos(y)|
       | 2 * x             0|

Precondition:
    {``vars`` is non-empty}.)""";
        // Source: drake/common/symbolic_expression.h:1426
        const char* doc_expression =
R"""(Computes the Jacobian matrix J of the vector function ``f`` with
respect to ``vars``. J(i,j) contains ∂f(i)/∂vars(j).

Precondition:
    {``vars`` is non-empty}.)""";
        // Source: drake/common/symbolic_polynomial.h:481
        const char* doc_polynomial =
R"""(Computes the Jacobian matrix J of the vector function ``f`` with
respect to ``vars``. J(i,j) contains ∂f(i)/∂vars(j).

Precondition:
    {``vars`` is non-empty}.)""";
      } Jacobian;
      // Symbol: drake::symbolic::MakeMatrixBinaryVariable
      struct /* MakeMatrixBinaryVariable */ {
        // Source: drake/common/symbolic_variable.h:142
        const char* doc_3args =
R"""(Creates a dynamically-sized Eigen matrix of symbolic binary variables.

Parameter ``rows``:
    The number of rows in the new matrix.

Parameter ``cols``:
    The number of cols in the new matrix.

Parameter ``name``:
    The common prefix for variables. The (i, j)-th element will be
    named as ``name(i, j)``.)""";
        // Source: drake/common/symbolic_variable.h:198
        const char* doc_1args =
R"""(Creates a static-sized Eigen matrix of symbolic binary variables.

Template parameter ``rows``:
    The number of rows in the new matrix.

Template parameter ``cols``:
    The number of cols in the new matrix.

Parameter ``name``:
    The common prefix for variables. The (i, j)-th element will be
    named as ``name(i, j)``.)""";
      } MakeMatrixBinaryVariable;
      // Symbol: drake::symbolic::MakeMatrixBooleanVariable
      struct /* MakeMatrixBooleanVariable */ {
        // Source: drake/common/symbolic_variable.h:134
        const char* doc_3args =
R"""(Creates a dynamically-sized Eigen matrix of symbolic Boolean
variables.

Parameter ``rows``:
    The number of rows in the new matrix.

Parameter ``cols``:
    The number of cols in the new matrix.

Parameter ``name``:
    The common prefix for variables. The (i, j)-th element will be
    named as ``name(i, j)``.)""";
        // Source: drake/common/symbolic_variable.h:187
        const char* doc_1args =
R"""(Creates a static-sized Eigen matrix of symbolic Boolean variables.

Template parameter ``rows``:
    The number of rows in the new matrix.

Template parameter ``cols``:
    The number of cols in the new matrix.

Parameter ``name``:
    The common prefix for variables. The (i, j)-th element will be
    named as ``name(i, j)``.)""";
      } MakeMatrixBooleanVariable;
      // Symbol: drake::symbolic::MakeMatrixContinuousVariable
      struct /* MakeMatrixContinuousVariable */ {
        // Source: drake/common/symbolic_variable.h:150
        const char* doc_3args =
R"""(Creates a dynamically-sized Eigen matrix of symbolic continuous
variables.

Parameter ``rows``:
    The number of rows in the new matrix.

Parameter ``cols``:
    The number of cols in the new matrix.

Parameter ``name``:
    The common prefix for variables. The (i, j)-th element will be
    named as ``name(i, j)``.)""";
        // Source: drake/common/symbolic_variable.h:209
        const char* doc_1args =
R"""(Creates a static-sized Eigen matrix of symbolic continuous variables.

Template parameter ``rows``:
    The number of rows in the new matrix.

Template parameter ``cols``:
    The number of cols in the new matrix.

Parameter ``name``:
    The common prefix for variables. The (i, j)-th element will be
    named as ``name(i, j)``.)""";
      } MakeMatrixContinuousVariable;
      // Symbol: drake::symbolic::MakeMatrixIntegerVariable
      struct /* MakeMatrixIntegerVariable */ {
        // Source: drake/common/symbolic_variable.h:158
        const char* doc_3args =
R"""(Creates a dynamically-sized Eigen matrix of symbolic integer
variables.

Parameter ``rows``:
    The number of rows in the new matrix.

Parameter ``cols``:
    The number of cols in the new matrix.

Parameter ``name``:
    The common prefix for variables. The (i, j)-th element will be
    named as ``name(i, j)``.)""";
        // Source: drake/common/symbolic_variable.h:220
        const char* doc_1args =
R"""(Creates a static-sized Eigen matrix of symbolic integer variables.

Template parameter ``rows``:
    The number of rows in the new matrix.

Template parameter ``cols``:
    The number of cols in the new matrix.

Parameter ``name``:
    The common prefix for variables. The (i, j)-th element will be
    named as ``name(i, j)``.)""";
      } MakeMatrixIntegerVariable;
      // Symbol: drake::symbolic::MakeMatrixVariable
      struct /* MakeMatrixVariable */ {
        // Source: drake/common/symbolic_variable.h:125
        const char* doc_4args =
R"""(Creates a dynamically-sized Eigen matrix of symbolic variables.

Parameter ``rows``:
    The number of rows in the new matrix.

Parameter ``cols``:
    The number of cols in the new matrix.

Parameter ``name``:
    The common prefix for variables. The (i, j)-th element will be
    named as ``name(i, j)``.

Parameter ``type``:
    The type of variables in the matrix.)""";
        // Source: drake/common/symbolic_variable.h:168
        const char* doc_2args =
R"""(Creates a static-sized Eigen matrix of symbolic variables.

Template parameter ``rows``:
    The number of rows in the new matrix.

Template parameter ``cols``:
    The number of cols in the new matrix.

Parameter ``name``:
    The common prefix for variables. The (i, j)-th element will be
    named as ``name(i, j)``.

Parameter ``type``:
    The type of variables in the matrix.)""";
      } MakeMatrixVariable;
      // Symbol: drake::symbolic::MakeRuleRewriter
      struct /* MakeRuleRewriter */ {
        // Source: drake/common/symbolic_simplification.h:55
        const char* doc =
R"""(Constructs a rewriter based on a rewriting rule ``r``.)""";
      } MakeRuleRewriter;
      // Symbol: drake::symbolic::MakeVectorBinaryVariable
      struct /* MakeVectorBinaryVariable */ {
        // Source: drake/common/symbolic_variable.h:244
        const char* doc_2args =
R"""(Creates a dynamically-sized Eigen vector of symbolic binary variables.

Parameter ``rows``:
    The size of vector.

Parameter ``name``:
    The common prefix for variables. The i-th element will be named as
    ``name(i)``.)""";
        // Source: drake/common/symbolic_variable.h:289
        const char* doc_1args =
R"""(Creates a static-sized Eigen vector of symbolic binary variables.

Template parameter ``rows``:
    The size of vector.

Parameter ``name``:
    The common prefix for variables. The i-th element will be named as
    ``name(i)``.)""";
      } MakeVectorBinaryVariable;
      // Symbol: drake::symbolic::MakeVectorBooleanVariable
      struct /* MakeVectorBooleanVariable */ {
        // Source: drake/common/symbolic_variable.h:238
        const char* doc_2args =
R"""(Creates a dynamically-sized Eigen vector of symbolic Boolean
variables.

Parameter ``rows``:
    The size of vector.

Parameter ``name``:
    The common prefix for variables. The i-th element will be named as
    ``name(i)``.)""";
        // Source: drake/common/symbolic_variable.h:279
        const char* doc_1args =
R"""(Creates a static-sized Eigen vector of symbolic Boolean variables.

Template parameter ``rows``:
    The size of vector.

Parameter ``name``:
    The common prefix for variables. The i-th element will be named as
    ``name(i)``.)""";
      } MakeVectorBooleanVariable;
      // Symbol: drake::symbolic::MakeVectorContinuousVariable
      struct /* MakeVectorContinuousVariable */ {
        // Source: drake/common/symbolic_variable.h:250
        const char* doc_2args =
R"""(Creates a dynamically-sized Eigen vector of symbolic continuous
variables.

Parameter ``rows``:
    The size of vector.

Parameter ``name``:
    The common prefix for variables. The i-th element will be named as
    ``name(i)``.)""";
        // Source: drake/common/symbolic_variable.h:299
        const char* doc_1args =
R"""(Creates a static-sized Eigen vector of symbolic continuous variables.

Template parameter ``rows``:
    The size of vector.

Parameter ``name``:
    The common prefix for variables. The i-th element will be named as
    ``name(i)``.)""";
      } MakeVectorContinuousVariable;
      // Symbol: drake::symbolic::MakeVectorIntegerVariable
      struct /* MakeVectorIntegerVariable */ {
        // Source: drake/common/symbolic_variable.h:257
        const char* doc_2args =
R"""(Creates a dynamically-sized Eigen vector of symbolic integer
variables.

Parameter ``rows``:
    The size of vector.

Parameter ``name``:
    The common prefix for variables. The i-th element will be named as
    ``name(i)``.)""";
        // Source: drake/common/symbolic_variable.h:309
        const char* doc_1args =
R"""(Creates a static-sized Eigen vector of symbolic integer variables.

Template parameter ``rows``:
    The size of vector.

Parameter ``name``:
    The common prefix for variables. The i-th element will be named as
    ``name(i)``.)""";
      } MakeVectorIntegerVariable;
      // Symbol: drake::symbolic::MakeVectorVariable
      struct /* MakeVectorVariable */ {
        // Source: drake/common/symbolic_variable.h:230
        const char* doc_3args =
R"""(Creates a dynamically-sized Eigen vector of symbolic variables.

Parameter ``rows``:
    The size of vector.

Parameter ``name``:
    The common prefix for variables. The i-th element will be named as
    ``name(i)``.

Parameter ``type``:
    The type of variables in the vector.)""";
        // Source: drake/common/symbolic_variable.h:265
        const char* doc_2args =
R"""(Creates a static-sized Eigen vector of symbolic variables.

Template parameter ``rows``:
    The size of vector.

Parameter ``name``:
    The common prefix for variables. The i-th element will be named as
    ``name(i)``.

Parameter ``type``:
    The type of variables in the vector.)""";
      } MakeVectorVariable;
      // Symbol: drake::symbolic::Monomial
      struct /* Monomial */ {
        // Source: drake/common/symbolic_monomial.h:26
        const char* doc =
R"""(Represents a monomial, a product of powers of variables with
non-negative integer exponents. Note that it does not include the
coefficient part of a monomial.)""";
        // Symbol: drake::symbolic::Monomial::Evaluate
        struct /* Evaluate */ {
          // Source: drake/common/symbolic_monomial.h:84
          const char* doc =
R"""(Evaluates under a given environment ``env``.

Raises:
    ValueError exception if there is a variable in this monomial whose
    assignment is not provided by ``env``.)""";
        } Evaluate;
        // Symbol: drake::symbolic::Monomial::EvaluatePartial
        struct /* EvaluatePartial */ {
          // Source: drake/common/symbolic_monomial.h:99
          const char* doc =
R"""(Partially evaluates using a given environment ``env``. The evaluation
result is of type pair<double, Monomial>. The first component (:
double) represents the coefficient part while the second component
represents the remaining parts of the Monomial which was not
evaluated.

Example 1. Evaluate with a fully-specified environment
(x³*y²).EvaluatePartial({{x, 2}, {y, 3}}) = (2³ * 3² = 8 * 9 = 72,
Monomial{} = 1).

Example 2. Evaluate with a partial environment
(x³*y²).EvaluatePartial({{x, 2}}) = (2³ = 8, y²).)""";
        } EvaluatePartial;
        // Symbol: drake::symbolic::Monomial::GetVariables
        struct /* GetVariables */ {
          // Source: drake/common/symbolic_monomial.h:73
          const char* doc =
R"""(Returns the set of variables in this monomial.)""";
        } GetVariables;
        // Symbol: drake::symbolic::Monomial::Monomial
        struct /* ctor */ {
          // Source: drake/common/symbolic_monomial.h:31
          const char* doc_0args =
R"""(Constructs a monomial equal to 1. Namely the total degree is zero.)""";
          // Source: drake/common/symbolic_monomial.h:36
          const char* doc_1args_stdnullptrt =
R"""(Constructs a default value. This overload is used by Eigen when
EIGEN_INITIALIZE_MATRICES_BY_ZERO is enabled.)""";
          // Source: drake/common/symbolic_monomial.h:41
          const char* doc_1args_powers =
R"""(Constructs a Monomial from ``powers``.

Raises:
    RuntimeError if ``powers`` includes a negative exponent.)""";
          // Source: drake/common/symbolic_monomial.h:50
          const char* doc_2args_vars_exponents =
R"""(Constructs a Monomial from a vector of variables ``vars`` and their
corresponding integer exponents ``exponents``. For example,
``Monomial([x, y, z], [2, 0, 1])`` constructs a Monomial ``x²z``.

Precondition:
    The size of ``vars`` should be the same as the size of
    ``exponents``.

Raises:
    RuntimeError if ``exponents`` includes a negative integer.)""";
          // Source: drake/common/symbolic_monomial.h:58
          const char* doc_1args_e =
R"""(Converts an expression to a monomial if the expression is written as
∏ᵢpow(xᵢ, kᵢ), otherwise throws a runtime error.

Precondition:
    is_polynomial(e) should be true.)""";
          // Source: drake/common/symbolic_monomial.h:61
          const char* doc_1args_var = R"""(Constructs a Monomial from ``var``.)""";
          // Source: drake/common/symbolic_monomial.h:64
          const char* doc_2args_var_exponent =
R"""(Constructs a Monomial from ``var`` and ``exponent``.)""";
        } ctor;
        // Symbol: drake::symbolic::Monomial::ToExpression
        struct /* ToExpression */ {
          // Source: drake/common/symbolic_monomial.h:102
          const char* doc =
R"""(Returns a symbolic expression representing this monomial.)""";
        } ToExpression;
        // Symbol: drake::symbolic::Monomial::degree
        struct /* degree */ {
          // Source: drake/common/symbolic_monomial.h:67
          const char* doc =
R"""(Returns the degree of this Monomial in a variable ``v``.)""";
        } degree;
        // Symbol: drake::symbolic::Monomial::get_powers
        struct /* get_powers */ {
          // Source: drake/common/symbolic_monomial.h:77
          const char* doc =
R"""(Returns the internal representation of Monomial, the map from a base
(Variable) to its exponent (int).)""";
        } get_powers;
        // Symbol: drake::symbolic::Monomial::operator!=
        struct /* operator_ne */ {
          // Source: drake/common/symbolic_monomial.h:110
          const char* doc =
R"""(Checks if this monomial and ``m`` do not represent the same monomial.)""";
        } operator_ne;
        // Symbol: drake::symbolic::Monomial::operator*=
        struct /* operator_imul */ {
          // Source: drake/common/symbolic_monomial.h:113
          const char* doc =
R"""(Returns this monomial multiplied by ``m``.)""";
        } operator_imul;
        // Symbol: drake::symbolic::Monomial::pow_in_place
        struct /* pow_in_place */ {
          // Source: drake/common/symbolic_monomial.h:118
          const char* doc =
R"""(Returns this monomial raised to ``p``.

Raises:
    RuntimeError if ``p`` is negative.)""";
        } pow_in_place;
        // Symbol: drake::symbolic::Monomial::total_degree
        struct /* total_degree */ {
          // Source: drake/common/symbolic_monomial.h:70
          const char* doc =
R"""(Returns the total degree of this Monomial.)""";
        } total_degree;
      } Monomial;
      // Symbol: drake::symbolic::MonomialBasis
      struct /* MonomialBasis */ {
        // Source: drake/common/symbolic_monomial_util.h:190
        const char* doc_2args =
R"""(Returns all monomials up to a given degree under the graded reverse
lexicographic order. Note that graded reverse lexicographic order uses
the total order among Variable which is based on a variable's unique
ID. For example, for a given variable ordering x > y > z,
``MonomialBasis({x, y, z}, 2)`` returns a column vector ``[x^2, xy,
y^2, xz, yz, z^2, x, y, z, 1]``.

Precondition:
    ``vars`` is a non-empty set.

Precondition:
    ``degree`` is a non-negative integer.)""";
        // Source: drake/common/symbolic_monomial_util.h:210
        const char* doc_1args =
R"""(Returns all monomials up to a given degree under the graded reverse
lexicographic order.

Template parameter ``n``:
    number of variables.

Template parameter ``degree``:
    maximum total degree of monomials to compute.

Precondition:
    ``vars`` is a non-empty set.

Precondition:
    vars.size() == ``n``.)""";
      } MonomialBasis;
      // Symbol: drake::symbolic::MonomialBasisElement
      struct /* MonomialBasisElement */ {
        // Source: drake/common/symbolic_monomial_basis_element.h:28
        const char* doc =
R"""(MonomialBasisElement represents a monomial, a product of powers of
variables with non-negative integer exponents. Note that it doesn't
not include the coefficient part of a monomial. So x, x³y, xy²z are
all valid MonomialBasisElement instances, but 1+x or 2xy²z are not.
TODO(hongkai.dai): deprecate Monomial class and replace Monomial class
with MonomialBasisElement class. For more information regarding the
motivation of this class, please see Drake github issue #13602 and
#13803.)""";
        // Symbol: drake::symbolic::MonomialBasisElement::Differentiate
        struct /* Differentiate */ {
          // Source: drake/common/symbolic_monomial_basis_element.h:111
          const char* doc =
R"""(Differentiates this MonomialBasisElement. Since dxⁿ/dx = nxⁿ⁻¹, we
return the map from the MonomialBasisElement to its coefficient. So if
this MonomialBasisElement is x³y², then differentiate with x will
return (x²y² → 3) as dx³y²/dx = 3x²y² If ``var`` is not a variable in
MonomialBasisElement, then returns an empty map.)""";
        } Differentiate;
        // Symbol: drake::symbolic::MonomialBasisElement::EvaluatePartial
        struct /* EvaluatePartial */ {
          // Source: drake/common/symbolic_monomial_basis_element.h:90
          const char* doc =
R"""(Partially evaluates using a given environment ``env``. The evaluation
result is of type pair<double, MonomialBasisElement>. The first
component (: double) represents the coefficient part while the second
component represents the remaining parts of the MonomialBasisElement
which was not evaluated.

Example 1. Evaluate with a fully-specified environment
(x³*y²).EvaluatePartial({{x, 2}, {y, 3}}) = (2³ * 3² = 8 * 9 = 72,
MonomialBasisElement{} = 1).

Example 2. Evaluate with a partial environment
(x³*y²).EvaluatePartial({{x, 2}}) = (2³ = 8, y²).)""";
        } EvaluatePartial;
        // Symbol: drake::symbolic::MonomialBasisElement::Integrate
        struct /* Integrate */ {
          // Source: drake/common/symbolic_monomial_basis_element.h:122
          const char* doc =
R"""(Integrates this MonomialBasisElement on a variable. Since ∫ xⁿ dx = 1
/ (n+1) xⁿ⁺¹, we return the map from the MonomialBasisElement to its
coefficient in the integration result. So if this MonomialBasisElement
is x³y², then we return (x⁴y² → 1/4) as ∫ x³y²dx = 1/4 x⁴y². If
``var`` is not a variable in this MonomialBasisElement, for example ∫
x³y²dz = x³y²z, then we return (x³y²z → 1))""";
        } Integrate;
        // Symbol: drake::symbolic::MonomialBasisElement::MergeBasisElementInPlace
        struct /* MergeBasisElementInPlace */ {
          // Source: drake/common/symbolic_monomial_basis_element.h:129
          const char* doc =
R"""(Merges this basis element with another basis element ``other`` by
merging their var_to_degree_map. This is equivalent to multiplying
this monomial basis element in place with monomial basis element
``other``.)""";
        } MergeBasisElementInPlace;
        // Symbol: drake::symbolic::MonomialBasisElement::MonomialBasisElement
        struct /* ctor */ {
          // Source: drake/common/symbolic_monomial_basis_element.h:33
          const char* doc_0args =
R"""(Constructs a monomial equal to 1. Namely the toal degree is zero.)""";
          // Source: drake/common/symbolic_monomial_basis_element.h:38
          const char* doc_1args_stdnullptrt =
R"""(Constructs a default value. This overload is used by Eigen when
EIGEN_INITIALIZE_MATRICES_BY_ZERO is enabled.)""";
          // Source: drake/common/symbolic_monomial_basis_element.h:43
          const char* doc_1args_var_to_degree_map =
R"""(Constructs a MonomialBasisElement from variable to degree map.)""";
          // Source: drake/common/symbolic_monomial_basis_element.h:51
          const char* doc_1args_e =
R"""(Converts an expression to a monomial if the expression is written as
∏ᵢpow(xᵢ, kᵢ), otherwise throws a runtime error.

Precondition:
    is_polynomial(e) should be true.)""";
          // Source: drake/common/symbolic_monomial_basis_element.h:61
          const char* doc_2args_vars_degrees =
R"""(Constructs a Monomial from a vector of variables ``vars`` and their
corresponding integer degrees ``degrees``. For example,
``MonomialBasisElement([x, y, z], [2, 0, 1])`` constructs a
MonomialBasisElement ``x²z``.

Precondition:
    The size of ``vars`` should be the same as the size of
    ``degrees``.

Raises:
    RuntimeError if ``degrees`` includes a negative integer.)""";
          // Source: drake/common/symbolic_monomial_basis_element.h:68
          const char* doc_1args_var =
R"""(Constructs a monomial basis element with only one variable, and the
degree is 1.)""";
          // Source: drake/common/symbolic_monomial_basis_element.h:74
          const char* doc_2args_var_degree =
R"""(Constructs a monomial basis element with only one variable, and the
degree of that variable is given by ``degree``.)""";
        } ctor;
        // Symbol: drake::symbolic::MonomialBasisElement::ToBasis
        struct /* ToBasis */ {
          // Source: drake/common/symbolic_monomial_basis_element.h:167
          const char* doc =
R"""(Converts this monomial to a weighted sum of basis elements of type
BasisElement. We return the map from each BasisElement to its
coefficient. For example, if BasisElement=ChebyshevBasisElement, then
when this = x²y³, it returns {[T₂(x)T₃(y)⇒1/8], [T₂(x)T₁(y)⇒3/8],
[T₀(x)T₃(y)⇒1/8], [T₀(x)T₁(y)⇒3/8]}.

Note:
    Currently we only support

Template parameter ``BasisElement``:
    being MonomialBasisElement and ChebyshevBasisElement.)""";
        } ToBasis;
        // Symbol: drake::symbolic::MonomialBasisElement::ToChebyshevBasis
        struct /* ToChebyshevBasis */ {
          // Source: drake/common/symbolic_monomial_basis_element.h:154
          const char* doc =
R"""(Converts this monomial to Chebyshev polynomial basis. For example,

- For x², it returns 0.5T₂(x) + 0.5T₀(x). - For x²y³, it returns
1/8T₂(x)T₃(y) + 3/8T₂(x)T₁(y) + 1/8T₀(x)T₃(y) + 3/8T₀(x)T₁(y).

We return the map from each ChebyshevBasisElement to its coefficient.
For example, when this = x², it returns {[T₂(x)⇒0.5], [T₀(x)⇒0.5]}.
When this = x²y³, it returns {[T₂(x)T₃(y)⇒1/8], [T₂(x)T₁(y)⇒3/8],
[T₀(x)T₃(y)⇒1/8], [T₀(x)T₁(y)⇒3/8]}.)""";
        } ToChebyshevBasis;
        // Symbol: drake::symbolic::MonomialBasisElement::operator<
        struct /* operator_lt */ {
          // Source: drake/common/symbolic_monomial_basis_element.h:101
          const char* doc =
R"""(Compares two MonomialBasisElement in lexicographic order.)""";
        } operator_lt;
        // Symbol: drake::symbolic::MonomialBasisElement::pow_in_place
        struct /* pow_in_place */ {
          // Source: drake/common/symbolic_monomial_basis_element.h:96
          const char* doc =
R"""(Returns this monomial raised to ``p``.

Raises:
    RuntimeError if ``p`` is negative.)""";
        } pow_in_place;
      } MonomialBasisElement;
      // Symbol: drake::symbolic::NChooseK
      struct /* NChooseK */ {
        // Source: drake/common/symbolic_monomial_util.h:196
        const char* doc = R"""()""";
      } NChooseK;
      // Symbol: drake::symbolic::NaryFormulaCell
      struct /* NaryFormulaCell */ {
        // Source: drake/common/symbolic_formula_cell.h:117
        const char* doc =
R"""(Represents the base class for N-ary logic operators (∧ and ∨).

Note:
    Internally this class maintains a set of symbolic formulas to
    avoid duplicated elements (i.e. f1 ∧ ... ∧ f1).)""";
        // Symbol: drake::symbolic::NaryFormulaCell::DisplayWithOp
        struct /* DisplayWithOp */ {
          // Source: drake/common/symbolic_formula_cell.h:141
          const char* doc = R"""()""";
        } DisplayWithOp;
        // Symbol: drake::symbolic::NaryFormulaCell::EqualTo
        struct /* EqualTo */ {
          // Source: drake/common/symbolic_formula_cell.h:133
          const char* doc = R"""()""";
        } EqualTo;
        // Symbol: drake::symbolic::NaryFormulaCell::GetFreeVariables
        struct /* GetFreeVariables */ {
          // Source: drake/common/symbolic_formula_cell.h:132
          const char* doc = R"""()""";
        } GetFreeVariables;
        // Symbol: drake::symbolic::NaryFormulaCell::HashAppendDetail
        struct /* HashAppendDetail */ {
          // Source: drake/common/symbolic_formula_cell.h:131
          const char* doc = R"""()""";
        } HashAppendDetail;
        // Symbol: drake::symbolic::NaryFormulaCell::Less
        struct /* Less */ {
          // Source: drake/common/symbolic_formula_cell.h:134
          const char* doc = R"""()""";
        } Less;
        // Symbol: drake::symbolic::NaryFormulaCell::NaryFormulaCell
        struct /* ctor */ {
          // Source: drake/common/symbolic_formula_cell.h:120
          const char* doc_0args = R"""(Default constructor (deleted).)""";
          // Source: drake/common/symbolic_formula_cell.h:122
          const char* doc_move =
R"""(Move-construct a formula from an rvalue.)""";
          // Source: drake/common/symbolic_formula_cell.h:124
          const char* doc_copy =
R"""(Copy-construct a formula from an lvalue.)""";
          // Source: drake/common/symbolic_formula_cell.h:130
          const char* doc_2args =
R"""(Construct NaryFormulaCell of kind ``k`` with ``formulas``.)""";
        } ctor;
        // Symbol: drake::symbolic::NaryFormulaCell::get_operands
        struct /* get_operands */ {
          // Source: drake/common/symbolic_formula_cell.h:136
          const char* doc = R"""(Returns the formulas.)""";
        } get_operands;
      } NaryFormulaCell;
      // Symbol: drake::symbolic::OddDegreeMonomialBasis
      struct /* OddDegreeMonomialBasis */ {
        // Source: drake/common/symbolic_monomial_util.h:245
        const char* doc =
R"""(Returns all odd degree monomials up to a given degree under the graded
reverse lexicographic order. A monomial has an odd degree if its total
degree is odd. So x²y is an odd degree monomial (degree 3) while xy is
not (degree 2). Note that graded reverse lexicographic order uses the
total order among Variable which is based on a variable's unique ID.
For example, for a given variable ordering x > y > z,
``OddDegreeMonomialBasis({x, y, z}, 3)`` returns a column vector
``[x³, x²y, xy², y³, x²z, xyz, y²z, xz², yz², z³, x, y, z]``

Precondition:
    ``vars`` is a non-empty set.

Precondition:
    ``degree`` is a non-negative integer.)""";
      } OddDegreeMonomialBasis;
      // Symbol: drake::symbolic::Pattern
      struct /* Pattern */ {
        // Source: drake/common/symbolic_simplification.h:13
        const char* doc =
R"""(A pattern is an expression which possibly includes variables which
represent placeholders. It is used to construct a ``RewritingRule``.)""";
      } Pattern;
      // Symbol: drake::symbolic::Polynomial
      struct /* Polynomial */ {
        // Source: drake/common/symbolic_polynomial.h:70
        const char* doc = R"""()""";
        // Symbol: drake::symbolic::Polynomial::AddProduct
        struct /* AddProduct */ {
          // Source: drake/common/symbolic_polynomial.h:187
          const char* doc =
R"""(Adds ``coeff`` * ``m`` to this polynomial.)""";
        } AddProduct;
        // Symbol: drake::symbolic::Polynomial::CoefficientsAlmostEqual
        struct /* CoefficientsAlmostEqual */ {
          // Source: drake/common/symbolic_polynomial.h:224
          const char* doc =
R"""(Returns true if this polynomial and ``are`` almost equal (the
difference in the corresponding coefficients are all less than
``tol)``, after expanding the coefficients.)""";
        } CoefficientsAlmostEqual;
        // Symbol: drake::symbolic::Polynomial::Degree
        struct /* Degree */ {
          // Source: drake/common/symbolic_polynomial.h:135
          const char* doc =
R"""(Returns the highest degree of this polynomial in a variable ``v``.)""";
        } Degree;
        // Symbol: drake::symbolic::Polynomial::Differentiate
        struct /* Differentiate */ {
          // Source: drake/common/symbolic_polynomial.h:150
          const char* doc =
R"""(Differentiates this polynomial with respect to the variable ``x``.
Note that a variable ``x`` can be either a decision variable or an
indeterminate.)""";
        } Differentiate;
        // Symbol: drake::symbolic::Polynomial::EqualTo
        struct /* EqualTo */ {
          // Source: drake/common/symbolic_polynomial.h:215
          const char* doc =
R"""(Returns true if this polynomial and ``p`` are structurally equal.)""";
        } EqualTo;
        // Symbol: drake::symbolic::Polynomial::EqualToAfterExpansion
        struct /* EqualToAfterExpansion */ {
          // Source: drake/common/symbolic_polynomial.h:219
          const char* doc =
R"""(Returns true if this polynomial and ``p`` are equal, after expanding
the coefficients.)""";
        } EqualToAfterExpansion;
        // Symbol: drake::symbolic::Polynomial::Evaluate
        struct /* Evaluate */ {
          // Source: drake/common/symbolic_polynomial.h:173
          const char* doc =
R"""(Evaluates this polynomial under a given environment ``env``.

Raises:
    ValueError if there is a variable in this polynomial whose
    assignment is not provided by ``env``.)""";
        } Evaluate;
        // Symbol: drake::symbolic::Polynomial::EvaluatePartial
        struct /* EvaluatePartial */ {
          // Source: drake/common/symbolic_polynomial.h:178
          const char* doc_1args =
R"""(Partially evaluates this polynomial using an environment ``env``.

Raises:
    RuntimeError if NaN is detected during evaluation.)""";
          // Source: drake/common/symbolic_polynomial.h:184
          const char* doc_2args =
R"""(Partially evaluates this polynomial by substituting ``var`` with
``c``.

Raises:
    RuntimeError if NaN is detected at any point during evaluation.)""";
        } EvaluatePartial;
        // Symbol: drake::symbolic::Polynomial::Jacobian
        struct /* Jacobian */ {
          // Source: drake/common/symbolic_polynomial.h:155
          const char* doc =
R"""(Computes the Jacobian matrix J of the polynomial with respect to
``vars``. J(0,i) contains ∂f/∂vars(i).)""";
        } Jacobian;
        // Symbol: drake::symbolic::Polynomial::MapType
        struct /* MapType */ {
          // Source: drake/common/symbolic_polynomial.h:72
          const char* doc = R"""()""";
        } MapType;
        // Symbol: drake::symbolic::Polynomial::Polynomial
        struct /* ctor */ {
          // Source: drake/common/symbolic_polynomial.h:75
          const char* doc_0args = R"""(Constructs a zero polynomial.)""";
          // Source: drake/common/symbolic_polynomial.h:81
          const char* doc_1args_stdnullptrt =
R"""(Constructs a default value. This overload is used by Eigen when
EIGEN_INITIALIZE_MATRICES_BY_ZERO is enabled.)""";
          // Source: drake/common/symbolic_polynomial.h:84
          const char* doc_1args_init =
R"""(Constructs a polynomial from a map, Monomial → Expression.)""";
          // Source: drake/common/symbolic_polynomial.h:92
          const char* doc_1args_m =
R"""(Constructs a polynomial from a monomial ``m``. Note that all variables
in ``m`` are considered as indeterminates.)""";
          // Source: drake/common/symbolic_polynomial.h:98
          const char* doc_1args_e =
R"""(Constructs a polynomial from an expression ``e``. Note that all
variables in ``e`` are considered as indeterminates.

Raises:
    RuntimeError if ``e`` is not a polynomial.)""";
          // Source: drake/common/symbolic_polynomial.h:108
          const char* doc_2args_e_indeterminates =
R"""(Constructs a polynomial from an expression ``e`` by decomposing it
with respect to ``indeterminates``.

Note:
    It collects the intersection of the variables appeared in ``e``
    and the provided ``indeterminates``.

Raises:
    RuntimeError if ``e`` is not a polynomial in ``indeterminates``.)""";
        } ctor;
        // Symbol: drake::symbolic::Polynomial::RemoveTermsWithSmallCoefficients
        struct /* RemoveTermsWithSmallCoefficients */ {
          // Source: drake/common/symbolic_polynomial.h:197
          const char* doc =
R"""(Removes the terms whose absolute value of the coefficients are smaller
than or equal to ``coefficient_tol`` For example, if the polynomial is
2x² + 3xy + 10⁻⁴x - 10⁻⁵, then after calling
RemoveTermsWithSmallCoefficients(1e-3), the returned polynomial
becomes 2x² + 3xy.

Parameter ``coefficient_tol``:
    A positive scalar.

Returns ``polynomial_cleaned``:
    A polynomial whose terms with small coefficients are removed.)""";
        } RemoveTermsWithSmallCoefficients;
        // Symbol: drake::symbolic::Polynomial::SetIndeterminates
        struct /* SetIndeterminates */ {
          // Source: drake/common/symbolic_polynomial.h:132
          const char* doc =
R"""(Sets the indeterminates to ``new_indeterminates``.

Changing the indeterminates would change
``monomial_to_coefficient_map()``, and also potentially the degree of
the polynomial. Here is an example.


::

    // p is a quadratic polynomial with x being the indeterminates.
    symbolic::Polynomial p(a * x * x + b * x + c, {x});
    // p.monomial_to_coefficient_map() contains {1: c, x: b, x*x:a}.
    std::cout << p.TotalDegree(); // prints 2.
    // Now set (a, b, c) to the indeterminates. p becomes a linear
    // polynomial of a, b, c.
    p.SetIndeterminates({a, b, c});
    // p.monomial_to_coefficient_map() now is {a: x * x, b: x, c: 1}.
    std::cout << p.TotalDegree(); // prints 1.)""";
        } SetIndeterminates;
        // Symbol: drake::symbolic::Polynomial::ToExpression
        struct /* ToExpression */ {
          // Source: drake/common/symbolic_polynomial.h:145
          const char* doc =
R"""(Returns an equivalent symbolic expression of this polynomial.)""";
        } ToExpression;
        // Symbol: drake::symbolic::Polynomial::TotalDegree
        struct /* TotalDegree */ {
          // Source: drake/common/symbolic_polynomial.h:138
          const char* doc =
R"""(Returns the total degree of this polynomial.)""";
        } TotalDegree;
        // Symbol: drake::symbolic::Polynomial::decision_variables
        struct /* decision_variables */ {
          // Source: drake/common/symbolic_polynomial.h:114
          const char* doc =
R"""(Returns the decision variables of this polynomial.)""";
        } decision_variables;
        // Symbol: drake::symbolic::Polynomial::indeterminates
        struct /* indeterminates */ {
          // Source: drake/common/symbolic_polynomial.h:111
          const char* doc =
R"""(Returns the indeterminates of this polynomial.)""";
        } indeterminates;
        // Symbol: drake::symbolic::Polynomial::monomial_to_coefficient_map
        struct /* monomial_to_coefficient_map */ {
          // Source: drake/common/symbolic_polynomial.h:142
          const char* doc =
R"""(Returns the mapping from a Monomial to its corresponding coefficient
of this polynomial.)""";
        } monomial_to_coefficient_map;
        // Symbol: drake::symbolic::Polynomial::operator!=
        struct /* operator_ne */ {
          // Source: drake/common/symbolic_polynomial.h:232
          const char* doc =
R"""(Returns a symbolic formula representing the condition where this
polynomial and ``p`` are not the same.)""";
        } operator_ne;
        // Symbol: drake::symbolic::Polynomial::operator*=
        struct /* operator_imul */ {
          // Source: drake/common/symbolic_polynomial.h:209
          const char* doc = R"""()""";
        } operator_imul;
        // Symbol: drake::symbolic::Polynomial::operator+=
        struct /* operator_iadd */ {
          // Source: drake/common/symbolic_polynomial.h:199
          const char* doc = R"""()""";
        } operator_iadd;
        // Symbol: drake::symbolic::Polynomial::operator-=
        struct /* operator_isub */ {
          // Source: drake/common/symbolic_polynomial.h:204
          const char* doc = R"""()""";
        } operator_isub;
      } Polynomial;
      // Symbol: drake::symbolic::PolynomialBasisElement
      struct /* PolynomialBasisElement */ {
        // Source: drake/common/symbolic_polynomial_basis_element.h:46
        const char* doc =
R"""(Each polynomial p(x) can be written as a linear combination of its
basis elements p(x) = ∑ᵢ cᵢ * ϕᵢ(x), where ϕᵢ(x) is the i'th element
in the basis, cᵢ is the coefficient of that element. The most commonly
used basis is monomials. For example in polynomial p(x) = 2x₀²x₁ +
3x₀x₁ + 2, x₀²x₁, x₀x₁ and 1 are all elements of monomial basis.
Likewise, a polynomial can be written using other basis, such as
Chebyshev polynomials, Legendre polynomials, etc. For a polynomial
written with Chebyshev polynomial basis p(x) = 2T₂(x₀)T₁(x₁) + 3T₁(x₁)
+ 2T₂(x₀), T₂(x₀)T₁(x₁),T₁(x₁), and T₂(x₀) are all elements of
Chebyshev basis. This PolynomialBasisElement class represents an
element ϕᵢ(x) in the basis. We can think of an element of polynomial
basis as a mapping from the variable to its degree. So for monomial
basis element x₀²x₁, it can be thought of as a mapping {x₀ -> 2, x₁ ->
1}. For a Chebyshev basis element T₂(x₀)T₁(x₁), it can be thought of
as a mapping {x₀ -> 2, x₁ -> 1}.

Each of the derived class, ``Derived``, should implement the following
functions

- std::map<Derived, double> operator*(const Derived& A, const Derived&B)
- std::map<Derived, double> Derived::Differentiate(const Variable& var)
const;
- std::map<Derived, double> Derived::Integrate(const Variable& var) const;
- bool Derived::operator<(const Derived& other) const;
- std::pair<double, Derived> EvaluatePartial(const Environment& e) const;
- void MergeBasisElementInPlace(const Derived& other)

The function lexicographical_compare can be used when implementing
operator<. The function DoEvaluatePartial can be used when
implementing EvaluatePartial)""";
        // Symbol: drake::symbolic::PolynomialBasisElement::DoEvaluatePartial
        struct /* DoEvaluatePartial */ {
          // Source: drake/common/symbolic_polynomial_basis_element.h:127
          const char* doc = R"""()""";
        } DoEvaluatePartial;
        // Symbol: drake::symbolic::PolynomialBasisElement::DoMergeBasisElementInPlace
        struct /* DoMergeBasisElementInPlace */ {
          // Source: drake/common/symbolic_polynomial_basis_element.h:141
          const char* doc =
R"""(Merge this basis element with another basis element by merging their
var_to_degree_map. After merging, the degree of each variable is
raised to the sum of the degree in each basis element (if a variable
does not show up in either one of the basis element, we regard its
degree to be 0).)""";
        } DoMergeBasisElementInPlace;
        // Symbol: drake::symbolic::PolynomialBasisElement::EqualTo
        struct /* EqualTo */ {
          // Source: drake/common/symbolic_polynomial_basis_element.h:122
          const char* doc = R"""()""";
        } EqualTo;
        // Symbol: drake::symbolic::PolynomialBasisElement::Evaluate
        struct /* Evaluate */ {
          // Source: drake/common/symbolic_polynomial_basis_element.h:105
          const char* doc =
R"""(Evaluates under a given environment ``env``.

Raises:
    ValueError exception if there is a variable in this monomial whose
    assignment is not provided by ``env``.)""";
        } Evaluate;
        // Symbol: drake::symbolic::PolynomialBasisElement::GetVariables
        struct /* GetVariables */ {
          // Source: drake/common/symbolic_polynomial_basis_element.h:98
          const char* doc = R"""()""";
        } GetVariables;
        // Symbol: drake::symbolic::PolynomialBasisElement::PolynomialBasisElement
        struct /* ctor */ {
          // Source: drake/common/symbolic_polynomial_basis_element.h:54
          const char* doc_0args =
R"""(Constructs a polynomial basis with empty var_to_degree map. This
element should be interpreted as 1.)""";
          // Source: drake/common/symbolic_polynomial_basis_element.h:62
          const char* doc_1args =
R"""(Constructs a polynomial basis given the variable and the degree of
that variable.

Raises:
    RuntimeError if any of the degree is negative.

Note:
    we will ignore the variable with degree 0.)""";
          // Source: drake/common/symbolic_polynomial_basis_element.h:71
          const char* doc_2args =
R"""(Constructs a polynomial basis, such that it contains the
variable-to-degree map vars(i)→degrees(i).

Raises:
    invalid_argument if ``vars`` contains repeated variables.

Raises:
    logic_error if any degree is negative.)""";
        } ctor;
        // Symbol: drake::symbolic::PolynomialBasisElement::ToExpression
        struct /* ToExpression */ {
          // Source: drake/common/symbolic_polynomial_basis_element.h:111
          const char* doc = R"""()""";
        } ToExpression;
        // Symbol: drake::symbolic::PolynomialBasisElement::degree
        struct /* degree */ {
          // Source: drake/common/symbolic_polynomial_basis_element.h:96
          const char* doc =
R"""(Returns the degree of this PolynomialBasisElement in a variable ``v``.
If ``v`` is not a variable in this PolynomialBasisElement, then
returns 0.)""";
        } degree;
        // Symbol: drake::symbolic::PolynomialBasisElement::get_mutable_total_degree
        struct /* get_mutable_total_degree */ {
          // Source: drake/common/symbolic_polynomial_basis_element.h:130
          const char* doc = R"""()""";
        } get_mutable_total_degree;
        // Symbol: drake::symbolic::PolynomialBasisElement::get_mutable_var_to_degree_map
        struct /* get_mutable_var_to_degree_map */ {
          // Source: drake/common/symbolic_polynomial_basis_element.h:132
          const char* doc = R"""()""";
        } get_mutable_var_to_degree_map;
        // Symbol: drake::symbolic::PolynomialBasisElement::get_powers
        struct /* get_powers */ {
          // Source: drake/common/symbolic_polynomial_basis_element.h:86
          const char* doc =
R"""(Returns variable to degree map. TODO(hongkai.dai): this function is
added because Monomial class has get_powers() function. We will remove
this get_powers() function when Monomial class is deprecated.)""";
        } get_powers;
        // Symbol: drake::symbolic::PolynomialBasisElement::lexicographical_compare
        struct /* lexicographical_compare */ {
          // Source: drake/common/symbolic_polynomial_basis_element.h:119
          const char* doc =
R"""(Compares two PolynomialBasisElement using lexicographical order. This
function is meant to be called by the derived class, to compare two
polynomial basis of the same derived class.)""";
        } lexicographical_compare;
        // Symbol: drake::symbolic::PolynomialBasisElement::operator!=
        struct /* operator_ne */ {
          // Source: drake/common/symbolic_polynomial_basis_element.h:109
          const char* doc = R"""()""";
        } operator_ne;
        // Symbol: drake::symbolic::PolynomialBasisElement::total_degree
        struct /* total_degree */ {
          // Source: drake/common/symbolic_polynomial_basis_element.h:92
          const char* doc =
R"""(Returns the total degree of a polynomial basis. This is the summation
of the degree for each variable.)""";
        } total_degree;
        // Symbol: drake::symbolic::PolynomialBasisElement::var_to_degree_map
        struct /* var_to_degree_map */ {
          // Source: drake/common/symbolic_polynomial_basis_element.h:76
          const char* doc = R"""()""";
        } var_to_degree_map;
      } PolynomialBasisElement;
      // Symbol: drake::symbolic::PopulateRandomVariables
      struct /* PopulateRandomVariables */ {
        // Source: drake/common/symbolic_environment.h:155
        const char* doc =
R"""(Populates the environment ``env`` by sampling values for the
unassigned random variables in ``variables`` using
``random_generator``.)""";
      } PopulateRandomVariables;
      // Symbol: drake::symbolic::RationalFunction
      struct /* RationalFunction */ {
        // Source: drake/common/symbolic_rational_function.h:29
        const char* doc =
R"""(Represents symbolic rational function. A function f(x) is a rational
function, if f(x) = p(x) / q(x), where both p(x) and q(x) are
polynomials of x. Note that rational functions are closed under (+, -,
x, /). One application of rational function is in polynomial
optimization, where we represent (or approximate) functions using
rational functions, and then convert the constraint f(x) = h(x) (where
h(x) is a polynomial) to a polynomial constraint p(x) - q(x) * h(x) =
0, or convert the inequality constraint f(x) >= h(x) as p(x) - q(x) *
h(x) >= 0 if we know q(x) > 0.

This class represents a special subset of the symbolic::Expression.
While a symbolic::Expression can represent a rational function,
extracting the numerator and denominator, generally, is quite
difficult; for instance, from p1(x) / q1(x) + p2(x) / q2(x) + ... +
pn(x) / qn(x). This class's explicit structure facilitates this
decomposition.)""";
        // Symbol: drake::symbolic::RationalFunction::EqualTo
        struct /* EqualTo */ {
          // Source: drake/common/symbolic_rational_function.h:95
          const char* doc =
R"""(Returns true if this rational function and f are structurally equal.)""";
        } EqualTo;
        // Symbol: drake::symbolic::RationalFunction::RationalFunction
        struct /* ctor */ {
          // Source: drake/common/symbolic_rational_function.h:32
          const char* doc_0args =
R"""(Constructs a zero rational function 0 / 1.)""";
          // Source: drake/common/symbolic_rational_function.h:46
          const char* doc_2args_numerator_denominator =
R"""(Constructs the rational function: numerator / denominator.

Parameter ``numerator``:
    The numerator of the fraction.

Parameter ``denominator``:
    The denominator of the fraction.

Precondition:
    denominator cannot be structurally equal to 0.

Precondition:
    None of the indeterminates in the numerator can be decision
    variables in the denominator; similarly none of the indeterminates
    in the denominator can be decision variables in the numerator.

Raises:
    RuntimeError if the precondition is not satisfied.)""";
          // Source: drake/common/symbolic_rational_function.h:53
          const char* doc_1args_p =
R"""(Constructs the rational function: p / 1. Note that we use 1 as the
denominator.

Parameter ``p``:
    The numerator of the rational function.)""";
          // Source: drake/common/symbolic_rational_function.h:60
          const char* doc_1args_c =
R"""(Constructs the rational function: c / 1. Note that we use 1 as the
denominator.

Parameter ``c``:
    The numerator of the rational function.)""";
        } ctor;
        // Symbol: drake::symbolic::RationalFunction::denominator
        struct /* denominator */ {
          // Source: drake/common/symbolic_rational_function.h:68
          const char* doc = R"""(Getter for the denominator.)""";
        } denominator;
        // Symbol: drake::symbolic::RationalFunction::numerator
        struct /* numerator */ {
          // Source: drake/common/symbolic_rational_function.h:65
          const char* doc = R"""(Getter for the numerator.)""";
        } numerator;
        // Symbol: drake::symbolic::RationalFunction::operator!=
        struct /* operator_ne */ {
          // Source: drake/common/symbolic_rational_function.h:108
          const char* doc =
R"""(Returns a symbolic formula representing the condition where this
rational function and ``f`` are not the same.)""";
        } operator_ne;
        // Symbol: drake::symbolic::RationalFunction::operator*=
        struct /* operator_imul */ {
          // Source: drake/common/symbolic_rational_function.h:78
          const char* doc = R"""()""";
        } operator_imul;
        // Symbol: drake::symbolic::RationalFunction::operator+=
        struct /* operator_iadd */ {
          // Source: drake/common/symbolic_rational_function.h:70
          const char* doc = R"""()""";
        } operator_iadd;
        // Symbol: drake::symbolic::RationalFunction::operator-=
        struct /* operator_isub */ {
          // Source: drake/common/symbolic_rational_function.h:74
          const char* doc = R"""()""";
        } operator_isub;
        // Symbol: drake::symbolic::RationalFunction::operator/=
        struct /* operator_idiv */ {
          // Source: drake/common/symbolic_rational_function.h:82
          const char* doc = R"""()""";
        } operator_idiv;
      } RationalFunction;
      // Symbol: drake::symbolic::RelationalFormulaCell
      struct /* RelationalFormulaCell */ {
        // Source: drake/common/symbolic_formula_cell.h:83
        const char* doc =
R"""(Represents the base class for relational operators (==, !=, <, <=, >,
>=).)""";
        // Symbol: drake::symbolic::RelationalFormulaCell::EqualTo
        struct /* EqualTo */ {
          // Source: drake/common/symbolic_formula_cell.h:99
          const char* doc = R"""()""";
        } EqualTo;
        // Symbol: drake::symbolic::RelationalFormulaCell::GetFreeVariables
        struct /* GetFreeVariables */ {
          // Source: drake/common/symbolic_formula_cell.h:98
          const char* doc = R"""()""";
        } GetFreeVariables;
        // Symbol: drake::symbolic::RelationalFormulaCell::HashAppendDetail
        struct /* HashAppendDetail */ {
          // Source: drake/common/symbolic_formula_cell.h:97
          const char* doc = R"""()""";
        } HashAppendDetail;
        // Symbol: drake::symbolic::RelationalFormulaCell::Less
        struct /* Less */ {
          // Source: drake/common/symbolic_formula_cell.h:100
          const char* doc = R"""()""";
        } Less;
        // Symbol: drake::symbolic::RelationalFormulaCell::RelationalFormulaCell
        struct /* ctor */ {
          // Source: drake/common/symbolic_formula_cell.h:86
          const char* doc_0args = R"""(Default constructor (deleted).)""";
          // Source: drake/common/symbolic_formula_cell.h:88
          const char* doc_move =
R"""(Move-construct a formula from an rvalue.)""";
          // Source: drake/common/symbolic_formula_cell.h:90
          const char* doc_copy =
R"""(Copy-construct a formula from an lvalue.)""";
          // Source: drake/common/symbolic_formula_cell.h:96
          const char* doc_3args =
R"""(Construct RelationalFormulaCell of kind ``k`` with ``lhs`` and
``rhs``.)""";
        } ctor;
        // Symbol: drake::symbolic::RelationalFormulaCell::get_lhs_expression
        struct /* get_lhs_expression */ {
          // Source: drake/common/symbolic_formula_cell.h:103
          const char* doc =
R"""(Returns the expression on left-hand-side.)""";
        } get_lhs_expression;
        // Symbol: drake::symbolic::RelationalFormulaCell::get_rhs_expression
        struct /* get_rhs_expression */ {
          // Source: drake/common/symbolic_formula_cell.h:105
          const char* doc =
R"""(Returns the expression on right-hand-side.)""";
        } get_rhs_expression;
      } RelationalFormulaCell;
      // Symbol: drake::symbolic::Rewriter
      struct /* Rewriter */ {
        // Source: drake/common/symbolic_simplification.h:52
        const char* doc =
R"""(A ``Rewriter`` is a function from an Expression to an Expression.)""";
      } Rewriter;
      // Symbol: drake::symbolic::RewritingRule
      struct /* RewritingRule */ {
        // Source: drake/common/symbolic_simplification.h:20
        const char* doc =
R"""(A ``RewritingRule``, `lhs => rhs`, consists of two Patterns ``lhs``
and ``rhs``. A rewriting rule instructs a rewriter how to transform a
given expression ``e``. First, the rewriter tries to find a match
between the expression ``e`` and the pattern ``lhs``. If such a match
is found, it applies the match result (substitution) to ``rhs``.
Otherwise, the same expression ``e`` is returned.)""";
        // Symbol: drake::symbolic::RewritingRule::RewritingRule
        struct /* ctor */ {
          // Source: drake/common/symbolic_simplification.h:23
          const char* doc =
R"""(Constructs a rewriting rule ``lhs => rhs``.)""";
          // Source: drake/common/symbolic_simplification.h:27
          const char* doc_copy = R"""(Default copy constructor.)""";
          // Source: drake/common/symbolic_simplification.h:30
          const char* doc_move = R"""(Default move constructor.)""";
        } ctor;
        // Symbol: drake::symbolic::RewritingRule::lhs
        struct /* lhs */ {
          // Source: drake/common/symbolic_simplification.h:42
          const char* doc =
R"""(Returns the const reference of the LHS of the rewriting rule.)""";
        } lhs;
        // Symbol: drake::symbolic::RewritingRule::rhs
        struct /* rhs */ {
          // Source: drake/common/symbolic_simplification.h:44
          const char* doc =
R"""(Returns the const reference of the RHS of the rewriting rule.)""";
        } rhs;
      } RewritingRule;
      // Symbol: drake::symbolic::Substitute
      struct /* Substitute */ {
        // Source: drake/common/symbolic_expression.h:1374
        const char* doc_2args =
R"""(Substitutes a symbolic matrix ``m`` using a given substitution
``subst``.

Returns:
    a matrix of symbolic expressions whose size is the size of ``m``.

Raises:
    RuntimeError if NaN is detected during substitution.)""";
        // Source: drake/common/symbolic_expression.h:1391
        const char* doc_3args =
R"""(Substitutes ``var`` with ``e`` in a symbolic matrix ``m``.

Returns:
    a matrix of symbolic expressions whose size is the size of ``m``.

Raises:
    RuntimeError if NaN is detected during substitution.)""";
      } Substitute;
      // Symbol: drake::symbolic::Substitution
      struct /* Substitution */ {
        // Source: drake/common/symbolic_expression.h:108
        const char* doc = R"""()""";
      } Substitution;
      // Symbol: drake::symbolic::TaylorExpand
      struct /* TaylorExpand */ {
        // Source: drake/common/symbolic_expression.h:778
        const char* doc =
R"""(Returns the Taylor series expansion of ``f`` around ``a`` of order
``order``.

Parameter ``f``:
    Symbolic expression to approximate using Taylor series expansion.

Parameter ``a``:
    Symbolic environment which specifies the point of approximation.
    If a partial environment is provided, the unspecified variables
    are treated as symbolic variables (e.g. decision variable).

Parameter ``order``:
    Positive integer which specifies the maximum order of the
    resulting polynomial approximating ``f`` around ``a``.)""";
      } TaylorExpand;
      // Symbol: drake::symbolic::UnaryExpressionCell
      struct /* UnaryExpressionCell */ {
        // Source: drake/common/symbolic_expression_cell.h:127
        const char* doc =
R"""(Represents the base class for unary expressions.)""";
        // Symbol: drake::symbolic::UnaryExpressionCell::DoEvaluate
        struct /* DoEvaluate */ {
          // Source: drake/common/symbolic_expression_cell.h:156
          const char* doc =
R"""(Returns the evaluation result f(``v`` ).)""";
        } DoEvaluate;
        // Symbol: drake::symbolic::UnaryExpressionCell::EqualTo
        struct /* EqualTo */ {
          // Source: drake/common/symbolic_expression_cell.h:131
          const char* doc = R"""()""";
        } EqualTo;
        // Symbol: drake::symbolic::UnaryExpressionCell::Evaluate
        struct /* Evaluate */ {
          // Source: drake/common/symbolic_expression_cell.h:133
          const char* doc = R"""()""";
        } Evaluate;
        // Symbol: drake::symbolic::UnaryExpressionCell::GetVariables
        struct /* GetVariables */ {
          // Source: drake/common/symbolic_expression_cell.h:130
          const char* doc = R"""()""";
        } GetVariables;
        // Symbol: drake::symbolic::UnaryExpressionCell::HashAppendDetail
        struct /* HashAppendDetail */ {
          // Source: drake/common/symbolic_expression_cell.h:129
          const char* doc = R"""()""";
        } HashAppendDetail;
        // Symbol: drake::symbolic::UnaryExpressionCell::Less
        struct /* Less */ {
          // Source: drake/common/symbolic_expression_cell.h:132
          const char* doc = R"""()""";
        } Less;
        // Symbol: drake::symbolic::UnaryExpressionCell::UnaryExpressionCell
        struct /* ctor */ {
          // Source: drake/common/symbolic_expression_cell.h:138
          const char* doc_0args = R"""(Default constructor (DELETED).)""";
          // Source: drake/common/symbolic_expression_cell.h:148
          const char* doc_move = R"""(Move-constructs from an rvalue.)""";
          // Source: drake/common/symbolic_expression_cell.h:150
          const char* doc_copy = R"""(Copy-constructs from an lvalue.)""";
          // Source: drake/common/symbolic_expression_cell.h:153
          const char* doc_4args =
R"""(Constructs UnaryExpressionCell of kind ``k`` with ``e``, ``is_poly``,
and ``is_expanded``.)""";
        } ctor;
        // Symbol: drake::symbolic::UnaryExpressionCell::get_argument
        struct /* get_argument */ {
          // Source: drake/common/symbolic_expression_cell.h:135
          const char* doc = R"""(Returns the argument.)""";
        } get_argument;
      } UnaryExpressionCell;
      // Symbol: drake::symbolic::Variable
      struct /* Variable */ {
        // Source: drake/common/symbolic_variable.h:32
        const char* doc =
R"""(Represents a symbolic variable.

Note:
    Expression::Evaluate and Formula::Evaluate methods take a symbolic
    environment (Variable → double) and a random number generator.
    When an expression or a formula includes random variables,
    ``Evaluate`` methods use the random number generator to draw a
    number for a random variable from the given distribution. Then
    this numeric value is used to substitute all the occurrences of
    the corresponding random variable in an expression or a formula.)""";
        // Symbol: drake::symbolic::Variable::Id
        struct /* Id */ {
          // Source: drake/common/symbolic_variable.h:34
          const char* doc = R"""()""";
        } Id;
        // Symbol: drake::symbolic::Variable::Type
        struct /* Type */ {
          // Source: drake/common/symbolic_variable.h:38
          const char* doc = R"""(Supported types of symbolic variables.)""";
          // Symbol: drake::symbolic::Variable::Type::BINARY
          struct /* BINARY */ {
            // Source: drake/common/symbolic_variable.h:41
            const char* doc =
R"""(A BINARY variable takes an integer value from {0, 1}.)""";
          } BINARY;
          // Symbol: drake::symbolic::Variable::Type::BOOLEAN
          struct /* BOOLEAN */ {
            // Source: drake/common/symbolic_variable.h:42
            const char* doc =
R"""(A BOOLEAN variable takes a ``bool`` value.)""";
          } BOOLEAN;
          // Symbol: drake::symbolic::Variable::Type::CONTINUOUS
          struct /* CONTINUOUS */ {
            // Source: drake/common/symbolic_variable.h:39
            const char* doc =
R"""(A CONTINUOUS variable takes a ``double`` value.)""";
          } CONTINUOUS;
          // Symbol: drake::symbolic::Variable::Type::INTEGER
          struct /* INTEGER */ {
            // Source: drake/common/symbolic_variable.h:40
            const char* doc =
R"""(An INTEGER variable takes an ``int`` value.)""";
          } INTEGER;
          // Symbol: drake::symbolic::Variable::Type::RANDOM_EXPONENTIAL
          struct /* RANDOM_EXPONENTIAL */ {
            // Source: drake/common/symbolic_variable.h:47
            const char* doc =
R"""(A random variable whose value will be drawn from exponential
distribution with λ=1.)""";
          } RANDOM_EXPONENTIAL;
          // Symbol: drake::symbolic::Variable::Type::RANDOM_GAUSSIAN
          struct /* RANDOM_GAUSSIAN */ {
            // Source: drake/common/symbolic_variable.h:45
            const char* doc =
R"""(A random variable whose value will be drawn from mean-zero,
unit-variance normal.)""";
          } RANDOM_GAUSSIAN;
          // Symbol: drake::symbolic::Variable::Type::RANDOM_UNIFORM
          struct /* RANDOM_UNIFORM */ {
            // Source: drake/common/symbolic_variable.h:43
            const char* doc =
R"""(A random variable whose value will be drawn from uniform real
distributed ∈ [0,1).)""";
          } RANDOM_UNIFORM;
        } Type;
        // Symbol: drake::symbolic::Variable::Variable
        struct /* ctor */ {
          // Source: drake/common/symbolic_variable.h:62
          const char* doc_0args =
R"""(Default constructor. Constructs a dummy variable of CONTINUOUS type.
This is needed to have Eigen::Matrix<Variable>. The objects created by
the default constructor share the same ID, zero. As a result, they all
are identified as a single variable by equality operator (==). They
all have the same hash value as well.

It is allowed to construct a dummy variable but it should not be used
to construct a symbolic expression.)""";
          // Source: drake/common/symbolic_variable.h:67
          const char* doc_1args =
R"""(Constructs a default value. This overload is used by Eigen when
EIGEN_INITIALIZE_MATRICES_BY_ZERO is enabled.)""";
          // Source: drake/common/symbolic_variable.h:71
          const char* doc_2args =
R"""(Constructs a variable with a string. If not specified, it has
CONTINUOUS type by default.)""";
        } ctor;
        // Symbol: drake::symbolic::Variable::equal_to
        struct /* equal_to */ {
          // Source: drake/common/symbolic_variable.h:82
          const char* doc =
R"""(Checks the equality of two variables based on their ID values.)""";
        } equal_to;
        // Symbol: drake::symbolic::Variable::get_id
        struct /* get_id */ {
          // Source: drake/common/symbolic_variable.h:76
          const char* doc = R"""()""";
        } get_id;
        // Symbol: drake::symbolic::Variable::get_name
        struct /* get_name */ {
          // Source: drake/common/symbolic_variable.h:78
          const char* doc = R"""()""";
        } get_name;
        // Symbol: drake::symbolic::Variable::get_type
        struct /* get_type */ {
          // Source: drake/common/symbolic_variable.h:77
          const char* doc = R"""()""";
        } get_type;
        // Symbol: drake::symbolic::Variable::is_dummy
        struct /* is_dummy */ {
          // Source: drake/common/symbolic_variable.h:75
          const char* doc =
R"""(Checks if this is a dummy variable (ID = 0) which is created by the
default constructor.)""";
        } is_dummy;
        // Symbol: drake::symbolic::Variable::less
        struct /* less */ {
          // Source: drake/common/symbolic_variable.h:87
          const char* doc =
R"""(Compares two variables based on their ID values.)""";
        } less;
        // Symbol: drake::symbolic::Variable::to_string
        struct /* to_string */ {
          // Source: drake/common/symbolic_variable.h:79
          const char* doc = R"""()""";
        } to_string;
      } Variable;
      // Symbol: drake::symbolic::Variables
      struct /* Variables */ {
        // Source: drake/common/symbolic_variables.h:29
        const char* doc =
R"""(Represents a set of variables.

This class is based on std::set<Variable>. The intent is to add things
that we need including set-union (Variables::insert, operator+,
operator+=), set-minus (Variables::erase, operator-, operator-=), and
subset/superset checking functions (Variables::IsSubsetOf,
Variables::IsSupersetOf, Variables::IsStrictSubsetOf,
Variables::IsStrictSupersetOf).)""";
        // Symbol: drake::symbolic::Variables::IsStrictSubsetOf
        struct /* IsStrictSubsetOf */ {
          // Source: drake/common/symbolic_variables.h:128
          const char* doc =
R"""(Return true if ``vars`` is a strict subset of the Variables.)""";
        } IsStrictSubsetOf;
        // Symbol: drake::symbolic::Variables::IsStrictSupersetOf
        struct /* IsStrictSupersetOf */ {
          // Source: drake/common/symbolic_variables.h:130
          const char* doc =
R"""(Return true if ``vars`` is a strict superset of the Variables.)""";
        } IsStrictSupersetOf;
        // Symbol: drake::symbolic::Variables::IsSubsetOf
        struct /* IsSubsetOf */ {
          // Source: drake/common/symbolic_variables.h:124
          const char* doc =
R"""(Return true if ``vars`` is a subset of the Variables.)""";
        } IsSubsetOf;
        // Symbol: drake::symbolic::Variables::IsSupersetOf
        struct /* IsSupersetOf */ {
          // Source: drake/common/symbolic_variables.h:126
          const char* doc =
R"""(Return true if ``vars`` is a superset of the Variables.)""";
        } IsSupersetOf;
        // Symbol: drake::symbolic::Variables::Variables
        struct /* ctor */ {
          // Source: drake/common/symbolic_variables.h:41
          const char* doc_0args = R"""(Default constructor.)""";
          // Source: drake/common/symbolic_variables.h:44
          const char* doc_1args_init = R"""(List constructor.)""";
          // Source: drake/common/symbolic_variables.h:47
          const char* doc_1args_vec =
R"""(Constructs from an Eigen vector of variables.)""";
        } ctor;
        // Symbol: drake::symbolic::Variables::begin
        struct /* begin */ {
          // Source: drake/common/symbolic_variables.h:67
          const char* doc = R"""(Returns an iterator to the beginning.)""";
        } begin;
        // Symbol: drake::symbolic::Variables::cbegin
        struct /* cbegin */ {
          // Source: drake/common/symbolic_variables.h:75
          const char* doc =
R"""(Returns a const iterator to the beginning.)""";
        } cbegin;
        // Symbol: drake::symbolic::Variables::cend
        struct /* cend */ {
          // Source: drake/common/symbolic_variables.h:77
          const char* doc = R"""(Returns a const iterator to the end.)""";
        } cend;
        // Symbol: drake::symbolic::Variables::const_iterator
        struct /* const_iterator */ {
          // Source: drake/common/symbolic_variables.h:35
          const char* doc = R"""()""";
        } const_iterator;
        // Symbol: drake::symbolic::Variables::const_reverse_iterator
        struct /* const_reverse_iterator */ {
          // Source: drake/common/symbolic_variables.h:38
          const char* doc = R"""()""";
        } const_reverse_iterator;
        // Symbol: drake::symbolic::Variables::crbegin
        struct /* crbegin */ {
          // Source: drake/common/symbolic_variables.h:89
          const char* doc =
R"""(Returns a const reverse-iterator to the beginning.)""";
        } crbegin;
        // Symbol: drake::symbolic::Variables::crend
        struct /* crend */ {
          // Source: drake/common/symbolic_variables.h:93
          const char* doc =
R"""(Returns a const reverse-iterator to the end.)""";
        } crend;
        // Symbol: drake::symbolic::Variables::empty
        struct /* empty */ {
          // Source: drake/common/symbolic_variables.h:53
          const char* doc = R"""(Checks if this set is empty or not.)""";
        } empty;
        // Symbol: drake::symbolic::Variables::end
        struct /* end */ {
          // Source: drake/common/symbolic_variables.h:69
          const char* doc = R"""(Returns an iterator to the end.)""";
        } end;
        // Symbol: drake::symbolic::Variables::erase
        struct /* erase */ {
          // Source: drake/common/symbolic_variables.h:106
          const char* doc_1args_key =
R"""(Erases ``key`` from a set. Return number of erased elements (0 or 1).)""";
          // Source: drake/common/symbolic_variables.h:110
          const char* doc_1args_vars =
R"""(Erases variables in ``vars`` from a set. Return number of erased
elements ([0, vars.size()]).)""";
        } erase;
        // Symbol: drake::symbolic::Variables::find
        struct /* find */ {
          // Source: drake/common/symbolic_variables.h:113
          const char* doc = R"""(Finds element with specific key.)""";
        } find;
        // Symbol: drake::symbolic::Variables::include
        struct /* include */ {
          // Source: drake/common/symbolic_variables.h:119
          const char* doc =
R"""(Return true if ``key`` is included in the Variables.)""";
        } include;
        // Symbol: drake::symbolic::Variables::insert
        struct /* insert */ {
          // Source: drake/common/symbolic_variables.h:96
          const char* doc_1args_var = R"""(Inserts a variable ``var`` into a set.)""";
          // Source: drake/common/symbolic_variables.h:99
          const char* doc_2args_InputIt_InputIt =
R"""(Inserts variables in [``first``, ``last)`` into a set.)""";
          // Source: drake/common/symbolic_variables.h:103
          const char* doc_1args_vars =
R"""(Inserts variables in ``vars`` into a set.)""";
        } insert;
        // Symbol: drake::symbolic::Variables::iterator
        struct /* iterator */ {
          // Source: drake/common/symbolic_variables.h:34
          const char* doc = R"""()""";
        } iterator;
        // Symbol: drake::symbolic::Variables::rbegin
        struct /* rbegin */ {
          // Source: drake/common/symbolic_variables.h:79
          const char* doc =
R"""(Returns a reverse iterator to the beginning.)""";
        } rbegin;
        // Symbol: drake::symbolic::Variables::rend
        struct /* rend */ {
          // Source: drake/common/symbolic_variables.h:81
          const char* doc = R"""(Returns a reverse iterator to the end.)""";
        } rend;
        // Symbol: drake::symbolic::Variables::reverse_iterator
        struct /* reverse_iterator */ {
          // Source: drake/common/symbolic_variables.h:36
          const char* doc = R"""()""";
        } reverse_iterator;
        // Symbol: drake::symbolic::Variables::size
        struct /* size */ {
          // Source: drake/common/symbolic_variables.h:50
          const char* doc = R"""(Returns the number of elements.)""";
        } size;
        // Symbol: drake::symbolic::Variables::size_type
        struct /* size_type */ {
          // Source: drake/common/symbolic_variables.h:33
          const char* doc = R"""()""";
        } size_type;
        // Symbol: drake::symbolic::Variables::to_string
        struct /* to_string */ {
          // Source: drake/common/symbolic_variables.h:56
          const char* doc =
R"""(Returns string representation of Variables.)""";
        } to_string;
      } Variables;
      // Symbol: drake::symbolic::VisitExpression
      struct /* VisitExpression */ {
        // Source: drake/common/symbolic_expression_visitor.h:91
        const char* doc =
R"""(Calls visitor object ``v`` with a symbolic-expression ``e``, and
arguments ``args``. Visitor object is expected to implement the
following methods which take ``f`` and ``args:`` ``VisitConstant``,
`VisitVariable`, ``VisitAddition``, `VisitMultiplication`,
``VisitDivision``, `VisitLog`, ``VisitAbs``, `VisitExp`,
``VisitSqrt``, `VisitPow`, ``VisitSin``, `VisitCos`, ``VisitTan``,
`VisitAsin`, ``VisitAtan``, `VisitAtan2`, ``VisitSinh``, `VisitCosh`,
``VisitTanh``, `VisitMin`, ``VisitMax``, `VisitCeil`, ``VisitFloor``,
`VisitIfThenElse`, `VisitUninterpretedFunction.

Raises:
    RuntimeError if NaN is detected during a visit.)""";
      } VisitExpression;
      // Symbol: drake::symbolic::VisitFormula
      struct /* VisitFormula */ {
        // Source: drake/common/symbolic_formula_visitor.h:26
        const char* doc =
R"""(Calls visitor object ``v`` with a symbolic formula ``f``, and
arguments ``args``. Visitor object is expected to implement the
following methods which take ``f`` and ``args:`` ``VisitFalse``,
`VisitTrue`, ``VisitVariable``, `VisitEqualTo`, VisitNotEqualTo,
VisitGreaterThan, ``VisitGreaterThanOrEqualTo``, `VisitLessThan`,
``VisitLessThanOrEqualTo``, `VisitConjunction`, ``VisitDisjunction``,
`VisitNegation`, ``VisitForall``, `VisitIsnan`,
``VisitPositiveSemidefinite``.

Check the implementation of ``NegationNormalFormConverter`` class in
drake/common/test/symbolic_formula_visitor_test.cc file to find an
example.)""";
      } VisitFormula;
      // Symbol: drake::symbolic::VisitPolynomial
      struct /* VisitPolynomial */ {
        // Source: drake/common/symbolic_expression_visitor.h:28
        const char* doc =
R"""(Calls visitor object ``v`` with a polynomial symbolic-expression
``e``, and arguments ``args``. Visitor object is expected to implement
the following methods which take ``f`` and ``args:``
``VisitConstant``, `VisitVariable`, ``VisitAddition``,
`VisitMultiplication`, ``VisitDivision``, `VisitPow`.

Raises:
    RuntimeError if NaN is detected during a visit.

See the implementation of ``DegreeVisitor`` class and ``Degree``
function in drake/common/symbolic_monomial.cc as an example usage.

Precondition:
    e.is_polynomial() is true.)""";
      } VisitPolynomial;
      // Symbol: drake::symbolic::abs
      struct /* abs */ {
        // Source: drake/common/symbolic_expression.h:595
        const char* doc = R"""()""";
      } abs;
      // Symbol: drake::symbolic::acos
      struct /* acos */ {
        // Source: drake/common/symbolic_expression.h:603
        const char* doc = R"""()""";
      } acos;
      // Symbol: drake::symbolic::asin
      struct /* asin */ {
        // Source: drake/common/symbolic_expression.h:602
        const char* doc = R"""()""";
      } asin;
      // Symbol: drake::symbolic::atan
      struct /* atan */ {
        // Source: drake/common/symbolic_expression.h:604
        const char* doc = R"""()""";
      } atan;
      // Symbol: drake::symbolic::atan2
      struct /* atan2 */ {
        // Source: drake/common/symbolic_expression.h:605
        const char* doc = R"""()""";
      } atan2;
      // Symbol: drake::symbolic::ceil
      struct /* ceil */ {
        // Source: drake/common/symbolic_expression.h:611
        const char* doc = R"""()""";
      } ceil;
      // Symbol: drake::symbolic::cos
      struct /* cos */ {
        // Source: drake/common/symbolic_expression.h:600
        const char* doc = R"""()""";
      } cos;
      // Symbol: drake::symbolic::cosh
      struct /* cosh */ {
        // Source: drake/common/symbolic_expression.h:607
        const char* doc = R"""()""";
      } cosh;
      // Symbol: drake::symbolic::exp
      struct /* exp */ {
        // Source: drake/common/symbolic_expression.h:596
        const char* doc = R"""()""";
      } exp;
      // Symbol: drake::symbolic::floor
      struct /* floor */ {
        // Source: drake/common/symbolic_expression.h:612
        const char* doc = R"""()""";
      } floor;
      // Symbol: drake::symbolic::forall
      struct /* forall */ {
        // Source: drake/common/symbolic_formula.h:273
        const char* doc =
R"""(Returns a formula ``f``, universally quantified by variables ``vars``.)""";
      } forall;
      // Symbol: drake::symbolic::get_argument
      struct /* get_argument */ {
        // Source: drake/common/symbolic_expression.h:705
        const char* doc =
R"""(Returns the argument in the unary expression ``e``.

Precondition:
    {``e`` is a unary expression.})""";
      } get_argument;
      // Symbol: drake::symbolic::get_base_to_exponent_map_in_multiplication
      struct /* get_base_to_exponent_map_in_multiplication */ {
        // Source: drake/common/symbolic_expression.h:737
        const char* doc =
R"""(Returns the map from a base expression to its exponent expression in
the multiplication expression ``e``. For instance, given 7 * x^2 * y^3
* z^x, the return value maps 'x' to 2, 'y' to 3, and 'z' to 'x'.

Precondition:
    {``e`` is a multiplication expression.})""";
      } get_base_to_exponent_map_in_multiplication;
      // Symbol: drake::symbolic::get_conditional_formula
      struct /* get_conditional_formula */ {
        // Source: drake/common/symbolic_expression.h:753
        const char* doc =
R"""(Returns the conditional formula in the if-then-else expression ``e``.

Precondition:
    ``e`` is an if-then-else expression.)""";
      } get_conditional_formula;
      // Symbol: drake::symbolic::get_constant_in_addition
      struct /* get_constant_in_addition */ {
        // Source: drake/common/symbolic_expression.h:718
        const char* doc =
R"""(Returns the constant part of the addition expression ``e``. For
instance, given 7 + 2 * x + 3 * y, it returns 7.

Precondition:
    {``e`` is an addition expression.})""";
      } get_constant_in_addition;
      // Symbol: drake::symbolic::get_constant_in_multiplication
      struct /* get_constant_in_multiplication */ {
        // Source: drake/common/symbolic_expression.h:730
        const char* doc =
R"""(Returns the constant part of the multiplication expression ``e``. For
instance, given 7 * x^2 * y^3, it returns 7.

Precondition:
    {``e`` is a multiplication expression.})""";
      } get_constant_in_multiplication;
      // Symbol: drake::symbolic::get_constant_value
      struct /* get_constant_value */ {
        // Source: drake/common/symbolic_expression.h:697
        const char* doc =
R"""(Returns the constant value of the constant expression ``e``.

Precondition:
    {``e`` is a constant expression.})""";
      } get_constant_value;
      // Symbol: drake::symbolic::get_else_expression
      struct /* get_else_expression */ {
        // Source: drake/common/symbolic_expression.h:763
        const char* doc =
R"""(Returns the 'else' expression in the if-then-else expression ``e``.

Precondition:
    ``e`` is an if-then-else expression.)""";
      } get_else_expression;
      // Symbol: drake::symbolic::get_expr_to_coeff_map_in_addition
      struct /* get_expr_to_coeff_map_in_addition */ {
        // Source: drake/common/symbolic_expression.h:724
        const char* doc =
R"""(Returns the map from an expression to its coefficient in the addition
expression ``e``. For instance, given 7 + 2 * x + 3 * y, the return
value maps 'x' to 2 and 'y' to 3.

Precondition:
    {``e`` is an addition expression.})""";
      } get_expr_to_coeff_map_in_addition;
      // Symbol: drake::symbolic::get_first_argument
      struct /* get_first_argument */ {
        // Source: drake/common/symbolic_expression.h:709
        const char* doc =
R"""(Returns the first argument of the binary expression ``e``.

Precondition:
    {``e`` is a binary expression.})""";
      } get_first_argument;
      // Symbol: drake::symbolic::get_lhs_expression
      struct /* get_lhs_expression */ {
        // Source: drake/common/symbolic_formula.h:465
        const char* doc =
R"""(Returns the lhs-argument of a relational formula ``f``.

Precondition:
    {``f`` is a relational formula.})""";
      } get_lhs_expression;
      // Symbol: drake::symbolic::get_matrix_in_positive_semidefinite
      struct /* get_matrix_in_positive_semidefinite */ {
        // Source: drake/common/symbolic_formula.h:495
        const char* doc =
R"""(Returns the matrix in a positive-semidefinite formula ``f``.

Precondition:
    {``f`` is a positive-semidefinite formula.})""";
      } get_matrix_in_positive_semidefinite;
      // Symbol: drake::symbolic::get_operand
      struct /* get_operand */ {
        // Source: drake/common/symbolic_formula.h:480
        const char* doc =
R"""(Returns the formula in a negation formula ``f``.

Precondition:
    {``f`` is a negation formula.})""";
      } get_operand;
      // Symbol: drake::symbolic::get_operands
      struct /* get_operands */ {
        // Source: drake/common/symbolic_formula.h:475
        const char* doc =
R"""(Returns the set of formulas in a n-ary formula ``f``.

Precondition:
    {``f`` is a n-ary formula.})""";
      } get_operands;
      // Symbol: drake::symbolic::get_quantified_formula
      struct /* get_quantified_formula */ {
        // Source: drake/common/symbolic_formula.h:490
        const char* doc =
R"""(Returns the quantified formula in a forall formula ``f``.

Precondition:
    {``f`` is a forall formula.})""";
      } get_quantified_formula;
      // Symbol: drake::symbolic::get_quantified_variables
      struct /* get_quantified_variables */ {
        // Source: drake/common/symbolic_formula.h:485
        const char* doc =
R"""(Returns the quantified variables in a forall formula ``f``.

Precondition:
    {``f`` is a forall formula.})""";
      } get_quantified_variables;
      // Symbol: drake::symbolic::get_rhs_expression
      struct /* get_rhs_expression */ {
        // Source: drake/common/symbolic_formula.h:470
        const char* doc =
R"""(Returns the rhs-argument of a relational formula ``f``.

Precondition:
    {``f`` is a relational formula.})""";
      } get_rhs_expression;
      // Symbol: drake::symbolic::get_second_argument
      struct /* get_second_argument */ {
        // Source: drake/common/symbolic_expression.h:713
        const char* doc =
R"""(Returns the second argument of the binary expression ``e``.

Precondition:
    {``e`` is a binary expression.})""";
      } get_second_argument;
      // Symbol: drake::symbolic::get_then_expression
      struct /* get_then_expression */ {
        // Source: drake/common/symbolic_expression.h:758
        const char* doc =
R"""(Returns the 'then' expression in the if-then-else expression ``e``.

Precondition:
    ``e`` is an if-then-else expression.)""";
      } get_then_expression;
      // Symbol: drake::symbolic::get_uninterpreted_function_arguments
      struct /* get_uninterpreted_function_arguments */ {
        // Source: drake/common/symbolic_expression.h:747
        const char* doc =
R"""(Returns the arguments of an uninterpreted-function expression ``e``.

Precondition:
    ``e`` is an uninterpreted-function expression.)""";
      } get_uninterpreted_function_arguments;
      // Symbol: drake::symbolic::get_uninterpreted_function_name
      struct /* get_uninterpreted_function_name */ {
        // Source: drake/common/symbolic_expression.h:742
        const char* doc =
R"""(Returns the name of an uninterpreted-function expression ``e``.

Precondition:
    ``e`` is an uninterpreted-function expression.)""";
      } get_uninterpreted_function_name;
      // Symbol: drake::symbolic::get_variable
      struct /* get_variable */ {
        // Source: drake/common/symbolic_expression.h:701
        const char* doc_1args_e =
R"""(Returns the embedded variable in the variable expression ``e``.

Precondition:
    {``e`` is a variable expression.})""";
        // Source: drake/common/symbolic_formula.h:460
        const char* doc_1args_f =
R"""(Returns the embedded variable in the variable formula ``f``.

Precondition:
    ``f`` is a variable formula.)""";
      } get_variable;
      // Symbol: drake::symbolic::if_then_else
      struct /* if_then_else */ {
        // Source: drake/common/symbolic_expression.h:613
        const char* doc =
R"""(Constructs if-then-else expression.


::

    if_then_else(cond, expr_then, expr_else)

The value returned by the above if-then-else expression is
``expr_then`` if ``cond`` is evaluated to true. Otherwise, it returns
``expr_else``.

The semantics is similar to the C++'s conditional expression
constructed by its ternary operator, @c ?:. However, there is a key
difference between the C++'s conditional expression and our
``if_then_else`` expression in a way the arguments are evaluated
during the construction.

- In case of the C++'s conditional expression, `` cond ? expr_then :
expr_else``, the then expression ``expr_then`` (respectively, the else
expression ``expr_else)`` is **only** evaluated when the conditional
expression ``cond`` is evaluated to **true** (respectively, when ``cond`` is
evaluated to **false)**.

- In case of the symbolic expression, ``if_then_else(cond, expr_then,
expr_else)``, however, **both** arguments ``expr_then`` and ``expr_else``
are evaluated first and then passed to the ``if_then_else`` function.

Note:
    This function returns an **expression** and it is different from
    the C++'s if-then-else **statement**.

Note:
    While it is still possible to define `` min, max, abs`` math
    functions using ``if_then_else`` expression, it is highly
    **recommended** to use the provided native definitions for them
    because it allows solvers to detect specific math functions and to
    have a room for special optimizations.

Note:
    More information about the C++'s conditional expression and
    ternary operator is available at
    http://en.cppreference.com/w/cpp/language/operator_other#Conditional_operator.)""";
      } if_then_else;
      // Symbol: drake::symbolic::intersect
      struct /* intersect */ {
        // Source: drake/common/symbolic_variables.h:176
        const char* doc =
R"""(Returns the intersection of ``vars1`` and ``vars2``.

This function has a time complexity of ``O(N₁ + N₂)`` where ``N₁`` and
``N₂`` are the size of ``vars1`` and ``vars2`` respectively.)""";
      } intersect;
      // Symbol: drake::symbolic::is_abs
      struct /* is_abs */ {
        // Source: drake/common/symbolic_expression.h:654
        const char* doc_1args_e = R"""(Checks if ``e`` is an abs expression.)""";
        // Source: drake/common/symbolic_expression_cell.h:832
        const char* doc_1args_c =
R"""(Checks if ``c`` is an absolute-value-function expression.)""";
      } is_abs;
      // Symbol: drake::symbolic::is_acos
      struct /* is_acos */ {
        // Source: drake/common/symbolic_expression.h:670
        const char* doc_1args_e =
R"""(Checks if ``e`` is an arccosine expression.)""";
        // Source: drake/common/symbolic_expression_cell.h:848
        const char* doc_1args_c =
R"""(Checks if ``c`` is an arccosine expression.)""";
      } is_acos;
      // Symbol: drake::symbolic::is_addition
      struct /* is_addition */ {
        // Source: drake/common/symbolic_expression.h:646
        const char* doc_1args_e =
R"""(Checks if ``e`` is an addition expression.)""";
        // Source: drake/common/symbolic_expression_cell.h:824
        const char* doc_1args_c =
R"""(Checks if ``c`` is an addition expression.)""";
      } is_addition;
      // Symbol: drake::symbolic::is_asin
      struct /* is_asin */ {
        // Source: drake/common/symbolic_expression.h:668
        const char* doc_1args_e =
R"""(Checks if ``e`` is an arcsine expression.)""";
        // Source: drake/common/symbolic_expression_cell.h:846
        const char* doc_1args_c =
R"""(Checks if ``c`` is an arcsine expression.)""";
      } is_asin;
      // Symbol: drake::symbolic::is_atan
      struct /* is_atan */ {
        // Source: drake/common/symbolic_expression.h:672
        const char* doc_1args_e =
R"""(Checks if ``e`` is an arctangent expression.)""";
        // Source: drake/common/symbolic_expression_cell.h:850
        const char* doc_1args_c =
R"""(Checks if ``c`` is an arctangent expression.)""";
      } is_atan;
      // Symbol: drake::symbolic::is_atan2
      struct /* is_atan2 */ {
        // Source: drake/common/symbolic_expression.h:674
        const char* doc_1args_e =
R"""(Checks if ``e`` is an arctangent2 expression.)""";
        // Source: drake/common/symbolic_expression_cell.h:852
        const char* doc_1args_c =
R"""(Checks if ``c`` is a arctangent2 expression.)""";
      } is_atan2;
      // Symbol: drake::symbolic::is_ceil
      struct /* is_ceil */ {
        // Source: drake/common/symbolic_expression.h:686
        const char* doc_1args_e = R"""(Checks if ``e`` is a ceil expression.)""";
        // Source: drake/common/symbolic_expression_cell.h:864
        const char* doc_1args_c = R"""(Checks if ``c`` is a ceil expression.)""";
      } is_ceil;
      // Symbol: drake::symbolic::is_conjunction
      struct /* is_conjunction */ {
        // Source: drake/common/symbolic_formula.h:443
        const char* doc = R"""(Checks if ``f`` is a conjunction (∧).)""";
      } is_conjunction;
      // Symbol: drake::symbolic::is_constant
      struct /* is_constant */ {
        // Source: drake/common/symbolic_expression.h:630
        const char* doc_1args_e =
R"""(Checks if ``e`` is a constant expression.)""";
        // Source: drake/common/symbolic_expression.h:632
        const char* doc_2args_e_v =
R"""(Checks if ``e`` is a constant expression representing ``v``.)""";
        // Source: drake/common/symbolic_expression_cell.h:820
        const char* doc_1args_c =
R"""(Checks if ``c`` is a constant expression.)""";
      } is_constant;
      // Symbol: drake::symbolic::is_cos
      struct /* is_cos */ {
        // Source: drake/common/symbolic_expression.h:664
        const char* doc_1args_e = R"""(Checks if ``e`` is a cosine expression.)""";
        // Source: drake/common/symbolic_expression_cell.h:842
        const char* doc_1args_c = R"""(Checks if ``c`` is a cosine expression.)""";
      } is_cos;
      // Symbol: drake::symbolic::is_cosh
      struct /* is_cosh */ {
        // Source: drake/common/symbolic_expression.h:678
        const char* doc_1args_e =
R"""(Checks if ``e`` is a hyperbolic-cosine expression.)""";
        // Source: drake/common/symbolic_expression_cell.h:856
        const char* doc_1args_c =
R"""(Checks if ``c`` is a hyperbolic-cosine expression.)""";
      } is_cosh;
      // Symbol: drake::symbolic::is_disjunction
      struct /* is_disjunction */ {
        // Source: drake/common/symbolic_formula.h:445
        const char* doc = R"""(Checks if ``f`` is a disjunction (∨).)""";
      } is_disjunction;
      // Symbol: drake::symbolic::is_division
      struct /* is_division */ {
        // Source: drake/common/symbolic_expression.h:650
        const char* doc_1args_e =
R"""(Checks if ``e`` is a division expression.)""";
        // Source: drake/common/symbolic_expression_cell.h:828
        const char* doc_1args_c =
R"""(Checks if ``c`` is a division expression.)""";
      } is_division;
      // Symbol: drake::symbolic::is_equal_to
      struct /* is_equal_to */ {
        // Source: drake/common/symbolic_formula.h:429
        const char* doc =
R"""(Checks if ``f`` is a formula representing equality (==).)""";
      } is_equal_to;
      // Symbol: drake::symbolic::is_exp
      struct /* is_exp */ {
        // Source: drake/common/symbolic_expression.h:656
        const char* doc_1args_e = R"""(Checks if ``e`` is an exp expression.)""";
        // Source: drake/common/symbolic_expression_cell.h:834
        const char* doc_1args_c = R"""(Checks if ``c`` is an exp expression.)""";
      } is_exp;
      // Symbol: drake::symbolic::is_false
      struct /* is_false */ {
        // Source: drake/common/symbolic_formula.h:423
        const char* doc =
R"""(Checks if ``f`` is structurally equal to False formula.)""";
      } is_false;
      // Symbol: drake::symbolic::is_floor
      struct /* is_floor */ {
        // Source: drake/common/symbolic_expression.h:688
        const char* doc_1args_e = R"""(Checks if ``e`` is a floor expression.)""";
        // Source: drake/common/symbolic_expression_cell.h:866
        const char* doc_1args_c = R"""(Checks if ``c`` is a floor expression.)""";
      } is_floor;
      // Symbol: drake::symbolic::is_forall
      struct /* is_forall */ {
        // Source: drake/common/symbolic_formula.h:451
        const char* doc =
R"""(Checks if ``f`` is a Forall formula (∀).)""";
      } is_forall;
      // Symbol: drake::symbolic::is_greater_than
      struct /* is_greater_than */ {
        // Source: drake/common/symbolic_formula.h:433
        const char* doc =
R"""(Checks if ``f`` is a formula representing greater-than (>).)""";
      } is_greater_than;
      // Symbol: drake::symbolic::is_greater_than_or_equal_to
      struct /* is_greater_than_or_equal_to */ {
        // Source: drake/common/symbolic_formula.h:435
        const char* doc =
R"""(Checks if ``f`` is a formula representing greater-than-or-equal-to
(>=).)""";
      } is_greater_than_or_equal_to;
      // Symbol: drake::symbolic::is_if_then_else
      struct /* is_if_then_else */ {
        // Source: drake/common/symbolic_expression.h:690
        const char* doc_1args_e =
R"""(Checks if ``e`` is an if-then-else expression.)""";
        // Source: drake/common/symbolic_expression_cell.h:868
        const char* doc_1args_c =
R"""(Checks if ``c`` is an if-then-else expression.)""";
      } is_if_then_else;
      // Symbol: drake::symbolic::is_integer
      struct /* is_integer */ {
        // Source: drake/common/symbolic_expression_cell.h:32
        const char* doc = R"""()""";
      } is_integer;
      // Symbol: drake::symbolic::is_isnan
      struct /* is_isnan */ {
        // Source: drake/common/symbolic_formula.h:453
        const char* doc = R"""(Checks if ``f`` is an isnan formula.)""";
      } is_isnan;
      // Symbol: drake::symbolic::is_less_than
      struct /* is_less_than */ {
        // Source: drake/common/symbolic_formula.h:437
        const char* doc =
R"""(Checks if ``f`` is a formula representing less-than (<).)""";
      } is_less_than;
      // Symbol: drake::symbolic::is_less_than_or_equal_to
      struct /* is_less_than_or_equal_to */ {
        // Source: drake/common/symbolic_formula.h:439
        const char* doc =
R"""(Checks if ``f`` is a formula representing less-than-or-equal-to (<=).)""";
      } is_less_than_or_equal_to;
      // Symbol: drake::symbolic::is_log
      struct /* is_log */ {
        // Source: drake/common/symbolic_expression.h:652
        const char* doc_1args_e = R"""(Checks if ``e`` is a log expression.)""";
        // Source: drake/common/symbolic_expression_cell.h:830
        const char* doc_1args_c = R"""(Checks if ``c`` is a log expression.)""";
      } is_log;
      // Symbol: drake::symbolic::is_max
      struct /* is_max */ {
        // Source: drake/common/symbolic_expression.h:684
        const char* doc_1args_e = R"""(Checks if ``e`` is a max expression.)""";
        // Source: drake/common/symbolic_expression_cell.h:862
        const char* doc_1args_c = R"""(Checks if ``c`` is a max expression.)""";
      } is_max;
      // Symbol: drake::symbolic::is_min
      struct /* is_min */ {
        // Source: drake/common/symbolic_expression.h:682
        const char* doc_1args_e = R"""(Checks if ``e`` is a min expression.)""";
        // Source: drake/common/symbolic_expression_cell.h:860
        const char* doc_1args_c = R"""(Checks if ``c`` is a min expression.)""";
      } is_min;
      // Symbol: drake::symbolic::is_multiplication
      struct /* is_multiplication */ {
        // Source: drake/common/symbolic_expression.h:648
        const char* doc_1args_e =
R"""(Checks if ``e`` is a multiplication expression.)""";
        // Source: drake/common/symbolic_expression_cell.h:826
        const char* doc_1args_c =
R"""(Checks if ``c`` is an multiplication expression.)""";
      } is_multiplication;
      // Symbol: drake::symbolic::is_nan
      struct /* is_nan */ {
        // Source: drake/common/symbolic_expression.h:642
        const char* doc = R"""(Checks if ``e`` is NaN.)""";
      } is_nan;
      // Symbol: drake::symbolic::is_nary
      struct /* is_nary */ {
        // Source: drake/common/symbolic_formula.h:447
        const char* doc =
R"""(Checks if ``f`` is a n-ary formula ({∧, ∨}).)""";
      } is_nary;
      // Symbol: drake::symbolic::is_neg_one
      struct /* is_neg_one */ {
        // Source: drake/common/symbolic_expression.h:638
        const char* doc = R"""(Checks if ``e`` is -1.0.)""";
      } is_neg_one;
      // Symbol: drake::symbolic::is_negation
      struct /* is_negation */ {
        // Source: drake/common/symbolic_formula.h:449
        const char* doc = R"""(Checks if ``f`` is a negation (¬).)""";
      } is_negation;
      // Symbol: drake::symbolic::is_non_negative_integer
      struct /* is_non_negative_integer */ {
        // Source: drake/common/symbolic_expression_cell.h:38
        const char* doc = R"""()""";
      } is_non_negative_integer;
      // Symbol: drake::symbolic::is_not_equal_to
      struct /* is_not_equal_to */ {
        // Source: drake/common/symbolic_formula.h:431
        const char* doc =
R"""(Checks if ``f`` is a formula representing disequality (!=).)""";
      } is_not_equal_to;
      // Symbol: drake::symbolic::is_one
      struct /* is_one */ {
        // Source: drake/common/symbolic_expression.h:636
        const char* doc = R"""(Checks if ``e`` is 1.0.)""";
      } is_one;
      // Symbol: drake::symbolic::is_positive_integer
      struct /* is_positive_integer */ {
        // Source: drake/common/symbolic_expression_cell.h:35
        const char* doc = R"""()""";
      } is_positive_integer;
      // Symbol: drake::symbolic::is_positive_semidefinite
      struct /* is_positive_semidefinite */ {
        // Source: drake/common/symbolic_formula.h:455
        const char* doc_was_unable_to_choose_unambiguous_names =
R"""(Checks if ``f`` is a positive-semidefinite formula.)""";
      } is_positive_semidefinite;
      // Symbol: drake::symbolic::is_pow
      struct /* is_pow */ {
        // Source: drake/common/symbolic_expression.h:660
        const char* doc_1args_e =
R"""(Checks if ``e`` is a power-function expression.)""";
        // Source: drake/common/symbolic_expression_cell.h:838
        const char* doc_1args_c =
R"""(Checks if ``c`` is a power-function expression.)""";
      } is_pow;
      // Symbol: drake::symbolic::is_relational
      struct /* is_relational */ {
        // Source: drake/common/symbolic_formula.h:441
        const char* doc =
R"""(Checks if ``f`` is a relational formula ({==, !=, >, >=, <, <=}).)""";
      } is_relational;
      // Symbol: drake::symbolic::is_sin
      struct /* is_sin */ {
        // Source: drake/common/symbolic_expression.h:662
        const char* doc_1args_e = R"""(Checks if ``e`` is a sine expression.)""";
        // Source: drake/common/symbolic_expression_cell.h:840
        const char* doc_1args_c = R"""(Checks if ``c`` is a sine expression.)""";
      } is_sin;
      // Symbol: drake::symbolic::is_sinh
      struct /* is_sinh */ {
        // Source: drake/common/symbolic_expression.h:676
        const char* doc_1args_e =
R"""(Checks if ``e`` is a hyperbolic-sine expression.)""";
        // Source: drake/common/symbolic_expression_cell.h:854
        const char* doc_1args_c =
R"""(Checks if ``c`` is a hyperbolic-sine expression.)""";
      } is_sinh;
      // Symbol: drake::symbolic::is_sqrt
      struct /* is_sqrt */ {
        // Source: drake/common/symbolic_expression.h:658
        const char* doc_1args_e =
R"""(Checks if ``e`` is a square-root expression.)""";
        // Source: drake/common/symbolic_expression_cell.h:836
        const char* doc_1args_c =
R"""(Checks if ``c`` is a square-root expression.)""";
      } is_sqrt;
      // Symbol: drake::symbolic::is_tan
      struct /* is_tan */ {
        // Source: drake/common/symbolic_expression.h:666
        const char* doc_1args_e =
R"""(Checks if ``e`` is a tangent expression.)""";
        // Source: drake/common/symbolic_expression_cell.h:844
        const char* doc_1args_c =
R"""(Checks if ``c`` is a tangent expression.)""";
      } is_tan;
      // Symbol: drake::symbolic::is_tanh
      struct /* is_tanh */ {
        // Source: drake/common/symbolic_expression.h:680
        const char* doc_1args_e =
R"""(Checks if ``e`` is a hyperbolic-tangent expression.)""";
        // Source: drake/common/symbolic_expression_cell.h:858
        const char* doc_1args_c =
R"""(Checks if ``c`` is a hyperbolic-tangent expression.)""";
      } is_tanh;
      // Symbol: drake::symbolic::is_true
      struct /* is_true */ {
        // Source: drake/common/symbolic_formula.h:425
        const char* doc =
R"""(Checks if ``f`` is structurally equal to True formula.)""";
      } is_true;
      // Symbol: drake::symbolic::is_two
      struct /* is_two */ {
        // Source: drake/common/symbolic_expression.h:640
        const char* doc = R"""(Checks if ``e`` is 2.0.)""";
      } is_two;
      // Symbol: drake::symbolic::is_uninterpreted_function
      struct /* is_uninterpreted_function */ {
        // Source: drake/common/symbolic_expression.h:692
        const char* doc_1args_e =
R"""(Checks if ``e`` is an uninterpreted-function expression.)""";
        // Source: drake/common/symbolic_expression_cell.h:870
        const char* doc_1args_c =
R"""(Checks if ``c`` is an uninterpreted-function expression.)""";
      } is_uninterpreted_function;
      // Symbol: drake::symbolic::is_variable
      struct /* is_variable */ {
        // Source: drake/common/symbolic_expression.h:644
        const char* doc_1args_e =
R"""(Checks if ``e`` is a variable expression.)""";
        // Source: drake/common/symbolic_expression_cell.h:822
        const char* doc_1args_c =
R"""(Checks if ``c`` is a variable expression.)""";
        // Source: drake/common/symbolic_formula.h:427
        const char* doc_1args_f = R"""(Checks if ``f`` is a variable formula.)""";
      } is_variable;
      // Symbol: drake::symbolic::is_zero
      struct /* is_zero */ {
        // Source: drake/common/symbolic_expression.h:634
        const char* doc = R"""(Checks if ``e`` is 0.0.)""";
      } is_zero;
      // Symbol: drake::symbolic::isfinite
      struct /* isfinite */ {
        // Source: drake/common/symbolic_formula.h:335
        const char* doc =
R"""(Returns a Formula determining if the given expression ``e`` has a
finite value.

Raises:
    RuntimeError if NaN is detected during evaluation.)""";
      } isfinite;
      // Symbol: drake::symbolic::isinf
      struct /* isinf */ {
        // Source: drake/common/symbolic_formula.h:329
        const char* doc =
R"""(Returns a Formula determining if the given expression ``e`` is a
positive or negative infinity.

Raises:
    RuntimeError if NaN is detected during evaluation.)""";
      } isinf;
      // Symbol: drake::symbolic::isnan
      struct /* isnan */ {
        // Source: drake/common/symbolic_formula.h:323
        const char* doc =
R"""(Returns a Formula for the predicate isnan(e) to the given expression.
This serves as the argument-dependent lookup related to
std::isnan(double).

When this formula is evaluated, there are two possible outcomes: -
Returns false if the e.Evaluate() is not NaN. - Throws RuntimeError if
NaN is detected during evaluation. Note that the evaluation of
``isnan(e)`` never returns true.)""";
      } isnan;
      // Symbol: drake::symbolic::log
      struct /* log */ {
        // Source: drake/common/symbolic_expression.h:594
        const char* doc = R"""()""";
      } log;
      // Symbol: drake::symbolic::make_conjunction
      struct /* make_conjunction */ {
        // Source: drake/common/symbolic_formula.h:285
        const char* doc =
R"""(Returns a conjunction of ``formulas``. It performs the following
simplification:

- make_conjunction({}) returns True.
- make_conjunction({f₁}) returns f₁.
- If False ∈ ``formulas``, it returns False.
- If True ∈ ``formulas``, it will not appear in the return value.
- Nested conjunctions will be flattened. For example, make_conjunction({f₁,
  f₂ ∧ f₃}) returns f₁ ∧ f₂ ∧ f₃.)""";
      } make_conjunction;
      // Symbol: drake::symbolic::make_disjunction
      struct /* make_disjunction */ {
        // Source: drake/common/symbolic_formula.h:301
        const char* doc =
R"""(Returns a disjunction of ``formulas``. It performs the following
simplification:

- make_disjunction({}) returns False.
- make_disjunction({f₁}) returns f₁.
- If True ∈ ``formulas``, it returns True.
- If False ∈ ``formulas``, it will not appear in the return value.
- Nested disjunctions will be flattened. For example, make_disjunction({f₁,
  f₂ ∨ f₃}) returns f₁ ∨ f₂ ∨ f₃.)""";
      } make_disjunction;
      // Symbol: drake::symbolic::max
      struct /* max */ {
        // Source: drake/common/symbolic_expression.h:610
        const char* doc = R"""()""";
      } max;
      // Symbol: drake::symbolic::min
      struct /* min */ {
        // Source: drake/common/symbolic_expression.h:609
        const char* doc = R"""()""";
      } min;
      // Symbol: drake::symbolic::operator!
      struct /* operator_lnot */ {
        // Source: drake/common/symbolic_formula.h:306
        const char* doc = R"""()""";
      } operator_lnot;
      // Symbol: drake::symbolic::operator!=
      struct /* operator_ne */ {
        // Source: drake/common/symbolic_formula.h:309
        const char* doc_was_unable_to_choose_unambiguous_names = R"""()""";
      } operator_ne;
      // Symbol: drake::symbolic::operator&&
      struct /* operator_land */ {
        // Source: drake/common/symbolic_formula.h:286
        const char* doc = R"""()""";
      } operator_land;
      // Symbol: drake::symbolic::operator*
      struct /* operator_mul */ {
        // Source: drake/common/symbolic_chebyshev_basis_element.h:133
        const char* doc_was_unable_to_choose_unambiguous_names =
R"""(Returns the product of two Chebyshev basis elements. Since Tₘ(x) *
Tₙ(x) = 0.5 (Tₘ₊ₙ(x) + Tₘ₋ₙ(x)) if m >= n, the product of Chebyshev
basis elements is the weighted sum of several Chebyshev basis
elements. For example T₁(x)T₂(y) * T₃(x)T₁(y) = 0.25*(T₄(x)T₃(y) +
T₂(x)T₃(y) + T₄(x)T₁(y) + T₂(x)T₁(y))

Returns:
    the result of the product, from each ChebyshevBasisElement to its
    coefficient. In the example above, it returns (T₄(x)T₃(y) ->
    0.25), (T₂(x)T₃(y) -> 0.25), (T₄(x)T₁(y) -> 0.25) and (T₂(x)T₁(y)
    -> 0.25))""";
      } operator_mul;
      // Symbol: drake::symbolic::operator*=
      struct /* operator_imul */ {
        // Source: drake/common/symbolic_expression.h:589
        const char* doc = R"""()""";
      } operator_imul;
      // Symbol: drake::symbolic::operator+
      struct /* operator_add */ {
        // Source: drake/common/symbolic_expression.h:582
        const char* doc_1args_e = R"""(Provides unary plus operator.)""";
        // Source: drake/common/symbolic_variables.h:154
        const char* doc_2args_vars1_vars2 =
R"""(Returns set-union of ``var1`` and ``var2``.)""";
        // Source: drake/common/symbolic_variables.h:156
        const char* doc_2args_vars_var =
R"""(Returns set-union of ``vars`` and {``var``}.)""";
        // Source: drake/common/symbolic_variables.h:158
        const char* doc_2args_var_vars =
R"""(Returns set-union of {``var``} and ``vars``.)""";
      } operator_add;
      // Symbol: drake::symbolic::operator+=
      struct /* operator_iadd */ {
        // Source: drake/common/symbolic_variables.h:149
        const char* doc_2args_vars1_vars2 =
R"""(Updates ``var1`` with the result of set-union(``var1``, ``var2)``.)""";
        // Source: drake/common/symbolic_variables.h:152
        const char* doc_2args_vars_var =
R"""(Updates ``vars`` with the result of set-union(``vars``, { ``var`` }).)""";
      } operator_iadd;
      // Symbol: drake::symbolic::operator-
      struct /* operator_sub */ {
        // Source: drake/common/symbolic_expression.h:586
        const char* doc_1args_e = R"""(Provides unary minus operator.)""";
        // Source: drake/common/symbolic_polynomial.h:257
        const char* doc_1args_p = R"""(Unary minus operation for polynomial.)""";
        // Source: drake/common/symbolic_variables.h:167
        const char* doc_2args_vars1_vars2 = R"""(Returns set-minus(``var1``, ``vars2)``.)""";
        // Source: drake/common/symbolic_variables.h:169
        const char* doc_2args_vars_var =
R"""(Returns set-minus(``vars``, { ``var`` }).)""";
      } operator_sub;
      // Symbol: drake::symbolic::operator-=
      struct /* operator_isub */ {
        // Source: drake/common/symbolic_variables.h:162
        const char* doc_2args_vars1_vars2 =
R"""(Updates ``var1`` with the result of set-minus(``var1``, ``var2)``.)""";
        // Source: drake/common/symbolic_variables.h:165
        const char* doc_2args_vars_var =
R"""(Updates ``vars`` with the result of set-minus(``vars``, {``var``}).)""";
      } operator_isub;
      // Symbol: drake::symbolic::operator/
      struct /* operator_div */ {
        // Source: drake/common/symbolic_generic_polynomial.h:476
        const char* doc = R"""(Returns ``p / v``.)""";
      } operator_div;
      // Symbol: drake::symbolic::operator/=
      struct /* operator_idiv */ {
        // Source: drake/common/symbolic_expression.h:592
        const char* doc = R"""()""";
      } operator_idiv;
      // Symbol: drake::symbolic::operator<
      struct /* operator_lt */ {
        // Source: drake/common/symbolic_expression.h:72
        const char* doc_was_unable_to_choose_unambiguous_names = R"""(Total ordering between ExpressionKinds.)""";
      } operator_lt;
      // Symbol: drake::symbolic::operator<=
      struct /* operator_le */ {
        // Source: drake/common/symbolic_formula.h:311
        const char* doc_was_unable_to_choose_unambiguous_names = R"""()""";
      } operator_le;
      // Symbol: drake::symbolic::operator>
      struct /* operator_gt */ {
        // Source: drake/common/symbolic_formula.h:312
        const char* doc_was_unable_to_choose_unambiguous_names = R"""()""";
      } operator_gt;
      // Symbol: drake::symbolic::operator>=
      struct /* operator_ge */ {
        // Source: drake/common/symbolic_formula.h:313
        const char* doc_was_unable_to_choose_unambiguous_names = R"""()""";
      } operator_ge;
      // Symbol: drake::symbolic::operator||
      struct /* operator_lor */ {
        // Source: drake/common/symbolic_formula.h:302
        const char* doc = R"""()""";
      } operator_lor;
      // Symbol: drake::symbolic::positive_semidefinite
      struct /* positive_semidefinite */ {
        // Source: drake/common/symbolic_formula.h:349
        const char* doc_was_unable_to_choose_unambiguous_names =
R"""(Returns a symbolic formula constraining ``m`` to be a
positive-semidefinite matrix. By definition, a symmetric matrix ``m``
is positive-semidefinte if xᵀ m x ≥ 0 for all vector x ∈ ℝⁿ.

Raises:
    RuntimeError if ``m`` is not symmetric.

Note:
    This method checks if ``m`` is symmetric, which can be costly. If
    you want to avoid it, please consider using
    ``positive_semidefinite(m.triangularView<Eigen::Lower>())`` or
    ``positive_semidefinite(m.triangularView<Eigen::Upper>())``
    instead of ``positive_semidefinite(m)``.)""";
      } positive_semidefinite;
      // Symbol: drake::symbolic::pow
      struct /* pow */ {
        // Source: drake/common/symbolic_expression.h:598
        const char* doc_was_unable_to_choose_unambiguous_names = R"""()""";
      } pow;
      // Symbol: drake::symbolic::sin
      struct /* sin */ {
        // Source: drake/common/symbolic_expression.h:599
        const char* doc = R"""()""";
      } sin;
      // Symbol: drake::symbolic::sinh
      struct /* sinh */ {
        // Source: drake/common/symbolic_expression.h:606
        const char* doc = R"""()""";
      } sinh;
      // Symbol: drake::symbolic::sqrt
      struct /* sqrt */ {
        // Source: drake/common/symbolic_expression.h:597
        const char* doc = R"""()""";
      } sqrt;
      // Symbol: drake::symbolic::swap
      struct /* swap */ {
        // Source: drake/common/symbolic_expression.h:625
        const char* doc = R"""()""";
      } swap;
      // Symbol: drake::symbolic::tan
      struct /* tan */ {
        // Source: drake/common/symbolic_expression.h:601
        const char* doc = R"""()""";
      } tan;
      // Symbol: drake::symbolic::tanh
      struct /* tanh */ {
        // Source: drake/common/symbolic_expression.h:608
        const char* doc = R"""()""";
      } tanh;
      // Symbol: drake::symbolic::to_abs
      struct /* to_abs */ {
        // Source: drake/common/symbolic_expression_cell.h:929
        const char* doc =
R"""(Casts ``expr_ptr`` to ``shared_ptr``<ExpressionAbs>.

Precondition:
    ``*expr_ptr`` is of ``ExpressionAbs``.)""";
      } to_abs;
      // Symbol: drake::symbolic::to_acos
      struct /* to_acos */ {
        // Source: drake/common/symbolic_expression_cell.h:971
        const char* doc =
R"""(Casts ``expr_ptr`` to ``shared_ptr``<ExpressionAcos>.

Precondition:
    ``*expr_ptr`` is of ``ExpressionAcos``.)""";
      } to_acos;
      // Symbol: drake::symbolic::to_addition
      struct /* to_addition */ {
        // Source: drake/common/symbolic_expression_cell.h:899
        const char* doc =
R"""(Casts ``expr_ptr`` to ``shared_ptr``<ExpressionAdd>.

Precondition:
    ``*expr_ptr`` is of ``ExpressionAdd``.)""";
      } to_addition;
      // Symbol: drake::symbolic::to_asin
      struct /* to_asin */ {
        // Source: drake/common/symbolic_expression_cell.h:965
        const char* doc =
R"""(Casts ``expr_ptr`` to ``shared_ptr``<ExpressionAsin>.

Precondition:
    ``*expr_ptr`` is of ``ExpressionAsin``.)""";
      } to_asin;
      // Symbol: drake::symbolic::to_atan
      struct /* to_atan */ {
        // Source: drake/common/symbolic_expression_cell.h:977
        const char* doc =
R"""(Casts ``expr_ptr`` to ``shared_ptr``<ExpressionAtan>.

Precondition:
    ``*expr_ptr`` is of ``ExpressionAtan``.)""";
      } to_atan;
      // Symbol: drake::symbolic::to_atan2
      struct /* to_atan2 */ {
        // Source: drake/common/symbolic_expression_cell.h:983
        const char* doc =
R"""(Casts ``expr_ptr`` to ``shared_ptr``<ExpressionAtan2>.

Precondition:
    ``*expr_ptr`` is of ``ExpressionAtan2``.)""";
      } to_atan2;
      // Symbol: drake::symbolic::to_binary
      struct /* to_binary */ {
        // Source: drake/common/symbolic_expression_cell.h:893
        const char* doc =
R"""(Casts ``expr_ptr`` to ``shared_ptr``<BinaryExpressionCell>.

Precondition:
    ``*expr_ptr`` is of ``BinaryExpressionCell``.)""";
      } to_binary;
      // Symbol: drake::symbolic::to_ceil
      struct /* to_ceil */ {
        // Source: drake/common/symbolic_expression_cell.h:1019
        const char* doc =
R"""(Casts ``expr_ptr`` to ``shared_ptr``<ExpressionCeiling>.

Precondition:
    ``*expr_ptr`` is of ``ExpressionCeiling``.)""";
      } to_ceil;
      // Symbol: drake::symbolic::to_conjunction
      struct /* to_conjunction */ {
        // Source: drake/common/symbolic_formula_cell.h:532
        const char* doc =
R"""(Casts ``f_ptr`` to ``shared_ptr``<const FormulaAnd>.

Precondition:
    ``is_conjunction(*f_ptr)`` is true.)""";
      } to_conjunction;
      // Symbol: drake::symbolic::to_constant
      struct /* to_constant */ {
        // Source: drake/common/symbolic_expression_cell.h:875
        const char* doc =
R"""(Casts ``expr_ptr`` to ``shared_ptr``<ExpressionConstant>.

Precondition:
    ``*expr_ptr`` is of ``ExpressionConstant``.)""";
      } to_constant;
      // Symbol: drake::symbolic::to_cos
      struct /* to_cos */ {
        // Source: drake/common/symbolic_expression_cell.h:953
        const char* doc =
R"""(Casts ``expr_ptr`` to ``shared_ptr``<ExpressionCos>.

Precondition:
    ``*expr_ptr`` is of ``ExpressionCos``.)""";
      } to_cos;
      // Symbol: drake::symbolic::to_cosh
      struct /* to_cosh */ {
        // Source: drake/common/symbolic_expression_cell.h:995
        const char* doc =
R"""(Casts ``expr_ptr`` to ``shared_ptr``<ExpressionCosh>.

Precondition:
    ``*expr_ptr`` is of ``ExpressionCosh``.)""";
      } to_cosh;
      // Symbol: drake::symbolic::to_disjunction
      struct /* to_disjunction */ {
        // Source: drake/common/symbolic_formula_cell.h:538
        const char* doc =
R"""(Casts ``f_ptr`` to ``shared_ptr``<const FormulaOr>.

Precondition:
    ``is_disjunction(*f_ptr)`` is true.)""";
      } to_disjunction;
      // Symbol: drake::symbolic::to_division
      struct /* to_division */ {
        // Source: drake/common/symbolic_expression_cell.h:911
        const char* doc =
R"""(Casts ``expr_ptr`` to ``shared_ptr``<ExpressionDiv>.

Precondition:
    ``*expr_ptr`` is of ``ExpressionDiv``.)""";
      } to_division;
      // Symbol: drake::symbolic::to_equal_to
      struct /* to_equal_to */ {
        // Source: drake/common/symbolic_formula_cell.h:496
        const char* doc =
R"""(Casts ``f_ptr`` to ``shared_ptr``<const FormulaEq>.

Precondition:
    ``is_equal_to(*f_ptr)`` is true.)""";
      } to_equal_to;
      // Symbol: drake::symbolic::to_exp
      struct /* to_exp */ {
        // Source: drake/common/symbolic_expression_cell.h:923
        const char* doc =
R"""(Casts ``expr_ptr`` to ``shared_ptr``<ExpressionExp>.

Precondition:
    ``*expr_ptr`` is of ``ExpressionExp``.)""";
      } to_exp;
      // Symbol: drake::symbolic::to_false
      struct /* to_false */ {
        // Source: drake/common/symbolic_formula_cell.h:472
        const char* doc =
R"""(Casts ``f_ptr`` to ``shared_ptr``<const FormulaFalse>.

Precondition:
    ``is_false(*f_ptr)`` is true.)""";
      } to_false;
      // Symbol: drake::symbolic::to_floor
      struct /* to_floor */ {
        // Source: drake/common/symbolic_expression_cell.h:1025
        const char* doc =
R"""(Casts ``expr_ptr`` to ``shared_ptr``<ExpressionFloor>.

Precondition:
    ``*expr_ptr`` is of ``ExpressionFloor``.)""";
      } to_floor;
      // Symbol: drake::symbolic::to_forall
      struct /* to_forall */ {
        // Source: drake/common/symbolic_formula_cell.h:556
        const char* doc =
R"""(Casts ``f_ptr`` to ``shared_ptr``<const FormulaForall>.

Precondition:
    ``is_forall(*f_ptr)`` is true.)""";
      } to_forall;
      // Symbol: drake::symbolic::to_greater_than
      struct /* to_greater_than */ {
        // Source: drake/common/symbolic_formula_cell.h:508
        const char* doc =
R"""(Casts ``f_ptr`` to ``shared_ptr``<const FormulaGt>.

Precondition:
    ``is_greater_than(*f_ptr)`` is true.)""";
      } to_greater_than;
      // Symbol: drake::symbolic::to_greater_than_or_equal_to
      struct /* to_greater_than_or_equal_to */ {
        // Source: drake/common/symbolic_formula_cell.h:514
        const char* doc =
R"""(Casts ``f_ptr`` to ``shared_ptr``<const FormulaGeq>.

Precondition:
    ``is_greater_than_or_equal_to(*f_ptr)`` is true.)""";
      } to_greater_than_or_equal_to;
      // Symbol: drake::symbolic::to_if_then_else
      struct /* to_if_then_else */ {
        // Source: drake/common/symbolic_expression_cell.h:1031
        const char* doc =
R"""(Casts ``expr_ptr`` to ``shared_ptr``<ExpressionIfThenElse>.

Precondition:
    ``*expr_ptr`` is of ``ExpressionIfThenElse``.)""";
      } to_if_then_else;
      // Symbol: drake::symbolic::to_isnan
      struct /* to_isnan */ {
        // Source: drake/common/symbolic_formula_cell.h:562
        const char* doc =
R"""(Casts ``f_ptr`` to ``shared_ptr``<const FormulaIsnan>.

Precondition:
    ``is_isnan(*f_ptr)`` is true.)""";
      } to_isnan;
      // Symbol: drake::symbolic::to_less_than
      struct /* to_less_than */ {
        // Source: drake/common/symbolic_formula_cell.h:520
        const char* doc =
R"""(Casts ``f_ptr`` to ``shared_ptr``<const FormulaLt>.

Precondition:
    ``is_less_than(*f_ptr)`` is true.)""";
      } to_less_than;
      // Symbol: drake::symbolic::to_less_than_or_equal_to
      struct /* to_less_than_or_equal_to */ {
        // Source: drake/common/symbolic_formula_cell.h:526
        const char* doc =
R"""(Casts ``f_ptr`` to ``shared_ptr``<const FormulaLeq>.

Precondition:
    ``is_less_than_or_equal_to(*f_ptr)`` is true.)""";
      } to_less_than_or_equal_to;
      // Symbol: drake::symbolic::to_log
      struct /* to_log */ {
        // Source: drake/common/symbolic_expression_cell.h:917
        const char* doc =
R"""(Casts ``expr_ptr`` to ``shared_ptr``<ExpressionLog>.

Precondition:
    ``*expr_ptr`` is of ``ExpressionLog``.)""";
      } to_log;
      // Symbol: drake::symbolic::to_max
      struct /* to_max */ {
        // Source: drake/common/symbolic_expression_cell.h:1013
        const char* doc =
R"""(Casts ``expr_ptr`` to ``shared_ptr``<ExpressionMax>.

Precondition:
    ``*expr_ptr`` is of ``ExpressionMax``.)""";
      } to_max;
      // Symbol: drake::symbolic::to_min
      struct /* to_min */ {
        // Source: drake/common/symbolic_expression_cell.h:1007
        const char* doc =
R"""(Casts ``expr_ptr`` to ``shared_ptr``<ExpressionMin>.

Precondition:
    ``*expr_ptr`` is of ``ExpressionMin``.)""";
      } to_min;
      // Symbol: drake::symbolic::to_multiplication
      struct /* to_multiplication */ {
        // Source: drake/common/symbolic_expression_cell.h:905
        const char* doc =
R"""(Casts ``expr_ptr`` to ``shared_ptr``<ExpressionMul>.

Precondition:
    ``*expr_ptr`` is of ``ExpressionMul``.)""";
      } to_multiplication;
      // Symbol: drake::symbolic::to_nary
      struct /* to_nary */ {
        // Source: drake/common/symbolic_formula_cell.h:544
        const char* doc =
R"""(Casts ``f_ptr`` to ``shared_ptr``<const NaryFormulaCell>.

Precondition:
    ``is_nary(*f_ptr)`` is true.)""";
      } to_nary;
      // Symbol: drake::symbolic::to_negation
      struct /* to_negation */ {
        // Source: drake/common/symbolic_formula_cell.h:550
        const char* doc =
R"""(Casts ``f_ptr`` to ``shared_ptr``<const FormulaNot>.

Precondition:
    ``is_negation(*f_ptr)`` is true.)""";
      } to_negation;
      // Symbol: drake::symbolic::to_not_equal_to
      struct /* to_not_equal_to */ {
        // Source: drake/common/symbolic_formula_cell.h:502
        const char* doc =
R"""(Casts ``f_ptr`` to ``shared_ptr``<const FormulaNeq>.

Precondition:
    ``is_not_equal_to(*f_ptr)`` is true.)""";
      } to_not_equal_to;
      // Symbol: drake::symbolic::to_positive_semidefinite
      struct /* to_positive_semidefinite */ {
        // Source: drake/common/symbolic_formula_cell.h:568
        const char* doc =
R"""(Casts ``f_ptr`` to ``shared_ptr``<const FormulaPositiveSemidefinite>.

Precondition:
    ``is_positive_semidefinite(*f_ptr)`` is true.)""";
      } to_positive_semidefinite;
      // Symbol: drake::symbolic::to_pow
      struct /* to_pow */ {
        // Source: drake/common/symbolic_expression_cell.h:941
        const char* doc =
R"""(Casts ``expr_ptr`` to ``shared_ptr``<ExpressionPow>.

Precondition:
    ``*expr_ptr`` is of ``ExpressionPow``.)""";
      } to_pow;
      // Symbol: drake::symbolic::to_relational
      struct /* to_relational */ {
        // Source: drake/common/symbolic_formula_cell.h:490
        const char* doc =
R"""(Casts ``f_ptr`` to ``shared_ptr``<const RelationalFormulaCell>.

Precondition:
    ``is_relational(*f_ptr)`` is true.)""";
      } to_relational;
      // Symbol: drake::symbolic::to_sin
      struct /* to_sin */ {
        // Source: drake/common/symbolic_expression_cell.h:947
        const char* doc =
R"""(Casts ``expr_ptr`` to ``shared_ptr``<ExpressionSin>.

Precondition:
    ``*expr_ptr`` is of ``ExpressionSin``.)""";
      } to_sin;
      // Symbol: drake::symbolic::to_sinh
      struct /* to_sinh */ {
        // Source: drake/common/symbolic_expression_cell.h:989
        const char* doc =
R"""(Casts ``expr_ptr`` to ``shared_ptr``<ExpressionSinh>.

Precondition:
    ``*expr_ptr`` is of ``ExpressionSinh``.)""";
      } to_sinh;
      // Symbol: drake::symbolic::to_sqrt
      struct /* to_sqrt */ {
        // Source: drake/common/symbolic_expression_cell.h:935
        const char* doc =
R"""(Casts ``expr_ptr`` to ``shared_ptr``<ExpressionSqrt>.

Precondition:
    ``*expr_ptr`` is of ``ExpressionSqrt``.)""";
      } to_sqrt;
      // Symbol: drake::symbolic::to_tan
      struct /* to_tan */ {
        // Source: drake/common/symbolic_expression_cell.h:959
        const char* doc =
R"""(Casts ``expr_ptr`` to ``shared_ptr``<ExpressionTan>.

Precondition:
    ``*expr_ptr`` is of ``ExpressionTan``.)""";
      } to_tan;
      // Symbol: drake::symbolic::to_tanh
      struct /* to_tanh */ {
        // Source: drake/common/symbolic_expression_cell.h:1001
        const char* doc =
R"""(Casts ``expr_ptr`` to ``shared_ptr``<ExpressionTanh>.

Precondition:
    ``*expr_ptr`` is of ``ExpressionTanh``.)""";
      } to_tanh;
      // Symbol: drake::symbolic::to_true
      struct /* to_true */ {
        // Source: drake/common/symbolic_formula_cell.h:478
        const char* doc =
R"""(Casts ``f_ptr`` to ``shared_ptr``<const FormulaTrue>.

Precondition:
    ``is_true(*f_ptr)`` is true.)""";
      } to_true;
      // Symbol: drake::symbolic::to_unary
      struct /* to_unary */ {
        // Source: drake/common/symbolic_expression_cell.h:887
        const char* doc =
R"""(Casts ``expr_ptr`` to ``shared_ptr``<UnaryExpressionCell>.

Precondition:
    ``*expr_ptr`` is of ``UnaryExpressionCell``.)""";
      } to_unary;
      // Symbol: drake::symbolic::to_uninterpreted_function
      struct /* to_uninterpreted_function */ {
        // Source: drake/common/symbolic_expression_cell.h:1037
        const char* doc =
R"""(Casts ``expr_ptr`` to ``shared_ptr``<ExpressionUninterpretedFunction>.

Precondition:
    ``*expr_ptr`` is of ``ExpressionUninterpretedFunction``.)""";
      } to_uninterpreted_function;
      // Symbol: drake::symbolic::to_variable
      struct /* to_variable */ {
        // Source: drake/common/symbolic_expression_cell.h:881
        const char* doc_1args_expr_ptr =
R"""(Casts ``expr_ptr`` to ``shared_ptr``<ExpressionVar>.

Precondition:
    ``*expr_ptr`` is of ``ExpressionVar``.)""";
        // Source: drake/common/symbolic_formula_cell.h:484
        const char* doc_1args_f_ptr =
R"""(Casts ``f_ptr`` to ``shared_ptr``<const FormulaVar>.

Precondition:
    ``is_variable(*f_ptr)`` is true.)""";
      } to_variable;
      // Symbol: drake::symbolic::uninterpreted_function
      struct /* uninterpreted_function */ {
        // Source: drake/common/symbolic_expression.h:623
        const char* doc =
R"""(Constructs an uninterpreted-function expression with ``name`` and
``arguments``. An uninterpreted function is an opaque function that
has no other property than its name and a list of its arguments. This
is useful to applications where it is good enough to provide abstract
information of a function without exposing full details. Declaring
sparsity of a system is a typical example.)""";
      } uninterpreted_function;
    } symbolic;
    // Symbol: drake::systems
    struct /* systems */ {
      // Symbol: drake::systems::AbstractParameterIndex
      struct /* AbstractParameterIndex */ {
        // Source: drake/systems/framework/framework_common.h:66
        const char* doc =
R"""(Serves as the local index for abstract parameters within a given
System and its corresponding Context.)""";
      } AbstractParameterIndex;
      // Symbol: drake::systems::AbstractStateIndex
      struct /* AbstractStateIndex */ {
        // Source: drake/systems/framework/framework_common.h:58
        const char* doc =
R"""(Serves as the local index for abstract state variables within a given
System and its corresponding Context.)""";
      } AbstractStateIndex;
      // Symbol: drake::systems::AbstractValues
      struct /* AbstractValues */ {
        // Source: drake/systems/framework/abstract_values.h:17
        const char* doc =
R"""(AbstractValues is a container for non-numerical state and parameters.
It may or may not own the underlying data, and therefore is suitable
for both leaf Systems and diagrams.)""";
        // Symbol: drake::systems::AbstractValues::AbstractValues
        struct /* ctor */ {
          // Source: drake/systems/framework/abstract_values.h:23
          const char* doc_0args = R"""(Constructs an empty AbstractValues.)""";
          // Source: drake/systems/framework/abstract_values.h:33
          const char* doc_1args =
R"""(Constructs an AbstractValues that does not own the underlying data.)""";
        } ctor;
        // Symbol: drake::systems::AbstractValues::Clone
        struct /* Clone */ {
          // Source: drake/systems/framework/abstract_values.h:61
          const char* doc =
R"""(Returns a deep copy of all the data in this AbstractValues. The clone
will own its own data. This is true regardless of whether the data
being cloned had ownership of its data or not.)""";
        } Clone;
        // Symbol: drake::systems::AbstractValues::SetFrom
        struct /* SetFrom */ {
          // Source: drake/systems/framework/abstract_values.h:56
          const char* doc =
R"""(Copies all of the AbstractValues in ``other`` into this. Asserts if
the two are not equal in size.

Raises:
    RuntimeError if any of the elements are of incompatible type.)""";
        } SetFrom;
        // Symbol: drake::systems::AbstractValues::get_mutable_value
        struct /* get_mutable_value */ {
          // Source: drake/systems/framework/abstract_values.h:51
          const char* doc =
R"""(Returns the element of AbstractValues at the given ``index``, or
aborts if the index is out-of-bounds.)""";
        } get_mutable_value;
        // Symbol: drake::systems::AbstractValues::get_value
        struct /* get_value */ {
          // Source: drake/systems/framework/abstract_values.h:47
          const char* doc =
R"""(Returns the element of AbstractValues at the given ``index``, or
aborts if the index is out-of-bounds.)""";
        } get_value;
        // Symbol: drake::systems::AbstractValues::size
        struct /* size */ {
          // Source: drake/systems/framework/abstract_values.h:43
          const char* doc =
R"""(Returns the number of elements of AbstractValues.)""";
        } size;
      } AbstractValues;
      // Symbol: drake::systems::AddRandomInputs
      struct /* AddRandomInputs */ {
        // Source: drake/systems/primitives/random_source.h:123
        const char* doc =
R"""(For each subsystem input port in ``builder`` that is (a) not yet
connected and (b) labeled as random in the InputPort, this method will
add a new RandomSource system of the appropriate type and connect it
to the subsystem input port.

Parameter ``sampling_interval_sec``:
    interval to be used for all new sources.

Returns:
    the total number of RandomSource systems added.

See also:
    stochastic_systems)""";
      } AddRandomInputs;
      // Symbol: drake::systems::Adder
      struct /* Adder */ {
        // Source: drake/systems/primitives/adder.h:26
        const char* doc =
R"""(An adder for arbitrarily many inputs of equal size.

.. pydrake_system::

    name: Adder
    input_ports:
    - input(0)
    - ...
    - input(N-1)
    output_ports:
    - sum)""";
        // Symbol: drake::systems::Adder::Adder<T>
        struct /* ctor */ {
          // Source: drake/systems/primitives/adder.h:33
          const char* doc =
R"""(Construct an Adder System.

Parameter ``num_inputs``:
    is the number of input ports to be added.

Parameter ``size``:
    number of elements in each input and output signal.)""";
          // Source: drake/systems/primitives/adder.h:37
          const char* doc_copyconvert =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";
        } ctor;
      } Adder;
      // Symbol: drake::systems::AffineSystem
      struct /* AffineSystem */ {
        // Source: drake/systems/primitives/affine_system.h:191
        const char* doc =
R"""(A discrete OR continuous affine system (with constant coefficients).

.. pydrake_system::

    name: AffineSystem
    input_ports:
    - u(t)
    output_ports:
    - y(t)

Let ``u`` denote the input vector, ``x`` denote the state vector, and
``y`` denote the output vector.

If ``time_period > 0.0``, the affine system will have the following
discrete-time state update:

.. math:: x(t+h) = A x(t) + B u(t) + f_0,

where ``h`` is the time_period. If ``time_period == 0.0``, the affine
system will have the following continuous-time state update:

.. math:: \dot{x} = A x + B u + f_0.

In both cases, the system will have the output:

.. math:: y = C x + D u + y_0,

See also:
    LinearSystem

See also:
    MatrixGain)""";
        // Symbol: drake::systems::AffineSystem::A
        struct /* A */ {
          // Source: drake/systems/primitives/affine_system.h:236
          const char* doc_0args = R"""(@name Helper getter methods.)""";
          // Source: drake/systems/primitives/affine_system.h:247
          const char* doc_1args =
R"""(@name Implementations of TimeVaryingAffineSystem<T>'s pure virtual
methods.)""";
        } A;
        // Symbol: drake::systems::AffineSystem::AffineSystem<T>
        struct /* ctor */ {
          // Source: drake/systems/primitives/affine_system.h:210
          const char* doc_7args =
R"""(Constructs an Affine system with a fixed set of coefficient matrices
``A``, `B`,``C``, and ``D`` as well as fixed initial velocity offset
``xDot0`` and output offset ``y0``. The coefficient matrices must obey
the following dimensions : | Matrix | Num Rows | Num Columns |
|:-------:|:-----------:|:-----------:| | A | num states | num states
| | B | num states | num inputs | | C | num outputs | num states | | D
| num outputs | num inputs |

Parameter ``time_period``:
    Defines the period of the discrete time system; use
    time_period=0.0 to denote a continuous time system. $*Default:*
    0.0

Subclasses must use the protected constructor, not this one.)""";
          // Source: drake/systems/primitives/affine_system.h:220
          const char* doc_copyconvert =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";
          // Source: drake/systems/primitives/affine_system.h:261
          const char* doc_8args =
R"""(Constructor that specifies scalar-type conversion support.

Parameter ``converter``:
    scalar-type conversion support helper (i.e., AutoDiff, etc.); pass
    a default-constructed object if such support is not desired. See
    system_scalar_conversion for detailed background and examples
    related to scalar-type conversion support.)""";
        } ctor;
        // Symbol: drake::systems::AffineSystem::B
        struct /* B */ {
          // Source: drake/systems/primitives/affine_system.h:237
          const char* doc = R"""()""";
        } B;
        // Symbol: drake::systems::AffineSystem::C
        struct /* C */ {
          // Source: drake/systems/primitives/affine_system.h:239
          const char* doc = R"""()""";
        } C;
        // Symbol: drake::systems::AffineSystem::D
        struct /* D */ {
          // Source: drake/systems/primitives/affine_system.h:240
          const char* doc = R"""()""";
        } D;
        // Symbol: drake::systems::AffineSystem::MakeAffineSystem
        struct /* MakeAffineSystem */ {
          // Source: drake/systems/primitives/affine_system.h:227
          const char* doc =
R"""(Creates a unique pointer to AffineSystem<T> by decomposing
``dynamics`` and ``outputs`` using ``state_vars`` and ``input_vars``.

Raises:
    RuntimeError if either ``dynamics`` or ``outputs`` is not affine
    in ``state_vars`` and ``input_vars``.)""";
        } MakeAffineSystem;
        // Symbol: drake::systems::AffineSystem::f0
        struct /* f0 */ {
          // Source: drake/systems/primitives/affine_system.h:238
          const char* doc = R"""()""";
        } f0;
        // Symbol: drake::systems::AffineSystem::y0
        struct /* y0 */ {
          // Source: drake/systems/primitives/affine_system.h:241
          const char* doc = R"""()""";
        } y0;
      } AffineSystem;
      // Symbol: drake::systems::AntiderivativeFunction
      struct /* AntiderivativeFunction */ {
        // Source: drake/systems/analysis/antiderivative_function.h:51
        const char* doc =
R"""(A thin wrapper of the ScalarInitialValueProblem class that, in concert
with Drake's ODE initial value problem solvers ("integrators"),
provide the ability to perform quadrature on an arbitrary scalar
integrable function. That is, it allows the evaluation of an
antiderivative function F(u; 𝐤), such that F(u; 𝐤) = ∫ᵥᵘ f(x; 𝐤) dx
where f : ℝ → ℝ , u ∈ ℝ, v ∈ ℝ, 𝐤 ∈ ℝᵐ. The parameter vector 𝐤 allows
for generic function definitions, which can later be evaluated for any
instance of said vector. Also, note that 𝐤 can be understood as an
m-tuple or as an element of ℝᵐ, the vector space, depending on how it
is used by the integrable function.

See ScalarInitialValueProblem class documentation for information on
caching support and dense output usage for improved efficiency in
antiderivative function F evaluation.

For further insight into its use, consider the following examples.

- Solving the elliptic integral of the first kind
  E(φ; ξ) = ∫ᵠ √(1 - ξ² sin² θ)⁻¹ dθ becomes straightforward by defining
  f(x; 𝐤) ≜ √(1 - k₀² sin² x)⁻¹ with 𝐤 ≜ [ξ] and evaluating F(u; 𝐤) at
  u = φ.

- As the bearings in a rotating machine age over time, these are more likely
  to fail. Let γ be a random variable describing the time to first bearing
  failure, described by a family of probability density functions gᵧ(y; l)
  parameterized by bearing load l. In this context, the probability of a
  bearing under load to fail during the first N months becomes
  P(0 < γ ≤ N mo.; l) = Gᵧ(N mo.; l) - Gᵧ(0; l), where Gᵧ(y; l) is the
  family of cumulative density functions, parameterized by bearing load l,
  and G'ᵧ(y; l) = gᵧ(y; l). Therefore, defining f(x; 𝐤) ≜ gᵧ(x; k₀) with
  𝐤 ≜ [l] and evaluating F(u; 𝐤) at u = N yields the result.)""";
        // Symbol: drake::systems::AntiderivativeFunction::AntiderivativeFunction<T>
        struct /* ctor */ {
          // Source: drake/systems/analysis/antiderivative_function.h:90
          const char* doc =
R"""(Constructs the antiderivative function of the given
``integrable_function``, using ``default_values``.v as lower
integration bound if given (0 if not) and parameterized with
``default_values``.k if given (an empty vector if not) by default.

Parameter ``integrable_function``:
    The function f(x; 𝐤) to be integrated.

Parameter ``default_values``:
    The values specified by default for this function, i.e. default
    lower integration bound v ∈ ℝ and default parameter vector 𝐤 ∈ ℝᵐ.)""";
        } ctor;
        // Symbol: drake::systems::AntiderivativeFunction::Evaluate
        struct /* Evaluate */ {
          // Source: drake/systems/analysis/antiderivative_function.h:131
          const char* doc =
R"""(Evaluates the definite integral F(u; 𝐤) = ∫ᵥᵘ f(x; 𝐤) dx from the
lower integration bound v (see definition in class documentation) to
``u`` using the parameter vector 𝐤 (see definition in class
documentation) if present in ``values``, falling back to the ones
given on construction if missing.

Parameter ``u``:
    The upper integration bound.

Parameter ``values``:
    The specified values for the integration.

Returns:
    The value of the definite integral.

Precondition:
    The given upper integration bound ``u`` must be larger than or
    equal to the lower integration bound v.

Precondition:
    If given, the dimension of the parameter vector ``values``.k must
    match that of the parameter vector 𝐤 in the default specified
    values given on construction.

Raises:
    RuntimeError if any of the preconditions is not met.)""";
        } Evaluate;
        // Symbol: drake::systems::AntiderivativeFunction::IntegrableFunction
        struct /* IntegrableFunction */ {
          // Source: drake/systems/analysis/antiderivative_function.h:60
          const char* doc =
R"""(Scalar integrable function f(x; 𝐤) type.

Parameter ``x``:
    The variable of integration x ∈ ℝ .

Parameter ``k``:
    The parameter vector 𝐤 ∈ ℝᵐ.

Returns:
    The function value f(``x``; ``k)``.)""";
        } IntegrableFunction;
        // Symbol: drake::systems::AntiderivativeFunction::IntegrableFunctionContext
        struct /* IntegrableFunctionContext */ {
          // Source: drake/systems/analysis/antiderivative_function.h:66
          const char* doc =
R"""(The set of values that, along with the function being integrated,
partially specify the definite integral i.e. providing the lower
integration bound v and the parameter vector 𝐤, leaving the upper
integration bound u to be specified on evaluation.)""";
          // Symbol: drake::systems::AntiderivativeFunction::IntegrableFunctionContext::IntegrableFunctionContext
          struct /* ctor */ {
            // Source: drake/systems/analysis/antiderivative_function.h:68
            const char* doc_0args =
R"""(Default constructor that leaves all values unspecified.)""";
            // Source: drake/systems/analysis/antiderivative_function.h:73
            const char* doc_2args =
R"""(Constructor that specifies all values.

Parameter ``v_in``:
    Specified lower integration bound v.

Parameter ``k_in``:
    Specified parameter vector 𝐤.)""";
          } ctor;
          // Symbol: drake::systems::AntiderivativeFunction::IntegrableFunctionContext::k
          struct /* k */ {
            // Source: drake/systems/analysis/antiderivative_function.h:78
            const char* doc = R"""(The parameter vector 𝐤.)""";
          } k;
          // Symbol: drake::systems::AntiderivativeFunction::IntegrableFunctionContext::v
          struct /* v */ {
            // Source: drake/systems/analysis/antiderivative_function.h:77
            const char* doc = R"""(The lower integration bound v.)""";
          } v;
        } IntegrableFunctionContext;
        // Symbol: drake::systems::AntiderivativeFunction::MakeDenseEvalFunction
        struct /* MakeDenseEvalFunction */ {
          // Source: drake/systems/analysis/antiderivative_function.h:165
          const char* doc =
R"""(Evaluates and yields an approximation of the definite integral F(u; 𝐤)
= ∫ᵥᵘ f(x; 𝐤) dx for v ≤ u ≤ w, i.e. the closed interval that goes
from the lower integration bound v (see definition in class
documentation) to the uppermost integration bound ``w``, using the
parameter vector 𝐤 (see definition in class documentation) if present
in ``values``, falling back to the ones given on construction if
missing.

To this end, the wrapped IntegratorBase instance solves the integral
from v to ``w`` (i.e. advances the state x of its differential form
x'(t) = f(x; 𝐤) from v to ``w)``, creating a scalar dense output over
that [v, ``w``] interval along the way.

Parameter ``w``:
    The uppermost integration bound. Usually, v < ``w`` as an empty
    dense output would result if v = ``w``.

Parameter ``values``:
    The specified values for the integration.

Returns:
    A dense approximation to F(u; 𝐤) (that is, a function), defined
    for v ≤ u ≤ w.

Note:
    The larger the given ``w`` value is, the larger the approximated
    interval will be. See documentation of the specific dense output
    technique in use for reference on performance impact as this
    interval grows.

Precondition:
    The given uppermost integration bound ``w`` must be larger than or
    equal to the lower integration bound v.

Precondition:
    If given, the dimension of the parameter vector ``values``.k must
    match that of the parameter vector 𝐤 in the default specified
    values given on construction.

Raises:
    RuntimeError if any of the preconditions is not met.)""";
        } MakeDenseEvalFunction;
        // Symbol: drake::systems::AntiderivativeFunction::get_integrator
        struct /* get_integrator */ {
          // Source: drake/systems/analysis/antiderivative_function.h:196
          const char* doc =
R"""(Gets a reference to the internal integrator instance.)""";
        } get_integrator;
        // Symbol: drake::systems::AntiderivativeFunction::get_mutable_integrator
        struct /* get_mutable_integrator */ {
          // Source: drake/systems/analysis/antiderivative_function.h:201
          const char* doc =
R"""(Gets a mutable reference to the internal integrator instance.)""";
        } get_mutable_integrator;
        // Symbol: drake::systems::AntiderivativeFunction::reset_integrator
        struct /* reset_integrator */ {
          // Source: drake/systems/analysis/antiderivative_function.h:190
          const char* doc =
R"""(Resets the internal integrator instance.

A usage example is shown below.


::

    antiderivative_f.reset_integrator<RungeKutta2Integrator<T>>(max_step);

Parameter ``args``:
    The integrator type-specific arguments.

Returns:
    The new integrator instance.

Template parameter ``Integrator``:
    The integrator type, which must be an IntegratorBase subclass.

Template parameter ``Args``:
    The integrator specific argument types.

Warning:
    This operation invalidates pointers returned by
    AntiderivativeFunction::get_integrator() and
    AntiderivativeFunction::get_mutable_integrator().)""";
        } reset_integrator;
      } AntiderivativeFunction;
      // Symbol: drake::systems::ApplySimulatorConfig
      struct /* ApplySimulatorConfig */ {
        // Source: drake/systems/analysis/simulator_config_functions.h:55
        const char* doc =
R"""(Modifies the ``simulator`` to use the given config. (Always replaces
the Integrator with a new one; be careful not to keep old references
around.)

Parameter ``simulator``:
    On input, a valid pointer to a Simulator. On output the integretor
    for ``simulator`` is reset according to the given ``config``.

Parameter ``config``:
    Configuration to be used. Contains values for both the integrator
    and the simulator.)""";
      } ApplySimulatorConfig;
      // Symbol: drake::systems::BarycentricMeshSystem
      struct /* BarycentricMeshSystem */ {
        // Source: drake/systems/primitives/barycentric_system.h:24
        const char* doc =
R"""(A (stateless) vector system implemented as a multi-linear
(barycentric) interpolation on a mesh over the inputs.

This has many potential uses, including representing the policies that
are generated by numerical control design methods like approximate
dynamic programming.

See also:
    math::BarycentricMesh)""";
        // Symbol: drake::systems::BarycentricMeshSystem::BarycentricMeshSystem<T>
        struct /* ctor */ {
          // Source: drake/systems/primitives/barycentric_system.h:35
          const char* doc =
R"""(Constructs the system from a mesh and the associated mesh values.
``output_values`` is a matrix with each column representing the value
to output if the input is the associated mesh point. It must have the
same number of columns as mesh.get_num_mesh_points();
mesh.MeshValuesFrom(function) is one useful tool for creating it.)""";
        } ctor;
        // Symbol: drake::systems::BarycentricMeshSystem::get_mesh
        struct /* get_mesh */ {
          // Source: drake/systems/primitives/barycentric_system.h:39
          const char* doc = R"""(Returns a reference to the mesh.)""";
        } get_mesh;
        // Symbol: drake::systems::BarycentricMeshSystem::get_output_values
        struct /* get_output_values */ {
          // Source: drake/systems/primitives/barycentric_system.h:42
          const char* doc =
R"""(Returns a reference to the output values.)""";
        } get_output_values;
      } BarycentricMeshSystem;
      // Symbol: drake::systems::BasicVector
      struct /* BasicVector */ {
        // Source: drake/systems/framework/basic_vector.h:21
        const char* doc =
R"""(BasicVector is a semantics-free wrapper around an Eigen vector that
satisfies VectorBase. Once constructed, its size is fixed.)""";
        // Symbol: drake::systems::BasicVector::BasicVector<T>
        struct /* ctor */ {
          // Source: drake/systems/framework/basic_vector.h:29
          const char* doc_0args = R"""(Constructs an empty BasicVector.)""";
          // Source: drake/systems/framework/basic_vector.h:33
          const char* doc_1args_size =
R"""(Initializes with the given ``size`` using the drake::dummy_value<T>,
which is NaN when T = double.)""";
          // Source: drake/systems/framework/basic_vector.h:37
          const char* doc_1args_vec =
R"""(Constructs a BasicVector with the specified ``vec`` data.)""";
          // Source: drake/systems/framework/basic_vector.h:40
          const char* doc_1args_init =
R"""(Constructs a BasicVector whose elements are the elements of ``init``.)""";
        } ctor;
        // Symbol: drake::systems::BasicVector::Clone
        struct /* Clone */ {
          // Source: drake/systems/framework/basic_vector.h:108
          const char* doc =
R"""(Copies the entire vector to a new BasicVector, with the same concrete
implementation type.

Uses the Non-Virtual Interface idiom because smart pointers do not
have type covariance.)""";
        } Clone;
        // Symbol: drake::systems::BasicVector::CopyToVector
        struct /* CopyToVector */ {
          // Source: drake/systems/framework/basic_vector.h:91
          const char* doc = R"""()""";
        } CopyToVector;
        // Symbol: drake::systems::BasicVector::DoClone
        struct /* DoClone */ {
          // Source: drake/systems/framework/basic_vector.h:141
          const char* doc =
R"""(Returns a new BasicVector containing a copy of the entire vector.
Caller must take ownership, and may rely on the NVI wrapper to
initialize the clone elementwise.

Subclasses of BasicVector must override DoClone to return their
covariant type.)""";
        } DoClone;
        // Symbol: drake::systems::BasicVector::DoGetAtIndexChecked
        struct /* DoGetAtIndexChecked */ {
          // Source: drake/systems/framework/basic_vector.h:125
          const char* doc = R"""()""";
        } DoGetAtIndexChecked;
        // Symbol: drake::systems::BasicVector::DoGetAtIndexUnchecked
        struct /* DoGetAtIndexUnchecked */ {
          // Source: drake/systems/framework/basic_vector.h:115
          const char* doc = R"""()""";
        } DoGetAtIndexUnchecked;
        // Symbol: drake::systems::BasicVector::Make
        struct /* Make */ {
          // Source: drake/systems/framework/basic_vector.h:49
          const char* doc_1args_init =
R"""(Constructs a BasicVector whose elements are the elements of ``init``.)""";
          // Source: drake/systems/framework/basic_vector.h:59
          const char* doc_1args_Fargs =
R"""(Constructs a BasicVector where each element is constructed using the
placewise-corresponding member of ``args`` as the sole constructor
argument. For instance: BasicVector<symbolic::Expression>::Make("x",
"y", "z");)""";
        } Make;
        // Symbol: drake::systems::BasicVector::MakeRecursive
        struct /* MakeRecursive */ {
          // Source: drake/systems/framework/basic_vector.h:150
          const char* doc_4args =
R"""(Sets ``data`` at ``index`` to an object of type T, which must have a
single-argument constructor invoked via ``constructor_arg``, and then
recursively invokes itself on the next index with ``recursive`` args.
Helper for BasicVector<T>::Make.)""";
          // Source: drake/systems/framework/basic_vector.h:158
          const char* doc_3args =
R"""(Base case for the MakeRecursive template recursion.)""";
        } MakeRecursive;
        // Symbol: drake::systems::BasicVector::ScaleAndAddToVector
        struct /* ScaleAndAddToVector */ {
          // Source: drake/systems/framework/basic_vector.h:93
          const char* doc = R"""()""";
        } ScaleAndAddToVector;
        // Symbol: drake::systems::BasicVector::SetFromVector
        struct /* SetFromVector */ {
          // Source: drake/systems/framework/basic_vector.h:87
          const char* doc = R"""()""";
        } SetFromVector;
        // Symbol: drake::systems::BasicVector::SetZero
        struct /* SetZero */ {
          // Source: drake/systems/framework/basic_vector.h:101
          const char* doc = R"""()""";
        } SetZero;
        // Symbol: drake::systems::BasicVector::get_mutable_value
        struct /* get_mutable_value */ {
          // Source: drake/systems/framework/basic_vector.h:83
          const char* doc =
R"""(Returns the entire vector as a mutable Eigen::VectorBlock, which
allows mutation of the values, but does not allow resizing the vector
itself.)""";
        } get_mutable_value;
        // Symbol: drake::systems::BasicVector::get_value
        struct /* get_value */ {
          // Source: drake/systems/framework/basic_vector.h:77
          const char* doc =
R"""(Returns the entire vector as a const Eigen::VectorBlock.)""";
        } get_value;
        // Symbol: drake::systems::BasicVector::set_value
        struct /* set_value */ {
          // Source: drake/systems/framework/basic_vector.h:70
          const char* doc =
R"""(Sets the vector to the given value. After a.set_value(b.get_value()),
a must be identical to b.

Raises:
    RuntimeError if the new value has different dimensions.)""";
        } set_value;
        // Symbol: drake::systems::BasicVector::size
        struct /* size */ {
          // Source: drake/systems/framework/basic_vector.h:65
          const char* doc = R"""()""";
        } size;
        // Symbol: drake::systems::BasicVector::values
        struct /* values */ {
          // Source: drake/systems/framework/basic_vector.h:164
          const char* doc_0args_const =
R"""(Provides const access to the element storage.)""";
          // Source: drake/systems/framework/basic_vector.h:167
          const char* doc_0args_nonconst =
R"""(Provides mutable access to the element storage.)""";
        } values;
      } BasicVector;
      // Symbol: drake::systems::BogackiShampine3Integrator
      struct /* BogackiShampine3Integrator */ {
        // Source: drake/systems/analysis/bogacki_shampine3_integrator.h:37
        const char* doc =
R"""(A third-order, four-stage, first-same-as-last (FSAL) Runge-Kutta
integrator with a second order error estimate.

For a discussion of this Runge-Kutta method, see [Hairer, 1993]. The
Butcher tableau for this integrator follows:


::

    0    |
    1/2  | 1/2
    3/4  | 0           3/4
    1    | 2/9         1/3      4/9
    -----------------------------------------------------------------------------
    2/9         1/3      4/9     0
    7/24        1/4      1/3     1/8

where the second to last row is the 3rd-order (propagated) solution
and the last row gives a 2nd-order accurate solution used for error
control.

- [Bogacki, 1989] P. Bogacki and L. Shampine. "A 3(2) pair of Runge–Kutta
formulas", Appl. Math. Letters, 2 (4): 321–325, 1989.)""";
        // Symbol: drake::systems::BogackiShampine3Integrator::BogackiShampine3Integrator<T>
        struct /* ctor */ {
          // Source: drake/systems/analysis/bogacki_shampine3_integrator.h:39
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::systems::BogackiShampine3Integrator::get_error_estimate_order
        struct /* get_error_estimate_order */ {
          // Source: drake/systems/analysis/bogacki_shampine3_integrator.h:58
          const char* doc =
R"""(The order of the asymptotic term in the error estimate.)""";
        } get_error_estimate_order;
        // Symbol: drake::systems::BogackiShampine3Integrator::supports_error_estimation
        struct /* supports_error_estimation */ {
          // Source: drake/systems/analysis/bogacki_shampine3_integrator.h:55
          const char* doc =
R"""(The integrator supports error estimation.)""";
        } supports_error_estimation;
      } BogackiShampine3Integrator;
      // Symbol: drake::systems::Cache
      struct /* Cache */ {
        // Source: drake/systems/framework/cache.h:646
        const char* doc =
R"""((Advanced) Stores all the CacheEntryValue objects owned by a
particular Context, organized to allow fast access using a CacheIndex
as an index. Most users will not use this class directly -- System and
CacheEntry provide the most common APIs, and Context provides
additional useful methods.

See also:
    System, CacheEntry, Context for user-facing APIs.

Memory addresses of CacheEntryValue objects are stable once allocated,
but CacheIndex numbers are stable even after a Context has been copied
so should be preferred as a means for identifying particular cache
entries.)""";
        // Symbol: drake::systems::Cache::Cache
        struct /* ctor */ {
          // Source: drake/systems/framework/cache.h:657
          const char* doc =
R"""(Constructor creates an empty cache referencing the system pathname
service of its owning subcontext. The supplied pointer must not be
null.)""";
        } ctor;
        // Symbol: drake::systems::Cache::CreateNewCacheEntryValue
        struct /* CreateNewCacheEntryValue */ {
          // Source: drake/systems/framework/cache.h:677
          const char* doc =
R"""(Allocates a new CacheEntryValue and provides it a DependencyTracker
using the given CacheIndex and DependencyTicket number. The
CacheEntryValue object is owned by this Cache and the returned
reference remains valid if other cache entry values are created. If
there is a pre-existing tracker with the given ticket number (allowed
only for well-known cached computations, such as time derivatives), it
is assigned the new cache entry value to manage. Otherwise a new
DependencyTracker is created. The created tracker object is owned by
the given DependencyGraph, which must be owned by the same Context
that owns this Cache. The graph must already contain trackers for the
indicated prerequisites. The tracker will retain a pointer to the
created CacheEntryValue for invalidation purposes.)""";
        } CreateNewCacheEntryValue;
        // Symbol: drake::systems::Cache::DisableCaching
        struct /* DisableCaching */ {
          // Source: drake/systems/framework/cache.h:720
          const char* doc =
R"""((Advanced) Disables caching for all the entries in this Cache. Note
that this is done by setting individual ``is_disabled`` flags in the
entries, so it can be changed on a per-entry basis later. This has no
effect on the ``out_of_date`` flags.)""";
        } DisableCaching;
        // Symbol: drake::systems::Cache::EnableCaching
        struct /* EnableCaching */ {
          // Source: drake/systems/framework/cache.h:728
          const char* doc =
R"""((Advanced) Re-enables caching for all entries in this Cache if any
were previously disabled. Note that this is done by clearing
individual ``is_disabled`` flags in the entries, so it overrides any
disabling that may have been done to individual entries. This has no
effect on the ``out_of_date`` flags so subsequent Eval() calls might
not initiate recomputation. Use SetAllEntriesOutOfDate() if you want
to force recomputation.)""";
        } EnableCaching;
        // Symbol: drake::systems::Cache::SetAllEntriesOutOfDate
        struct /* SetAllEntriesOutOfDate */ {
          // Source: drake/systems/framework/cache.h:733
          const char* doc =
R"""((Advanced) Mark every entry in this cache as "out of date". This
forces the next Eval() request for an entry to perform a
recalculation. After that normal caching behavior resumes.)""";
        } SetAllEntriesOutOfDate;
        // Symbol: drake::systems::Cache::cache_size
        struct /* cache_size */ {
          // Source: drake/systems/framework/cache.h:695
          const char* doc =
R"""(Returns the current size of the Cache container, providing for
CacheIndex values from ``0..cache_size()-1``. Note that it is possible
to have empty slots in the cache. Use has_cache_entry_value() to
determine if there is a cache entry associated with a particular
index.)""";
        } cache_size;
        // Symbol: drake::systems::Cache::freeze_cache
        struct /* freeze_cache */ {
          // Source: drake/systems/framework/cache.h:738
          const char* doc =
R"""((Advanced) Sets the "is frozen" flag. Cache entry values should check
this before permitting mutable access to values.

See also:
    ContextBase::FreezeCache() for the user-facing API)""";
        } freeze_cache;
        // Symbol: drake::systems::Cache::get_cache_entry_value
        struct /* get_cache_entry_value */ {
          // Source: drake/systems/framework/cache.h:701
          const char* doc =
R"""(Returns a const CacheEntryValue given an index. This is very fast.
Behavior is undefined if the index is out of range [0..cache_size()-1]
or if there is no CacheEntryValue with that index. Use
has_cache_entry_value() first if you aren't sure.)""";
        } get_cache_entry_value;
        // Symbol: drake::systems::Cache::get_mutable_cache_entry_value
        struct /* get_mutable_cache_entry_value */ {
          // Source: drake/systems/framework/cache.h:712
          const char* doc =
R"""(Returns a mutable CacheEntryValue given an index. This is very fast.
Behavior is undefined if the index is out of range [0..cache_size()-1]
or if there is no CacheEntryValue with that index. Use
has_cache_entry_value() first if you aren't sure.)""";
        } get_mutable_cache_entry_value;
        // Symbol: drake::systems::Cache::has_cache_entry_value
        struct /* has_cache_entry_value */ {
          // Source: drake/systems/framework/cache.h:685
          const char* doc =
R"""(Returns true if there is a CacheEntryValue in this cache that has the
given index.)""";
        } has_cache_entry_value;
        // Symbol: drake::systems::Cache::is_cache_frozen
        struct /* is_cache_frozen */ {
          // Source: drake/systems/framework/cache.h:751
          const char* doc =
R"""((Advanced) Reports the current value of the "is frozen" flag.

See also:
    ContextBase::is_cache_frozen() for the user-facing API)""";
        } is_cache_frozen;
        // Symbol: drake::systems::Cache::unfreeze_cache
        struct /* unfreeze_cache */ {
          // Source: drake/systems/framework/cache.h:745
          const char* doc =
R"""((Advanced) Clears the "is frozen" flag, permitting normal cache
activity.

See also:
    ContextBase::UnfreezeCache() for the user-facing API)""";
        } unfreeze_cache;
      } Cache;
      // Symbol: drake::systems::CacheEntry
      struct /* CacheEntry */ {
        // Source: drake/systems/framework/cache_entry.h:42
        const char* doc =
R"""(A CacheEntry belongs to a System and represents the properties of one
of that System's cached computations. CacheEntry objects are assigned
CacheIndex values in the order they are declared; these are unique
within a single System and can be used for quick access to both the
CacheEntry and the corresponding CacheEntryValue in the System's
Context.

CacheEntry objects are allocated automatically for known System
computations like output ports and time derivatives, and may also be
allocated by user code for other cached computations.

A cache entry's value is always stored as an AbstractValue, which can
hold a concrete value of any copyable type. However, once a value has
been allocated using a particular concrete type, the type cannot be
changed.

CacheEntry objects support four important operations: - Allocate()
returns an object that can hold the cached value. - Calc()
unconditionally computes the cached value. - Eval() returns a
reference to the cached value, first updating with Calc() if it was
out of date. - GetKnownUpToDate() returns a reference to the current
value that you are certain must already be up to date.

The allocation and calculation functions must be provided at the time
a cache entry is declared. That is typically done in a System
constructor, in a manner very similar to the declaration of output
ports.)""";
        // Symbol: drake::systems::CacheEntry::AllocCallback
        struct /* AllocCallback */ {
          // Source: drake/systems/framework/cache_entry.h:52
          const char* doc =
R"""(Signature of a function suitable for allocating an object that can
hold a value of a particular cache entry. The result is always
returned as an AbstractValue but must contain the correct concrete
type.)""";
        } AllocCallback;
        // Symbol: drake::systems::CacheEntry::Allocate
        struct /* Allocate */ {
          // Source: drake/systems/framework/cache_entry.h:124
          const char* doc =
R"""(Invokes this cache entry's allocator function to allocate a concrete
object suitable for holding the value to be held in this cache entry,
and returns that as an AbstractValue. The returned object will never
be null.

Raises:
    RuntimeError if the allocator function returned null.)""";
        } Allocate;
        // Symbol: drake::systems::CacheEntry::CacheEntry
        struct /* ctor */ {
          // Source: drake/systems/framework/cache_entry.h:88
          const char* doc =
R"""((Advanced) Constructs a cache entry within a System and specifies the
resources it needs.

This method is intended only for use by the framework which provides
much nicer APIs for end users. See DeclareCacheEntry_documentation
"DeclareCacheEntry" for the user-facing API documentation.

The supplied allocator must return a suitable AbstractValue in which
to hold the result. The supplied calculator function must write to an
AbstractValue of the same underlying concrete type as is returned by
the allocator. The allocator function is not invoked here during
construction of the cache entry. Instead allocation is deferred until
the allocator can be provided with a complete Context, which cannot
occur until the full Diagram containing this subsystem has been
completed. That way the initial type, size, or value can be
Context-dependent. The supplied prerequisite tickets are interpreted
as belonging to the same subsystem that owns this CacheEntry.

The list of prerequisites cannot be empty -- a cache entry that really
has no prerequisites must say so explicitly by providing a list
containing only ``nothing_ticket()`` as a prerequisite. The subsystem
pointer must not be null, and the cache index and ticket must be
valid. The description is an arbitrary string not interpreted in any
way by Drake.

Raises:
    RuntimeError if the prerequisite list is empty.

See also:
    drake::systems::SystemBase::DeclareCacheEntry())""";
        } ctor;
        // Symbol: drake::systems::CacheEntry::Calc
        struct /* Calc */ {
          // Source: drake/systems/framework/cache_entry.h:132
          const char* doc =
R"""(Unconditionally computes the value this cache entry should have given
a particular context, into an already-allocated object.

Precondition:
    ``context`` is a subcontext that is compatible with the subsystem
    that owns this cache entry.

Precondition:
    ``value`` is non null and has exactly the same concrete type as
    that of the object returned by this entry's Allocate() method.)""";
        } Calc;
        // Symbol: drake::systems::CacheEntry::CalcCallback
        struct /* CalcCallback */ {
          // Source: drake/systems/framework/cache_entry.h:57
          const char* doc =
R"""(Signature of a function suitable for calculating a value of a
particular cache entry, given a place to put the value.)""";
        } CalcCallback;
        // Symbol: drake::systems::CacheEntry::Eval
        struct /* Eval */ {
          // Source: drake/systems/framework/cache_entry.h:146
          const char* doc =
R"""(Returns a reference to the up-to-date value of this cache entry
contained in the given Context. This is the preferred way to obtain a
cached value. If the value is not already up to date with respect to
its prerequisites, or if caching is disabled for this entry, then this
entry's Calc() method is used first to update the value before the
reference is returned. The Calc() method may be arbitrarily expensive,
but this method is constant time and *very* fast if the value is
already up to date. If you are certain the value should be up to date
already, you may use the GetKnownUpToDate() method instead.

Precondition:
    ``context`` is a subcontext that is compatible with the subsystem
    that owns this cache entry.

Raises:
    RuntimeError if the value doesn't actually have type V.)""";
        } Eval;
        // Symbol: drake::systems::CacheEntry::EvalAbstract
        struct /* EvalAbstract */ {
          // Source: drake/systems/framework/cache_entry.h:161
          const char* doc = R"""()""";
        } EvalAbstract;
        // Symbol: drake::systems::CacheEntry::GetKnownUpToDate
        struct /* GetKnownUpToDate */ {
          // Source: drake/systems/framework/cache_entry.h:182
          const char* doc = R"""()""";
        } GetKnownUpToDate;
        // Symbol: drake::systems::CacheEntry::GetKnownUpToDateAbstract
        struct /* GetKnownUpToDateAbstract */ {
          // Source: drake/systems/framework/cache_entry.h:197
          const char* doc = R"""()""";
        } GetKnownUpToDateAbstract;
        // Symbol: drake::systems::CacheEntry::cache_index
        struct /* cache_index */ {
          // Source: drake/systems/framework/cache_entry.h:279
          const char* doc =
R"""(Returns the CacheIndex used to locate this CacheEntry within the
containing System.)""";
        } cache_index;
        // Symbol: drake::systems::CacheEntry::description
        struct /* description */ {
          // Source: drake/systems/framework/cache_entry.h:253
          const char* doc =
R"""(Return the human-readable description for this CacheEntry.)""";
        } description;
        // Symbol: drake::systems::CacheEntry::disable_caching
        struct /* disable_caching */ {
          // Source: drake/systems/framework/cache_entry.h:226
          const char* doc =
R"""((Debugging) Disables caching for this cache entry in the given
``context``. Eval() will recompute the cached value every time it is
invoked, regardless of the state of the out_of_date flag. That should
have no effect on any computed results, other than speed. See class
documentation for ideas as to what might be wrong if you see a change.
Note that the ``context`` is ``const`` here; cache entry values are
mutable.)""";
        } disable_caching;
        // Symbol: drake::systems::CacheEntry::disable_caching_by_default
        struct /* disable_caching_by_default */ {
          // Source: drake/systems/framework/cache_entry.h:244
          const char* doc =
R"""((Debugging) Marks this cache entry so that the corresponding
CacheEntryValue object in any allocated Context is created with its
``disabled`` flag initially set. This can be useful for debugging when
you have observed a difference between cached and non-cached behavior
that can't be diagnosed with the runtime disable_caching() method.

See also:
    disable_caching())""";
        } disable_caching_by_default;
        // Symbol: drake::systems::CacheEntry::enable_caching
        struct /* enable_caching */ {
          // Source: drake/systems/framework/cache_entry.h:233
          const char* doc =
R"""((Debugging) Enables caching for this cache entry in the given
``context`` if it was previously disabled.)""";
        } enable_caching;
        // Symbol: drake::systems::CacheEntry::get_cache_entry_value
        struct /* get_cache_entry_value */ {
          // Source: drake/systems/framework/cache_entry.h:261
          const char* doc =
R"""((Advanced) Returns a const reference to the CacheEntryValue object
that corresponds to this CacheEntry, from the supplied Context. The
returned object contains the current value and tracks whether it is up
to date with respect to its prerequisites. If you just need the value,
use the Eval() method rather than this one. This method is constant
time and *very* fast in all circumstances.)""";
        } get_cache_entry_value;
        // Symbol: drake::systems::CacheEntry::get_mutable_cache_entry_value
        struct /* get_mutable_cache_entry_value */ {
          // Source: drake/systems/framework/cache_entry.h:271
          const char* doc =
R"""((Advanced) Returns a mutable reference to the CacheEntryValue object
that corresponds to this CacheEntry, from the supplied Context. Note
that ``context`` is const; cache values are mutable. Don't call this
method unless you know what you're doing. This method is constant time
and *very* fast in all circumstances.)""";
        } get_mutable_cache_entry_value;
        // Symbol: drake::systems::CacheEntry::has_default_prerequisites
        struct /* has_default_prerequisites */ {
          // Source: drake/systems/framework/cache_entry.h:297
          const char* doc =
R"""((Advanced) Returns ``True`` if this cache entry was created without
specifying any prerequisites. This can be useful in determining
whether the apparent dependencies should be believed, or whether they
may just be due to some user's ignorance.

Note:
    Currently we can't distinguish between "no prerequisites given"
    (in which case we default to ``all_sources_ticket()``) and
    "prerequisite specified as ``all_sources_ticket()`". Either of
    those cases makes this method return `true`` now, but we intend to
    change so that *explicit* specification of
    ``all_sources_ticket()`` will be considered non-default. So don't
    depend on the current behavior.)""";
        } has_default_prerequisites;
        // Symbol: drake::systems::CacheEntry::is_cache_entry_disabled
        struct /* is_cache_entry_disabled */ {
          // Source: drake/systems/framework/cache_entry.h:216
          const char* doc =
R"""((Debugging) Returns ``True`` if caching has been disabled for this
cache entry in the given ``context``. That means Eval() will
recalculate even if the entry is marked up to date.)""";
        } is_cache_entry_disabled;
        // Symbol: drake::systems::CacheEntry::is_disabled_by_default
        struct /* is_disabled_by_default */ {
          // Source: drake/systems/framework/cache_entry.h:250
          const char* doc =
R"""((Debugging) Returns the current value of this flag. It is ``False``
unless a call to ``disable_caching_by_default()`` has previously been
made.)""";
        } is_disabled_by_default;
        // Symbol: drake::systems::CacheEntry::is_out_of_date
        struct /* is_out_of_date */ {
          // Source: drake/systems/framework/cache_entry.h:209
          const char* doc =
R"""(Returns ``True`` if the current value of this cache entry is out of
date with respect to its prerequisites. If this returns ``False`` then
the Eval() method will not perform any computation when invoked,
unless caching has been disabled for this entry. If this returns
``True`` the GetKnownUpToDate() methods will fail if invoked.)""";
        } is_out_of_date;
        // Symbol: drake::systems::CacheEntry::mutable_prerequisites
        struct /* mutable_prerequisites */ {
          // Source: drake/systems/framework/cache_entry.h:116
          const char* doc =
R"""((Advanced) Returns a mutable reference to the set of prerequisites
needed by this entry's Calc() function. Any tickets in this set are
interpreted as referring to prerequisites within the same subsystem
that owns this CacheEntry. Modifications take effect the next time the
containing System is asked to create a Context.

A cache entry should normally be given its complete set of
prerequisites at the time it is declared (typically in a System
constructor). If possible, defer declaration of cache entries until
all their prerequisites have been declared so that all necessary
tickets are available. In Systems with complicated extended
construction phases it may be awkward or impossible to know all the
prerequisites at that time. In that case, consider choosing a
comprehensive prerequisite like ``all_input_ports_ticket()`` that can
include as-yet-undeclared prerequisites. If performance requirements
preclude that approach, then an advanced user may use this method to
add more prerequisites as their tickets become available.)""";
        } mutable_prerequisites;
        // Symbol: drake::systems::CacheEntry::prerequisites
        struct /* prerequisites */ {
          // Source: drake/systems/framework/cache_entry.h:96
          const char* doc =
R"""(Returns a reference to the set of prerequisites needed by this cache
entry's Calc() function. These are all within the same subsystem that
owns this CacheEntry.)""";
        } prerequisites;
        // Symbol: drake::systems::CacheEntry::ticket
        struct /* ticket */ {
          // Source: drake/systems/framework/cache_entry.h:285
          const char* doc =
R"""(Returns the DependencyTicket used to register dependencies on the
value of this CacheEntry. This can also be used to locate the
DependencyTracker that manages dependencies at runtime for the
associated CacheEntryValue in a Context.)""";
        } ticket;
      } CacheEntry;
      // Symbol: drake::systems::CacheEntryValue
      struct /* CacheEntryValue */ {
        // Source: drake/systems/framework/cache.h:72
        const char* doc =
R"""((Advanced) This is the representation in the Context for the value of
one of a System's CacheEntry objects. Most users will not use this
class directly -- System and CacheEntry provide the most common APIs,
and Context provides additional useful methods.

See also:
    System, CacheEntry, Context for user-facing APIs.

A CacheEntryValue consists of a single type-erased value, a serial
number, an ``out_of_date`` flag, and a DependencyTracker ticket.
Details: - "Out of date" means that some prerequisite of this cache
entry's computation has been changed in the current Context since the
stored value was last computed, and thus must be recomputed prior to
use. On the other hand, if the entry is *not* out of date, then it is
"up to date" meaning that if you were to recompute it using the
current Context values you would get the identical result (so don't
bother!). - The "serial number" is an integer that is incremented
whenever the value is modified, or made available for mutable access.
You can use it to recognize that you are looking at the same value as
you saw at some earlier time. It is also useful for performance
studies since it is a count of how many times this value was
recomputed. Note that marking the value "out of date" is *not* a
modification; that does not change the serial number. The serial
number is maintained internally and cannot be user-modified. - The
DependencyTicket ("ticket") stored here identifies the
DependencyTracker ("tracker") associated with this cache entry. The
tracker maintains lists of all upstream prerequisites and downstream
dependents of the value stored here, and also has a pointer to this
CacheEntryValue that it uses for invalidation. Upstream modifications
cause the tracker to set the ``out_of_date`` flag here, and mark all
downstream dependents out of date also. The tracker lives in the same
subcontext that owns the Cache that owns this CacheEntryValue.

We sometimes use the terms "invalid" and "invalidate" as synonyms for
"out of date" and "mark out of date".

For debugging purposes, caching may be disabled for an entire Context
or for particular cache entry values. This is independent of the
``out_of_date`` flag described above, which is still expected to be
operational when caching is disabled. However, when caching is
disabled the Eval() methods will recompute the contained value even if
it is not marked out of date. That should have no effect other than to
slow computation; if results change, something is wrong. There could
be a problem with the specification of dependencies, a bug in user
code such as improper retention of a stale reference, or a bug in the
caching system.)""";
        // Symbol: drake::systems::CacheEntryValue::CacheEntryValue
        struct /* ctor */ {
          // Source: drake/systems/framework/cache.h:76
          const char* doc_move =
R"""(@name Does not allow move or assignment; copy constructor is private.)""";
        } ctor;
        // Symbol: drake::systems::CacheEntryValue::GetAbstractValueOrThrow
        struct /* GetAbstractValueOrThrow */ {
          // Source: drake/systems/framework/cache.h:128
          const char* doc =
R"""(Returns a const reference to the contained abstract value, which must
not be out of date with respect to any of its prerequisites. It is an
error to call this if there is no stored value object, or if the value
is out of date.

Raises:
    RuntimeError if there is no value or it is out of date.

See also:
    get_abstract_value())""";
        } GetAbstractValueOrThrow;
        // Symbol: drake::systems::CacheEntryValue::GetMutableAbstractValueOrThrow
        struct /* GetMutableAbstractValueOrThrow */ {
          // Source: drake/systems/framework/cache.h:186
          const char* doc =
R"""((Advanced) Returns a mutable reference to the contained value after
incrementing the serial number. This is for the purpose of performing
an update or extended computation in place. If possible, use the safer
and more straightforward method SetValueOrThrow() rather than this
method. Mutable access is only permitted if the value is already
marked out of date (meaning that all downstream dependents have
already been notified). It is an error to call this if there is no
stored value, or it is already up to date. Since this is intended for
relatively expensive computations, these preconditions are checked
even in Release builds. If you have a small, fast computation to
perform, use set_value() instead. If your computation completes
successfully, you must mark the entry up to date yourself using
mark_up_to_date() if you want anyone to be able to use the new value.

Raises:
    RuntimeError if there is no value, or if the value is already up
    to date.

Raises:
    RuntimeError if the cache is frozen.

See also:
    SetValueOrThrow(), set_value(), mark_up_to_date())""";
        } GetMutableAbstractValueOrThrow;
        // Symbol: drake::systems::CacheEntryValue::GetMutableValueOrThrow
        struct /* GetMutableValueOrThrow */ {
          // Source: drake/systems/framework/cache.h:201
          const char* doc =
R"""((Advanced) Convenience method that returns a mutable reference to the
contained value downcast to its known concrete type. Throws an
exception if the contained value does not have the indicated concrete
type. Note that you must call mark_up_to_date() after modifying the
value through the returned reference. See
GetMutableAbstractValueOrThrow() above for more information.

Raises:
    RuntimeError if there is no value, or if the value is already up
    to date, of it doesn't actually have type V.

Raises:
    RuntimeError if the cache is frozen.

See also:
    SetValueOrThrow(), set_value(), mark_up_to_date()

Template parameter ``V``:
    The known actual value type.)""";
        } GetMutableValueOrThrow;
        // Symbol: drake::systems::CacheEntryValue::GetPathDescription
        struct /* GetPathDescription */ {
          // Source: drake/systems/framework/cache.h:389
          const char* doc =
R"""(Returns the description, preceded by the full pathname of the
subsystem associated with the owning subcontext.)""";
        } GetPathDescription;
        // Symbol: drake::systems::CacheEntryValue::GetValueOrThrow
        struct /* GetValueOrThrow */ {
          // Source: drake/systems/framework/cache.h:139
          const char* doc =
R"""(Returns a const reference to the contained value of known type V. It
is an error to call this if there is no stored value, or the value is
out of date, or the value doesn't actually have type V.

Raises:
    RuntimeError if there is no stored value, or if it is out of date,
    or it doesn't actually have type V.

See also:
    get_value())""";
        } GetValueOrThrow;
        // Symbol: drake::systems::CacheEntryValue::PeekAbstractValueOrThrow
        struct /* PeekAbstractValueOrThrow */ {
          // Source: drake/systems/framework/cache.h:211
          const char* doc =
R"""((Advanced) Returns a reference to the contained value *without*
checking whether the value is out of date. This can be used to check
type and size information but should not be used to look at the value
unless you *really* know what you're doing.

Raises:
    RuntimeError if there is no contained value.)""";
        } PeekAbstractValueOrThrow;
        // Symbol: drake::systems::CacheEntryValue::PeekValueOrThrow
        struct /* PeekValueOrThrow */ {
          // Source: drake/systems/framework/cache.h:224
          const char* doc =
R"""((Advanced) Convenience method that provides access to the contained
value downcast to its known concrete type, *without* checking whether
the value is out of date. This can be used to check type and size
information but should not be used to look at the value unless you
*really* know what you're doing.

Raises:
    RuntimeError if there is no contained value, or if the contained
    value does not actually have type V.

Template parameter ``V``:
    The known actual value type.)""";
        } PeekValueOrThrow;
        // Symbol: drake::systems::CacheEntryValue::SetInitialValue
        struct /* SetInitialValue */ {
          // Source: drake/systems/framework/cache.h:98
          const char* doc =
R"""(Defines the concrete value type by providing an initial AbstractValue
object containing an object of the appropriate concrete type. This
value is marked out of date. It is an error to call this if there is
already a value here; use has_value() if you want to check first.
Also, the given initial value may not be null. The serial number is
set to 1. No out-of-date notifications are sent to downstream
dependents. Operation of this initialization method is not affected by
whether the cache is currently frozen. However, the corresponding
value won't be accessible while the cache remains frozen (since it is
out of date).

Raises:
    RuntimeError if the given value is null or if there is already a
    value, or if this CacheEntryValue is malformed in some detectable
    way.)""";
        } SetInitialValue;
        // Symbol: drake::systems::CacheEntryValue::SetValueOrThrow
        struct /* SetValueOrThrow */ {
          // Source: drake/systems/framework/cache.h:164
          const char* doc =
R"""(Assigns a new value to a cache entry and marks it up to date. The
cache entry must already contain a value object of type V to which the
new value is assigned, and that value must currently be marked out of
date. The supplied new value *must* have been calculated using the
current values in the owning Context, and we assume that here although
this method cannot check that assumption. Consequently, this method
clears the ``out_of_date`` flag. No out-of-date notifications are
issued by this method; we assume downstream dependents were marked out
of date at the time this value went out of date. The serial number is
incremented.

This method is the safest and most convenient way to assign a new
value. However it requires that a new value be computed and then
copied into the cache entry, which is fine for small types V but may
be too expensive for large ones. You can alternatively obtain a
mutable reference to the value already contained in the cache entry
and update it in place via GetMutableValueOrThrow().

Raises:
    RuntimeError if there is no value, or the value is already up to
    date, of it doesn't actually have type V.

Raises:
    RuntimeError if the cache is frozen.

See also:
    set_value(), GetMutableValueOrThrow())""";
        } SetValueOrThrow;
        // Symbol: drake::systems::CacheEntryValue::ThrowIfBadCacheEntryValue
        struct /* ThrowIfBadCacheEntryValue */ {
          // Source: drake/systems/framework/cache.h:421
          const char* doc =
R"""(Throws an RuntimeError if there is something clearly wrong with this
CacheEntryValue object. If the owning subcontext is known, provide a
pointer to it here and we'll check that this cache entry agrees. In
addition we check for other internal inconsistencies.

Raises:
    RuntimeError for anything that goes wrong, with an appropriate
    explanatory message.)""";
        } ThrowIfBadCacheEntryValue;
        // Symbol: drake::systems::CacheEntryValue::cache_index
        struct /* cache_index */ {
          // Source: drake/systems/framework/cache.h:398
          const char* doc =
R"""(Returns the CacheIndex used to locate this CacheEntryValue within its
containing subcontext.)""";
        } cache_index;
        // Symbol: drake::systems::CacheEntryValue::description
        struct /* description */ {
          // Source: drake/systems/framework/cache.h:385
          const char* doc =
R"""(Returns the human-readable description for this CacheEntryValue.)""";
        } description;
        // Symbol: drake::systems::CacheEntryValue::disable_caching
        struct /* disable_caching */ {
          // Source: drake/systems/framework/cache.h:433
          const char* doc =
R"""((Advanced) Disables caching for just this cache entry value. When
disabled, the corresponding entry's Eval() method will unconditionally
invoke Calc() to recompute the value, regardless of the setting of the
``out_of_date`` flag. The ``disabled`` flag is independent of the
``out_of_date`` flag, which will continue to be managed even if
caching is disabled. It is also independent of whether the cache is
frozen, although in that case any cache access will fail since
recomputation is not permitted in a frozen cache. Once unfrozen,
caching will remain disabled unless enable_caching() is called.)""";
        } disable_caching;
        // Symbol: drake::systems::CacheEntryValue::dummy
        struct /* dummy */ {
          // Source: drake/systems/framework/cache.h:464
          const char* doc = R"""()""";
        } dummy;
        // Symbol: drake::systems::CacheEntryValue::enable_caching
        struct /* enable_caching */ {
          // Source: drake/systems/framework/cache.h:442
          const char* doc =
R"""((Advanced) Enables caching for this cache entry value if it was
previously disabled. When enabled (the default condition) the
corresponding entry's Eval() method will check the ``out_of_date``
flag and invoke Calc() only if the entry is marked out of date. It is
also independent of whether the cache is frozen; in that case caching
will be enabled once the cache is unfrozen.)""";
        } enable_caching;
        // Symbol: drake::systems::CacheEntryValue::get_abstract_value
        struct /* get_abstract_value */ {
          // Source: drake/systems/framework/cache.h:247
          const char* doc =
R"""(Returns a const reference to the contained abstract value, which must
not be out of date with respect to any of its prerequisites. It is an
error to call this if there is no stored value, or it is out of date.
Because this is used in performance-critical contexts, these
requirements will be checked only in Debug builds. If you are not in a
performance-critical situation (and you probably are not!), use
GetAbstractValueOrThrow() instead.)""";
        } get_abstract_value;
        // Symbol: drake::systems::CacheEntryValue::get_value
        struct /* get_value */ {
          // Source: drake/systems/framework/cache.h:263
          const char* doc =
R"""(Returns a const reference to the contained value of known type V. It
is an error to call this if there is no stored value, or the value is
out of date, or the value doesn't actually have type V. Because this
is expected to be used in performance-critical, inner-loop
circumstances, these requirements will be checked only in Debug
builds. If you are not in a performance-critical situation (and you
probably are not!), use ``GetValueOrThrow<V>``() instead.

Template parameter ``V``:
    The known actual value type.)""";
        } get_value;
        // Symbol: drake::systems::CacheEntryValue::has_value
        struct /* has_value */ {
          // Source: drake/systems/framework/cache.h:394
          const char* doc =
R"""(Returns ``True`` if this CacheEntryValue currently contains a value
object at all, regardless of whether it is up to date. There will be
no value object after default construction, prior to
SetInitialValue().)""";
        } has_value;
        // Symbol: drake::systems::CacheEntryValue::is_cache_entry_disabled
        struct /* is_cache_entry_disabled */ {
          // Source: drake/systems/framework/cache.h:449
          const char* doc =
R"""((Advanced) Returns ``True`` if caching is disabled for this cache
entry. This is independent of the ``out_of_date`` flag, and
independent of whether the cache is currently frozen.)""";
        } is_cache_entry_disabled;
        // Symbol: drake::systems::CacheEntryValue::is_out_of_date
        struct /* is_out_of_date */ {
          // Source: drake/systems/framework/cache.h:321
          const char* doc =
R"""(Returns ``True`` if the current value is out of date with respect to
any of its prerequisites. This refers only to the ``out_of_date`` flag
and is independent of whether caching is enabled or disabled. Don't
call this if there is no value here; use has_value() if you aren't
sure.

See also:
    needs_recomputation())""";
        } is_out_of_date;
        // Symbol: drake::systems::CacheEntryValue::mark_out_of_date
        struct /* mark_out_of_date */ {
          // Source: drake/systems/framework/cache.h:371
          const char* doc =
R"""((Advanced) Marks the cache entry value as *out-of-date* with respect
to its prerequisites, with no other effects. In particular, it does
not modify the value, does not change the serial number, and does not
notify downstream dependents. You should not call this method unless
you know that dependent notification has already been taken care of.
There are no error conditions; even an empty cache entry can be marked
out of date.

Note:
    Operation of this method is unaffected by whether the cache is
    frozen. If you call it in that case the corresponding value will
    become inaccessible since it would require recomputation.)""";
        } mark_out_of_date;
        // Symbol: drake::systems::CacheEntryValue::mark_up_to_date
        struct /* mark_up_to_date */ {
          // Source: drake/systems/framework/cache.h:356
          const char* doc =
R"""((Advanced) Marks the cache entry value as up to date with respect to
its prerequisites, with no other effects. That is, this method clears
the ``out_of_date`` flag. In particular, this method does not modify
the value, does not change the serial number, and does not notify
downstream dependents of anything. This is a very dangerous method
since it enables access to the value but can't independently determine
whether it is really up to date. You should not call it unless you
really know what you're doing, or have a death wish. Do not call this
method if there is no stored value object; use has_value() if you
aren't sure. This is intended to be very fast so doesn't check for a
value object except in Debug builds.

Note:
    Operation of this method is unaffected by whether the cache is
    frozen. It may be useful for testing and debugging in that case
    but you should be *very* careful if you use it -- once you call
    this the value will be accessible in the frozen cache, regardless
    of whether it is any good!)""";
        } mark_up_to_date;
        // Symbol: drake::systems::CacheEntryValue::needs_recomputation
        struct /* needs_recomputation */ {
          // Source: drake/systems/framework/cache.h:335
          const char* doc =
R"""(Returns ``True`` if either (a) the value is out of date, or (b)
caching is disabled for this entry. This is a *very* fast inline
method intended to be called every time a cache value is obtained with
Eval(). This is equivalent to ``is_out_of_date() ||
is_entry_disabled()`` but faster. Don't call this if there is no value
here; use has_value() if you aren't sure. Note that if this returns
true while the cache is frozen, any attempt to access the value will
fail since recomputation is forbidden in that case. However, operation
of *this* method is unaffected by whether the cache is frozen.)""";
        } needs_recomputation;
        // Symbol: drake::systems::CacheEntryValue::serial_number
        struct /* serial_number */ {
          // Source: drake/systems/framework/cache.h:377
          const char* doc =
R"""(Returns the serial number of the contained value. This counts up every
time the contained value changes, or whenever mutable access is
granted.)""";
        } serial_number;
        // Symbol: drake::systems::CacheEntryValue::set_value
        struct /* set_value */ {
          // Source: drake/systems/framework/cache.h:283
          const char* doc =
R"""(Assigns a new value to a cache entry and marks it up to date. The
cache value must already have a value object of type V to which the
new value is assigned, and that value must not already be up to date.
The new value is assumed to be up to date with its prerequisites, so
the ``out_of_date`` flag is cleared. No out-of-date notifications are
issued by this method; we assume downstream dependents were marked out
of date at the time this value went out of date. The serial number is
incremented. If you are not in a performance-critical situation (and
you probably are not!), use ``SetValueOrThrow<V>()`` instead.

Raises:
    RuntimeError if the cache is frozen.

Template parameter ``V``:
    The known actual value type.)""";
        } set_value;
        // Symbol: drake::systems::CacheEntryValue::swap_value
        struct /* swap_value */ {
          // Source: drake/systems/framework/cache.h:301
          const char* doc =
R"""((Advanced) Swaps ownership of the stored value object with the given
one. The value is marked out of date and the serial number is
incremented. This is useful for discrete updates of abstract state
variables that contain large objects. Both values must be non-null and
of the same concrete type but we won't check for errors except in
Debug builds.

Raises:
    RuntimeError if the cache is frozen.)""";
        } swap_value;
        // Symbol: drake::systems::CacheEntryValue::ticket
        struct /* ticket */ {
          // Source: drake/systems/framework/cache.h:404
          const char* doc =
R"""(Returns the DependencyTicket used to locate the DependencyTracker that
manages dependencies for this CacheEntryValue. The ticket refers to a
tracker that is owned by the same subcontext that owns this
CacheEntryValue.)""";
        } ticket;
      } CacheEntryValue;
      // Symbol: drake::systems::CacheIndex
      struct /* CacheIndex */ {
        // Source: drake/systems/framework/framework_common.h:36
        const char* doc =
R"""(Serves as a unique identifier for a particular CacheEntry in a System
and the corresponding CacheEntryValue in that System's Context. This
is an index providing extremely fast constant-time access to both.)""";
      } CacheIndex;
      // Symbol: drake::systems::CompositeEventCollection
      struct /* CompositeEventCollection */ {
        // Source: drake/systems/framework/event_collection.h:413
        const char* doc =
R"""(This class bundles an instance of each EventCollection<EventType> into
one object that stores the heterogeneous collection. This is intended
to hold heterogeneous events returned by methods like
System::CalcNextUpdateTime.


::

    CompositeEventCollection<T> = {
      EventCollection<PublishEvent<T>>,
      EventCollection<DiscreteUpdateEvent<T>>,
      EventCollection<UnrestrictedUpdate<T>>}

There are two concrete derived classes: LeafCompositeEventCollection
and DiagramCompositeEventCollection. Adding new events to the
collection is only allowed for LeafCompositeEventCollection.

End users should never need to use or know about this class. It is for
internal use only.)""";
        // Symbol: drake::systems::CompositeEventCollection::AddToEnd
        struct /* AddToEnd */ {
          // Source: drake/systems/framework/event_collection.h:506
          const char* doc =
R"""(Adds the contained homogeneous event collections (e.g.,
EventCollection<PublishEvent<T>>,
EventCollection<DiscreteUpdateEvent<T>>, etc.) from ``other`` to the
end of ``this``.)""";
        } AddToEnd;
        // Symbol: drake::systems::CompositeEventCollection::Clear
        struct /* Clear */ {
          // Source: drake/systems/framework/event_collection.h:422
          const char* doc = R"""(Clears all the events.)""";
        } Clear;
        // Symbol: drake::systems::CompositeEventCollection::CompositeEventCollection<T>
        struct /* ctor */ {
          // Source: drake/systems/framework/event_collection.h:575
          const char* doc =
R"""(Takes ownership of ``pub``, `discrete` and ``unrestricted``. Aborts if
any of these are null.)""";
        } ctor;
        // Symbol: drake::systems::CompositeEventCollection::HasDiscreteUpdateEvents
        struct /* HasDiscreteUpdateEvents */ {
          // Source: drake/systems/framework/event_collection.h:447
          const char* doc =
R"""(Returns ``True`` if and only if this collection contains one or more
discrete update events.)""";
        } HasDiscreteUpdateEvents;
        // Symbol: drake::systems::CompositeEventCollection::HasEvents
        struct /* HasEvents */ {
          // Source: drake/systems/framework/event_collection.h:431
          const char* doc =
R"""(Returns ``True`` if and only if this collection contains any events.)""";
        } HasEvents;
        // Symbol: drake::systems::CompositeEventCollection::HasPublishEvents
        struct /* HasPublishEvents */ {
          // Source: drake/systems/framework/event_collection.h:441
          const char* doc =
R"""(Returns ``True`` if and only if this collection contains one or more
publish events.)""";
        } HasPublishEvents;
        // Symbol: drake::systems::CompositeEventCollection::HasUnrestrictedUpdateEvents
        struct /* HasUnrestrictedUpdateEvents */ {
          // Source: drake/systems/framework/event_collection.h:455
          const char* doc =
R"""(Returns ``True`` if and only if this collection contains one or more
unrestricted update events.)""";
        } HasUnrestrictedUpdateEvents;
        // Symbol: drake::systems::CompositeEventCollection::SetFrom
        struct /* SetFrom */ {
          // Source: drake/systems/framework/event_collection.h:516
          const char* doc =
R"""(Copies the collections of homogeneous events from ``other`` to
``this``.)""";
        } SetFrom;
        // Symbol: drake::systems::CompositeEventCollection::add_discrete_update_event
        struct /* add_discrete_update_event */ {
          // Source: drake/systems/framework/event_collection.h:478
          const char* doc =
R"""(Assuming the internal discrete update event collection is an instance
of LeafEventCollection, adds the discrete update event ``event``
(ownership is also transferred) to it.

Raises:
    RuntimeError if the assumption is incorrect.)""";
        } add_discrete_update_event;
        // Symbol: drake::systems::CompositeEventCollection::add_publish_event
        struct /* add_publish_event */ {
          // Source: drake/systems/framework/event_collection.h:465
          const char* doc =
R"""(Assuming the internal publish event collection is an instance of
LeafEventCollection, adds the publish event ``event`` (ownership is
also transferred) to it.

Raises:
    RuntimeError if the assumption is incorrect.)""";
        } add_publish_event;
        // Symbol: drake::systems::CompositeEventCollection::add_unrestricted_update_event
        struct /* add_unrestricted_update_event */ {
          // Source: drake/systems/framework/event_collection.h:492
          const char* doc =
R"""(Assuming the internal unrestricted update event collection is an
instance of LeafEventCollection, adds the unrestricted update event
``event`` (ownership is also transferred) to it.

Raises:
    RuntimeError if the assumption is incorrect.)""";
        } add_unrestricted_update_event;
        // Symbol: drake::systems::CompositeEventCollection::get_discrete_update_events
        struct /* get_discrete_update_events */ {
          // Source: drake/systems/framework/event_collection.h:533
          const char* doc =
R"""(Returns a const reference to the collection of discrete update events.)""";
        } get_discrete_update_events;
        // Symbol: drake::systems::CompositeEventCollection::get_mutable_discrete_update_events
        struct /* get_mutable_discrete_update_events */ {
          // Source: drake/systems/framework/event_collection.h:556
          const char* doc =
R"""(Returns a mutable reference to the collection of discrete update
events.)""";
        } get_mutable_discrete_update_events;
        // Symbol: drake::systems::CompositeEventCollection::get_mutable_publish_events
        struct /* get_mutable_publish_events */ {
          // Source: drake/systems/framework/event_collection.h:549
          const char* doc =
R"""(Returns a mutable reference to the collection of publish events)""";
        } get_mutable_publish_events;
        // Symbol: drake::systems::CompositeEventCollection::get_mutable_unrestricted_update_events
        struct /* get_mutable_unrestricted_update_events */ {
          // Source: drake/systems/framework/event_collection.h:566
          const char* doc =
R"""(Returns a mutable reference to the collection of unrestricted update
events.)""";
        } get_mutable_unrestricted_update_events;
        // Symbol: drake::systems::CompositeEventCollection::get_publish_events
        struct /* get_publish_events */ {
          // Source: drake/systems/framework/event_collection.h:526
          const char* doc =
R"""(Returns a const reference to the collection of publish events.)""";
        } get_publish_events;
        // Symbol: drake::systems::CompositeEventCollection::get_unrestricted_update_events
        struct /* get_unrestricted_update_events */ {
          // Source: drake/systems/framework/event_collection.h:542
          const char* doc =
R"""(Returns a const reference to the collection of unrestricted update
events.)""";
        } get_unrestricted_update_events;
      } CompositeEventCollection;
      // Symbol: drake::systems::ConstantValueSource
      struct /* ConstantValueSource */ {
        // Source: drake/systems/primitives/constant_value_source.h:17
        const char* doc =
R"""(A source block that always outputs a constant value.)""";
        // Symbol: drake::systems::ConstantValueSource::ConstantValueSource<T>
        struct /* ctor */ {
          // Source: drake/systems/primitives/constant_value_source.h:22
          const char* doc =
R"""(Parameter ``value``:
    The constant value to emit, which is copied by this system.)""";
          // Source: drake/systems/primitives/constant_value_source.h:26
          const char* doc_copyconvert =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";
        } ctor;
      } ConstantValueSource;
      // Symbol: drake::systems::ConstantVectorSource
      struct /* ConstantVectorSource */ {
        // Source: drake/systems/primitives/constant_vector_source.h:19
        const char* doc =
R"""(A source block with a constant output port at all times. The value of
the output port is a parameter of the system (see Parameters).)""";
        // Symbol: drake::systems::ConstantVectorSource::ConstantVectorSource<T>
        struct /* ctor */ {
          // Source: drake/systems/primitives/constant_vector_source.h:27
          const char* doc =
R"""(Constructs a system with a vector output that is constant and equals
the supplied ``source_value`` at all times.

Parameter ``source_value``:
    the constant value of the output so that ``y = source_value`` at
    all times.)""";
          // Source: drake/systems/primitives/constant_vector_source.h:49
          const char* doc_copyconvert =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";
        } ctor;
        // Symbol: drake::systems::ConstantVectorSource::get_mutable_source_value
        struct /* get_mutable_source_value */ {
          // Source: drake/systems/primitives/constant_vector_source.h:59
          const char* doc =
R"""(Return a mutable reference to the source value of this block in the
given ``context``.)""";
        } get_mutable_source_value;
        // Symbol: drake::systems::ConstantVectorSource::get_source_value
        struct /* get_source_value */ {
          // Source: drake/systems/primitives/constant_vector_source.h:55
          const char* doc =
R"""(Return a read-only reference to the source value of this block in the
given ``context``.)""";
        } get_source_value;
      } ConstantVectorSource;
      // Symbol: drake::systems::Context
      struct /* Context */ {
        // Source: drake/systems/framework/context.h:33
        const char* doc =
R"""(%Context is an abstract class template that represents all the typed
values that are used in a System's computations: time, numeric-valued
input ports, numerical state, and numerical parameters. There are also
type-erased abstract state variables, abstract-valued input ports,
abstract parameters, and a double accuracy setting. The framework
provides two concrete subclasses of Context: LeafContext (for leaf
Systems) and DiagramContext (for composite System Diagrams). Users are
forbidden to extend DiagramContext and are discouraged from
subclassing LeafContext.

A Context is designed to be used only with the System that created it.
State and Parameter data can be copied between contexts for compatible
systems as necessary.)""";
        // Symbol: drake::systems::Context::Clone
        struct /* Clone */ {
          // Source: drake/systems/framework/context.h:677
          const char* doc =
R"""(Returns a deep copy of this Context.

Raises:
    RuntimeError if this is not the root context.)""";
        } Clone;
        // Symbol: drake::systems::Context::CloneState
        struct /* CloneState */ {
          // Source: drake/systems/framework/context.h:680
          const char* doc =
R"""(Returns a deep copy of this Context's State.)""";
        } CloneState;
        // Symbol: drake::systems::Context::CloneWithoutPointers
        struct /* CloneWithoutPointers */ {
          // Source: drake/systems/framework/context.h:753
          const char* doc =
R"""((Internal use only) Clones a context but without any of its internal
pointers.)""";
        } CloneWithoutPointers;
        // Symbol: drake::systems::Context::Context<T>
        struct /* ctor */ {
          // Source: drake/systems/framework/context.h:716
          const char* doc_copy =
R"""(Copy constructor takes care of base class and ``Context<T>`` data
members. Derived classes must implement copy constructors that
delegate to this one for use in their DoCloneWithoutPointers()
implementations.)""";
        } ctor;
        // Symbol: drake::systems::Context::DoCloneState
        struct /* DoCloneState */ {
          // Source: drake/systems/framework/context.h:767
          const char* doc =
R"""(Returns the appropriate concrete State object to be returned by
CloneState(). The implementation should not set_system_id on the
result, the caller will set an id on the state after this method
returns.)""";
        } DoCloneState;
        // Symbol: drake::systems::Context::DoPropagateAccuracyChange
        struct /* DoPropagateAccuracyChange */ {
          // Source: drake/systems/framework/context.h:784
          const char* doc =
R"""(Invokes PropagateAccuracyChange() on all subcontexts of this Context.
The default implementation does nothing, which is suitable for leaf
contexts. Diagram contexts must override.)""";
        } DoPropagateAccuracyChange;
        // Symbol: drake::systems::Context::DoPropagateTimeChange
        struct /* DoPropagateTimeChange */ {
          // Source: drake/systems/framework/context.h:776
          const char* doc =
R"""(Invokes PropagateTimeChange() on all subcontexts of this Context. The
default implementation does nothing, which is suitable for leaf
contexts. Diagram contexts must override.)""";
        } DoPropagateTimeChange;
        // Symbol: drake::systems::Context::GetMutableVZVectors
        struct /* GetMutableVZVectors */ {
          // Source: drake/systems/framework/context.h:642
          const char* doc =
R"""((Advanced) Returns mutable references to the first-order continuous
state partitions v and z from xc. Performs a single notification sweep
to avoid duplicate notifications for computations that depend on both
v and z. Does *not* invalidate computations that depend on time or
pose q, unless those also depend on v or z.

See also:
    SetTimeAndGetMutableQVector())""";
        } GetMutableVZVectors;
        // Symbol: drake::systems::Context::NoteContinuousStateChange
        struct /* NoteContinuousStateChange */ {
          // Source: drake/systems/framework/context.h:663
          const char* doc =
R"""((Advanced) Registers an intention to modify the continuous state xc.
Intended use is for integrators that are already holding a mutable
reference to xc which they are going to modify. Performs a
notification sweep to invalidate computations that depend on any
continuous state variables. If you need to change the time also, use
SetTimeAndNoteContinuousStateChange() instead to avoid unnecessary
duplicate notifications.

See also:
    SetTimeAndNoteContinuousStateChange())""";
        } NoteContinuousStateChange;
        // Symbol: drake::systems::Context::PerturbTime
        struct /* PerturbTime */ {
          // Source: drake/systems/framework/context.h:695
          const char* doc = R"""()""";
        } PerturbTime;
        // Symbol: drake::systems::Context::PropagateAccuracyChange
        struct /* PropagateAccuracyChange */ {
          // Source: drake/systems/framework/context.h:729
          const char* doc =
R"""((Internal use only) Sets a new accuracy and notifies
accuracy-dependent quantities that they are now invalid, as part of a
given change event.)""";
        } PropagateAccuracyChange;
        // Symbol: drake::systems::Context::PropagateTimeChange
        struct /* PropagateTimeChange */ {
          // Source: drake/systems/framework/context.h:723
          const char* doc =
R"""((Internal use only) Sets a new time and notifies time-dependent
quantities that they are now invalid, as part of a given change event.)""";
        } PropagateTimeChange;
        // Symbol: drake::systems::Context::SetAbstractState
        struct /* SetAbstractState */ {
          // Source: drake/systems/framework/context.h:400
          const char* doc =
R"""(Sets the value of the abstract state variable selected by ``index``.
Sends out of date notifications for all computations that depend on
that abstract state variable. The template type will be inferred and
need not be specified explicitly.

Precondition:
    ``index`` must identify an existing abstract state variable.

Precondition:
    the abstract state's type must match the template argument.

Note:
    Currently notifies dependents of *any* abstract state variable.)""";
        } SetAbstractState;
        // Symbol: drake::systems::Context::SetAccuracy
        struct /* SetAccuracy */ {
          // Source: drake/systems/framework/context.h:501
          const char* doc =
R"""(Records the user's requested accuracy, which is a unit-less quantity
designed for use with simulation and other numerical studies. Since
accuracy is unit-less, algorithms and systems are free to interpret
this quantity as they wish. The intention is that more computational
work is acceptable as the accuracy setting is tightened (set closer to
zero). If no accuracy is requested, computations are free to choose
suitable defaults, or to refuse to proceed without an explicit
accuracy setting. The accuracy of a complete simulation or other
numerical study depends on the accuracy of *all* contributing
computations, so it is important that each computation is done in
accordance with the requested accuracy. Some examples of where this is
needed: - Error-controlled numerical integrators use the accuracy
setting to decide what step sizes to take. - The Simulator employs a
numerical integrator, but also uses accuracy to decide how precisely
to isolate witness function zero crossings. - Iterative calculations
reported as results or cached internally depend on accuracy to decide
how strictly to converge the results. Examples of these are:
constraint projection, calculation of distances between smooth shapes,
and deformation calculations for soft contact.

The common thread among these examples is that they all share the same
Context, so by keeping accuracy here it can be used effectively to
control all accuracy-dependent computations.

Any accuracy-dependent computation in this Context and its subcontexts
may be invalidated by a change to the accuracy setting, so out of date
notifications are sent to all such computations (at least if the
accuracy setting has actually changed). Accuracy must have the same
value in every subcontext within the same context tree so may only be
modified at the root context of a tree.

Requested accuracy is stored in the Context for two reasons: - It
permits all computations performed over a System to see the *same*
accuracy request since accuracy is stored in one shared place, and -
it allows us to notify accuracy-dependent cached results that they are
out of date when the accuracy setting changes.

Raises:
    RuntimeError if this is not the root context.)""";
        } SetAccuracy;
        // Symbol: drake::systems::Context::SetContinuousState
        struct /* SetContinuousState */ {
          // Source: drake/systems/framework/context.h:343
          const char* doc =
R"""(Sets the continuous state to ``xc``, including q, v, and z partitions.
The supplied vector must be the same size as the existing continuous
state. Sends out of date notifications for all
continuous-state-dependent computations.)""";
        } SetContinuousState;
        // Symbol: drake::systems::Context::SetDiscreteState
        struct /* SetDiscreteState */ {
          // Source: drake/systems/framework/context.h:367
          const char* doc_1args =
R"""(Sets the discrete state to ``xd``, assuming there is just one discrete
state group. The supplied vector must be the same size as the existing
discrete state. Sends out of date notifications for all
discrete-state-dependent computations. Use the other signature for
this method if you have multiple discrete state groups.

Precondition:
    There is exactly one discrete state group.)""";
          // Source: drake/systems/framework/context.h:384
          const char* doc_2args =
R"""(Sets the discrete state group indicated by ``group_index`` to ``xd``.
The supplied vector ``xd`` must be the same size as the existing
discrete state group. Sends out of date notifications for all
computations that depend on this discrete state group.

Precondition:
    ``group_index`` identifies an existing group.

Note:
    Currently notifies dependents of *all* groups.)""";
        } SetDiscreteState;
        // Symbol: drake::systems::Context::SetStateAndParametersFrom
        struct /* SetStateAndParametersFrom */ {
          // Source: drake/systems/framework/context.h:418
          const char* doc =
R"""(Copies all state and parameters in ``source``, where numerical values
are of type ``U``, to ``this`` context. Time and accuracy are
unchanged in ``this`` context, which means that this method can be
called on a subcontext. Sends out of date notifications for all
dependent computations in ``this`` context.

Note:
    Currently does not copy fixed input port values from ``source``.
    See System::FixInputPortsFrom() if you want to copy those.

See also:
    SetTimeStateAndParametersFrom() if you want to copy time and
    accuracy along with state and parameters to a root context.)""";
        } SetStateAndParametersFrom;
        // Symbol: drake::systems::Context::SetTime
        struct /* SetTime */ {
          // Source: drake/systems/framework/context.h:334
          const char* doc =
R"""(Sets the current time in seconds. Sends out of date notifications for
all time-dependent computations (at least if the time has actually
changed). Time must have the same value in every subcontext within the
same Diagram context tree so may only be modified at the root context
of the tree.

Raises:
    RuntimeError if this is not the root context.)""";
        } SetTime;
        // Symbol: drake::systems::Context::SetTimeAndContinuousState
        struct /* SetTimeAndContinuousState */ {
          // Source: drake/systems/framework/context.h:353
          const char* doc =
R"""(Sets time to ``time_sec`` and continuous state to ``xc``. Performs a
single notification sweep to avoid duplicate notifications for
computations that depend on both time and state.

Raises:
    RuntimeError if this is not the root context.)""";
        } SetTimeAndContinuousState;
        // Symbol: drake::systems::Context::SetTimeAndGetMutableContinuousStateVector
        struct /* SetTimeAndGetMutableContinuousStateVector */ {
          // Source: drake/systems/framework/context.h:622
          const char* doc =
R"""((Advanced) Sets time and returns a mutable reference to the continuous
state xc (including q, v, z) as a VectorBase. Performs a single
notification sweep to avoid duplicate notifications for computations
that depend on both time and state.

Raises:
    RuntimeError if this is not the root context.

See also:
    SetTimeAndNoteContinuousStateChange()

See also:
    SetTimeAndGetMutableContinuousState())""";
        } SetTimeAndGetMutableContinuousStateVector;
        // Symbol: drake::systems::Context::SetTimeAndGetMutableQVector
        struct /* SetTimeAndGetMutableQVector */ {
          // Source: drake/systems/framework/context.h:634
          const char* doc =
R"""((Advanced) Sets time and returns a mutable reference to the
second-order continuous state partition q from xc. Performs a single
notification sweep to avoid duplicate notifications for computations
that depend on both time and q.

Raises:
    RuntimeError if this is not the root context.

See also:
    GetMutableVZVectors()

See also:
    SetTimeAndGetMutableContinuousStateVector())""";
        } SetTimeAndGetMutableQVector;
        // Symbol: drake::systems::Context::SetTimeAndNoteContinuousStateChange
        struct /* SetTimeAndNoteContinuousStateChange */ {
          // Source: drake/systems/framework/context.h:651
          const char* doc =
R"""((Advanced) Sets time and registers an intention to modify the
continuous state xc. Intended use is for integrators that are already
holding a mutable reference to xc which they are going to modify.
Performs a single notification sweep to avoid duplicate notifications
for computations that depend on both time and state.

Raises:
    RuntimeError if this is not the root context.

See also:
    SetTimeAndGetMutableContinuousStateVector())""";
        } SetTimeAndNoteContinuousStateChange;
        // Symbol: drake::systems::Context::SetTimeStateAndParametersFrom
        struct /* SetTimeStateAndParametersFrom */ {
          // Source: drake/systems/framework/context.h:442
          const char* doc =
R"""(Copies time, accuracy, all state and all parameters in ``source``,
where numerical values are of type ``U``, to ``this`` context. This
method can only be called on root contexts because time and accuracy
are copied. Sends out of date notifications for all dependent
computations in this context.

Raises:
    RuntimeError if this is not the root context.

Note:
    Currently does not copy fixed input port values from ``source``.
    See System::FixInputPortsFrom() if you want to copy those.

See also:
    SetStateAndParametersFrom() if you want to copy state and
    parameters to a non-root context.)""";
        } SetTimeStateAndParametersFrom;
        // Symbol: drake::systems::Context::access_mutable_parameters
        struct /* access_mutable_parameters */ {
          // Source: drake/systems/framework/context.h:736
          const char* doc =
R"""((Internal use only) Returns a reference to mutable parameters
*without* invalidation notifications. Use get_mutable_parameters()
instead for normal access.)""";
        } access_mutable_parameters;
        // Symbol: drake::systems::Context::access_mutable_state
        struct /* access_mutable_state */ {
          // Source: drake/systems/framework/context.h:744
          const char* doc =
R"""((Internal use only) Returns a reference to a mutable state *without*
invalidation notifications. Use get_mutable_state() instead for normal
access.)""";
        } access_mutable_state;
        // Symbol: drake::systems::Context::do_access_mutable_state
        struct /* do_access_mutable_state */ {
          // Source: drake/systems/framework/context.h:762
          const char* doc =
R"""(Returns a mutable reference to its concrete State object *without* any
invalidation. We promise not to allow user access to this object
without invalidation.)""";
        } do_access_mutable_state;
        // Symbol: drake::systems::Context::do_access_state
        struct /* do_access_state */ {
          // Source: drake/systems/framework/context.h:757
          const char* doc =
R"""(Returns a const reference to its concrete State object.)""";
        } do_access_state;
        // Symbol: drake::systems::Context::do_to_string
        struct /* do_to_string */ {
          // Source: drake/systems/framework/context.h:771
          const char* doc =
R"""(Returns a partial textual description of the Context, intended to be
human-readable. It is not guaranteed to be unambiguous nor complete.)""";
        } do_to_string;
        // Symbol: drake::systems::Context::get_abstract_parameter
        struct /* get_abstract_parameter */ {
          // Source: drake/systems/framework/context.h:196
          const char* doc =
R"""(Returns a const reference to the abstract-valued parameter at
``index``.

Precondition:
    ``index`` must identify an existing parameter.)""";
        } get_abstract_parameter;
        // Symbol: drake::systems::Context::get_abstract_state
        struct /* get_abstract_state */ {
          // Source: drake/systems/framework/context.h:156
          const char* doc_0args =
R"""(Returns a const reference to the abstract component of the state,
which may be of size zero.)""";
          // Source: drake/systems/framework/context.h:165
          const char* doc_1args =
R"""(Returns a const reference to the abstract component of the state at
``index``.

Precondition:
    ``index`` must identify an existing element.

Precondition:
    the abstract state's type must match the template argument.)""";
        } get_abstract_state;
        // Symbol: drake::systems::Context::get_accuracy
        struct /* get_accuracy */ {
          // Source: drake/systems/framework/context.h:173
          const char* doc =
R"""(Returns the accuracy setting (if any). Note that the return type is
``optional<double>`` rather than the double value itself.

See also:
    SetAccuracy() for details.)""";
        } get_accuracy;
        // Symbol: drake::systems::Context::get_continuous_state
        struct /* get_continuous_state */ {
          // Source: drake/systems/framework/context.h:113
          const char* doc =
R"""(Returns a const reference to the continuous component of the state,
which may be of size zero.)""";
        } get_continuous_state;
        // Symbol: drake::systems::Context::get_continuous_state_vector
        struct /* get_continuous_state_vector */ {
          // Source: drake/systems/framework/context.h:119
          const char* doc =
R"""(Returns a reference to the continuous state vector, devoid of
second-order structure. The vector may be of size zero.)""";
        } get_continuous_state_vector;
        // Symbol: drake::systems::Context::get_discrete_state
        struct /* get_discrete_state */ {
          // Source: drake/systems/framework/context.h:130
          const char* doc_0args =
R"""(Returns a reference to the entire discrete state, which may consist of
multiple discrete state vectors (groups).)""";
          // Source: drake/systems/framework/context.h:144
          const char* doc_1args =
R"""(Returns a const reference to group (vector) ``index`` of the discrete
state.

Precondition:
    ``index`` must identify an existing group.)""";
        } get_discrete_state;
        // Symbol: drake::systems::Context::get_discrete_state_vector
        struct /* get_discrete_state_vector */ {
          // Source: drake/systems/framework/context.h:137
          const char* doc =
R"""(Returns a reference to the *only* discrete state vector. The vector
may be of size zero.

Precondition:
    There is only one discrete state group.)""";
        } get_discrete_state_vector;
        // Symbol: drake::systems::Context::get_mutable_abstract_parameter
        struct /* get_mutable_abstract_parameter */ {
          // Source: drake/systems/framework/context.h:602
          const char* doc =
R"""(Returns a mutable reference to element ``index`` of the
abstract-valued parameters. Sends out of date notifications for all
computations dependent on this parameter.

Precondition:
    ``index`` must identify an existing abstract parameter.

Note:
    Currently notifies dependents of *all* abstract parameters.)""";
        } get_mutable_abstract_parameter;
        // Symbol: drake::systems::Context::get_mutable_abstract_state
        struct /* get_mutable_abstract_state */ {
          // Source: drake/systems/framework/context.h:566
          const char* doc_0args =
R"""(Returns a mutable reference to the abstract component of the state,
which may be of size zero. Sends out of date notifications for all
abstract-state-dependent computations.)""";
          // Source: drake/systems/framework/context.h:576
          const char* doc_1args =
R"""(Returns a mutable reference to element ``index`` of the abstract
state. Sends out of date notifications for all computations that
depend on this abstract state variable.

Precondition:
    ``index`` must identify an existing element.

Precondition:
    the abstract state's type must match the template argument.

Note:
    Currently notifies dependents of *any* abstract state variable.)""";
        } get_mutable_abstract_state;
        // Symbol: drake::systems::Context::get_mutable_continuous_state
        struct /* get_mutable_continuous_state */ {
          // Source: drake/systems/framework/context.h:529
          const char* doc =
R"""(Returns a mutable reference to the continuous component of the state,
which may be of size zero. Sends out of date notifications for all
continuous-state-dependent computations.)""";
        } get_mutable_continuous_state;
        // Symbol: drake::systems::Context::get_mutable_continuous_state_vector
        struct /* get_mutable_continuous_state_vector */ {
          // Source: drake/systems/framework/context.h:534
          const char* doc =
R"""(Returns a mutable reference to the continuous state vector, devoid of
second-order structure. The vector may be of size zero. Sends out of
date notifications for all continuous-state-dependent computations.)""";
        } get_mutable_continuous_state_vector;
        // Symbol: drake::systems::Context::get_mutable_discrete_state
        struct /* get_mutable_discrete_state */ {
          // Source: drake/systems/framework/context.h:541
          const char* doc_0args =
R"""(Returns a mutable reference to the discrete component of the state,
which may be of size zero. Sends out of date notifications for all
discrete-state-dependent computations.)""";
          // Source: drake/systems/framework/context.h:558
          const char* doc_1args =
R"""(Returns a mutable reference to group (vector) ``index`` of the
discrete state. Sends out of date notifications for all computations
that depend on this discrete state group.

Precondition:
    ``index`` must identify an existing group.

Note:
    Currently notifies dependents of *all* groups.)""";
        } get_mutable_discrete_state;
        // Symbol: drake::systems::Context::get_mutable_discrete_state_vector
        struct /* get_mutable_discrete_state_vector */ {
          // Source: drake/systems/framework/context.h:548
          const char* doc =
R"""(Returns a mutable reference to the *only* discrete state vector. Sends
out of date notifications for all discrete-state-dependent
computations.

See also:
    get_discrete_state_vector().

Precondition:
    There is only one discrete state group.)""";
        } get_mutable_discrete_state_vector;
        // Symbol: drake::systems::Context::get_mutable_numeric_parameter
        struct /* get_mutable_numeric_parameter */ {
          // Source: drake/systems/framework/context.h:594
          const char* doc =
R"""(Returns a mutable reference to element ``index`` of the vector-valued
(numeric) parameters. Sends out of date notifications for all
computations dependent on this parameter.

Precondition:
    ``index`` must identify an existing numeric parameter.

Note:
    Currently notifies dependents of *all* numeric parameters.)""";
        } get_mutable_numeric_parameter;
        // Symbol: drake::systems::Context::get_mutable_parameters
        struct /* get_mutable_parameters */ {
          // Source: drake/systems/framework/context.h:586
          const char* doc =
R"""(Returns a mutable reference to this Context's parameters. Sends out of
date notifications for all parameter-dependent computations. If you
don't mean to change all the parameters, use the indexed methods to
modify only some of the parameters so that fewer computations are
invalidated and fewer notifications need be sent.)""";
        } get_mutable_parameters;
        // Symbol: drake::systems::Context::get_mutable_state
        struct /* get_mutable_state */ {
          // Source: drake/systems/framework/context.h:524
          const char* doc =
R"""(Returns a mutable reference to the whole State, potentially
invalidating *all* state-dependent computations so requiring out of
date notifications to be made for all such computations. If you don't
mean to change the whole state, use more focused methods to modify
only a portion of the state. See class documentation for more
information.)""";
        } get_mutable_state;
        // Symbol: drake::systems::Context::get_numeric_parameter
        struct /* get_numeric_parameter */ {
          // Source: drake/systems/framework/context.h:185
          const char* doc =
R"""(Returns a const reference to the vector-valued parameter at ``index``.

Precondition:
    ``index`` must identify an existing parameter.)""";
        } get_numeric_parameter;
        // Symbol: drake::systems::Context::get_parameters
        struct /* get_parameters */ {
          // Source: drake/systems/framework/context.h:176
          const char* doc =
R"""(Returns a const reference to this Context's parameters.)""";
        } get_parameters;
        // Symbol: drake::systems::Context::get_state
        struct /* get_state */ {
          // Source: drake/systems/framework/context.h:65
          const char* doc =
R"""(Returns a const reference to the whole State.)""";
        } get_state;
        // Symbol: drake::systems::Context::get_time
        struct /* get_time */ {
          // Source: drake/systems/framework/context.h:62
          const char* doc =
R"""(Returns the current time in seconds.

See also:
    SetTime())""";
        } get_time;
        // Symbol: drake::systems::Context::get_true_time
        struct /* get_true_time */ {
          // Source: drake/systems/framework/context.h:705
          const char* doc = R"""()""";
        } get_true_time;
        // Symbol: drake::systems::Context::has_only_continuous_state
        struct /* has_only_continuous_state */ {
          // Source: drake/systems/framework/context.h:79
          const char* doc =
R"""(Returns true if the Context has continuous state, but no discrete or
abstract state.)""";
        } has_only_continuous_state;
        // Symbol: drake::systems::Context::has_only_discrete_state
        struct /* has_only_discrete_state */ {
          // Source: drake/systems/framework/context.h:88
          const char* doc =
R"""(Returns true if the Context has discrete state, but no continuous or
abstract state.)""";
        } has_only_discrete_state;
        // Symbol: drake::systems::Context::init_abstract_state
        struct /* init_abstract_state */ {
          // Source: drake/systems/framework/context.h:802
          const char* doc =
R"""((Internal use only) Sets the abstract state to ``xa``, deleting
whatever was there before.

Warning:
    Does *not* invalidate state-dependent computations.)""";
        } init_abstract_state;
        // Symbol: drake::systems::Context::init_continuous_state
        struct /* init_continuous_state */ {
          // Source: drake/systems/framework/context.h:792
          const char* doc =
R"""((Internal use only) Sets the continuous state to ``xc``, deleting
whatever was there before.

Warning:
    Does *not* invalidate state-dependent computations.)""";
        } init_continuous_state;
        // Symbol: drake::systems::Context::init_discrete_state
        struct /* init_discrete_state */ {
          // Source: drake/systems/framework/context.h:797
          const char* doc =
R"""((Internal use only) Sets the discrete state to ``xd``, deleting
whatever was there before.

Warning:
    Does *not* invalidate state-dependent computations.)""";
        } init_discrete_state;
        // Symbol: drake::systems::Context::init_parameters
        struct /* init_parameters */ {
          // Source: drake/systems/framework/context.h:808
          const char* doc =
R"""((Internal use only) Sets the parameters to ``params``, deleting
whatever was there before. You must supply a Parameters object; null
is not acceptable.

Warning:
    Does *not* invalidate parameter-dependent computations.)""";
        } init_parameters;
        // Symbol: drake::systems::Context::is_stateless
        struct /* is_stateless */ {
          // Source: drake/systems/framework/context.h:70
          const char* doc =
R"""(Returns true if the Context has no state.)""";
        } is_stateless;
        // Symbol: drake::systems::Context::num_abstract_parameters
        struct /* num_abstract_parameters */ {
          // Source: drake/systems/framework/context.h:190
          const char* doc =
R"""(Returns the number of abstract-valued parameters.)""";
        } num_abstract_parameters;
        // Symbol: drake::systems::Context::num_abstract_states
        struct /* num_abstract_states */ {
          // Source: drake/systems/framework/context.h:150
          const char* doc =
R"""(Returns the number of elements in the abstract state.)""";
        } num_abstract_states;
        // Symbol: drake::systems::Context::num_continuous_states
        struct /* num_continuous_states */ {
          // Source: drake/systems/framework/context.h:107
          const char* doc =
R"""(Returns the number of continuous state variables ``xc = {q, v, z}``.)""";
        } num_continuous_states;
        // Symbol: drake::systems::Context::num_discrete_state_groups
        struct /* num_discrete_state_groups */ {
          // Source: drake/systems/framework/context.h:124
          const char* doc =
R"""(Returns the number of vectors (groups) in the discrete state.)""";
        } num_discrete_state_groups;
        // Symbol: drake::systems::Context::num_numeric_parameter_groups
        struct /* num_numeric_parameter_groups */ {
          // Source: drake/systems/framework/context.h:179
          const char* doc =
R"""(Returns the number of vector-valued parameters.)""";
        } num_numeric_parameter_groups;
        // Symbol: drake::systems::Context::num_total_states
        struct /* num_total_states */ {
          // Source: drake/systems/framework/context.h:98
          const char* doc =
R"""(Returns the total dimension of all of the basic vector states (as if
they were muxed).

Raises:
    RuntimeError if the system contains any abstract state.)""";
        } num_total_states;
        // Symbol: drake::systems::Context::to_string
        struct /* to_string */ {
          // Source: drake/systems/framework/context.h:684
          const char* doc =
R"""(Returns a partial textual description of the Context, intended to be
human-readable. It is not guaranteed to be unambiguous nor complete.)""";
        } to_string;
      } Context;
      // Symbol: drake::systems::ContextBase
      struct /* ContextBase */ {
        // Source: drake/systems/framework/context_base.h:39
        const char* doc =
R"""(Provides non-templatized Context functionality shared by the
templatized derived classes. That includes caching, dependency
tracking, and management of local values for fixed input ports.

Terminology: in general a Drake System is a tree structure composed of
"subsystems", which are themselves System objects. The corresponding
Context is a parallel tree structure composed of "subcontexts", which
are themselves Context objects. There is a one-to-one correspondence
between subsystems and subcontexts. Within a given System (Context),
its child subsystems (subcontexts) are indexed using a SubsystemIndex;
there is no separate SubcontextIndex since the numbering must be
identical.)""";
        // Symbol: drake::systems::ContextBase::AddAbstractParameterTicket
        struct /* AddAbstractParameterTicket */ {
          // Source: drake/systems/framework/context_base.h:325
          const char* doc =
R"""(Adds a ticket to the list of abstract parameter tickets.)""";
        } AddAbstractParameterTicket;
        // Symbol: drake::systems::ContextBase::AddAbstractStateTicket
        struct /* AddAbstractStateTicket */ {
          // Source: drake/systems/framework/context_base.h:315
          const char* doc =
R"""(Adds a ticket to the list of abstract state tickets.)""";
        } AddAbstractStateTicket;
        // Symbol: drake::systems::ContextBase::AddDiscreteStateTicket
        struct /* AddDiscreteStateTicket */ {
          // Source: drake/systems/framework/context_base.h:310
          const char* doc =
R"""(Adds a ticket to the list of discrete state tickets.)""";
        } AddDiscreteStateTicket;
        // Symbol: drake::systems::ContextBase::AddInputPort
        struct /* AddInputPort */ {
          // Source: drake/systems/framework/context_base.h:299
          const char* doc =
R"""(Adds the next input port. Expected index is supplied along with the
assigned ticket. Subscribes the "all input ports" tracker to this one.
The fixed_input_type_checker will be used for validation when setting
a fixed input, or may be null when no validation should be performed.
Typically the fixed_input_type_checker is created by
System::MakeFixInputPortTypeChecker. The fixed_input_type_checker
lifetime will be the same as this ContextBase, so it should not depend
on pointers that may go out of scope. Most acutely, the function must
not depend on any captured SystemBase pointers.)""";
        } AddInputPort;
        // Symbol: drake::systems::ContextBase::AddNumericParameterTicket
        struct /* AddNumericParameterTicket */ {
          // Source: drake/systems/framework/context_base.h:320
          const char* doc =
R"""(Adds a ticket to the list of numeric parameter tickets.)""";
        } AddNumericParameterTicket;
        // Symbol: drake::systems::ContextBase::AddOutputPort
        struct /* AddOutputPort */ {
          // Source: drake/systems/framework/context_base.h:305
          const char* doc =
R"""(Adds the next output port. Expected index is supplied along with the
assigned ticket.)""";
        } AddOutputPort;
        // Symbol: drake::systems::ContextBase::BuildTrackerPointerMap
        struct /* BuildTrackerPointerMap */ {
          // Source: drake/systems/framework/context_base.h:477
          const char* doc =
R"""((Internal use only) Given a new context ``clone`` containing an
identically-structured dependency graph as the one in ``source``,
creates a mapping of all tracker memory addresses from ``source`` to
``clone``. This must be done for the whole Context tree because
pointers can point outside of their containing subcontext.)""";
        } BuildTrackerPointerMap;
        // Symbol: drake::systems::ContextBase::Clone
        struct /* Clone */ {
          // Source: drake/systems/framework/context_base.h:52
          const char* doc =
R"""(Creates an identical copy of the concrete context object.

Raises:
    RuntimeError if this is not the root context.)""";
        } Clone;
        // Symbol: drake::systems::ContextBase::CloneWithoutPointers
        struct /* CloneWithoutPointers */ {
          // Source: drake/systems/framework/context_base.h:458
          const char* doc =
R"""((Internal use only) Clones a context but without copying any of its
internal pointers; the clone's pointers are set to null.)""";
        } CloneWithoutPointers;
        // Symbol: drake::systems::ContextBase::ContextBase
        struct /* ctor */ {
          // Source: drake/systems/framework/context_base.h:45
          const char* doc_move =
R"""(@name Does not allow copy, move, or assignment.)""";
          // Source: drake/systems/framework/context_base.h:273
          const char* doc =
R"""(Default constructor creates an empty ContextBase but initializes all
the built-in dependency trackers that are the same in every System
(like time, q, all states, all inputs, etc.). We can't allocate
trackers for individual discrete & abstract states, parameters, or
input ports since we don't yet know how many there are.)""";
          // Source: drake/systems/framework/context_base.h:282
          const char* doc_copy =
R"""(Copy constructor takes care of base class data members, but *does not*
fix up base class pointers. Derived classes must implement copy
constructors that delegate to this one for use in their
DoCloneWithoutPointers() implementations. The cache and dependency
graph are copied, but any pointers contained in the source are left
null in the copy.)""";
        } ctor;
        // Symbol: drake::systems::ContextBase::DisableCaching
        struct /* DisableCaching */ {
          // Source: drake/systems/framework/context_base.h:65
          const char* doc =
R"""((Debugging) Disables caching recursively for this context and all its
subcontexts. Disabling forces every ``Eval()`` method to perform a
full calculation rather than returning the cached one. Results should
be identical with or without caching, except for performance. If they
are not, there is likely a problem with (a) the specified dependencies
for some calculation, or (b) a misuse of references into cached values
that hides modifications from the caching system, or (c) a bug in the
caching system. The ``is_disabled`` flags are independent of the
``out_of_date`` flags, which continue to be maintained even when
caching is disabled (though they are ignored).)""";
        } DisableCaching;
        // Symbol: drake::systems::ContextBase::DoCloneWithoutPointers
        struct /* DoCloneWithoutPointers */ {
          // Source: drake/systems/framework/context_base.h:544
          const char* doc =
R"""(Derived classes must implement this so that it performs the complete
deep copy of the context, including all base class members but not
fixing up base class pointers. To do that, implement a protected copy
constructor that inherits from the base class copy constructor (which
doesn't repair the pointers), then implement DoCloneWithoutPointers()
as ``return std::unique_ptr<ContextBase>(new DerivedType(*this));``.)""";
        } DoCloneWithoutPointers;
        // Symbol: drake::systems::ContextBase::DoPropagateBuildTrackerPointerMap
        struct /* DoPropagateBuildTrackerPointerMap */ {
          // Source: drake/systems/framework/context_base.h:549
          const char* doc =
R"""(DiagramContext must implement this to invoke BuildTrackerPointerMap()
on each of its subcontexts. The default implementation does nothing
which is fine for a LeafContext.)""";
        } DoPropagateBuildTrackerPointerMap;
        // Symbol: drake::systems::ContextBase::DoPropagateBulkChange
        struct /* DoPropagateBulkChange */ {
          // Source: drake/systems/framework/context_base.h:576
          const char* doc =
R"""(DiagramContext must implement this to invoke PropagateBulkChange() on
its subcontexts, passing along the indicated method that specifies the
particular bulk change (e.g. whole state, all parameters, all discrete
state variables, etc.). The default implementation does nothing which
is fine for a LeafContext.)""";
        } DoPropagateBulkChange;
        // Symbol: drake::systems::ContextBase::DoPropagateCachingChange
        struct /* DoPropagateCachingChange */ {
          // Source: drake/systems/framework/context_base.h:567
          const char* doc =
R"""(DiagramContext must implement this to invoke a caching behavior change
on each of its subcontexts. The default implementation does nothing
which is fine for a LeafContext.)""";
        } DoPropagateCachingChange;
        // Symbol: drake::systems::ContextBase::DoPropagateFixContextPointers
        struct /* DoPropagateFixContextPointers */ {
          // Source: drake/systems/framework/context_base.h:558
          const char* doc =
R"""(DiagramContext must implement this to invoke FixContextPointers() on
each of its subcontexts. The default implementation does nothing which
is fine for a LeafContext.)""";
        } DoPropagateFixContextPointers;
        // Symbol: drake::systems::ContextBase::EnableCaching
        struct /* EnableCaching */ {
          // Source: drake/systems/framework/context_base.h:78
          const char* doc =
R"""((Debugging) Re-enables caching recursively for this context and all
its subcontexts. The ``is_disabled`` flags are independent of the
``out_of_date`` flags, which continue to be maintained even when
caching is disabled (though they are ignored). Hence re-enabling the
cache with this method may result in some entries being already
considered up to date. See SetAllCacheEntriesOutOfDate() if you want
to ensure that caching restarts with everything out of date. You might
want to do that, for example, for repeatability or because you
modified something in the debugger and want to make sure it gets used.)""";
        } EnableCaching;
        // Symbol: drake::systems::ContextBase::FixContextPointers
        struct /* FixContextPointers */ {
          // Source: drake/systems/framework/context_base.h:486
          const char* doc =
R"""((Internal use only) Assuming ``clone`` is a recently-cloned Context
that has yet to have its internal pointers updated, sets those
pointers now. The given map is used to update tracker pointers.)""";
        } FixContextPointers;
        // Symbol: drake::systems::ContextBase::FixInputPort
        struct /* FixInputPort */ {
          // Source: drake/systems/framework/context_base.h:218
          const char* doc =
R"""((Advanced) Connects the input port at ``index`` to a
FixedInputPortValue with the given abstract ``value``. Returns a
reference to the allocated FixedInputPortValue that will remain valid
until this input port's value source is replaced or the Context is
destroyed. You may use that reference to modify the input port's value
using the appropriate FixedInputPortValue method, which will ensure
that invalidation notifications are delivered.

This is the most general way to provide a value (type-erased) for an
unconnected input port. Using the ``FixValue()`` method of the input
port to set the value is the preferred workflow due to its additional
sugar.

Note:
    Calling this method on an already connected input port, i.e., an
    input port that has previously been passed into a call to
    DiagramBuilder::Connect(), causes FixedInputPortValue to override
    any other value present on that port.

Precondition:
    ``index`` selects an existing input port of this Context.)""";
          // Source: drake/systems/framework/context_base.h:227
          const char* doc_deprecated =
R"""((Advanced) Same as above method but the value is passed by unique_ptr
instead of by const reference. The port will contain a copy of the
``value`` (not retain a pointer to the ``value``). */ (Deprecated.)

Deprecated:
    Use input_port.FixValue() instead of context.FixInputPort(), or in
    rare cases if an InputPort is not available, pass the value
    argument here by-value, instead of by-unique-ptr. This will be
    removed from Drake on or after 2021-04-01.)""";
        } FixInputPort;
        // Symbol: drake::systems::ContextBase::FreezeCache
        struct /* FreezeCache */ {
          // Source: drake/systems/framework/context_base.h:100
          const char* doc =
R"""((Advanced) Freezes the cache at its current contents, preventing any
further cache updates. When frozen, accessing an out-of-date cache
entry causes an exception to be throw. This is applied recursively to
this Context and all its subcontexts, but *not* to its parent or
siblings so it is most useful when called on the root Context. If the
cache was already frozen this method does nothing but waste a little
time.)""";
        } FreezeCache;
        // Symbol: drake::systems::ContextBase::GetSystemName
        struct /* GetSystemName */ {
          // Source: drake/systems/framework/context_base.h:123
          const char* doc =
R"""(Returns the local name of the subsystem for which this is the Context.
This is intended primarily for error messages and logging.

See also:
    SystemBase::GetSystemName() for details.

See also:
    GetSystemPathname() if you want the full name.)""";
        } GetSystemName;
        // Symbol: drake::systems::ContextBase::GetSystemPathname
        struct /* GetSystemPathname */ {
          // Source: drake/systems/framework/context_base.h:134
          const char* doc =
R"""(Returns the full pathname of the subsystem for which this is the
Context. This is intended primarily for error messages and logging.

See also:
    SystemBase::GetSystemPathname() for details.)""";
        } GetSystemPathname;
        // Symbol: drake::systems::ContextBase::MaybeGetFixedInputPortValue
        struct /* MaybeGetFixedInputPortValue */ {
          // Source: drake/systems/framework/context_base.h:235
          const char* doc =
R"""(For input port ``index``, returns a const FixedInputPortValue if the
port is fixed, otherwise nullptr.

Precondition:
    ``index`` selects an existing input port of this Context.)""";
        } MaybeGetFixedInputPortValue;
        // Symbol: drake::systems::ContextBase::MaybeGetMutableFixedInputPortValue
        struct /* MaybeGetMutableFixedInputPortValue */ {
          // Source: drake/systems/framework/context_base.h:243
          const char* doc =
R"""(For input port ``index``, returns a mutable FixedInputPortValue if the
port is fixed, otherwise nullptr.

Precondition:
    ``index`` selects an existing input port of this Context.)""";
        } MaybeGetMutableFixedInputPortValue;
        // Symbol: drake::systems::ContextBase::NoteAccuracyChanged
        struct /* NoteAccuracyChanged */ {
          // Source: drake/systems/framework/context_base.h:350
          const char* doc =
R"""(Notifies the local accuracy tracker that the accuracy setting may have
changed.)""";
        } NoteAccuracyChanged;
        // Symbol: drake::systems::ContextBase::NoteAllAbstractParametersChanged
        struct /* NoteAllAbstractParametersChanged */ {
          // Source: drake/systems/framework/context_base.h:436
          const char* doc =
R"""(Notifies each local abstract parameter tracker that the value of the
parameter it manages may have changed. If there are no abstract
parameters owned by this context, nothing happens. A DiagramContext
does not own any parameters.)""";
        } NoteAllAbstractParametersChanged;
        // Symbol: drake::systems::ContextBase::NoteAllAbstractStateChanged
        struct /* NoteAllAbstractStateChanged */ {
          // Source: drake/systems/framework/context_base.h:410
          const char* doc =
R"""(Notifies each local abstract state variable tracker that the value of
the abstract state variable it manages may have changed. If there are
no abstract state variables owned by this context, nothing happens. A
DiagramContext does not own any abstract state variables.)""";
        } NoteAllAbstractStateChanged;
        // Symbol: drake::systems::ContextBase::NoteAllContinuousStateChanged
        struct /* NoteAllContinuousStateChanged */ {
          // Source: drake/systems/framework/context_base.h:366
          const char* doc =
R"""(Notifies the local q, v, and z trackers that each of them may have
changed, likely because someone has asked to modify continuous state
xc.)""";
        } NoteAllContinuousStateChanged;
        // Symbol: drake::systems::ContextBase::NoteAllDiscreteStateChanged
        struct /* NoteAllDiscreteStateChanged */ {
          // Source: drake/systems/framework/context_base.h:401
          const char* doc =
R"""(Notifies each local discrete state group tracker that the value of the
discrete state group it manages may have changed. If there are no
discrete state groups owned by this context, nothing happens. A
DiagramContext does not own any discrete state groups.)""";
        } NoteAllDiscreteStateChanged;
        // Symbol: drake::systems::ContextBase::NoteAllNumericParametersChanged
        struct /* NoteAllNumericParametersChanged */ {
          // Source: drake/systems/framework/context_base.h:427
          const char* doc =
R"""(Notifies each local numeric parameter tracker that the value of the
parameter it manages may have changed. If there are no numeric
parameters owned by this context, nothing happens. A DiagramContext
does not own any parameters.)""";
        } NoteAllNumericParametersChanged;
        // Symbol: drake::systems::ContextBase::NoteAllParametersChanged
        struct /* NoteAllParametersChanged */ {
          // Source: drake/systems/framework/context_base.h:418
          const char* doc =
R"""(Notifies the local numeric and abstract parameter trackers that each
of them may have changed, likely because someone asked to modify all
the parameters.)""";
        } NoteAllParametersChanged;
        // Symbol: drake::systems::ContextBase::NoteAllQChanged
        struct /* NoteAllQChanged */ {
          // Source: drake/systems/framework/context_base.h:380
          const char* doc =
R"""(Notifies the local q tracker that the q's may have changed.)""";
        } NoteAllQChanged;
        // Symbol: drake::systems::ContextBase::NoteAllStateChanged
        struct /* NoteAllStateChanged */ {
          // Source: drake/systems/framework/context_base.h:358
          const char* doc =
R"""(Notifies the local continuous, discrete, and abstract state trackers
that each of them may have changed, likely because someone has asked
to modify the whole state x.)""";
        } NoteAllStateChanged;
        // Symbol: drake::systems::ContextBase::NoteAllVChanged
        struct /* NoteAllVChanged */ {
          // Source: drake/systems/framework/context_base.h:386
          const char* doc =
R"""(Notifies the local v tracker that the v's may have changed.)""";
        } NoteAllVChanged;
        // Symbol: drake::systems::ContextBase::NoteAllVZChanged
        struct /* NoteAllVZChanged */ {
          // Source: drake/systems/framework/context_base.h:374
          const char* doc =
R"""(Notifies the local v and z trackers that each of them may have
changed, likely because someone has asked to modify just the
first-order state variables in xc.)""";
        } NoteAllVZChanged;
        // Symbol: drake::systems::ContextBase::NoteAllZChanged
        struct /* NoteAllZChanged */ {
          // Source: drake/systems/framework/context_base.h:392
          const char* doc =
R"""(Notifies the local z tracker that the z's may have changed.)""";
        } NoteAllZChanged;
        // Symbol: drake::systems::ContextBase::NoteTimeChanged
        struct /* NoteTimeChanged */ {
          // Source: drake/systems/framework/context_base.h:343
          const char* doc =
R"""(Notifies the local time tracker that time may have changed.)""";
        } NoteTimeChanged;
        // Symbol: drake::systems::ContextBase::PropagateBulkChange
        struct /* PropagateBulkChange */ {
          // Source: drake/systems/framework/context_base.h:508
          const char* doc_3args =
R"""((Internal use only) Applies the given bulk-change notification method
to the given ``context``, and propagates the notification to
subcontexts if this is a DiagramContext.)""";
          // Source: drake/systems/framework/context_base.h:517
          const char* doc_2args =
R"""((Internal use only) This is a convenience method for invoking the
eponymous static method on ``this`` context (which occurs frequently).)""";
        } PropagateBulkChange;
        // Symbol: drake::systems::ContextBase::PropagateCachingChange
        struct /* PropagateCachingChange */ {
          // Source: drake/systems/framework/context_base.h:497
          const char* doc =
R"""((Internal use only) Applies the given caching-change notification
method to ``context``, and propagates the notification to subcontexts
if ``context`` is a DiagramContext. Used, for example, to enable and
disable the cache. The supplied ``context`` is const so depends on the
cache being mutable.)""";
        } PropagateCachingChange;
        // Symbol: drake::systems::ContextBase::SetAllCacheEntriesOutOfDate
        struct /* SetAllCacheEntriesOutOfDate */ {
          // Source: drake/systems/framework/context_base.h:90
          const char* doc =
R"""((Debugging) Marks all cache entries out of date, recursively for this
context and all its subcontexts. This forces the next ``Eval()``
request for each cache entry to perform a full calculation rather than
returning the cached one. After that first recalculation, normal
caching behavior resumes (assuming the cache is not disabled). Results
should be identical whether this is called or not, since the caching
system should be maintaining this flag correctly. If they are not, see
the documentation for SetIsCacheDisabled() for suggestions.)""";
        } SetAllCacheEntriesOutOfDate;
        // Symbol: drake::systems::ContextBase::UnfreezeCache
        struct /* UnfreezeCache */ {
          // Source: drake/systems/framework/context_base.h:108
          const char* doc =
R"""((Advanced) Unfreezes the cache if it was previously frozen. This is
applied recursively to this Context and all its subcontexts, but *not*
to its parent or siblings. If the cache was not frozen, this does
nothing but waste a little time.)""";
        } UnfreezeCache;
        // Symbol: drake::systems::ContextBase::get_cache
        struct /* get_cache */ {
          // Source: drake/systems/framework/context_base.h:137
          const char* doc =
R"""(Returns a const reference to this subcontext's cache.)""";
        } get_cache;
        // Symbol: drake::systems::ContextBase::get_dependency_graph
        struct /* get_dependency_graph */ {
          // Source: drake/systems/framework/context_base.h:169
          const char* doc =
R"""(Returns a const reference to the collection of value trackers within
this subcontext. Together these form the dependency subgraph for the
values in this subcontext, plus edges leading to neighboring trackers.)""";
        } get_dependency_graph;
        // Symbol: drake::systems::ContextBase::get_mutable_cache
        struct /* get_mutable_cache */ {
          // Source: drake/systems/framework/context_base.h:149
          const char* doc =
R"""((Advanced) Returns a mutable reference to this subcontext's cache.
Note that this method is const because the cache is always writable.

Warning:
    Writing directly to the cache does not automatically propagate
    invalidations to downstream dependents of a contained cache entry,
    because invalidations would normally have been propagated when the
    cache entry itself went out of date. Cache entries are updated
    automatically when needed via their ``Calc()`` methods; most users
    should not bypass that mechanism by using this method.)""";
        } get_mutable_cache;
        // Symbol: drake::systems::ContextBase::get_mutable_dependency_graph
        struct /* get_mutable_dependency_graph */ {
          // Source: drake/systems/framework/context_base.h:174
          const char* doc =
R"""(Returns a mutable reference to the dependency graph.)""";
        } get_mutable_dependency_graph;
        // Symbol: drake::systems::ContextBase::get_mutable_tracker
        struct /* get_mutable_tracker */ {
          // Source: drake/systems/framework/context_base.h:162
          const char* doc =
R"""(Returns a mutable reference to a DependencyTracker in this subcontext.
(You do not need mutable access just to issue value change
notifications.))""";
        } get_mutable_tracker;
        // Symbol: drake::systems::ContextBase::get_system_id
        struct /* get_system_id */ {
          // Source: drake/systems/framework/context_base.h:129
          const char* doc =
R"""((Internal) Gets the id of the subsystem that created this context.)""";
        } get_system_id;
        // Symbol: drake::systems::ContextBase::get_tracker
        struct /* get_tracker */ {
          // Source: drake/systems/framework/context_base.h:156
          const char* doc =
R"""(Returns a const reference to a DependencyTracker in this subcontext.
Advanced users and internal code can use the returned reference to
issue value change notifications -- mutable access is not required for
that purpose.)""";
        } get_tracker;
        // Symbol: drake::systems::ContextBase::input_port_ticket
        struct /* input_port_ticket */ {
          // Source: drake/systems/framework/context_base.h:190
          const char* doc =
R"""(Returns the dependency ticket associated with a particular input port.)""";
        } input_port_ticket;
        // Symbol: drake::systems::ContextBase::is_cache_frozen
        struct /* is_cache_frozen */ {
          // Source: drake/systems/framework/context_base.h:115
          const char* doc =
R"""((Advanced) Reports whether this Context's cache is currently frozen.
This checks only locally; it is possible that parent, child, or
sibling subcontext caches are in a different state than this one.)""";
        } is_cache_frozen;
        // Symbol: drake::systems::ContextBase::is_root_context
        struct /* is_root_context */ {
          // Source: drake/systems/framework/context_base.h:265
          const char* doc =
R"""(Returns true if this context has no parent.)""";
        } is_root_context;
        // Symbol: drake::systems::ContextBase::num_input_ports
        struct /* num_input_ports */ {
          // Source: drake/systems/framework/context_base.h:179
          const char* doc =
R"""(Returns the number of input ports in this context.)""";
        } num_input_ports;
        // Symbol: drake::systems::ContextBase::num_output_ports
        struct /* num_output_ports */ {
          // Source: drake/systems/framework/context_base.h:185
          const char* doc =
R"""(Returns the number of output ports represented in this context.)""";
        } num_output_ports;
        // Symbol: drake::systems::ContextBase::output_port_ticket
        struct /* output_port_ticket */ {
          // Source: drake/systems/framework/context_base.h:196
          const char* doc =
R"""(Returns the dependency ticket associated with a particular output
port.)""";
        } output_port_ticket;
        // Symbol: drake::systems::ContextBase::owns_any_variables_or_parameters
        struct /* owns_any_variables_or_parameters */ {
          // Source: drake/systems/framework/context_base.h:447
          const char* doc =
R"""((Internal use only) Returns true if this context provides resources
for its own individual state variables or parameters. That means those
variables or parameters were declared by this context's corresponding
System. Currently only leaf systems may declare variables and
parameters; diagram contexts can use this method to check that
invariant.)""";
        } owns_any_variables_or_parameters;
        // Symbol: drake::systems::ContextBase::set_parent
        struct /* set_parent */ {
          // Source: drake/systems/framework/context_base.h:528
          const char* doc =
R"""(Declares that ``parent`` is the context of the enclosing Diagram.
Aborts if the parent has already been set or is null.)""";
        } set_parent;
        // Symbol: drake::systems::ContextBase::start_new_change_event
        struct /* start_new_change_event */ {
          // Source: drake/systems/framework/context_base.h:251
          const char* doc =
R"""((Internal use only) Returns the next change event serial number that
is unique for this entire Context tree, not just this subcontext. This
number is not reset after a Context is copied but continues to count
up.)""";
        } start_new_change_event;
      } ContextBase;
      // Symbol: drake::systems::ContinuousState
      struct /* ContinuousState */ {
        // Source: drake/systems/framework/continuous_state.h:74
        const char* doc =
R"""(%ContinuousState is a view of, and optionally a container for, all the
continuous state variables ``xc`` of a Drake System. Continuous state
variables are those whose values are defined by differential
equations, so we expect there to be a well-defined time derivative
``xcdot`` ≜ ``d/dt xc``.

The contents of ``xc`` are conceptually partitioned into three groups:

- ``q`` is generalized position
- ``v`` is generalized velocity
- ``z`` is other continuous state

For a Drake LeafSystem these partitions are stored contiguously in
memory in this sequence: xc=[q v z]. But because a Drake System may be
a Diagram composed from subsystems, each with its own continuous state
variables ("substates"), the composite continuous state will not
generally be stored in contiguous memory. In that case the most we can
say is that xc={q,v,z}, that is, it consists of all the q's, v's, and
z's, in some order.

Nevertheless, this ContinuousState class provides a vector view of the
data that groups together all the q partitions, v partitions, and z
partitions. For example, if there are three subsystems (possibly
Diagrams) whose continuous state variables are respectively
xc₁={q₁,v₁,z₁}, xc₂={q₂,v₂,z₂}, and xc₃={q₃,v₃,z₃} the composite xc
includes all the partitions in an undefined order. However, composite
q, v, and z appear ordered as q=[q₁ q₂ q₃], v=[v₁ v₂ v₃], z=[z₁ z₂
z₃]. Note that the element ordering of the composite xc is *not* a
concatenation of the composite subgroups. Do not index elements of the
full state xc unless you know it is the continuous state of a
LeafSystem (a LeafSystem looking at its own Context can depend on
that).

Any of the groups may be empty. However, groups q and v must be either
both present or both empty, because the time derivative ``qdot`` of
the second-order state variables ``q`` must be computable using a
linear mapping ``qdot=N(q)*v``.

The time derivative ``xcdot`` has the identical substructure to
``xc``, with the partitions interpreted as ``qdot``, `vdot`, and
``zdot``. We use identical ContinuousState objects for both.

*Memory ownership*

When a ContinuousState represents the state of a LeafSystem, it always
owns the memory that is used for the state variables and is
responsible for destruction. For a Diagram, ContinuousState can
instead be a *view* of the underlying LeafSystem substates, so that
modifying the Diagram's continuous state affects the LeafSystems
appropriately. In that case, the memory is owned by the underlying
LeafSystems. However, when a ContinuousState object of any structure
is cloned, the resulting object *always* owns all its underlying
memory, which is initialized with a copy of the original state
variable values but is otherwise independent. The cloned object
retains the structure and ordering of the elements and does not
guarantee contiguous storage.

See also:
    DiagramContinuousState for more information.)""";
        // Symbol: drake::systems::ContinuousState::Clone
        struct /* Clone */ {
          // Source: drake/systems/framework/continuous_state.h:109
          const char* doc =
R"""(Creates a deep copy of this object with the same substructure but with
all data owned by the copy. That is, if the original was a Diagram
continuous state that merely referenced substates, the clone will not
include any references to the original substates and is thus decoupled
from the Context containing the original. The concrete type of the
BasicVector underlying each leaf ContinuousState is preserved. See the
class comments above for more information.)""";
        } Clone;
        // Symbol: drake::systems::ContinuousState::ContinuousState<T>
        struct /* ctor */ {
          // Source: drake/systems/framework/continuous_state.h:83
          const char* doc_1args_state =
R"""(Constructs a ContinuousState for a system that does not have
second-order structure. The ``q`` and ``v`` partitions are empty; all
of the state ``xc`` is miscellaneous continuous state ``z``.)""";
          // Source: drake/systems/framework/continuous_state.h:94
          const char* doc_4args_state_num_q_num_v_num_z =
R"""(Constructs a ContinuousState that exposes second-order structure.

Parameter ``state``:
    The source xc of continuous state information.

Parameter ``num_q``:
    The number of position variables q.

Parameter ``num_v``:
    The number of velocity variables v.

Parameter ``num_z``:
    The number of other continuous variables z.

We require that ``num_q ≥ num_v`` and that the sum of the partition
sizes adds up to the size of ``state``.)""";
          // Source: drake/systems/framework/continuous_state.h:98
          const char* doc_0args =
R"""(Constructs a zero-length ContinuousState.)""";
          // Source: drake/systems/framework/continuous_state.h:213
          const char* doc_4args_state_q_v_z =
R"""(Constructs a continuous state that exposes second-order structure,
with no particular constraints on the layout.

Precondition:
    The q, v, z are all views into the same storage as ``state``.

Parameter ``state``:
    The entire continuous state.

Parameter ``q``:
    The subset of state that is generalized position.

Parameter ``v``:
    The subset of state that is generalized velocity.

Parameter ``z``:
    The subset of state that is neither position nor velocity.)""";
        } ctor;
        // Symbol: drake::systems::ContinuousState::CopyToVector
        struct /* CopyToVector */ {
          // Source: drake/systems/framework/continuous_state.h:195
          const char* doc =
R"""(Returns a copy of the entire continuous state vector into an Eigen
vector.)""";
        } CopyToVector;
        // Symbol: drake::systems::ContinuousState::DoClone
        struct /* DoClone */ {
          // Source: drake/systems/framework/continuous_state.h:226
          const char* doc =
R"""(DiagramContinuousState must override this to maintain the necessary
internal substructure, and to perform a deep copy so that the result
owns all its own data. The default implementation here requires that
the full state is a BasicVector (that is, this is a leaf continuous
state). The BasicVector is cloned to preserve its concrete type and
contents, then the q, v, z Subvectors are created referencing it. The
implementation should not set_system_id on the result, the caller will
set an id on the state after this method returns.)""";
        } DoClone;
        // Symbol: drake::systems::ContinuousState::SetFrom
        struct /* SetFrom */ {
          // Source: drake/systems/framework/continuous_state.h:179
          const char* doc =
R"""(Copies the values from ``other`` into ``this``, converting the scalar
type as necessary.)""";
        } SetFrom;
        // Symbol: drake::systems::ContinuousState::SetFromVector
        struct /* SetFromVector */ {
          // Source: drake/systems/framework/continuous_state.h:189
          const char* doc =
R"""(Sets the entire continuous state vector from an Eigen expression.)""";
        } SetFromVector;
        // Symbol: drake::systems::ContinuousState::get_generalized_position
        struct /* get_generalized_position */ {
          // Source: drake/systems/framework/continuous_state.h:142
          const char* doc =
R"""(Returns a const reference to the subset of the state vector that is
generalized position ``q``. May be zero length.)""";
        } get_generalized_position;
        // Symbol: drake::systems::ContinuousState::get_generalized_velocity
        struct /* get_generalized_velocity */ {
          // Source: drake/systems/framework/continuous_state.h:154
          const char* doc =
R"""(Returns a const reference to the subset of the continuous state vector
that is generalized velocity ``v``. May be zero length.)""";
        } get_generalized_velocity;
        // Symbol: drake::systems::ContinuousState::get_misc_continuous_state
        struct /* get_misc_continuous_state */ {
          // Source: drake/systems/framework/continuous_state.h:166
          const char* doc =
R"""(Returns a const reference to the subset of the continuous state vector
that is other continuous state ``z``. May be zero length.)""";
        } get_misc_continuous_state;
        // Symbol: drake::systems::ContinuousState::get_mutable_generalized_position
        struct /* get_mutable_generalized_position */ {
          // Source: drake/systems/framework/continuous_state.h:148
          const char* doc =
R"""(Returns a mutable reference to the subset of the state vector that is
generalized position ``q``. May be zero length.)""";
        } get_mutable_generalized_position;
        // Symbol: drake::systems::ContinuousState::get_mutable_generalized_velocity
        struct /* get_mutable_generalized_velocity */ {
          // Source: drake/systems/framework/continuous_state.h:160
          const char* doc =
R"""(Returns a mutable reference to the subset of the continuous state
vector that is generalized velocity ``v``. May be zero length.)""";
        } get_mutable_generalized_velocity;
        // Symbol: drake::systems::ContinuousState::get_mutable_misc_continuous_state
        struct /* get_mutable_misc_continuous_state */ {
          // Source: drake/systems/framework/continuous_state.h:172
          const char* doc =
R"""(Returns a mutable reference to the subset of the continuous state
vector that is other continuous state ``z``. May be zero length.)""";
        } get_mutable_misc_continuous_state;
        // Symbol: drake::systems::ContinuousState::get_mutable_vector
        struct /* get_mutable_vector */ {
          // Source: drake/systems/framework/continuous_state.h:135
          const char* doc =
R"""(Returns a mutable reference to the entire continuous state vector.)""";
        } get_mutable_vector;
        // Symbol: drake::systems::ContinuousState::get_system_id
        struct /* get_system_id */ {
          // Source: drake/systems/framework/continuous_state.h:198
          const char* doc =
R"""((Internal) Gets the id of the subsystem that created this state.)""";
        } get_system_id;
        // Symbol: drake::systems::ContinuousState::get_vector
        struct /* get_vector */ {
          // Source: drake/systems/framework/continuous_state.h:129
          const char* doc =
R"""(Returns a reference to the entire continuous state vector.)""";
        } get_vector;
        // Symbol: drake::systems::ContinuousState::num_q
        struct /* num_q */ {
          // Source: drake/systems/framework/continuous_state.h:116
          const char* doc =
R"""(Returns the number of generalized positions q in this state vector.)""";
        } num_q;
        // Symbol: drake::systems::ContinuousState::num_v
        struct /* num_v */ {
          // Source: drake/systems/framework/continuous_state.h:119
          const char* doc =
R"""(Returns the number of generalized velocities v in this state vector.)""";
        } num_v;
        // Symbol: drake::systems::ContinuousState::num_z
        struct /* num_z */ {
          // Source: drake/systems/framework/continuous_state.h:123
          const char* doc =
R"""(Returns the number of miscellaneous continuous state variables z in
this state vector.)""";
        } num_z;
        // Symbol: drake::systems::ContinuousState::operator[]
        struct /* operator_array */ {
          // Source: drake/systems/framework/continuous_state.h:125
          const char* doc = R"""()""";
        } operator_array;
        // Symbol: drake::systems::ContinuousState::set_system_id
        struct /* set_system_id */ {
          // Source: drake/systems/framework/continuous_state.h:201
          const char* doc =
R"""((Internal) Records the id of the subsystem that created this state.)""";
        } set_system_id;
        // Symbol: drake::systems::ContinuousState::size
        struct /* size */ {
          // Source: drake/systems/framework/continuous_state.h:113
          const char* doc =
R"""(Returns the size of the entire continuous state vector, which is
necessarily ``num_q + num_v + num_z``.)""";
        } size;
      } ContinuousState;
      // Symbol: drake::systems::ControllabilityMatrix
      struct /* ControllabilityMatrix */ {
        // Source: drake/systems/primitives/linear_system.h:242
        const char* doc =
R"""(Returns the controllability matrix: R = [B, AB, ..., A^{n-1}B].)""";
      } ControllabilityMatrix;
      // Symbol: drake::systems::Demultiplexer
      struct /* Demultiplexer */ {
        // Source: drake/systems/primitives/demultiplexer.h:20
        const char* doc =
R"""(This system splits a vector valued signal on its input into multiple
outputs.

The input to this system directly feeds through to its output.)""";
        // Symbol: drake::systems::Demultiplexer::Demultiplexer<T>
        struct /* ctor */ {
          // Source: drake/systems/primitives/demultiplexer.h:37
          const char* doc_1args =
R"""(Constructs Demultiplexer with one vector valued output ports with
sizes specified as the vector ``output_ports_sizes``. The number of
output ports is the length of this vector. The size of each output
port is the value of the corresponding element of the vector
``output_ports_sizes``.

Raises:
    RuntimeError if ``output_ports_sizes`` is a zero length vector.

Raises:
    RuntimeError if any element of the ``output_ports_sizes`` is zero.
    Therefore, the Demultiplexer does not allow zero size output
    ports.

Parameter ``output_ports_sizes``:
    Contains the sizes of each output port. The number of output ports
    is determined by the length of ``output_ports_sizes``. The
    accumulative value of the all the values in ``output_ports_sizes``
    will be the size of the input port.)""";
          // Source: drake/systems/primitives/demultiplexer.h:49
          const char* doc_2args =
R"""(Constructs Demultiplexer with one vector valued input port of size
``size`` and vector valued output ports of size ``output_ports_size``.

Raises:
    RuntimeError if output_ports_sizes can not exactly divide
    ``size``. The number of output ports is therefore ``size /
    output_ports_size``.

Parameter ``size``:
    is the size of the input signal to be demultiplexed into its
    individual components.

Parameter ``output_ports_size``:
    The size of the output ports. ``size`` must be a multiple of
    ``output_ports_size``.)""";
          // Source: drake/systems/primitives/demultiplexer.h:53
          const char* doc_copyconvert =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";
        } ctor;
        // Symbol: drake::systems::Demultiplexer::get_output_ports_sizes
        struct /* get_output_ports_sizes */ {
          // Source: drake/systems/primitives/demultiplexer.h:55
          const char* doc = R"""()""";
        } get_output_ports_sizes;
      } Demultiplexer;
      // Symbol: drake::systems::DenseOutput
      struct /* DenseOutput */ {
        // Source: drake/systems/analysis/dense_output.h:46
        const char* doc =
R"""(An interface for dense output of ODE solutions, to efficiently
approximate them at arbitrarily many points when solving them
numerically (see IntegratorBase class documentation).

Multiple definitions of *dense output* may be found in literature. For
some authors, it refers to the process of repeatedly adjusting the
integration step size so that all points to be approximated are
directly provided by the integrator (see [Engquist, 2015]). For
others, it stands for any numerical approximation technique used to
determine the solution in between steps (see [Hairer, 1993]). Despite
this caveat, it is common terminology in IVP literature and thus its
imparted functionality is immediately clear.

Herein, the concept in use may be formally stated as follows: given a
solution 𝐱(t) ∈ ℝⁿ to an ODE system that is approximated at a discrete
set of points 𝐲(tₖ) ∈ ℝⁿ where tₖ ∈ {t₁, ..., tᵢ} with tᵢ ∈ ℝ (e.g. as
a result of numerical integration), a dense output of 𝐱(t) is another
function 𝐳(t) ∈ ℝⁿ defined for t ∈ [t₁, tᵢ] such that 𝐳(tⱼ) = 𝐲(tⱼ)
for all tⱼ ∈ {t₁, ..., tᵢ} and that approximates 𝐱(t) for every value
in the closed interval [t₁, tᵢ].

Warning:
    Dense outputs are, in general, not bound to attain the same
    accuracy that error-controlled integration schemes do. Check each
    subclass documentation for further specification.

Warning:
    Note that dense outputs do not enforce any algebraic constraints
    on the solution that integrators might enforce.

- [Engquist, 2105] B. Engquist. Encyclopedia of Applied and Computational
                   Mathematics, p. 339, Springer, 2015.
- [Hairer, 1993] E. Hairer, S. Nørsett and G. Wanner. Solving Ordinary
                 Differential Equations I (Nonstiff Problems), p.188,
                 Springer, 1993.)""";
        // Symbol: drake::systems::DenseOutput::DenseOutput<T>
        struct /* ctor */ {
          // Source: drake/systems/analysis/dense_output.h:48
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::systems::DenseOutput::DoEvaluate
        struct /* DoEvaluate */ {
          // Source: drake/systems/analysis/dense_output.h:122
          const char* doc = R"""()""";
        } DoEvaluate;
        // Symbol: drake::systems::DenseOutput::DoEvaluateNth
        struct /* DoEvaluateNth */ {
          // Source: drake/systems/analysis/dense_output.h:128
          const char* doc = R"""()""";
        } DoEvaluateNth;
        // Symbol: drake::systems::DenseOutput::Evaluate
        struct /* Evaluate */ {
          // Source: drake/systems/analysis/dense_output.h:59
          const char* doc =
R"""(Evaluates the output at the given time ``t``.

Parameter ``t``:
    Time at which to evaluate output.

Returns:
    Output vector value.

Precondition:
    Output is not empty i.e. is_empty() equals false.

Raises:
    RuntimeError if any of the preconditions are not met.

Raises:
    RuntimeError if given ``t`` is not within output's domain i.e.
    ``t`` ∉ [start_time(), end_time()].)""";
        } Evaluate;
        // Symbol: drake::systems::DenseOutput::EvaluateNth
        struct /* EvaluateNth */ {
          // Source: drake/systems/analysis/dense_output.h:81
          const char* doc =
R"""(Evaluates the output value's `n`th scalar element (0-indexed) at the
given time ``t``.

Note:
    On some implementations, the computational cost of this method may
    be lower than that of indexing an Evaluate(const T&) call return
    vector value, thus making it the preferred mechanism when
    targeting a single dimension.

Parameter ``t``:
    Time at which to evaluate output.

Parameter ``n``:
    The nth scalar element (0-indexed) of the output value to
    evaluate.

Returns:
    Output value's `n`th scalar element (0-indexed).

Precondition:
    Output is not empty i.e. is_empty() equals false.

Raises:
    RuntimeError if any of the preconditions are not met.

Raises:
    RuntimeError if given ``t`` is not within output's domain i.e.
    ``t`` ∉ [start_time(), end_time()].

Raises:
    RuntimeError if given ``n`` does not refer to a valid output
    dimension i.e. ``n`` ∉ [0, size()).)""";
        } EvaluateNth;
        // Symbol: drake::systems::DenseOutput::ThrowIfNthElementIsInvalid
        struct /* ThrowIfNthElementIsInvalid */ {
          // Source: drake/systems/analysis/dense_output.h:159
          const char* doc = R"""()""";
        } ThrowIfNthElementIsInvalid;
        // Symbol: drake::systems::DenseOutput::ThrowIfOutputIsEmpty
        struct /* ThrowIfOutputIsEmpty */ {
          // Source: drake/systems/analysis/dense_output.h:147
          const char* doc = R"""()""";
        } ThrowIfOutputIsEmpty;
        // Symbol: drake::systems::DenseOutput::ThrowIfTimeIsInvalid
        struct /* ThrowIfTimeIsInvalid */ {
          // Source: drake/systems/analysis/dense_output.h:172
          const char* doc = R"""()""";
        } ThrowIfTimeIsInvalid;
        // Symbol: drake::systems::DenseOutput::do_end_time
        struct /* do_end_time */ {
          // Source: drake/systems/analysis/dense_output.h:142
          const char* doc = R"""()""";
        } do_end_time;
        // Symbol: drake::systems::DenseOutput::do_is_empty
        struct /* do_is_empty */ {
          // Source: drake/systems/analysis/dense_output.h:133
          const char* doc = R"""()""";
        } do_is_empty;
        // Symbol: drake::systems::DenseOutput::do_size
        struct /* do_size */ {
          // Source: drake/systems/analysis/dense_output.h:136
          const char* doc = R"""()""";
        } do_size;
        // Symbol: drake::systems::DenseOutput::do_start_time
        struct /* do_start_time */ {
          // Source: drake/systems/analysis/dense_output.h:139
          const char* doc = R"""()""";
        } do_start_time;
        // Symbol: drake::systems::DenseOutput::end_time
        struct /* end_time */ {
          // Source: drake/systems/analysis/dense_output.h:113
          const char* doc =
R"""(Returns output's end time, or in other words, the newest time ``t``
that it can be evaluated at e.g. via Evaluate().

Precondition:
    Output is not empty i.e. is_empty() equals false.

Raises:
    RuntimeError if any of the preconditions is not met.)""";
        } end_time;
        // Symbol: drake::systems::DenseOutput::is_empty
        struct /* is_empty */ {
          // Source: drake/systems/analysis/dense_output.h:98
          const char* doc =
R"""(Checks whether the output is empty or not.)""";
        } is_empty;
        // Symbol: drake::systems::DenseOutput::size
        struct /* size */ {
          // Source: drake/systems/analysis/dense_output.h:92
          const char* doc =
R"""(Returns the output size (i.e. the number of elements in an output
value).

Precondition:
    Output is not empty i.e. is_empty() equals false.

Raises:
    RuntimeError if any of the preconditions is not met.)""";
        } size;
        // Symbol: drake::systems::DenseOutput::start_time
        struct /* start_time */ {
          // Source: drake/systems/analysis/dense_output.h:104
          const char* doc =
R"""(Returns output's start time, or in other words, the oldest time ``t``
that it can be evaluated at e.g. via Evaluate().

Precondition:
    Output is not empty i.e. is_empty() equals false.

Raises:
    RuntimeError if any of the preconditions is not met.)""";
        } start_time;
      } DenseOutput;
      // Symbol: drake::systems::DependencyGraph
      struct /* DependencyGraph */ {
        // Source: drake/systems/framework/dependency_tracker.h:442
        const char* doc =
R"""(Represents the portion of the complete dependency graph that is a
subgraph centered on the owning subcontext, plus some edges leading to
other subcontexts. DependencyTracker objects are the nodes of the
graph, and maintain prerequisite/subscriber edges that interconnect
these nodes, and may also connect to nodes contained in dependency
graphs belonging to other subcontexts within the same complete context
tree. Dependencies on the parent (containing DiagramContext) and
children (contained subcontexts) typically arise from exported input
and output ports, while sibling dependencies arise from
output-to-input port connections.

A DependencyGraph creates and owns all the DependencyTracker objects
for a particular subcontext, organized to allow fast access using a
DependencyTicket as an index. Memory addresses of DependencyTracker
objects are stable once allocated, but DependencyTicket numbers are
stable even after a Context has been copied so should be preferred.

Because DependencyTrackers contain pointers, copying a DependencyGraph
must always be done as part of copying an entire Context tree. There
is a copy constructor here but it must be followed by a pointer-fixup
step so is for internal use only.)""";
        // Symbol: drake::systems::DependencyGraph::AppendToTrackerPointerMap
        struct /* AppendToTrackerPointerMap */ {
          // Source: drake/systems/framework/dependency_tracker.h:549
          const char* doc =
R"""((Internal use only) Create a mapping from the memory addresses of the
trackers contained here to the corresponding ones in ``clone``, which
must have exactly the same number of trackers. The mapping is appended
to the supplied map, which must not be null.)""";
        } AppendToTrackerPointerMap;
        // Symbol: drake::systems::DependencyGraph::CreateNewDependencyTracker
        struct /* CreateNewDependencyTracker */ {
          // Source: drake/systems/framework/dependency_tracker.h:475
          const char* doc_3args =
R"""(Allocates a new DependencyTracker with an already-known ticket number,
the given description and an optional cache value to be invalidated.
The new tracker has no prerequisites or subscribers yet. This may
leave gaps in the node numbering. Use has_tracker() if you need to
know whether there is a tracker for a particular ticket. We promise
that the returned DependencyTracker's location in memory will remain
unchanged once created in a particular Context, even as more trackers
are added. The DependencyTicket retains its meaning even after cloning
the Context, although of course the tracker has a new address in the
clone.

Precondition:
    The given ticket must be valid.

Precondition:
    No DependencyTracker is already using the given ticket.)""";
          // Source: drake/systems/framework/dependency_tracker.h:489
          const char* doc_2args =
R"""(Assigns a new ticket number and then allocates a new DependencyTracker
that can be accessed with that ticket. You may obtain the assigned
ticket from the returned tracker. See the other signature for details.)""";
        } CreateNewDependencyTracker;
        // Symbol: drake::systems::DependencyGraph::DependencyGraph
        struct /* ctor */ {
          // Source: drake/systems/framework/dependency_tracker.h:448
          const char* doc_move =
R"""(@name Does not allow move or assignment; copy constructor limited. The
copy constructor does not copy internal pointers so requires special
handling.)""";
          // Source: drake/systems/framework/dependency_tracker.h:455
          const char* doc =
R"""(Constructor creates an empty graph referencing the system pathname
service of its owning subcontext. The supplied pointer must not be
null.)""";
          // Source: drake/systems/framework/dependency_tracker.h:534
          const char* doc_copy =
R"""((Internal use only) Copy constructor partially duplicates the source
DependencyGraph object, with identical structure to the source but
with all internal pointers set to null, and all counters and
statistics set to their default-constructed values. Pointers must be
set properly using RepairTrackerPointers() once all the old-to-new
pointer mappings have been determined *for the whole Context*, not
just the containing subcontext. This should only be invoked by Context
code as part of copying an entire Context tree.

See also:
    AppendToTrackerPointerMap(), RepairTrackerPointers())""";
        } ctor;
        // Symbol: drake::systems::DependencyGraph::RepairTrackerPointers
        struct /* RepairTrackerPointers */ {
          // Source: drake/systems/framework/dependency_tracker.h:562
          const char* doc =
R"""((Internal use only) Assumes ``this`` DependencyGraph is a recent clone
whose trackers do not yet contain subscriber and prerequisite pointers
and sets the local pointers to point to the ``source``-corresponding
trackers in the new owning context, the appropriate cache entry values
in the new cache, and to the system name providing service of the new
owning Context for logging and error reporting. The supplied map
should map source pointers to their corresponding trackers. It is a
fatal error if any old pointer we encounter is not present in the map;
that would indicate a bug in the Context cloning code.)""";
        } RepairTrackerPointers;
        // Symbol: drake::systems::DependencyGraph::get_mutable_tracker
        struct /* get_mutable_tracker */ {
          // Source: drake/systems/framework/dependency_tracker.h:521
          const char* doc =
R"""(Returns a mutable DependencyTracker given a ticket. This is very fast.
Behavior is undefined if the ticket is out of range
[0..num_trackers()-1].)""";
        } get_mutable_tracker;
        // Symbol: drake::systems::DependencyGraph::get_tracker
        struct /* get_tracker */ {
          // Source: drake/systems/framework/dependency_tracker.h:512
          const char* doc =
R"""(Returns a const DependencyTracker given a ticket. This is very fast.
Behavior is undefined if the ticket is out of range
[0..num_trackers()-1].)""";
        } get_tracker;
        // Symbol: drake::systems::DependencyGraph::has_tracker
        struct /* has_tracker */ {
          // Source: drake/systems/framework/dependency_tracker.h:498
          const char* doc =
R"""(Returns true if there is a DependencyTracker in this graph that has
the given ticket number.)""";
        } has_tracker;
        // Symbol: drake::systems::DependencyGraph::trackers_size
        struct /* trackers_size */ {
          // Source: drake/systems/framework/dependency_tracker.h:508
          const char* doc =
R"""(Returns the current size of the DependencyTracker container, providing
for DependencyTicket numbers from ``0..trackers_size()-1``. Note that
it is possible to have empty slots in the container. Use has_tracker()
to determine if there is a tracker associated with a particular
ticket.)""";
        } trackers_size;
      } DependencyGraph;
      // Symbol: drake::systems::DependencyTicket
      struct /* DependencyTicket */ {
        // Source: drake/systems/framework/framework_common.h:31
        const char* doc =
R"""(Identifies a particular source value or computation for purposes of
declaring and managing dependencies. Unique only within a given
subsystem and its corresponding subcontext.)""";
      } DependencyTicket;
      // Symbol: drake::systems::DependencyTracker
      struct /* DependencyTracker */ {
        // Source: drake/systems/framework/dependency_tracker.h:134
        const char* doc = R"""()""";
        // Symbol: drake::systems::DependencyTracker::AddDownstreamSubscriber
        struct /* AddDownstreamSubscriber */ {
          // Source: drake/systems/framework/dependency_tracker.h:218
          const char* doc =
R"""(Adds a downstream subscriber to ``this`` DependencyTracker, which will
keep a pointer to the subscribing tracker. The subscriber will be
notified whenever this DependencyTracker is notified of a value or
prerequisite change.

Precondition:
    The subscriber has already recorded its dependency on this tracker
    in its prerequisite list.)""";
        } AddDownstreamSubscriber;
        // Symbol: drake::systems::DependencyTracker::DependencyTracker
        struct /* ctor */ {
          // Source: drake/systems/framework/dependency_tracker.h:136
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::systems::DependencyTracker::GetPathDescription
        struct /* GetPathDescription */ {
          // Source: drake/systems/framework/dependency_tracker.h:147
          const char* doc =
R"""(Returns the description, preceded by the full pathname of the
subsystem associated with the owning subcontext.)""";
        } GetPathDescription;
        // Symbol: drake::systems::DependencyTracker::HasPrerequisite
        struct /* HasPrerequisite */ {
          // Source: drake/systems/framework/dependency_tracker.h:227
          const char* doc =
R"""(Returns ``True`` if this tracker has already subscribed to
``prerequisite``. This is slow and should not be used in
performance-sensitive code.)""";
        } HasPrerequisite;
        // Symbol: drake::systems::DependencyTracker::HasSubscriber
        struct /* HasSubscriber */ {
          // Source: drake/systems/framework/dependency_tracker.h:231
          const char* doc =
R"""(Returns ``True`` if ``subscriber`` is one of this tracker's
subscribers. This is slow and should not be used in
performance-sensitive code.)""";
        } HasSubscriber;
        // Symbol: drake::systems::DependencyTracker::NoteValueChange
        struct /* NoteValueChange */ {
          // Source: drake/systems/framework/dependency_tracker.h:194
          const char* doc =
R"""(Notifies ``this`` DependencyTracker that its managed value was
directly modified or made available for mutable access. That is, this
is the *initiating* event of a value modification. All of our
downstream subscribers are notified but the associated cache entry (if
any) is *not* invalidated (see below for why). A unique, positive
``change_event`` should have been obtained from the owning Context and
supplied here.

Why don't we invalidate the cache entry? Recall that this method is
for *initiating* a change event, meaning that the quantity that this
tracker tracks is *initiating* an invalidation sweep, as opposed to
just reacting to prerequisite changes. Normally cache entries become
invalid because their prerequisites change; they are not usually the
first step in an invalidation sweep. So it is unusual for
NoteValueChange() to be called on a cache entry's dependency tracker.
But if it is called, that is likely to mean the cache entry was just
given a new value, and is therefore *valid*; invalidating it now would
be an error.)""";
        } NoteValueChange;
        // Symbol: drake::systems::DependencyTracker::PointerMap
        struct /* PointerMap */ {
          // Source: drake/systems/framework/dependency_tracker.h:139
          const char* doc = R"""((Internal use only))""";
        } PointerMap;
        // Symbol: drake::systems::DependencyTracker::RemoveDownstreamSubscriber
        struct /* RemoveDownstreamSubscriber */ {
          // Source: drake/systems/framework/dependency_tracker.h:223
          const char* doc =
R"""(Removes a downstream subscriber from ``this`` DependencyTracker.

Precondition:
    The subscriber has already removed the dependency on this tracker
    from its prerequisite list.)""";
        } RemoveDownstreamSubscriber;
        // Symbol: drake::systems::DependencyTracker::SubscribeToPrerequisite
        struct /* SubscribeToPrerequisite */ {
          // Source: drake/systems/framework/dependency_tracker.h:204
          const char* doc =
R"""(Subscribes ``this`` tracker to an upstream prerequisite's tracker. The
upstream tracker will keep a const pointer back to ``this`` tracker in
its subscriber list, and ``this`` tracker will keep a pointer to the
prerequisite tracker in its prerequisites list.)""";
        } SubscribeToPrerequisite;
        // Symbol: drake::systems::DependencyTracker::ThrowIfBadDependencyTracker
        struct /* ThrowIfBadDependencyTracker */ {
          // Source: drake/systems/framework/dependency_tracker.h:304
          const char* doc =
R"""(Throws an RuntimeError if there is something clearly wrong with this
DependencyTracker object. If the owning subcontext is known, provide a
pointer to it here and we'll check that this tracker agrees. If you
know which cache entry is supposed to be associated with this tracker,
supply a pointer to that and we'll check it (trackers that are not
associated with a real cache entry are still associated with the
CacheEntryValue::dummy()). In addition we check for other internal
inconsistencies.

Raises:
    RuntimeError for anything that goes wrong, with an appropriate
    explanatory message.)""";
        } ThrowIfBadDependencyTracker;
        // Symbol: drake::systems::DependencyTracker::UnsubscribeFromPrerequisite
        struct /* UnsubscribeFromPrerequisite */ {
          // Source: drake/systems/framework/dependency_tracker.h:211
          const char* doc =
R"""(Unsubscribes ``this`` tracker from an upstream prerequisite tracker to
which we previously subscribed. Both the prerequisite list in ``this``
tracker and the subscriber list in ``prerequisite`` are modified.

Precondition:
    The supplied pointer must not be null.

Precondition:
    This tracker must already be subscribed to the given
    ``prerequisite``.)""";
        } UnsubscribeFromPrerequisite;
        // Symbol: drake::systems::DependencyTracker::cache_entry_value
        struct /* cache_entry_value */ {
          // Source: drake/systems/framework/dependency_tracker.h:171
          const char* doc =
R"""((Internal use only) Returns a pointer to the CacheEntryValue if this
tracker is a cache entry tracker, otherwise nullptr.)""";
        } cache_entry_value;
        // Symbol: drake::systems::DependencyTracker::description
        struct /* description */ {
          // Source: drake/systems/framework/dependency_tracker.h:143
          const char* doc =
R"""(Returns the human-readable description for this tracker.)""";
        } description;
        // Symbol: drake::systems::DependencyTracker::num_ignored_notifications
        struct /* num_ignored_notifications */ {
          // Source: drake/systems/framework/dependency_tracker.h:268
          const char* doc =
R"""(How many times did we receive a repeat notification for the same
change event that we ignored?)""";
        } num_ignored_notifications;
        // Symbol: drake::systems::DependencyTracker::num_notifications_received
        struct /* num_notifications_received */ {
          // Source: drake/systems/framework/dependency_tracker.h:262
          const char* doc =
R"""(What is the total number of notifications received by this tracker?
This is the sum of managed-value change event notifications and
prerequisite change notifications received.)""";
        } num_notifications_received;
        // Symbol: drake::systems::DependencyTracker::num_notifications_sent
        struct /* num_notifications_sent */ {
          // Source: drake/systems/framework/dependency_tracker.h:274
          const char* doc =
R"""(What is the total number of notifications sent to downstream
subscribers by this trackers?)""";
        } num_notifications_sent;
        // Symbol: drake::systems::DependencyTracker::num_prerequisite_change_events
        struct /* num_prerequisite_change_events */ {
          // Source: drake/systems/framework/dependency_tracker.h:286
          const char* doc =
R"""(How many times was this tracker notified of a change to one of its
value's prerequisites?)""";
        } num_prerequisite_change_events;
        // Symbol: drake::systems::DependencyTracker::num_prerequisites
        struct /* num_prerequisites */ {
          // Source: drake/systems/framework/dependency_tracker.h:235
          const char* doc =
R"""(Returns the total number of "depends-on" edges emanating from ``this``
tracker, pointing to its upstream prerequisites.)""";
        } num_prerequisites;
        // Symbol: drake::systems::DependencyTracker::num_subscribers
        struct /* num_subscribers */ {
          // Source: drake/systems/framework/dependency_tracker.h:246
          const char* doc =
R"""(Returns the total number of "is-prerequisite-of" edges emanating from
``this`` tracker, pointing to its downstream subscribers.)""";
        } num_subscribers;
        // Symbol: drake::systems::DependencyTracker::num_value_change_events
        struct /* num_value_change_events */ {
          // Source: drake/systems/framework/dependency_tracker.h:280
          const char* doc =
R"""(How many times was this tracker notified of a change event for a
direct change to a value it tracks?)""";
        } num_value_change_events;
        // Symbol: drake::systems::DependencyTracker::prerequisites
        struct /* prerequisites */ {
          // Source: drake/systems/framework/dependency_tracker.h:240
          const char* doc =
R"""(Returns a reference to the prerequisite trackers.)""";
        } prerequisites;
        // Symbol: drake::systems::DependencyTracker::set_cache_entry_value
        struct /* set_cache_entry_value */ {
          // Source: drake/systems/framework/dependency_tracker.h:160
          const char* doc =
R"""((Internal use only) Sets the cache entry value to be marked
out-of-date when this tracker's prerequisites change.

Precondition:
    The supplied cache entry value is non-null.

Precondition:
    No cache entry value has previously been assigned.)""";
        } set_cache_entry_value;
        // Symbol: drake::systems::DependencyTracker::subscribers
        struct /* subscribers */ {
          // Source: drake/systems/framework/dependency_tracker.h:249
          const char* doc =
R"""(Returns a reference to the subscribing trackers.)""";
        } subscribers;
        // Symbol: drake::systems::DependencyTracker::ticket
        struct /* ticket */ {
          // Source: drake/systems/framework/dependency_tracker.h:151
          const char* doc =
R"""(Returns the DependencyTicket for this DependencyTracker in its
containing DependencyGraph. The ticket is unique within the containing
subcontext.)""";
        } ticket;
      } DependencyTracker;
      // Symbol: drake::systems::Diagram
      struct /* Diagram */ {
        // Source: drake/systems/framework/diagram.h:70
        const char* doc =
R"""(Diagram is a System composed of one or more constituent Systems,
arranged in a directed graph where the vertices are the constituent
Systems themselves, and the edges connect the output of one
constituent System to the input of another. To construct a Diagram,
use a DiagramBuilder.

Each System in the Diagram must have a unique, non-empty name.)""";
        // Symbol: drake::systems::Diagram::Accept
        struct /* Accept */ {
          // Source: drake/systems/framework/diagram.h:89
          const char* doc =
R"""(Implements a visitor pattern.

See also:
    SystemVisitor<T>.)""";
        } Accept;
        // Symbol: drake::systems::Diagram::AddTriggeredWitnessFunctionToCompositeEventCollection
        struct /* AddTriggeredWitnessFunctionToCompositeEventCollection */ {
          // Source: drake/systems/framework/diagram.h:270
          const char* doc =
R"""(For the subsystem associated with ``witness_func``, gets its mutable
sub composite event collection from ``events``, and passes it to
``witness_func`'s AddEventToCollection method. This method also
modifies `event`` by updating the pointers to "diagram" continuous
state to point to the ContinuousState pointers for the associated
subsystem instead. Aborts if the subsystem is not part of this
Diagram.)""";
        } AddTriggeredWitnessFunctionToCompositeEventCollection;
        // Symbol: drake::systems::Diagram::AllocateCompositeEventCollection
        struct /* AllocateCompositeEventCollection */ {
          // Source: drake/systems/framework/diagram.h:115
          const char* doc =
R"""(Allocates a DiagramEventCollection for this Diagram.

See also:
    System::AllocateCompositeEventCollection().)""";
        } AllocateCompositeEventCollection;
        // Symbol: drake::systems::Diagram::AllocateDiscreteVariables
        struct /* AllocateDiscreteVariables */ {
          // Source: drake/systems/framework/diagram.h:144
          const char* doc = R"""()""";
        } AllocateDiscreteVariables;
        // Symbol: drake::systems::Diagram::AllocateForcedDiscreteUpdateEventCollection
        struct /* AllocateForcedDiscreteUpdateEventCollection */ {
          // Source: drake/systems/framework/diagram.h:136
          const char* doc = R"""()""";
        } AllocateForcedDiscreteUpdateEventCollection;
        // Symbol: drake::systems::Diagram::AllocateForcedPublishEventCollection
        struct /* AllocateForcedPublishEventCollection */ {
          // Source: drake/systems/framework/diagram.h:133
          const char* doc = R"""()""";
        } AllocateForcedPublishEventCollection;
        // Symbol: drake::systems::Diagram::AllocateForcedUnrestrictedUpdateEventCollection
        struct /* AllocateForcedUnrestrictedUpdateEventCollection */ {
          // Source: drake/systems/framework/diagram.h:139
          const char* doc = R"""()""";
        } AllocateForcedUnrestrictedUpdateEventCollection;
        // Symbol: drake::systems::Diagram::AllocateTimeDerivatives
        struct /* AllocateTimeDerivatives */ {
          // Source: drake/systems/framework/diagram.h:142
          const char* doc = R"""()""";
        } AllocateTimeDerivatives;
        // Symbol: drake::systems::Diagram::AreConnected
        struct /* AreConnected */ {
          // Source: drake/systems/framework/diagram.h:233
          const char* doc =
R"""(Reports if the indicated ``output`` is connected to the ``input``
port.

Precondition:
    the ports belong to systems that are direct children of this
    diagram.)""";
        } AreConnected;
        // Symbol: drake::systems::Diagram::Diagram<T>
        struct /* ctor */ {
          // Source: drake/systems/framework/diagram.h:80
          const char* doc_copyconvert =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";
          // Source: drake/systems/framework/diagram.h:244
          const char* doc_0args =
R"""(Constructs an uninitialized Diagram. Subclasses that use this
constructor are obligated to call DiagramBuilder::BuildInto(this).
Provides scalar- type conversion support only if every contained
subsystem provides the same support.)""";
          // Source: drake/systems/framework/diagram.h:255
          const char* doc_1args =
R"""((Advanced) Constructs an uninitialized Diagram. Subclasses that use
this constructor are obligated to call
DiagramBuilder::BuildInto(this).

Declares scalar-type conversion support using ``converter``. Support
for a given pair of types ``T, U`` to convert from and to will be
enabled only if every contained subsystem supports that pair.

See system_scalar_conversion for detailed background and examples
related to scalar-type conversion support.)""";
        } ctor;
        // Symbol: drake::systems::Diagram::DoCalcImplicitTimeDerivativesResidual
        struct /* DoCalcImplicitTimeDerivativesResidual */ {
          // Source: drake/systems/framework/diagram.h:149
          const char* doc = R"""()""";
        } DoCalcImplicitTimeDerivativesResidual;
        // Symbol: drake::systems::Diagram::DoCalcNextUpdateTime
        struct /* DoCalcNextUpdateTime */ {
          // Source: drake/systems/framework/diagram.h:331
          const char* doc =
R"""(Computes the next update time based on the configured actions, for
scalar types that are arithmetic, or aborts for scalar types that are
not arithmetic.)""";
        } DoCalcNextUpdateTime;
        // Symbol: drake::systems::Diagram::DoCalcTimeDerivatives
        struct /* DoCalcTimeDerivatives */ {
          // Source: drake/systems/framework/diagram.h:146
          const char* doc = R"""()""";
        } DoCalcTimeDerivatives;
        // Symbol: drake::systems::Diagram::DoCalcWitnessValue
        struct /* DoCalcWitnessValue */ {
          // Source: drake/systems/framework/diagram.h:261
          const char* doc =
R"""(For the subsystem associated with ``witness_func``, gets its
subcontext from ``context``, passes the subcontext to
``witness_func``' Evaluate method and returns the result. Aborts if
the subsystem is not part of this Diagram.)""";
        } DoCalcWitnessValue;
        // Symbol: drake::systems::Diagram::DoGetMutableTargetSystemCompositeEventCollection
        struct /* DoGetMutableTargetSystemCompositeEventCollection */ {
          // Source: drake/systems/framework/diagram.h:303
          const char* doc =
R"""(Returns a pointer to mutable composite event collection if
``target_system`` is a subsystem of this, nullptr is returned
otherwise.)""";
        } DoGetMutableTargetSystemCompositeEventCollection;
        // Symbol: drake::systems::Diagram::DoGetMutableTargetSystemState
        struct /* DoGetMutableTargetSystemState */ {
          // Source: drake/systems/framework/diagram.h:287
          const char* doc =
R"""(Returns a pointer to mutable state if ``target_system`` is a subsystem
of this, nullptr is returned otherwise.)""";
        } DoGetMutableTargetSystemState;
        // Symbol: drake::systems::Diagram::DoGetTargetSystemCompositeEventCollection
        struct /* DoGetTargetSystemCompositeEventCollection */ {
          // Source: drake/systems/framework/diagram.h:309
          const char* doc =
R"""(Returns a pointer to const composite event collection if
``target_system`` is a subsystem of this, nullptr is returned
otherwise.)""";
        } DoGetTargetSystemCompositeEventCollection;
        // Symbol: drake::systems::Diagram::DoGetTargetSystemContext
        struct /* DoGetTargetSystemContext */ {
          // Source: drake/systems/framework/diagram.h:282
          const char* doc =
R"""(Returns a pointer to const context if ``target_system`` is a subsystem
of this, nullptr is returned otherwise.)""";
        } DoGetTargetSystemContext;
        // Symbol: drake::systems::Diagram::DoGetTargetSystemContinuousState
        struct /* DoGetTargetSystemContinuousState */ {
          // Source: drake/systems/framework/diagram.h:292
          const char* doc =
R"""(Returns a pointer to const state if ``target_system`` is a subsystem
of this, nullptr is returned otherwise.)""";
        } DoGetTargetSystemContinuousState;
        // Symbol: drake::systems::Diagram::DoGetTargetSystemState
        struct /* DoGetTargetSystemState */ {
          // Source: drake/systems/framework/diagram.h:298
          const char* doc =
R"""(Returns a pointer to const state if ``target_system`` is a subsystem
of this, nullptr is returned otherwise.)""";
        } DoGetTargetSystemState;
        // Symbol: drake::systems::Diagram::DoGetWitnessFunctions
        struct /* DoGetWitnessFunctions */ {
          // Source: drake/systems/framework/diagram.h:277
          const char* doc =
R"""(Provides witness functions of subsystems that are active at the
beginning of a continuous time interval. The vector of witness
functions is not ordered in a particular manner.)""";
        } DoGetWitnessFunctions;
        // Symbol: drake::systems::Diagram::DoMapQDotToVelocity
        struct /* DoMapQDotToVelocity */ {
          // Source: drake/systems/framework/diagram.h:324
          const char* doc =
R"""(The ``generalized_velocity`` vector must have the same size and
ordering as the generalized velocity in the ContinuousState that this
Diagram reserves in its context.)""";
        } DoMapQDotToVelocity;
        // Symbol: drake::systems::Diagram::DoMapVelocityToQDot
        struct /* DoMapVelocityToQDot */ {
          // Source: drake/systems/framework/diagram.h:316
          const char* doc =
R"""(The ``generalized_velocity`` vector must have the same size and
ordering as the generalized velocity in the ContinuousState that this
Diagram reserves in its context.)""";
        } DoMapVelocityToQDot;
        // Symbol: drake::systems::Diagram::GetDirectFeedthroughs
        struct /* GetDirectFeedthroughs */ {
          // Source: drake/systems/framework/diagram.h:110
          const char* doc = R"""()""";
        } GetDirectFeedthroughs;
        // Symbol: drake::systems::Diagram::GetGraphvizFragment
        struct /* GetGraphvizFragment */ {
          // Source: drake/systems/framework/diagram.h:214
          const char* doc =
R"""(Returns a Graphviz fragment describing this Diagram. To obtain a
complete Graphviz graph, call System<T>::GetGraphvizString.)""";
        } GetGraphvizFragment;
        // Symbol: drake::systems::Diagram::GetGraphvizInputPortToken
        struct /* GetGraphvizInputPortToken */ {
          // Source: drake/systems/framework/diagram.h:217
          const char* doc = R"""()""";
        } GetGraphvizInputPortToken;
        // Symbol: drake::systems::Diagram::GetGraphvizOutputPortToken
        struct /* GetGraphvizOutputPortToken */ {
          // Source: drake/systems/framework/diagram.h:221
          const char* doc = R"""()""";
        } GetGraphvizOutputPortToken;
        // Symbol: drake::systems::Diagram::GetInputPortLocators
        struct /* GetInputPortLocators */ {
          // Source: drake/systems/framework/diagram.h:97
          const char* doc =
R"""(Returns the collection of "locators" for the subsystem input ports
that were exported or connected to the ``port_index`` input port for
the Diagram.)""";
        } GetInputPortLocators;
        // Symbol: drake::systems::Diagram::GetMutableSubsystemCompositeEventCollection
        struct /* GetMutableSubsystemCompositeEventCollection */ {
          // Source: drake/systems/framework/diagram.h:184
          const char* doc =
R"""(Returns the mutable subsystem composite event collection that
corresponds to ``subsystem``. Aborts if ``subsystem`` is not a
subsystem of this diagram.)""";
        } GetMutableSubsystemCompositeEventCollection;
        // Symbol: drake::systems::Diagram::GetMutableSubsystemState
        struct /* GetMutableSubsystemState */ {
          // Source: drake/systems/framework/diagram.h:193
          const char* doc_2args_subsystem_context =
R"""(Retrieves the state for a particular subsystem from the context for
the entire diagram. Invalidates all entries in that subsystem's cache
that depend on State. Aborts if ``subsystem`` is not actually a
subsystem of this diagram.)""";
          // Source: drake/systems/framework/diagram.h:199
          const char* doc_2args_subsystem_state =
R"""(Retrieves the state for a particular subsystem from the ``state`` for
the entire diagram. Aborts if ``subsystem`` is not actually a
subsystem of this diagram.)""";
        } GetMutableSubsystemState;
        // Symbol: drake::systems::Diagram::GetSubsystemByName
        struct /* GetSubsystemByName */ {
          // Source: drake/systems/framework/diagram.h:157
          const char* doc =
R"""(Retrieves a reference to the subsystem with name ``name`` returned by
get_name().

Raises:
    RuntimeError if a match cannot be found.

See also:
    System<T>::get_name())""";
        } GetSubsystemByName;
        // Symbol: drake::systems::Diagram::GetSubsystemCompositeEventCollection
        struct /* GetSubsystemCompositeEventCollection */ {
          // Source: drake/systems/framework/diagram.h:178
          const char* doc =
R"""(Returns the const subsystem composite event collection from ``events``
that corresponds to ``subsystem``. Aborts if ``subsystem`` is not a
subsystem of this diagram.)""";
        } GetSubsystemCompositeEventCollection;
        // Symbol: drake::systems::Diagram::GetSubsystemDerivatives
        struct /* GetSubsystemDerivatives */ {
          // Source: drake/systems/framework/diagram.h:163
          const char* doc =
R"""(Retrieves the state derivatives for a particular subsystem from the
derivatives for the entire diagram. Aborts if ``subsystem`` is not
actually a subsystem of this diagram. Returns a 0-length
ContinuousState if ``subsystem`` has none.)""";
        } GetSubsystemDerivatives;
        // Symbol: drake::systems::Diagram::GetSubsystemDiscreteValues
        struct /* GetSubsystemDiscreteValues */ {
          // Source: drake/systems/framework/diagram.h:170
          const char* doc =
R"""(Retrieves the discrete state values for a particular subsystem from
the discrete values for the entire diagram. Aborts if ``subsystem`` is
not actually a subsystem of this diagram. Returns an empty
DiscreteValues if ``subsystem`` has none.)""";
        } GetSubsystemDiscreteValues;
        // Symbol: drake::systems::Diagram::GetSubsystemState
        struct /* GetSubsystemState */ {
          // Source: drake/systems/framework/diagram.h:205
          const char* doc =
R"""(Retrieves the state for a particular subsystem from the ``state`` for
the entire diagram. Aborts if ``subsystem`` is not actually a
subsystem of this diagram.)""";
        } GetSubsystemState;
        // Symbol: drake::systems::Diagram::GetSystemIndexOrAbort
        struct /* GetSystemIndexOrAbort */ {
          // Source: drake/systems/framework/diagram.h:229
          const char* doc =
R"""(Returns the index of the given ``sys`` in this diagram, or aborts if
``sys`` is not a member of the diagram.)""";
        } GetSystemIndexOrAbort;
        // Symbol: drake::systems::Diagram::GetSystems
        struct /* GetSystems */ {
          // Source: drake/systems/framework/diagram.h:86
          const char* doc = R"""(Returns the list of contained Systems.)""";
        } GetSystems;
        // Symbol: drake::systems::Diagram::InputPortLocator
        struct /* InputPortLocator */ {
          // Source: drake/systems/framework/diagram.h:75
          const char* doc = R"""()""";
        } InputPortLocator;
        // Symbol: drake::systems::Diagram::OutputPortLocator
        struct /* OutputPortLocator */ {
          // Source: drake/systems/framework/diagram.h:76
          const char* doc = R"""()""";
        } OutputPortLocator;
        // Symbol: drake::systems::Diagram::SetDefaultParameters
        struct /* SetDefaultParameters */ {
          // Source: drake/systems/framework/diagram.h:120
          const char* doc = R"""()""";
        } SetDefaultParameters;
        // Symbol: drake::systems::Diagram::SetDefaultState
        struct /* SetDefaultState */ {
          // Source: drake/systems/framework/diagram.h:117
          const char* doc = R"""()""";
        } SetDefaultState;
        // Symbol: drake::systems::Diagram::SetRandomParameters
        struct /* SetRandomParameters */ {
          // Source: drake/systems/framework/diagram.h:126
          const char* doc = R"""()""";
        } SetRandomParameters;
        // Symbol: drake::systems::Diagram::SetRandomState
        struct /* SetRandomState */ {
          // Source: drake/systems/framework/diagram.h:123
          const char* doc = R"""()""";
        } SetRandomState;
        // Symbol: drake::systems::Diagram::connection_map
        struct /* connection_map */ {
          // Source: drake/systems/framework/diagram.h:92
          const char* doc =
R"""(Returns a reference to the map of connections between Systems.)""";
        } connection_map;
        // Symbol: drake::systems::Diagram::get_input_port_locator
        struct /* get_input_port_locator */ {
          // Source: drake/systems/framework/diagram.h:103
          const char* doc_deprecated =
R"""(Returns an arbitrary "locator" for one of the subsystem input ports
that were exported to the ``port_index`` input port for the Diagram.
(Deprecated.)

Deprecated:
    Use GetInputPortLocators() instead. This will be removed from
    Drake on or after 2021-04-01.)""";
        } get_input_port_locator;
        // Symbol: drake::systems::Diagram::get_output_port_locator
        struct /* get_output_port_locator */ {
          // Source: drake/systems/framework/diagram.h:107
          const char* doc =
R"""(Returns the "locator" for the subsystem output port that was exported
as the ``port_index`` output port for the Diagram.)""";
        } get_output_port_locator;
      } Diagram;
      // Symbol: drake::systems::DiagramBuilder
      struct /* DiagramBuilder */ {
        // Source: drake/systems/framework/diagram_builder.h:28
        const char* doc =
R"""(DiagramBuilder is a factory class for Diagram. It is single use: after
calling Build or BuildInto, DiagramBuilder gives up ownership of the
constituent systems, and should therefore be discarded.

A system must be added to the DiagramBuilder with AddSystem or
AddNamedSystem before it can be wired up in any way. Every system must
have a unique, non-empty name.)""";
        // Symbol: drake::systems::DiagramBuilder::AddNamedSystem
        struct /* AddNamedSystem */ {
          // Source: drake/systems/framework/diagram_builder.h:131
          const char* doc =
R"""(Takes ownership of ``system``, applies ``name`` to it, and adds it to
the builder. Returns a bare pointer to the System, which will remain
valid for the lifetime of the Diagram built by this builder.


::

    DiagramBuilder<T> builder;
      auto bar = builder.AddNamedSystem("bar", std::make_unique<Bar<T>>());

Template parameter ``S``:
    The type of system to add.

Postcondition:
    The system's name is ``name``.)""";
        } AddNamedSystem;
        // Symbol: drake::systems::DiagramBuilder::AddSystem
        struct /* AddSystem */ {
          // Source: drake/systems/framework/diagram_builder.h:50
          const char* doc =
R"""(Takes ownership of ``system`` and adds it to the builder. Returns a
bare pointer to the System, which will remain valid for the lifetime
of the Diagram built by this builder.

If the system's name is unset, sets it to
System::GetMemoryObjectName() as a default in order to have unique
names within the diagram.


::

    DiagramBuilder<T> builder;
      auto foo = builder.AddSystem(std::make_unique<Foo<T>>());

Template parameter ``S``:
    The type of system to add.)""";
        } AddSystem;
        // Symbol: drake::systems::DiagramBuilder::Build
        struct /* Build */ {
          // Source: drake/systems/framework/diagram_builder.h:280
          const char* doc =
R"""(Builds the Diagram that has been described by the calls to Connect,
ExportInput, and ExportOutput.

Raises:
    RuntimeError if the graph is not buildable.)""";
        } Build;
        // Symbol: drake::systems::DiagramBuilder::BuildInto
        struct /* BuildInto */ {
          // Source: drake/systems/framework/diagram_builder.h:288
          const char* doc =
R"""(Configures ``target`` to have the topology that has been described by
the calls to Connect, ExportInput, and ExportOutput.

Raises:
    RuntimeError if the graph is not buildable.

Only Diagram subclasses should call this method. The target must not
already be initialized.)""";
        } BuildInto;
        // Symbol: drake::systems::DiagramBuilder::Cascade
        struct /* Cascade */ {
          // Source: drake/systems/framework/diagram_builder.h:238
          const char* doc =
R"""(Cascades ``src`` and ``dest``. The sole input port on the ``dest``
system is connected to sole output port on the ``src`` system.

Raises:
    RuntimeError if the sole-port precondition is not met (i.e., if
    ``dest`` has no input ports, or ``dest`` has more than one input
    port, or ``src`` has no output ports, or ``src`` has more than one
    output port).)""";
        } Cascade;
        // Symbol: drake::systems::DiagramBuilder::Connect
        struct /* Connect */ {
          // Source: drake/systems/framework/diagram_builder.h:216
          const char* doc =
R"""(Declares that input port ``dest`` is connected to output port ``src``.

Note:
    The connection created between ``src`` and ``dest`` via a call to
    this method can be effectively overridden by any subsequent call
    to InputPort::FixValue(). That is, calling InputPort::FixValue()
    on an already connected input port causes the resultant
    FixedInputPortValue to override any other value present on that
    port.)""";
        } Connect;
        // Symbol: drake::systems::DiagramBuilder::ConnectInput
        struct /* ConnectInput */ {
          // Source: drake/systems/framework/diagram_builder.h:257
          const char* doc_2args_diagram_port_name_input =
R"""(Connects an input to the entire Diagram, indicated by
``diagram_port_name``, to the given ``input`` port of a constituent
system.

Precondition:
    The Diagram input indicated by ``diagram_port_name`` must have
    been previously built via ExportInput().

Postcondition:
    ``input`` is connected to the indicated Diagram input port.)""";
          // Source: drake/systems/framework/diagram_builder.h:265
          const char* doc_2args_diagram_port_index_input =
R"""(Connects an input to the entire Diagram, indicated by
``diagram_port_index``, to the given ``input`` port of a constituent
system.

Precondition:
    The Diagram input indicated by ``diagram_port_index`` must have
    been previously built via ExportInput().

Postcondition:
    ``input`` is connected to the indicated Diagram input port.)""";
        } ConnectInput;
        // Symbol: drake::systems::DiagramBuilder::DiagramBuilder<T>
        struct /* ctor */ {
          // Source: drake/systems/framework/diagram_builder.h:31
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::systems::DiagramBuilder::ExportInput
        struct /* ExportInput */ {
          // Source: drake/systems/framework/diagram_builder.h:248
          const char* doc =
R"""(Declares that the given ``input`` port of a constituent system is
connected to a new input to the entire Diagram. ``name`` is an
optional name for the new input port; if it is unspecified, then a
default name will be provided.

Precondition:
    If supplied at all, ``name`` must not be empty.

Precondition:
    A port indicated by the resolution of ``name`` must not exist.

Postcondition:
    ``input`` is connected to the new exported input port.

Returns:
    The index of the exported input port of the entire diagram.)""";
        } ExportInput;
        // Symbol: drake::systems::DiagramBuilder::ExportOutput
        struct /* ExportOutput */ {
          // Source: drake/systems/framework/diagram_builder.h:273
          const char* doc =
R"""(Declares that the given ``output`` port of a constituent system is an
output of the entire diagram. ``name`` is an optional name for the
output port; if it is unspecified, then a default name will be
provided.

Precondition:
    If supplied at all, ``name`` must not be empty.

Returns:
    The index of the exported output port of the entire diagram.)""";
        } ExportOutput;
        // Symbol: drake::systems::DiagramBuilder::GetMutableSystems
        struct /* GetMutableSystems */ {
          // Source: drake/systems/framework/diagram_builder.h:207
          const char* doc =
R"""(Returns the list of contained Systems. See also GetSystems().)""";
        } GetMutableSystems;
        // Symbol: drake::systems::DiagramBuilder::GetSystems
        struct /* GetSystems */ {
          // Source: drake/systems/framework/diagram_builder.h:203
          const char* doc =
R"""(Returns the list of contained Systems. See also GetMutableSystems().)""";
        } GetSystems;
        // Symbol: drake::systems::DiagramBuilder::empty
        struct /* empty */ {
          // Source: drake/systems/framework/diagram_builder.h:199
          const char* doc =
R"""(Returns whether any Systems have been added yet.)""";
        } empty;
      } DiagramBuilder;
      // Symbol: drake::systems::DiagramCompositeEventCollection
      struct /* DiagramCompositeEventCollection */ {
        // Source: drake/systems/framework/event_collection.h:649
        const char* doc =
R"""(CompositeEventCollection for a Diagram.

End users should never need to use or know about this class. It is for
internal use only.)""";
        // Symbol: drake::systems::DiagramCompositeEventCollection::DiagramCompositeEventCollection<T>
        struct /* ctor */ {
          // Source: drake/systems/framework/event_collection.h:660
          const char* doc =
R"""(Allocated CompositeEventCollection for all constituent subsystems are
passed in ``subevents`` (a vector of size of the number of subsystems
of the corresponding diagram), for which ownership is also transferred
to ``this``.)""";
        } ctor;
        // Symbol: drake::systems::DiagramCompositeEventCollection::get_mutable_subevent_collection
        struct /* get_mutable_subevent_collection */ {
          // Source: drake/systems/framework/event_collection.h:713
          const char* doc = R"""()""";
        } get_mutable_subevent_collection;
        // Symbol: drake::systems::DiagramCompositeEventCollection::get_subevent_collection
        struct /* get_subevent_collection */ {
          // Source: drake/systems/framework/event_collection.h:721
          const char* doc = R"""()""";
        } get_subevent_collection;
        // Symbol: drake::systems::DiagramCompositeEventCollection::num_subsystems
        struct /* num_subsystems */ {
          // Source: drake/systems/framework/event_collection.h:706
          const char* doc =
R"""(Returns the number of subsystems for which this object contains event
collections.)""";
        } num_subsystems;
      } DiagramCompositeEventCollection;
      // Symbol: drake::systems::DiagramContext
      struct /* DiagramContext */ {
        // Source: drake/systems/framework/diagram_context.h:28
        const char* doc =
R"""(The DiagramContext is a container for all of the data necessary to
uniquely determine the computations performed by a Diagram.
Specifically, a DiagramContext contains Context objects for all its
constituent Systems.

See also:
    Context for more information.

In general, users should not need to interact with a DiagramContext
directly. Use the accessors on Diagram instead.)""";
        // Symbol: drake::systems::DiagramContext::AddSystem
        struct /* AddSystem */ {
          // Source: drake/systems/framework/diagram_context.h:54
          const char* doc =
R"""(Declares a new subsystem in the DiagramContext. Subsystems are
identified by number. If the subsystem has already been declared,
aborts.

User code should not call this method. It is for use during Diagram
context allocation only.)""";
        } AddSystem;
        // Symbol: drake::systems::DiagramContext::DiagramContext<T>
        struct /* ctor */ {
          // Source: drake/systems/framework/diagram_context.h:47
          const char* doc =
R"""(Constructs a DiagramContext with the given ``num_subcontexts``, which
is final: you cannot resize a DiagramContext after construction. The
number and ordering of subcontexts is identical to the number and
ordering of subsystems in the corresponding Diagram.)""";
          // Source: drake/systems/framework/diagram_context.h:129
          const char* doc_copy =
R"""(Protected copy constructor takes care of the local data members and
all base class members, but doesn't update base class pointers so is
not a complete copy.)""";
        } ctor;
        // Symbol: drake::systems::DiagramContext::GetMutableSubsystemContext
        struct /* GetMutableSubsystemContext */ {
          // Source: drake/systems/framework/diagram_context.h:119
          const char* doc =
R"""(Returns the context structure for a given subsystem ``index``. Aborts
if ``index`` is out of bounds, or if no system has been added to the
DiagramContext at that index.)""";
        } GetMutableSubsystemContext;
        // Symbol: drake::systems::DiagramContext::GetSubsystemContext
        struct /* GetSubsystemContext */ {
          // Source: drake/systems/framework/diagram_context.h:109
          const char* doc =
R"""(Returns the context structure for a given constituent system
``index``. Aborts if ``index`` is out of bounds, or if no system has
been added to the DiagramContext at that index.)""";
        } GetSubsystemContext;
        // Symbol: drake::systems::DiagramContext::InputPortIdentifier
        struct /* InputPortIdentifier */ {
          // Source: drake/systems/framework/diagram_context.h:39
          const char* doc =
R"""(Identifies a child subsystem's input port.)""";
        } InputPortIdentifier;
        // Symbol: drake::systems::DiagramContext::MakeParameters
        struct /* MakeParameters */ {
          // Source: drake/systems/framework/diagram_context.h:103
          const char* doc =
R"""((Internal use only) Generates the parameters for the entire diagram by
wrapping the parameters of all the constituent Systems. The wrapper
simply holds pointers to the parameters in the subsystem Contexts. It
does not make a copy, or take ownership.)""";
        } MakeParameters;
        // Symbol: drake::systems::DiagramContext::MakeState
        struct /* MakeState */ {
          // Source: drake/systems/framework/diagram_context.h:97
          const char* doc =
R"""((Internal use only) Generates the state vector for the entire diagram
by wrapping the states of all the constituent diagrams.)""";
        } MakeState;
        // Symbol: drake::systems::DiagramContext::OutputPortIdentifier
        struct /* OutputPortIdentifier */ {
          // Source: drake/systems/framework/diagram_context.h:41
          const char* doc =
R"""(Identifies a child subsystem's output port.)""";
        } OutputPortIdentifier;
        // Symbol: drake::systems::DiagramContext::SubscribeDiagramCompositeTrackersToChildrens
        struct /* SubscribeDiagramCompositeTrackersToChildrens */ {
          // Source: drake/systems/framework/diagram_context.h:93
          const char* doc =
R"""((Internal use only) Makes the diagram state, parameter, and composite
cache entry trackers subscribe to the corresponding constituent
trackers in the child subcontexts.)""";
        } SubscribeDiagramCompositeTrackersToChildrens;
        // Symbol: drake::systems::DiagramContext::SubscribeDiagramPortToExportedOutputPort
        struct /* SubscribeDiagramPortToExportedOutputPort */ {
          // Source: drake/systems/framework/diagram_context.h:74
          const char* doc =
R"""((Internal use only) Declares that a particular output port of this
diagram is simply forwarded from an output port of one of its child
subsystems. Sets up tracking of the diagram port's dependency on the
child port. Aborts if the subsystem has not been added to the
DiagramContext.

User code should not call this method. It is for use during Diagram
context allocation only.)""";
        } SubscribeDiagramPortToExportedOutputPort;
        // Symbol: drake::systems::DiagramContext::SubscribeExportedInputPortToDiagramPort
        struct /* SubscribeExportedInputPortToDiagramPort */ {
          // Source: drake/systems/framework/diagram_context.h:63
          const char* doc =
R"""((Internal use only) Declares that a particular input port of a child
subsystem is an input to the entire Diagram that allocates this
Context. Sets up tracking of the child port's dependency on the parent
port. Aborts if the subsystem has not been added to the
DiagramContext.

User code should not call this method. It is for use during Diagram
context allocation only.)""";
        } SubscribeExportedInputPortToDiagramPort;
        // Symbol: drake::systems::DiagramContext::SubscribeInputPortToOutputPort
        struct /* SubscribeInputPortToOutputPort */ {
          // Source: drake/systems/framework/diagram_context.h:87
          const char* doc =
R"""((Internal use only) Declares that a connection exists between a peer
output port and input port in this Diagram, and registers the input
port's dependency tracker with the output port's dependency tracker.
By "peer" we mean that both ports belong to immediate child subsystems
of this Diagram (it is also possible for both ports to belong to the
same subsystem).

User code should not call this method. It is for use during Diagram
context allocation only.)""";
        } SubscribeInputPortToOutputPort;
      } DiagramContext;
      // Symbol: drake::systems::DiagramContinuousState
      struct /* DiagramContinuousState */ {
        // Source: drake/systems/framework/diagram_continuous_state.h:31
        const char* doc =
R"""(%DiagramContinuousState is a ContinuousState consisting of
Supervectors xc, q, v, z over the corresponding entries in a set of
referenced ContinuousState objects, which may or may not be owned by
this DiagramContinuousState. This is done recursively since any of the
referenced ContinuousState objects could themselves be
DiagramContinuousState objects. The actual numerical data is always
contained in the leaf ContinuousState objects at the bottom of the
tree.

This object is used both for a Diagram's actual continuous state
variables xc (with partitions q, v, z) and for the time derivatives
xdot (qdot, vdot, zdot). Cloning a DiagramContinuousState results in
an object with identical structure, but which owns the referenced
ContinuousState objects, regardless of whether the original had
ownership.)""";
        // Symbol: drake::systems::DiagramContinuousState::Clone
        struct /* Clone */ {
          // Source: drake/systems/framework/diagram_continuous_state.h:55
          const char* doc =
R"""(Creates a deep copy of this DiagramContinuousState, with the same
substructure but with new, owned data. Intentionally shadows the
ContinuousState::Clone() method but with a more-specific return type
so you don't have to downcast.)""";
        } Clone;
        // Symbol: drake::systems::DiagramContinuousState::DiagramContinuousState<T>
        struct /* ctor */ {
          // Source: drake/systems/framework/diagram_continuous_state.h:33
          const char* doc_was_unable_to_choose_unambiguous_names = R"""()""";
        } ctor;
        // Symbol: drake::systems::DiagramContinuousState::get_mutable_substate
        struct /* get_mutable_substate */ {
          // Source: drake/systems/framework/diagram_continuous_state.h:69
          const char* doc =
R"""(Returns the continuous state at the given ``index``. Aborts if
``index`` is out-of-bounds.)""";
        } get_mutable_substate;
        // Symbol: drake::systems::DiagramContinuousState::get_substate
        struct /* get_substate */ {
          // Source: drake/systems/framework/diagram_continuous_state.h:61
          const char* doc =
R"""(Returns the continuous state at the given ``index``. Aborts if
``index`` is out-of-bounds.)""";
        } get_substate;
        // Symbol: drake::systems::DiagramContinuousState::num_substates
        struct /* num_substates */ {
          // Source: drake/systems/framework/diagram_continuous_state.h:57
          const char* doc = R"""()""";
        } num_substates;
      } DiagramContinuousState;
      // Symbol: drake::systems::DiagramDiscreteValues
      struct /* DiagramDiscreteValues */ {
        // Source: drake/systems/framework/diagram_discrete_values.h:28
        const char* doc =
R"""(DiagramDiscreteValues is a DiscreteValues container comprised
recursively of a sequence of child DiscreteValues objects. The API
allows this to be treated as though it were a single DiscreteValues
object whose groups are the concatenation of the groups in each child.

The child objects may be owned or not. When this is used to aggregate
LeafSystem discrete values in a Diagram, the child objects are not
owned. When this is cloned, deep copies are made that are owned here.)""";
        // Symbol: drake::systems::DiagramDiscreteValues::Clone
        struct /* Clone */ {
          // Source: drake/systems/framework/diagram_discrete_values.h:63
          const char* doc =
R"""(Creates a deep copy of this DiagramDiscreteValues object, with the
same substructure but with new, owned data. Intentionally shadows the
DiscreteValues::Clone() method but with a more-specific return type so
you don't have to downcast.)""";
        } Clone;
        // Symbol: drake::systems::DiagramDiscreteValues::DiagramDiscreteValues<T>
        struct /* ctor */ {
          // Source: drake/systems/framework/diagram_discrete_values.h:40
          const char* doc_1args_subdiscretes =
R"""(Constructs a DiagramDiscreteValues object that is composed of other
DiscreteValues, which are not owned by this object and must outlive
it.

The DiagramDiscreteValues vector xd = [xd₁ xd₂ ...] where each of the
xdᵢ is an array of BasicVector objects. These will have the same
ordering as the ``subdiscretes`` parameter, which should be the order
of the Diagram itself. That is, the substates should be indexed by
SubsystemIndex in the same order as the subsystems are.)""";
          // Source: drake/systems/framework/diagram_discrete_values.h:48
          const char* doc_1args_owned_subdiscretes =
R"""(Constructs a DiagramDiscreteValues object that is composed
(recursively) of other DiscreteValues objects, ownership of which is
transferred here.)""";
        } ctor;
        // Symbol: drake::systems::DiagramDiscreteValues::get_mutable_subdiscrete
        struct /* get_mutable_subdiscrete */ {
          // Source: drake/systems/framework/diagram_discrete_values.h:86
          const char* doc =
R"""(Returns a mutable reference to one of the referenced DiscreteValues
objects which may or may not be owned locally.)""";
        } get_mutable_subdiscrete;
        // Symbol: drake::systems::DiagramDiscreteValues::get_subdiscrete
        struct /* get_subdiscrete */ {
          // Source: drake/systems/framework/diagram_discrete_values.h:78
          const char* doc =
R"""(Returns a const reference to one of the referenced DiscreteValues
objects which may or may not be owned locally.)""";
        } get_subdiscrete;
        // Symbol: drake::systems::DiagramDiscreteValues::num_subdiscretes
        struct /* num_subdiscretes */ {
          // Source: drake/systems/framework/diagram_discrete_values.h:72
          const char* doc =
R"""(Returns the number of DiscreteValues objects referenced by this
DiagramDiscreteValues object, necessarily the same as the number of
subcontexts in the containing DiagramContext.)""";
        } num_subdiscretes;
      } DiagramDiscreteValues;
      // Symbol: drake::systems::DiagramEventCollection
      struct /* DiagramEventCollection */ {
        // Source: drake/systems/framework/event_collection.h:167
        const char* doc =
R"""(A concrete class that holds all simultaneous *homogeneous* events for
a Diagram. For each subsystem in the corresponding Diagram, a derived
EventCollection instance is maintained internally, thus effectively
holding the same recursive tree structure as the corresponding
Diagram.

This class uses an unusual paradigm for storing collections of events
corresponding to subsystems of the diagram ("subevent collections").
The class owns some subevent collections and maintains pointers to
other subevent collections. The technical reasoning is that the same
data may need to be referenced by multiple collections;
DiagramCompositeEventCollection maintains one collection for all
publish events and another for the events from each subsystem, but
maintains only a single copy of all of the event data.

End users should never need to use or know about this class. It is for
internal use only.)""";
        // Symbol: drake::systems::DiagramEventCollection::Clear
        struct /* Clear */ {
          // Source: drake/systems/framework/event_collection.h:248
          const char* doc = R"""(Clears all subevent collections.)""";
        } Clear;
        // Symbol: drake::systems::DiagramEventCollection::DiagramEventCollection<EventType>
        struct /* ctor */ {
          // Source: drake/systems/framework/event_collection.h:177
          const char* doc =
R"""(Note that this constructor only resizes the containers; it does not
allocate any derived EventCollection instances.

Parameter ``num_subsystems``:
    Number of subsystems in the corresponding Diagram.)""";
        } ctor;
        // Symbol: drake::systems::DiagramEventCollection::DoAddToEnd
        struct /* DoAddToEnd */ {
          // Source: drake/systems/framework/event_collection.h:276
          const char* doc =
R"""(Goes through each subevent collection of ``this`` and adds the
corresponding one in ``other_collection`` to the subevent collection
in ``this``. Aborts if ``this`` does not have the same number of
subevent collections as ``other_collection``. In addition, this method
assumes that ``this`` and ``other_collection`` have the exact same
topology (i.e. both are created for the same Diagram.)

Raises:
    RuntimeError if ``other_collection`` is not an instance of
    DiagramEventCollection.)""";
        } DoAddToEnd;
        // Symbol: drake::systems::DiagramEventCollection::HasEvents
        struct /* HasEvents */ {
          // Source: drake/systems/framework/event_collection.h:258
          const char* doc =
R"""(Returns ``True`` if and only if any of the subevent collections have
any events.)""";
        } HasEvents;
        // Symbol: drake::systems::DiagramEventCollection::add_event
        struct /* add_event */ {
          // Source: drake/systems/framework/event_collection.h:185
          const char* doc =
R"""(Throws if called, because no events should be added at the Diagram
level.)""";
        } add_event;
        // Symbol: drake::systems::DiagramEventCollection::get_mutable_subevent_collection
        struct /* get_mutable_subevent_collection */ {
          // Source: drake/systems/framework/event_collection.h:240
          const char* doc =
R"""(Returns a mutable pointer to subsystem's EventCollection at ``index``.)""";
        } get_mutable_subevent_collection;
        // Symbol: drake::systems::DiagramEventCollection::get_subevent_collection
        struct /* get_subevent_collection */ {
          // Source: drake/systems/framework/event_collection.h:232
          const char* doc =
R"""(Returns a const pointer to subsystem's EventCollection at ``index``.
Aborts if the 0-indexed ``index`` is greater than or equal to the
number of subsystems specified in this object's construction (see
DiagramEventCollection(int)) or if ``index`` is not in the range [0,
num_subsystems() - 1].)""";
        } get_subevent_collection;
        // Symbol: drake::systems::DiagramEventCollection::num_subsystems
        struct /* num_subsystems */ {
          // Source: drake/systems/framework/event_collection.h:193
          const char* doc =
R"""(Returns the number of constituent EventCollection objects that
correspond to each subsystem in the Diagram.)""";
        } num_subsystems;
        // Symbol: drake::systems::DiagramEventCollection::set_and_own_subevent_collection
        struct /* set_and_own_subevent_collection */ {
          // Source: drake/systems/framework/event_collection.h:202
          const char* doc =
R"""(Transfers ``subevent_collection`` ownership to ``this`` and associates
it with the subsystem identified by ``index``. Aborts if ``index`` is
not in the range [0, num_subsystems() - 1] or if
``subevent_collection`` is null.)""";
        } set_and_own_subevent_collection;
        // Symbol: drake::systems::DiagramEventCollection::set_subevent_collection
        struct /* set_subevent_collection */ {
          // Source: drake/systems/framework/event_collection.h:218
          const char* doc =
R"""(Associate ``subevent_collection`` with subsystem identified by
``index``. Ownership of the object that ``subevent_collection`` is
maintained elsewhere, and its life span must be longer than this.
Aborts if ``index`` is not in the range [0, num_subsystems() - 1] or
if ``subevent_collection`` is null.)""";
        } set_subevent_collection;
      } DiagramEventCollection;
      // Symbol: drake::systems::DiagramOutputPort
      struct /* DiagramOutputPort */ {
        // Source: drake/systems/framework/diagram_output_port.h:28
        const char* doc =
R"""((Advanced.) Holds information about a subsystem output port that has
been exported to become one of this Diagram's output ports. The actual
methods for determining the port's value are supplied by the
LeafOutputPort that ultimately underlies the source port, although
that may be any number of levels down. This is intended for internal
use in implementing Diagram.)""";
        // Symbol: drake::systems::DiagramOutputPort::DiagramOutputPort<T>
        struct /* ctor */ {
          // Source: drake/systems/framework/diagram_output_port.h:30
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::systems::DiagramOutputPort::get_source_output_port
        struct /* get_source_output_port */ {
          // Source: drake/systems/framework/diagram_output_port.h:37
          const char* doc =
R"""(Obtains a reference to the subsystem output port that was exported to
create this diagram port. Note that the source may itself be a diagram
output port.)""";
        } get_source_output_port;
      } DiagramOutputPort;
      // Symbol: drake::systems::DiagramState
      struct /* DiagramState */ {
        // Source: drake/systems/framework/diagram_state.h:17
        const char* doc =
R"""(DiagramState is a State, annotated with pointers to all the mutable
substates that it spans.)""";
        // Symbol: drake::systems::DiagramState::DiagramState<T>
        struct /* ctor */ {
          // Source: drake/systems/framework/diagram_state.h:22
          const char* doc =
R"""(Constructs a DiagramState consisting of ``size`` substates.)""";
        } ctor;
        // Symbol: drake::systems::DiagramState::Finalize
        struct /* Finalize */ {
          // Source: drake/systems/framework/diagram_state.h:52
          const char* doc =
R"""(Finalizes this state as a span of all the constituent substates.)""";
        } Finalize;
        // Symbol: drake::systems::DiagramState::get_mutable_substate
        struct /* get_mutable_substate */ {
          // Source: drake/systems/framework/diagram_state.h:46
          const char* doc = R"""(Returns the substate at ``index``.)""";
        } get_mutable_substate;
        // Symbol: drake::systems::DiagramState::get_substate
        struct /* get_substate */ {
          // Source: drake/systems/framework/diagram_state.h:40
          const char* doc = R"""(Returns the substate at ``index``.)""";
        } get_substate;
        // Symbol: drake::systems::DiagramState::set_and_own_substate
        struct /* set_and_own_substate */ {
          // Source: drake/systems/framework/diagram_state.h:34
          const char* doc =
R"""(Sets the substate at ``index`` to ``substate``, or aborts if ``index``
is out of bounds.)""";
        } set_and_own_substate;
        // Symbol: drake::systems::DiagramState::set_substate
        struct /* set_substate */ {
          // Source: drake/systems/framework/diagram_state.h:27
          const char* doc =
R"""(Sets the substate at ``index`` to ``substate``, or aborts if ``index``
is out of bounds. Does not take ownership of ``substate``, which must
live as long as this object.)""";
        } set_substate;
      } DiagramState;
      // Symbol: drake::systems::DiscreteDerivative
      struct /* DiscreteDerivative */ {
        // Source: drake/systems/primitives/discrete_derivative.h:53
        const char* doc =
R"""(System that outputs the discrete-time derivative of its input: y(t) =
(u[n] - u[n-1])/h, where n = floor(t/h), where h is the time period.

This is implemented as the linear system


::

    x₀[n+1] = u[n],
      x₁[n+1] = x₀[n],
      y(t) = (x₀[n]-x₁[n])/h.
      x₀[0] and x₁[0] are initialized in the Context (default is zeros).

Alternatively, when ``suppress_initial_transient = true`` is passed to
the constructor, the output remains zero until u[n] has been sampled
twice.

This is implemented as the non-linear system


::

    x₀[n+1] = u[n],
      x₁[n+1] = x₀[n],
      x₂[n+1] = x₂[n] + 1,
      y(t) = { 0.0              if x₂ <  2 }
             { (x₀[n]-x₁[n])/h  if x₂ >= 2 }
      x₀[0], x₁[0], x₂[0] are initialized in the Context (default is zeros).

Note:
    For dynamical systems, a derivative should not be computed in
    continuous-time, i.e. ``y(t) = (u(t) - u[n])/(t-n*h)``. This is
    numerically unstable since the time interval ``t-n*h`` could be
    arbitrarily close to zero. Prefer the discrete-time implementation
    for robustness.

.. pydrake_system::

    name: DiscreteDerivative
    input_ports:
    - u
    output_ports:
    - dudt)""";
        // Symbol: drake::systems::DiscreteDerivative::DiscreteDerivative<T>
        struct /* ctor */ {
          // Source: drake/systems/primitives/discrete_derivative.h:59
          const char* doc =
R"""(Constructor taking ``num_inputs``, the size of the vector to be
differentiated, and ``time_step``, the sampling interval.)""";
          // Source: drake/systems/primitives/discrete_derivative.h:64
          const char* doc_copyconvert =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";
        } ctor;
        // Symbol: drake::systems::DiscreteDerivative::set_input_history
        struct /* set_input_history */ {
          // Source: drake/systems/primitives/discrete_derivative.h:74
          const char* doc_3args_state_u_n_u_n_minus_1 =
R"""(Sets the input history so that the initial output is fully specified.
This is useful during initialization to avoid large derivative outputs
if u[0] ≠ 0. ``u_n`` and @ u_n_minus_1 must be the same size as the
input/output ports. If suppress_initial_transient() is true, then also
sets x₂ to be >= 2 to disable the suppression for this ``state``.)""";
          // Source: drake/systems/primitives/discrete_derivative.h:83
          const char* doc_3args_context_u_n_u_n_minus_1 =
R"""(Sets the input history so that the initial output is fully specified.
This is useful during initialization to avoid large derivative outputs
if u[0] ≠ 0. ``u_n`` and @ u_n_minus_1 must be the same size as the
input/output ports. If suppress_initial_transient() is true, then also
sets x₂ to be >= 2 to disable the suppression for this ``context``.)""";
          // Source: drake/systems/primitives/discrete_derivative.h:96
          const char* doc_2args_context_u =
R"""(Convenience method that sets the entire input history to a constant
vector value (x₀ = x₁ = u,resulting in a derivative = 0). This is
useful during initialization to avoid large derivative outputs if u[0]
≠ 0. ``u`` must be the same size as the input/output ports. If
suppress_initial_transient() is true, then also sets x₂ to be >= 2 to
disable the suppression for this ``context``.)""";
        } set_input_history;
        // Symbol: drake::systems::DiscreteDerivative::suppress_initial_transient
        struct /* suppress_initial_transient */ {
          // Source: drake/systems/primitives/discrete_derivative.h:104
          const char* doc =
R"""(Returns the ``suppress_initial_transient`` passed to the constructor.)""";
        } suppress_initial_transient;
        // Symbol: drake::systems::DiscreteDerivative::time_step
        struct /* time_step */ {
          // Source: drake/systems/primitives/discrete_derivative.h:101
          const char* doc = R"""()""";
        } time_step;
      } DiscreteDerivative;
      // Symbol: drake::systems::DiscreteStateIndex
      struct /* DiscreteStateIndex */ {
        // Source: drake/systems/framework/framework_common.h:54
        const char* doc =
R"""(Serves as the local index for discrete state groups within a given
System and its corresponding Context.)""";
      } DiscreteStateIndex;
      // Symbol: drake::systems::DiscreteTimeDelay
      struct /* DiscreteTimeDelay */ {
        // Source: drake/systems/primitives/discrete_time_delay.h:52
        const char* doc =
R"""(A discrete time delay block with input u, which is vector-valued
(discrete or continuous) or abstract, and output delayed_u which is
previously received input, delayed by the given amount. The initial
output will be a vector of zeros for vector-valued or a given value
for abstract-valued until the delay time has passed.

.. pydrake_system::

    name: DiscreteTimeDelay
    input_ports:
    - u
    output_ports:
    - delayed_u

Let t,z ∈ ℕ be the number of delay time steps and the input vector
size. For abstract-valued DiscreteTimeDelay, z is 1. The state x ∈
ℝ⁽ᵗ⁺¹⁾ᶻ is partitioned into t+1 blocks x[0] x[1] ... x[t], each of
size z. The input and output are u,y ∈ ℝᶻ. The discrete state space
dynamics of DiscreteTimeDelay is:


::

    xₙ₊₁ = xₙ[1] xₙ[2] ... xₙ[t] uₙ  // update
      yₙ = xₙ[0]                       // output
      x₀ = xᵢₙᵢₜ                       // initialize

where xᵢₙᵢₜ = 0 for vector-valued DiscreteTimeDelay and xᵢₙᵢₜ is a
given value for abstract-valued DiscreteTimeDelay.

See discrete_systems "Discrete Systems" for general information about
discrete systems in Drake, including how they interact with continuous
systems.

Note:
    While the output port can be sampled at any continuous time, this
    system does not interpolate.)""";
        // Symbol: drake::systems::DiscreteTimeDelay::DiscreteTimeDelay<T>
        struct /* ctor */ {
          // Source: drake/systems/primitives/discrete_time_delay.h:59
          const char* doc_3args_update_sec_delay_timesteps_vector_size =
R"""(Constructs a DiscreteTimeDelay system updating every ``update_sec``
and delaying a vector-valued input of size ``vector_size`` for
``delay_timesteps`` number of updates.)""";
          // Source: drake/systems/primitives/discrete_time_delay.h:65
          const char* doc_3args_update_sec_delay_timesteps_abstract_model_value =
R"""(Constructs a DiscreteTimeDelay system updating every ``update_sec``
and delaying an abstract-valued input of type ``abstract_model_value``
for ``delay_timesteps`` number of updates.)""";
          // Source: drake/systems/primitives/discrete_time_delay.h:73
          const char* doc_copyconvert =
R"""(Scalar-type converting copy constructor. See system_scalar_conversion.)""";
        } ctor;
        // Symbol: drake::systems::DiscreteTimeDelay::SaveInputToBuffer
        struct /* SaveInputToBuffer */ {
          // Source: drake/systems/primitives/discrete_time_delay.h:80
          const char* doc =
R"""((Advanced) Manually samples the input port and updates the state of
the block, sliding the delay buffer forward and placing the sampled
input at the end. This emulates an update event and is mostly useful
for testing.)""";
        } SaveInputToBuffer;
      } DiscreteTimeDelay;
      // Symbol: drake::systems::DiscreteUpdateEvent
      struct /* DiscreteUpdateEvent */ {
        // Source: drake/systems/framework/event.h:645
        const char* doc =
R"""(This class represents a discrete update event. It has an optional
callback function to do custom handling of this event given const
Context and const DiscreteUpdateEvent references, and writes the
updates to a mutable, non-null DiscreteValues object.)""";
        // Symbol: drake::systems::DiscreteUpdateEvent::DiscreteUpdateCallback
        struct /* DiscreteUpdateCallback */ {
          // Source: drake/systems/framework/event.h:657
          const char* doc =
R"""(Callback function that processes a discrete update event.)""";
        } DiscreteUpdateCallback;
        // Symbol: drake::systems::DiscreteUpdateEvent::DiscreteUpdateEvent<T>
        struct /* ctor */ {
          // Source: drake/systems/framework/event.h:661
          const char* doc_0args =
R"""(Makes a DiscreteUpdateEvent with no trigger type, no event data, and
no specified callback function.)""";
          // Source: drake/systems/framework/event.h:665
          const char* doc_1args =
R"""(Makes a DiscreteUpdateEvent with no trigger type, no event data, and
the specified callback function.)""";
        } ctor;
        // Symbol: drake::systems::DiscreteUpdateEvent::handle
        struct /* handle */ {
          // Source: drake/systems/framework/event.h:688
          const char* doc =
R"""(Calls the optional callback function, if one exists, with ``context``,
'this' and ``discrete_state``.)""";
        } handle;
        // Symbol: drake::systems::DiscreteUpdateEvent::is_discrete_update
        struct /* is_discrete_update */ {
          // Source: drake/systems/framework/event.h:650
          const char* doc = R"""()""";
        } is_discrete_update;
      } DiscreteUpdateEvent;
      // Symbol: drake::systems::DiscreteValues
      struct /* DiscreteValues */ {
        // Source: drake/systems/framework/discrete_values.h:39
        const char* doc =
R"""(%DiscreteValues is a container for numerical but non-continuous state
and parameters. It may own its underlying data, for use with leaf
Systems, or not, for use with Diagrams.

DiscreteValues is an ordered collection xd of BasicVector "groups" so
xd = [xd₀, xd₁...], where each group xdᵢ is a contiguous vector.
Requesting a specific group index from this collection is the most
granular way to retrieve discrete values from the Context, and thus is
the unit of cache invalidation. System authors are encouraged to
partition their DiscreteValues such that each cacheable computation
within the System may depend on only the elements of DiscreteValues
that it needs.

None of the contained vectors (groups) may be null, although any of
them may be zero-length.)""";
        // Symbol: drake::systems::DiscreteValues::AppendGroup
        struct /* AppendGroup */ {
          // Source: drake/systems/framework/discrete_values.h:80
          const char* doc =
R"""(Adds an additional group that owns the given ``datum``, which must be
non-null. Returns the assigned group number, counting up from 0 for
the first group.)""";
        } AppendGroup;
        // Symbol: drake::systems::DiscreteValues::Clone
        struct /* Clone */ {
          // Source: drake/systems/framework/discrete_values.h:166
          const char* doc =
R"""(Creates a deep copy of this object with the same substructure but with
all data owned by the copy. That is, if the original was a
DiagramDiscreteValues object that maintains a tree of substates, the
clone will not include any references to the original substates and is
thus decoupled from the Context containing the original. The concrete
type of the BasicVector underlying each leaf DiscreteValue is
preserved.)""";
        } Clone;
        // Symbol: drake::systems::DiscreteValues::DiscreteValues<T>
        struct /* ctor */ {
          // Source: drake/systems/framework/discrete_values.h:45
          const char* doc_0args =
R"""(Constructs an empty DiscreteValues object containing no groups.)""";
          // Source: drake/systems/framework/discrete_values.h:61
          const char* doc_1args_data =
R"""(Constructs a DiscreteValues that owns the underlying ``data``. Every
entry must be non-null.)""";
          // Source: drake/systems/framework/discrete_values.h:73
          const char* doc_1args_datum =
R"""(Constructs a one-group DiscreteValues object that owns a single
``datum`` vector which may not be null.)""";
        } ctor;
        // Symbol: drake::systems::DiscreteValues::SetFrom
        struct /* SetFrom */ {
          // Source: drake/systems/framework/discrete_values.h:151
          const char* doc =
R"""(Resets the values in this DiscreteValues from the values in ``other``,
possibly writing through to unowned data. Throws if the dimensions
don't match.)""";
        } SetFrom;
        // Symbol: drake::systems::DiscreteValues::get_data
        struct /* get_data */ {
          // Source: drake/systems/framework/discrete_values.h:95
          const char* doc = R"""()""";
        } get_data;
        // Symbol: drake::systems::DiscreteValues::get_mutable_vector
        struct /* get_mutable_vector */ {
          // Source: drake/systems/framework/discrete_values.h:127
          const char* doc_0args =
R"""(Returns a mutable reference to the BasicVector containing the values
for the *only* group.)""";
          // Source: drake/systems/framework/discrete_values.h:142
          const char* doc_1args =
R"""(Returns a mutable reference to the vector holding data for the
indicated group.)""";
        } get_mutable_vector;
        // Symbol: drake::systems::DiscreteValues::get_vector
        struct /* get_vector */ {
          // Source: drake/systems/framework/discrete_values.h:120
          const char* doc_0args =
R"""(Returns a const reference to the BasicVector containing the values for
the *only* group.)""";
          // Source: drake/systems/framework/discrete_values.h:135
          const char* doc_1args =
R"""(Returns a const reference to the vector holding data for the indicated
group.)""";
        } get_vector;
        // Symbol: drake::systems::DiscreteValues::num_groups
        struct /* num_groups */ {
          // Source: drake/systems/framework/discrete_values.h:93
          const char* doc = R"""()""";
        } num_groups;
        // Symbol: drake::systems::DiscreteValues::operator[]
        struct /* operator_array */ {
          // Source: drake/systems/framework/discrete_values.h:109
          const char* doc_1args_idx_nonconst =
R"""(Returns a mutable reference to an element in the *only* group.)""";
          // Source: drake/systems/framework/discrete_values.h:114
          const char* doc_1args_idx_const =
R"""(Returns a const reference to an element in the *only* group.)""";
        } operator_array;
        // Symbol: drake::systems::DiscreteValues::size
        struct /* size */ {
          // Source: drake/systems/framework/discrete_values.h:104
          const char* doc =
R"""(Returns the number of elements in the only DiscreteValues group.)""";
        } size;
      } DiscreteValues;
      // Symbol: drake::systems::Event
      struct /* Event */ {
        // Source: drake/systems/framework/event.h:434
        const char* doc =
R"""(Abstract base class that represents an event. The base event contains
two main pieces of information: an enum trigger type and an optional
attribute of AbstractValue that can be used to explain why the event
is triggered. Derived classes should contain a function pointer to an
optional callback function that handles the event. No-op is the
default handling behavior. Currently, the System framework only
supports three concrete event types: PublishEvent,
DiscreteUpdateEvent, and UnrestrictedUpdateEvent distinguished by
their callback functions' write access level to the State.

Event handling occurs during a simulation of a system. The logic that
describes when particular event types are handled is described in the
class documentation for Simulator.)""";
        // Symbol: drake::systems::Event::AddToComposite
        struct /* AddToComposite */ {
          // Source: drake/systems/framework/event.h:507
          const char* doc_2args =
R"""(Adds a clone of ``this`` event to the event collection ``events``,
with the given trigger type. If ``this`` event has an unknown trigger
type, then any trigger type is acceptable. Otherwise the given trigger
type must match match the trigger type stored in ``this`` event.

Precondition:
    ``trigger_type`` must match the current trigger type unless that
    is unknown.

Precondition:
    ``events`` must not be null.)""";
          // Source: drake/systems/framework/event.h:519
          const char* doc_1args =
R"""(Provides an alternate signature for adding an Event that already has
the correct trigger type set. Must not have an unknown trigger type.)""";
        } AddToComposite;
        // Symbol: drake::systems::Event::Clone
        struct /* Clone */ {
          // Source: drake/systems/framework/event.h:458
          const char* doc = R"""(Clones this instance.)""";
        } Clone;
        // Symbol: drake::systems::Event::DoAddToComposite
        struct /* DoAddToComposite */ {
          // Source: drake/systems/framework/event.h:541
          const char* doc =
R"""(Derived classes must implement this to add a clone of this Event to
the event collection and unconditionally set its trigger type.)""";
        } DoAddToComposite;
        // Symbol: drake::systems::Event::DoClone
        struct /* DoClone */ {
          // Source: drake/systems/framework/event.h:549
          const char* doc =
R"""(Derived classes must implement this method to clone themselves. Any
Event-specific data is cloned using the Clone() method. Data specific
to the class derived from Event must be cloned by the implementation.)""";
        } DoClone;
        // Symbol: drake::systems::Event::Event<T>
        struct /* ctor */ {
          // Source: drake/systems/framework/event.h:438
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::systems::Event::TriggerType
        struct /* TriggerType */ {
          // Source: drake/systems/framework/event.h:450
          const char* doc = R"""()""";
        } TriggerType;
        // Symbol: drake::systems::Event::get_event_data
        struct /* get_event_data */ {
          // Source: drake/systems/framework/event.h:477
          const char* doc =
R"""(Returns a const pointer to the event data. The returned value can be
nullptr, which means this event does not have any associated data.)""";
        } get_event_data;
        // Symbol: drake::systems::Event::get_mutable_event_data
        struct /* get_mutable_event_data */ {
          // Source: drake/systems/framework/event.h:484
          const char* doc =
R"""(Returns a mutable pointer to the event data. The returned value can be
nullptr, which means this event does not have any associated data.)""";
        } get_mutable_event_data;
        // Symbol: drake::systems::Event::get_trigger_type
        struct /* get_trigger_type */ {
          // Source: drake/systems/framework/event.h:465
          const char* doc = R"""(Returns the trigger type.)""";
        } get_trigger_type;
        // Symbol: drake::systems::Event::has_event_data
        struct /* has_event_data */ {
          // Source: drake/systems/framework/event.h:470
          const char* doc =
R"""(Returns true if this event has associated data.)""";
        } has_event_data;
        // Symbol: drake::systems::Event::is_discrete_update
        struct /* is_discrete_update */ {
          // Source: drake/systems/framework/event.h:453
          const char* doc =
R"""(Returns ``True`` if this is a DiscreteUpdateEvent.)""";
        } is_discrete_update;
        // Symbol: drake::systems::Event::set_event_data
        struct /* set_event_data */ {
          // Source: drake/systems/framework/event.h:493
          const char* doc = R"""()""";
        } set_event_data;
        // Symbol: drake::systems::Event::set_trigger_type
        struct /* set_trigger_type */ {
          // Source: drake/systems/framework/event.h:489
          const char* doc = R"""()""";
        } set_trigger_type;
      } Event;
      // Symbol: drake::systems::EventCollection
      struct /* EventCollection */ {
        // Source: drake/systems/framework/event_collection.h:100
        const char* doc =
R"""(There are three concrete event types for any System: publish, discrete
state update, and unrestricted state update, listed in order of
increasing ability to change the state (i.e., zero to all).
EventCollection is an abstract base class that stores simultaneous
events *of the same type* that occur *at the same time* (i.e.,
simultaneous events).

For each concrete event type, the LeafSystem API provides a unique
customizable function for processing all simultaneous events of that
type, e.g. LeafSystem::DoPublish(const Context&, const vector<const
PublishEvent*>&) for publish events, where the second argument
represents all of the publish events that occur simultaneously for
that leaf system. The default implementation processes the events
(i.e., call their callback functions) in the order in which they are
stored in the second argument. The developer of new classes derived
from LeafSystem is responsible for overriding such functions if the
custom LeafSystem behavior depends on the order in which events are
processed. For example, suppose two publish events are being
processed, ``events = {per-step publish, periodic publish}``.
Depending on the desired behavior, the developer has the freedom to
ignore both events, perform only one publish action, or perform both
publish actions in any arbitrary order. The System and Diagram API
provide only dispatch mechanisms that delegate actual event handling
to the constituent leaf systems. The Simulator promises that for each
set of simultaneous events of the same type, the public event handling
method (e.g. System::Publish(context, publish_events)) will be invoked
exactly once.

The System API provides several functions for customizable event
generation such as System::DoCalcNextUpdateTime() or
System::DoGetPerStepEvents(). These functions can return any number of
events of arbitrary types, and the resulting events are stored in
separate CompositeEventCollection instances. Before calling the event
handlers, all of these CompositeEventCollection objects must be merged
to generate a complete set of simultaneous events. Then, only events
of the appropriate type are passed to the event handlers. e.g.
sys.Publish(context, combined_event_collection.get_publish_events()).
For example, the Simulator executes this collation process when it is
applied to simulate a system.

Here is a complete example. For some LeafSystem ``sys`` at time ``t``,
its System::DoCalcNextUpdateTime() generates the following
CompositeEventCollection (``events1``):


::

    PublishEvent: {event1(kPeriodic, callback1)}
      DiscreteUpdateEvent: {event2(kPeriodic, callback2)}
      UnrestrictedUpdateEvent: {}

This LeafSystem also desires per-step event processing(``events2``),
generated by its implementation of System::DoGetPerStepEvents():


::

    PublishEvent: {event3(kPerStep, callback3)}
      DiscreteUpdateEvent: {}
      UnrestrictedUpdateEvent: {event4(kPerStep,callback4)}

These collections of "simultaneous" events, ``events1`` and
``events2``, are then merged into the composite event collection
``all_events``:


::

    PublishEvent: {event1, event3}
      DiscreteUpdateEvent: {event2}
      UnrestrictedUpdateEvent: {event4}

This heterogeneous event collection can be processed by calling the
appropriate handler on the appropriate homogeneous subcollection:


::

    sys.CalcUnrestrictedUpdate(context,
          all_events.get_unrestricted_update_events(), state);
      sys.CalcDiscreteVariableUpdates(context,
          all_events.get_discrete_update_events(), discrete_state);
      sys.Publish(context, all_events.get_publish_events())

For a LeafSystem, this is equivalent to (by expanding the dispatch
mechanisms in the System API):


::

    sys.DoCalcUnrestrictedUpdate(context, {event4}, state);
      sys.DoCalcDiscreteVariableUpdates(context, {event2}, discrete_state);
      sys.DoPublish(context, {event1, event3})

Template parameter ``EventType``:
    a concrete derived type of Event (e.g., PublishEvent).)""";
        // Symbol: drake::systems::EventCollection::AddToEnd
        struct /* AddToEnd */ {
          // Source: drake/systems/framework/event_collection.h:118
          const char* doc =
R"""(Adds all of ``other`'s events to the end of `this``.)""";
        } AddToEnd;
        // Symbol: drake::systems::EventCollection::Clear
        struct /* Clear */ {
          // Source: drake/systems/framework/event_collection.h:125
          const char* doc =
R"""(Removes all events from this collection.)""";
        } Clear;
        // Symbol: drake::systems::EventCollection::DoAddToEnd
        struct /* DoAddToEnd */ {
          // Source: drake/systems/framework/event_collection.h:145
          const char* doc = R"""()""";
        } DoAddToEnd;
        // Symbol: drake::systems::EventCollection::EventCollection<EventType>
        struct /* ctor */ {
          // Source: drake/systems/framework/event_collection.h:143
          const char* doc =
R"""(Constructor only accessible by derived class.)""";
        } ctor;
        // Symbol: drake::systems::EventCollection::HasEvents
        struct /* HasEvents */ {
          // Source: drake/systems/framework/event_collection.h:130
          const char* doc =
R"""(Returns ``False`` if and only if this collection contains no events.)""";
        } HasEvents;
        // Symbol: drake::systems::EventCollection::SetFrom
        struct /* SetFrom */ {
          // Source: drake/systems/framework/event_collection.h:110
          const char* doc =
R"""(Clears all the events maintained by ``this`` then adds all of the
events in ``other`` to this.)""";
        } SetFrom;
        // Symbol: drake::systems::EventCollection::add_event
        struct /* add_event */ {
          // Source: drake/systems/framework/event_collection.h:137
          const char* doc =
R"""(Adds an event to this collection, or throws if the concrete collection
does not permit adding new events. Derived classes must implement this
method to add the specified event to the homogeneous event collection.)""";
        } add_event;
      } EventCollection;
      // Symbol: drake::systems::EventData
      struct /* EventData */ {
        // Source: drake/systems/framework/event.h:234
        const char* doc =
R"""(Base class for storing trigger-specific data to be passed to event
handlers.)""";
        // Symbol: drake::systems::EventData::Clone
        struct /* Clone */ {
          // Source: drake/systems/framework/event.h:239
          const char* doc = R"""()""";
        } Clone;
        // Symbol: drake::systems::EventData::DoClone
        struct /* DoClone */ {
          // Source: drake/systems/framework/event.h:244
          const char* doc = R"""()""";
        } DoClone;
        // Symbol: drake::systems::EventData::EventData
        struct /* ctor */ {
          // Source: drake/systems/framework/event.h:236
          const char* doc = R"""()""";
        } ctor;
      } EventData;
      // Symbol: drake::systems::EventStatus
      struct /* EventStatus */ {
        // Source: drake/systems/framework/event_status.h:30
        const char* doc =
R"""(Holds the return status from execution of an event handler function,
or the effective status after a series of handler executions due to
dispatching of simultaneous events. Drake API users will typically use
only the four factory methods below to return status, and optionally a
human-readable message, from their event handlers.)""";
        // Symbol: drake::systems::EventStatus::DidNothing
        struct /* DidNothing */ {
          // Source: drake/systems/framework/event_status.h:48
          const char* doc =
R"""(Returns "did nothing" status, with no message.)""";
        } DidNothing;
        // Symbol: drake::systems::EventStatus::EventStatus
        struct /* ctor */ {
          // Source: drake/systems/framework/event_status.h:32
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::systems::EventStatus::Failed
        struct /* Failed */ {
          // Source: drake/systems/framework/event_status.h:60
          const char* doc =
R"""(Returns "failed" status, with a message explaining why.)""";
        } Failed;
        // Symbol: drake::systems::EventStatus::KeepMoreSevere
        struct /* KeepMoreSevere */ {
          // Source: drake/systems/framework/event_status.h:82
          const char* doc =
R"""((Advanced) Replaces the contents of ``this`` with the more-severe
status if ``candidate`` is a more severe status than ``this`` one.
Does nothing if ``candidate`` severity is less than or equal to
``this`` severity. This method is for use in event dispatchers for
accumulating status returns from a series of event handlers for a set
of simultaneous events.)""";
        } KeepMoreSevere;
        // Symbol: drake::systems::EventStatus::ReachedTermination
        struct /* ReachedTermination */ {
          // Source: drake/systems/framework/event_status.h:54
          const char* doc =
R"""(Returns "reached termination" status, with a message explaining why.)""";
        } ReachedTermination;
        // Symbol: drake::systems::EventStatus::Severity
        struct /* Severity */ {
          // Source: drake/systems/framework/event_status.h:36
          const char* doc =
R"""(The numerical values are ordered, with did_nothing < success <
terminate < fatal.)""";
          // Symbol: drake::systems::EventStatus::Severity::kDidNothing
          struct /* kDidNothing */ {
            // Source: drake/systems/framework/event_status.h:38
            const char* doc =
R"""(Successful, but nothing happened; no state update needed.)""";
          } kDidNothing;
          // Symbol: drake::systems::EventStatus::Severity::kFailed
          struct /* kFailed */ {
            // Source: drake/systems/framework/event_status.h:44
            const char* doc =
R"""(Handler was unable to perform its job (has message).)""";
          } kFailed;
          // Symbol: drake::systems::EventStatus::Severity::kReachedTermination
          struct /* kReachedTermination */ {
            // Source: drake/systems/framework/event_status.h:42
            const char* doc =
R"""(Handler succeeded but detected a termination condition (has message).)""";
          } kReachedTermination;
          // Symbol: drake::systems::EventStatus::Severity::kSucceeded
          struct /* kSucceeded */ {
            // Source: drake/systems/framework/event_status.h:40
            const char* doc =
R"""(Handler executed successfully; state may have been updated.)""";
          } kSucceeded;
        } Severity;
        // Symbol: drake::systems::EventStatus::Succeeded
        struct /* Succeeded */ {
          // Source: drake/systems/framework/event_status.h:51
          const char* doc =
R"""(Returns "succeeded" status, with no message.)""";
        } Succeeded;
        // Symbol: drake::systems::EventStatus::message
        struct /* message */ {
          // Source: drake/systems/framework/event_status.h:75
          const char* doc =
R"""(Returns the optionally-provided human-readable message supplied by the
event handler that produced the current status. Returns an empty
string if no message was provided.)""";
        } message;
        // Symbol: drake::systems::EventStatus::severity
        struct /* severity */ {
          // Source: drake/systems/framework/event_status.h:65
          const char* doc =
R"""(Returns the severity of the current status.)""";
        } severity;
        // Symbol: drake::systems::EventStatus::system
        struct /* system */ {
          // Source: drake/systems/framework/event_status.h:70
          const char* doc =
R"""(Returns the optionally-provided subsystem that generated a status
return that can include a message (reached termination or failed).
Returns nullptr if no subsystem was provided.)""";
        } system;
      } EventStatus;
      // Symbol: drake::systems::ExplicitEulerIntegrator
      struct /* ExplicitEulerIntegrator */ {
        // Source: drake/systems/analysis/explicit_euler_integrator.h:23
        const char* doc =
R"""(A first-order, explicit Euler integrator. State is updated in the
following manner:


::

    x(t+h) = x(t) + dx/dt * h)""";
        // Symbol: drake::systems::ExplicitEulerIntegrator::ExplicitEulerIntegrator<T>
        struct /* ctor */ {
          // Source: drake/systems/analysis/explicit_euler_integrator.h:40
          const char* doc =
R"""(Constructs a fixed-step integrator for a given system using the given
context for initial conditions.

Parameter ``system``:
    A reference to the system to be simulated

Parameter ``max_step_size``:
    The maximum (fixed) step size; the integrator will not take larger
    step sizes than this.

Parameter ``context``:
    Pointer to the context (nullptr is ok, but the caller must set a
    non-null context before Initialize()-ing the integrator).

See also:
    Initialize())""";
        } ctor;
        // Symbol: drake::systems::ExplicitEulerIntegrator::get_error_estimate_order
        struct /* get_error_estimate_order */ {
          // Source: drake/systems/analysis/explicit_euler_integrator.h:52
          const char* doc =
R"""(Integrator does not provide an error estimate.)""";
        } get_error_estimate_order;
        // Symbol: drake::systems::ExplicitEulerIntegrator::supports_error_estimation
        struct /* supports_error_estimation */ {
          // Source: drake/systems/analysis/explicit_euler_integrator.h:49
          const char* doc =
R"""(Explicit Euler integrator does not support error estimation.)""";
        } supports_error_estimation;
      } ExplicitEulerIntegrator;
      // Symbol: drake::systems::ExternalSystemConstraint
      struct /* ExternalSystemConstraint */ {
        // Source: drake/systems/framework/system_constraint.h:275
        const char* doc =
R"""(An "external" constraint on a System. This class is intended for use
by applications that are examining a System by adding additional
constraints based on their particular situation (e.g., that a velocity
state element has an upper bound); it is not intended for declaring
intrinsic constraints that some particular System subclass might
always impose on itself (e.g., that a mass parameter is non-negative).)""";
        // Symbol: drake::systems::ExternalSystemConstraint::ExternalSystemConstraint
        struct /* ctor */ {
          // Source: drake/systems/framework/system_constraint.h:280
          const char* doc_0args = R"""(Creates an empty constraint.)""";
          // Source: drake/systems/framework/system_constraint.h:285
          const char* doc_5args =
R"""(Creates a constraint with the given arguments. The calc functions
(other than calc_double) may be omitted.)""";
        } ctor;
        // Symbol: drake::systems::ExternalSystemConstraint::MakeForAllScalars
        struct /* MakeForAllScalars */ {
          // Source: drake/systems/framework/system_constraint.h:300
          const char* doc =
R"""(Creates a constraint based on generic lambda. This constraint will
supply Calc functions for Drake's default scalar types.)""";
        } MakeForAllScalars;
        // Symbol: drake::systems::ExternalSystemConstraint::MakeForNonsymbolicScalars
        struct /* MakeForNonsymbolicScalars */ {
          // Source: drake/systems/framework/system_constraint.h:313
          const char* doc =
R"""(Creates a constraint based on generic lambda. This constraint will
supply Calc functions for Drake's non-symbolic default scalar types.)""";
        } MakeForNonsymbolicScalars;
        // Symbol: drake::systems::ExternalSystemConstraint::bounds
        struct /* bounds */ {
          // Source: drake/systems/framework/system_constraint.h:328
          const char* doc =
R"""(Returns the bounds of this constraint (and whether it is an equality
or inequality constraint.))""";
        } bounds;
        // Symbol: drake::systems::ExternalSystemConstraint::description
        struct /* description */ {
          // Source: drake/systems/framework/system_constraint.h:324
          const char* doc =
R"""(Returns a human-readable description of this constraint.)""";
        } description;
        // Symbol: drake::systems::ExternalSystemConstraint::get_calc
        struct /* get_calc */ {
          // Source: drake/systems/framework/system_constraint.h:336
          const char* doc =
R"""(Retrieves the evaluation function ``value = f(system, context)`` for
this constraint. The result may be a default-constructed (missing)
function, if the scalar type T is not supported by this constraint
instance.

Template parameter ``T``:
    denotes the scalar type of the System<T>.)""";
        } get_calc;
      } ExternalSystemConstraint;
      // Symbol: drake::systems::ExtractSimulatorConfig
      struct /* ExtractSimulatorConfig */ {
        // Source: drake/systems/analysis/simulator_config_functions.h:65
        const char* doc =
R"""(Reports the simulator's current configuration, including the
configuration of the integrator.

Parameter ``simulator``:
    The Simulator to extract the configuration from.)""";
      } ExtractSimulatorConfig;
      // Symbol: drake::systems::FirstOrderLowPassFilter
      struct /* FirstOrderLowPassFilter */ {
        // Source: drake/systems/primitives/first_order_low_pass_filter.h:34
        const char* doc =
R"""(An element-wise first order low pass filter system that filters the
i-th input uᵢ into the i-th output zᵢ. This system has one continuous
state per filtered input signal. Therefore, the i-th state of the
system zᵢ evolves according to:


::

    żᵢ = -1/τᵢ (zᵢ - uᵢ)

where τᵢ is the time constant of the i-th filter. The i-th output of
the system is given by:


::

    yᵢ = zᵢ

The transfer function for the i-th filter corresponds to:


::

    H(s) = 1 / (1 + τᵢ s)

The Bode plot for the i-th filter exhibits a cutoff frequency (angular
frequency) at 1/τᵢ and a gain of one. For frequencies higher than the
cutoff frequency, the Bode plot approaches a 20 dB per decade negative
slope. The Bode plot in phase exhibits a -90 degrees shift (lag) for
frequencies much larger than the cutoff frequency and a zero shift for
low frequencies.)""";
        // Symbol: drake::systems::FirstOrderLowPassFilter::FirstOrderLowPassFilter<T>
        struct /* ctor */ {
          // Source: drake/systems/primitives/first_order_low_pass_filter.h:44
          const char* doc_2args =
R"""(Constructs a FirstOrderLowPassFilter system that filters all input
signals with the same time constant, i.e. τᵢ = τ, ∀ i.

Parameter ``time_constant``:
    the time constant τ of the filter. It must be a positive number.

Parameter ``size``:
    number of elements in the signal to be processed.)""";
          // Source: drake/systems/primitives/first_order_low_pass_filter.h:52
          const char* doc_1args =
R"""(Constructs a FirstOrderLowPassFilter so that the i-th component of the
input signal vector is low pass filtered with a time constant given in
the i-th component τᵢ of the input ``time_constants`` vector.

Parameter ``time_constants``:
    Vector of time constants. Each entry in this vector must be
    positive.)""";
          // Source: drake/systems/primitives/first_order_low_pass_filter.h:56
          const char* doc_copyconvert =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";
        } ctor;
        // Symbol: drake::systems::FirstOrderLowPassFilter::get_time_constant
        struct /* get_time_constant */ {
          // Source: drake/systems/primitives/first_order_low_pass_filter.h:62
          const char* doc =
R"""(Returns the time constant of the filter for filters that have the same
time constant τ for all signals. This method aborts if called on
filters if with different time constants per input signal.

See also:
    get_time_constants_vector().)""";
        } get_time_constant;
        // Symbol: drake::systems::FirstOrderLowPassFilter::get_time_constants_vector
        struct /* get_time_constants_vector */ {
          // Source: drake/systems/primitives/first_order_low_pass_filter.h:65
          const char* doc =
R"""(Returns the vector of time constants for ``this`` filter.)""";
        } get_time_constants_vector;
        // Symbol: drake::systems::FirstOrderLowPassFilter::set_initial_output_value
        struct /* set_initial_output_value */ {
          // Source: drake/systems/primitives/first_order_low_pass_filter.h:70
          const char* doc =
R"""(Sets the initial conditions on the output value of the filtered
signal.

Parameter ``context``:
    The current system context.

Parameter ``z0``:
    The vector on initial conditions on the output value.)""";
        } set_initial_output_value;
      } FirstOrderLowPassFilter;
      // Symbol: drake::systems::FirstOrderTaylorApproximation
      struct /* FirstOrderTaylorApproximation */ {
        // Source: drake/systems/primitives/linear_system.h:233
        const char* doc =
R"""(A first-order Taylor series approximation to a ``system`` in the
neighborhood of an arbitrary point. When Taylor-expanding a system at
a non-equilibrium point, it may be represented either of the form:

.. math:: \dot{x} - \dot{x}_0 = A (x - x_0) + B (u - u_0),

for continuous time, or

.. math:: x[n+1] - x_0[n+1] = A (x[n] - x_0[n]) + B (u[n] - u_0[n]),

for discrete time. As above, we denote :math:`x_0, u_0` to be the
nominal state and input at the provided ``context``. The system
description is affine when the terms :math:`\dot{x}_0 - A x_0 - B u_0`
and :math:`x_0[n+1] - A x_0[n] - B u_0[n]` are nonzero.

More precisely, let x be a state and u be an input. This function
returns an AffineSystem of the form:

.. math:: \dot{x} = A x + B u + f_0,

(CT)

.. math:: x[n+1] = A x[n] + B u[n] + f_0,

(DT) where :math:`f_0 = \dot{x}_0 - A x_0 - B u_0` (CT) and :math:`f_0
= x_0[n+1] - A x[n] - B u[n]` (DT).

This method currently supports approximating around at most a single
vector input port and at most a single vector output port. For systems
with more ports, use ``input_port_index`` and ``output_port_index`` to
select the input for the newly constructed system. Any additional
input ports will be treated as constants (fixed at the value specified
in ``context)``.

Parameter ``system``:
    The system or subsystem to linearize.

Parameter ``context``:
    Defines the nominal operating point about which the system should
    be linearized.

Parameter ``input_port_index``:
    A valid input port index for ``system`` or InputPortSelection.
    $*Default:* kUseFirstInputIfItExists.

Parameter ``output_port_index``:
    A valid output port index for ``system`` or OutputPortSelection.
    $*Default:* kUseFirstOutputIfItExists.

Returns:
    An AffineSystem at this linearization point.

Raises:
    if any abstract inputs are connected, if any vector-valued inputs
    are unconnected, if the system is not (only) continuous or not
    (only) discrete time with a single periodic update.

Note:
    x, u and y are in the same coordinate system as the original
    ``system``, since the terms involving :math:`x_0, u_0` reside in
    :math:`f_0`.

Note:
    This method does *not* (yet) set the initial conditions (default
    nor random) of the AffineSystem based on ``system``.)""";
      } FirstOrderTaylorApproximation;
      // Symbol: drake::systems::FixedInputPortValue
      struct /* FixedInputPortValue */ {
        // Source: drake/systems/framework/fixed_input_port_value.h:35
        const char* doc =
R"""(A FixedInputPortValue encapsulates a vector or abstract value for use
as an internal value source for one of a System's input ports. The
semantics are identical to a Parameter. We assign a DependencyTracker
to this object and subscribe the InputPort to it when that port is
fixed. Any modification to the value here issues a notification to its
dependent, and increments a serial number kept here.)""";
        // Symbol: drake::systems::FixedInputPortValue::FixedInputPortValue
        struct /* ctor */ {
          // Source: drake/systems/framework/fixed_input_port_value.h:39
          const char* doc_move =
R"""(@name Does not allow move or assignment; copy is private.)""";
        } ctor;
        // Symbol: drake::systems::FixedInputPortValue::GetMutableData
        struct /* GetMutableData */ {
          // Source: drake/systems/framework/fixed_input_port_value.h:71
          const char* doc =
R"""(Returns a pointer to the data inside this FixedInputPortValue, and
notifies the dependent input port that the value has changed.

To ensure invalidation notifications are delivered, callers should
call this method every time they wish to update the stored value. In
particular, callers MUST NOT write through the returned pointer if
there is any possibility this FixedInputPortValue has been accessed
since the last time this method was called.)""";
        } GetMutableData;
        // Symbol: drake::systems::FixedInputPortValue::GetMutableVectorData
        struct /* GetMutableVectorData */ {
          // Source: drake/systems/framework/fixed_input_port_value.h:87
          const char* doc =
R"""(Returns a pointer to the data inside this FixedInputPortValue, and
notifies the dependent input port that the value has changed,
invalidating downstream computations.

Raises:
    RuntimeError if the data is not vector data.

To ensure invalidation notifications are delivered, callers should
call this method every time they wish to update the stored value. In
particular, callers MUST NOT write through the returned pointer if
there is any possibility this FixedInputPortValue has been accessed
since the last time this method was called.

Template parameter ``T``:
    Scalar type of the input port's vector value. Must match the type
    associated with this port.)""";
        } GetMutableVectorData;
        // Symbol: drake::systems::FixedInputPortValue::get_owning_context
        struct /* get_owning_context */ {
          // Source: drake/systems/framework/fixed_input_port_value.h:102
          const char* doc =
R"""(Returns a const reference to the context that owns this object.)""";
        } get_owning_context;
        // Symbol: drake::systems::FixedInputPortValue::get_value
        struct /* get_value */ {
          // Source: drake/systems/framework/fixed_input_port_value.h:50
          const char* doc =
R"""(Returns a reference to the contained abstract value.)""";
        } get_value;
        // Symbol: drake::systems::FixedInputPortValue::get_vector_value
        struct /* get_vector_value */ {
          // Source: drake/systems/framework/fixed_input_port_value.h:58
          const char* doc =
R"""(Returns a reference to the contained ``BasicVector<T>`` or throws an
exception if this doesn't contain an object of that type.)""";
        } get_vector_value;
        // Symbol: drake::systems::FixedInputPortValue::serial_number
        struct /* serial_number */ {
          // Source: drake/systems/framework/fixed_input_port_value.h:93
          const char* doc =
R"""(Returns the serial number of the contained value. This counts up every
time the contained value changes, or when mutable access is granted.)""";
        } serial_number;
        // Symbol: drake::systems::FixedInputPortValue::ticket
        struct /* ticket */ {
          // Source: drake/systems/framework/fixed_input_port_value.h:96
          const char* doc =
R"""(Returns the ticket used to find the associated DependencyTracker.)""";
        } ticket;
      } FixedInputPortValue;
      // Symbol: drake::systems::Gain
      struct /* Gain */ {
        // Source: drake/systems/primitives/gain.h:18
        const char* doc =
R"""(An element-wise gain block with input ``u`` and output ``y = k * u``
with ``k`` a constant vector. The input to this system directly feeds
through to its output.)""";
        // Symbol: drake::systems::Gain::Gain<T>
        struct /* ctor */ {
          // Source: drake/systems/primitives/gain.h:27
          const char* doc_2args =
R"""(Constructs a Gain system where the same gain is applied to every input
value.

Parameter ``k``:
    the gain constant so that ``y = k * u``.

Parameter ``size``:
    number of elements in the signal to be processed.)""";
          // Source: drake/systems/primitives/gain.h:34
          const char* doc_1args =
R"""(Constructs a Gain system where different gains can be applied to each
input value.

Parameter ``k``:
    the gain vector constants so that ``y_i = k_i * u_i`` where
    subscript ``i`` indicates the i-th element of the vector.)""";
          // Source: drake/systems/primitives/gain.h:38
          const char* doc_copyconvert =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";
        } ctor;
        // Symbol: drake::systems::Gain::get_gain
        struct /* get_gain */ {
          // Source: drake/systems/primitives/gain.h:44
          const char* doc =
R"""(Returns the gain constant. This method should only be called if the
gain can be represented as a scalar value, i.e., every element in the
gain vector is the same. It will throw an exception if the gain cannot
be represented as a single scalar value.)""";
        } get_gain;
        // Symbol: drake::systems::Gain::get_gain_vector
        struct /* get_gain_vector */ {
          // Source: drake/systems/primitives/gain.h:47
          const char* doc = R"""(Returns the gain vector constant.)""";
        } get_gain_vector;
      } Gain;
      // Symbol: drake::systems::GenerateHtml
      struct /* GenerateHtml */ {
        // Source: drake/systems/framework/system_html.h:20
        const char* doc =
R"""(Generates an html string to "render" the ``system``, with collapsible
diagrams. Use ``initial_depth`` to set the depth to which the
subdiagrams are expanded by default (0 for all collapsed, +∞ for all
expanded).

Warning:
    The implementation of GenerateHtml has been temporarily removed
    from Drake due to licensing restrictions. This function will
    return valid HTML, but will not produce any useful rendering.)""";
      } GenerateHtml;
      // Symbol: drake::systems::GetIntegrationSchemes
      struct /* GetIntegrationSchemes */ {
        // Source: drake/systems/analysis/simulator_config_functions.h:44
        const char* doc =
R"""(Returns the allowed string values for the ``scheme`` parameter in
ResetIntegratorFromFlags() and SimulatorConfig::integration_scheme.)""";
      } GetIntegrationSchemes;
      // Symbol: drake::systems::HermitianDenseOutput
      struct /* HermitianDenseOutput */ {
        // Source: drake/systems/analysis/hermitian_dense_output.h:96
        const char* doc =
R"""(A StepwiseDenseOutput class implementation using Hermitian
interpolators, and therefore a *continuous extension* of the solution
𝐱(t) (see [Engquist, 2105]). This concept can be recast as a type of
dense output that is continuous.

Updates take the form of integration steps, for which state 𝐱 and
state time derivative d𝐱/dt are known at least at both ends of the
step. Hermite cubic polynomials are then constructed upon
StepwiseDenseOutput::Consolidate "consolidation", yielding a C1
extension of the solution 𝐱(t).

Hermitian continuous extensions exhibit the same truncation error as
that of the integration scheme being used for up to 3rd order schemes
(see [Hairer, 1993]).

From a performance standpoint, memory footprint and evaluation
overhead (i.e. the computational cost of an evaluation) increase
linearly and logarithmically with the amount of steps taken,
respectively.

- [Engquist, 2105] B. Engquist. Encyclopedia of Applied and Computational
                   Mathematics, p. 339, Springer, 2015.
- [Hairer, 1993] E. Hairer, S. Nørsett and G. Wanner. Solving Ordinary
                 Differential Equations I (Nonstiff Problems), p.190,
                 Springer, 1993.)""";
        // Symbol: drake::systems::HermitianDenseOutput::Consolidate
        struct /* Consolidate */ {
          // Source: drake/systems/analysis/hermitian_dense_output.h:295
          const char* doc = R"""()""";
        } Consolidate;
        // Symbol: drake::systems::HermitianDenseOutput::DoEvaluate
        struct /* DoEvaluate */ {
          // Source: drake/systems/analysis/hermitian_dense_output.h:313
          const char* doc = R"""()""";
        } DoEvaluate;
        // Symbol: drake::systems::HermitianDenseOutput::DoEvaluateNth
        struct /* DoEvaluateNth */ {
          // Source: drake/systems/analysis/hermitian_dense_output.h:319
          const char* doc = R"""()""";
        } DoEvaluateNth;
        // Symbol: drake::systems::HermitianDenseOutput::HermitianDenseOutput<T>
        struct /* ctor */ {
          // Source: drake/systems/analysis/hermitian_dense_output.h:244
          const char* doc =
R"""(Initialize the DenseOutput with an existing trajectory.)""";
        } ctor;
        // Symbol: drake::systems::HermitianDenseOutput::IntegrationStep
        struct /* IntegrationStep */ {
          // Source: drake/systems/analysis/hermitian_dense_output.h:113
          const char* doc =
R"""(An integration step representation class, holding just enough for
Hermitian interpolation: three (3) related sets containing step times
{t₀, ..., tᵢ₋₁, tᵢ} where tᵢ ∈ ℝ, step states {𝐱₀, ..., 𝐱ᵢ₋₁, 𝐱ᵢ}
where 𝐱ᵢ ∈ ℝⁿ, and state derivatives {d𝐱/dt₀, ..., d𝐱/dtᵢ₋₁, d𝐱/dtᵢ}
where d𝐱/dtᵢ ∈ ℝⁿ.

This step definition allows for intermediate time, state and state
derivative triplets (e.g. the integrator internal stages) to improve
interpolation.

Note:
    The use of column matrices instead of plain vectors helps reduce
    HermitianDenseOutput construction overhead, as this type of dense
    output leverages a PiecewisePolynomial instance that takes
    matrices.)""";
          // Symbol: drake::systems::HermitianDenseOutput::IntegrationStep::Extend
          struct /* Extend */ {
            // Source: drake/systems/analysis/hermitian_dense_output.h:161
            const char* doc =
R"""(Extends the step forward in time from column matrices.

Provided ``time``, ``state`` and ``state_derivative`` are appended to
the current step, effectively increasing its time length.

Parameter ``time``:
    Time tᵢ to extend the step to.

Parameter ``state``:
    State vector 𝐱ᵢ at ``time`` tᵢ as a column matrix.

Parameter ``state_derivative``:
    State derivative vector d𝐱/dtᵢ at ``time`` tᵢ as a column matrix.

Raises:
    RuntimeError if given ``state`` 𝐱ᵢ is not a column matrix.

if given ``state_derivative`` d𝐱/dtᵢ is not a column matrix.

if given ``time`` tᵢ is not greater than the previous time tᵢ₋₁ in the
step.

if given ``state`` 𝐱ᵢ dimension does not match the dimension of the
previous state 𝐱ᵢ₋₁.

if given ``state`` 𝐱ᵢ and ``state_derivative`` d𝐱/dtᵢ do not match
each other's dimension.)""";
          } Extend;
          // Symbol: drake::systems::HermitianDenseOutput::IntegrationStep::IntegrationStep
          struct /* ctor */ {
            // Source: drake/systems/analysis/hermitian_dense_output.h:117
            const char* doc_0args = R"""(Constructs an empty step.)""";
            // Source: drake/systems/analysis/hermitian_dense_output.h:134
            const char* doc_3args =
R"""(Constructs a zero length step (i.e. a step containing a single time,
state and state derivative triplet) from column matrices.

Parameter ``initial_time``:
    Initial time t₀ where the step starts.

Parameter ``initial_state``:
    Initial state vector 𝐱₀ at ``initial_time`` as a column matrix.

Parameter ``initial_state_derivative``:
    Initial state derivative vector d𝐱/dt₀ at ``initial_time`` as a
    column matrix.

Raises:
    RuntimeError if given ``initial_state`` 𝐱₀ is not a column matrix.

if given ``initial_state_derivative`` d𝐱/t₀ is not a column matrix.

if given ``initial_state`` 𝐱₀ and ``initial_state_derivative`` d𝐱/dt₀
do not match each other's dimension.)""";
          } ctor;
          // Symbol: drake::systems::HermitianDenseOutput::IntegrationStep::end_time
          struct /* end_time */ {
            // Source: drake/systems/analysis/hermitian_dense_output.h:178
            const char* doc =
R"""(Returns step end time tᵢ (that of the first time, state and state
derivative triplet), which may coincide with its start time t₀ (that
of the last time, state and state derivative triplet) if the step has
zero length (that is, it contains a single triplet).)""";
          } end_time;
          // Symbol: drake::systems::HermitianDenseOutput::IntegrationStep::get_state_derivatives
          struct /* get_state_derivatives */ {
            // Source: drake/systems/analysis/hermitian_dense_output.h:193
            const char* doc =
R"""(Gets step state derivatives {d𝐱/dt₀, ..., d𝐱/dtᵢ₋₁, d𝐱/dtᵢ} as column
matrices.)""";
          } get_state_derivatives;
          // Symbol: drake::systems::HermitianDenseOutput::IntegrationStep::get_states
          struct /* get_states */ {
            // Source: drake/systems/analysis/hermitian_dense_output.h:189
            const char* doc =
R"""(Returns step states {𝐱₀, ..., 𝐱ᵢ₋₁, 𝐱ᵢ} as column matrices.)""";
          } get_states;
          // Symbol: drake::systems::HermitianDenseOutput::IntegrationStep::get_times
          struct /* get_times */ {
            // Source: drake/systems/analysis/hermitian_dense_output.h:186
            const char* doc = R"""(Returns step times {t₀, ..., tᵢ₋₁, tᵢ}.)""";
          } get_times;
          // Symbol: drake::systems::HermitianDenseOutput::IntegrationStep::size
          struct /* size */ {
            // Source: drake/systems/analysis/hermitian_dense_output.h:181
            const char* doc =
R"""(Returns the step state 𝐱 size (i.e. dimension).)""";
          } size;
          // Symbol: drake::systems::HermitianDenseOutput::IntegrationStep::start_time
          struct /* start_time */ {
            // Source: drake/systems/analysis/hermitian_dense_output.h:172
            const char* doc =
R"""(Returns step start time t₀ (that of the first time, state and state
derivative triplet), which may coincide with its end time tᵢ (that of
the last time, state and state derivative triplet) if the step has
zero length (that is, it contains a single triplet).)""";
          } start_time;
        } IntegrationStep;
        // Symbol: drake::systems::HermitianDenseOutput::Rollback
        struct /* Rollback */ {
          // Source: drake/systems/analysis/hermitian_dense_output.h:288
          const char* doc = R"""()""";
        } Rollback;
        // Symbol: drake::systems::HermitianDenseOutput::Update
        struct /* Update */ {
          // Source: drake/systems/analysis/hermitian_dense_output.h:283
          const char* doc =
R"""(Update output with the given ``step``.

Provided ``step`` is queued for later consolidation. Note that the
time the ``step`` extends cannot be readily evaluated (see
StepwiseDenseOutput class documentation).

Parameter ``step``:
    Integration step to update this output with.

Raises:
    RuntimeError if given ``step`` has zero length.

if given ``step`` does not ensure C1 continuity at the end of this
dense output.

if given ``step`` dimensions does not match this dense output
dimensions.)""";
        } Update;
        // Symbol: drake::systems::HermitianDenseOutput::do_end_time
        struct /* do_end_time */ {
          // Source: drake/systems/analysis/hermitian_dense_output.h:332
          const char* doc = R"""()""";
        } do_end_time;
        // Symbol: drake::systems::HermitianDenseOutput::do_is_empty
        struct /* do_is_empty */ {
          // Source: drake/systems/analysis/hermitian_dense_output.h:324
          const char* doc = R"""()""";
        } do_is_empty;
        // Symbol: drake::systems::HermitianDenseOutput::do_size
        struct /* do_size */ {
          // Source: drake/systems/analysis/hermitian_dense_output.h:328
          const char* doc = R"""()""";
        } do_size;
        // Symbol: drake::systems::HermitianDenseOutput::do_start_time
        struct /* do_start_time */ {
          // Source: drake/systems/analysis/hermitian_dense_output.h:334
          const char* doc = R"""()""";
        } do_start_time;
      } HermitianDenseOutput;
      // Symbol: drake::systems::ImplicitEulerIntegrator
      struct /* ImplicitEulerIntegrator */ {
        // Source: drake/systems/analysis/implicit_euler_integrator.h:114
        const char* doc =
R"""(A first-order, fully implicit integrator with second order error
estimation.

This integrator uses the following update rule:


::

    x(t+h) = x(t) + h f(t+h,x(t+h))

where x are the state variables, h is the integration step size, and
f() returns the time derivatives of the state variables. Contrast this
update rule to that of an explicit first-order integrator:


::

    x(t+h) = x(t) + h f(t, x(t))

Thus implicit first-order integration must solve a nonlinear system of
equations to determine *both* the state at t+h and the time
derivatives of that state at that time. Cast as a nonlinear system of
equations, we seek the solution to:


::

    x(t+h) − x(t) − h f(t+h,x(t+h)) = 0

given unknowns x(t+h).

This "implicit Euler" method is known to be L-Stable, meaning both
that applying it at a fixed integration step to the "test" equation
``y(t) = eᵏᵗ`` yields zero (for ``k < 0`` and ``t → ∞``) *and* that it
is also A-Stable. A-Stability, in turn, means that the method can
integrate the linear constant coefficient system ``dx/dt = Ax`` at any
step size without the solution becoming unstable (growing without
bound). The practical effect of L-Stability is that the integrator
tends to be stable for any given step size on an arbitrary system of
ordinary differential equations. See [Lambert, 1991], Ch. 6 for an
approachable discussion on stiff differential equations and L- and
A-Stability.

This implementation uses Newton-Raphson (NR) and relies upon the
obvious convergence to a solution for ``g = 0`` where ``g(x(t+h)) ≡
x(t+h) − x(t) − h f(t+h,x(t+h))`` as ``h`` becomes sufficiently small.
General implementational details for the Newton method were gleaned
from Section IV.8 in [Hairer, 1996].

**** Error Estimation

In this integrator, we simultaneously take a large step at the
requested step size of h as well as two half-sized steps each with
step size ``h/2``. The result from two half-sized steps is propagated
as the solution, while the difference between the two results is used
as the error estimate for the propagated solution. This error estimate
is accurate to the second order.

To be precise, let ``x̅ⁿ⁺¹`` be the computed solution from a large
step, ``x̃ⁿ⁺¹`` be the computed solution from two small steps, and
``xⁿ⁺¹`` be the true solution. Since the integrator propagates
``x̃ⁿ⁺¹`` as its solution, we denote the true error vector as ``ε =
x̃ⁿ⁺¹ − xⁿ⁺¹``. ImplicitEulerIntegrator uses ``ε* = x̅ⁿ⁺¹ − x̃ⁿ⁺¹``,
the difference between the two solutions, as the second-order error
estimate, because for a smooth system, ``‖ε*‖ = O(h²)``, and ``‖ε −
ε*‖ = O(h³)``. See the notes in get_error_estimate_order() for a
detailed derivation of the error estimate's truncation error.

In this implementation, ImplicitEulerIntegrator attempts the large
full-sized step before attempting the two small half-sized steps,
because the large step is more likely to fail to converge, and if it
is performed first, convergence failures are detected early, avoiding
the unnecessary effort of computing potentially-successful small
steps.

Optionally, ImplicitEulerIntegrator can instead use the implicit
trapezoid method for error estimation. However, in our testing the
step doubling method substantially outperforms the implicit trapezoid
method.

- [Hairer, 1996]   E. Hairer and G. Wanner. Solving Ordinary Differential
                   Equations II (Stiff and Differential-Algebraic Problems).
                   Springer, 1996, Section IV.8, p. 118–130.
- [Lambert, 1991]  J. D. Lambert. Numerical Methods for Ordinary Differential
                   Equations. John Wiley & Sons, 1991.

Note:
    In the statistics reported by IntegratorBase, all statistics that
    deal with the number of steps or the step sizes will track the
    large full-sized steps. This is because the large full-sized ``h``
    is the smallest irrevocable time-increment advanced by this
    integrator: if, for example, the second small half-sized step
    fails, this integrator revokes to the state before the first small
    step. This behavior is similar to other integrators with
    multi-stage evaluation: the step-counting statistics treat a
    "step" as the combination of all the stages.

Note:
    Furthermore, because the small half-sized steps are propagated as
    the solution, the large full-sized step is the error estimator,
    and the error estimation statistics track the effort during the
    large full-sized step. If the integrator is not in full-Newton
    mode (see ImplicitIntegrator::set_use_full_newton()), most of the
    work incurred by constructing and factorizing matrices and by
    failing Newton-Raphson iterations will be counted toward the error
    estimation statistics, because the large step is performed first.

Note:
    This integrator uses the integrator accuracy setting, even when
    run in fixed-step mode, to limit the error in the underlying
    Newton-Raphson process. See IntegratorBase::set_target_accuracy()
    for more info.

See also:
    ImplicitIntegrator class documentation for information about
    implicit integration methods in general.)""";
        // Symbol: drake::systems::ImplicitEulerIntegrator::ImplicitEulerIntegrator<T>
        struct /* ctor */ {
          // Source: drake/systems/analysis/implicit_euler_integrator.h:116
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::systems::ImplicitEulerIntegrator::get_error_estimate_order
        struct /* get_error_estimate_order */ {
          // Source: drake/systems/analysis/implicit_euler_integrator.h:277
          const char* doc =
R"""(Returns the asymptotic order of the difference between the large and
small steps (from which the error estimate is computed), which is 2.
That is, the error estimate, ``ε* = x̅ⁿ⁺¹ − x̃ⁿ⁺¹`` has the property
that ``‖ε*‖ = O(h²)``, and it deviates from the true error, ``ε``, by
``‖ε − ε*‖ = O(h³)``.

**** Derivation of the asymptotic order

This derivation is based on the same derivation for
VelocityImplicitEulerIntegrator, and so the equation numbers are from
there.

To derive the second-order error estimate, let us first define the
vector-valued function ``e(tⁿ, h, xⁿ) = x̅ⁿ⁺¹ − xⁿ⁺¹``, the local
truncation error for a single, full-sized implicit Euler integration
step, with initial conditions ``(tⁿ, xⁿ)``, and a step size of ``h``.
Furthermore, use ``ẍ`` to denote ``df/dt``, and ``∇f`` and ``∇ẍ`` to
denote the Jacobians ``df/dx`` and ``dẍ/dx`` of the ODE system ``ẋ =
f(t, x)``. Note that ``ẍ`` uses a total time derivative, i.e., ``ẍ =
∂f/∂t + ∇f f``.

Let us use ``x*`` to denote the true solution after a half-step,
``x(tⁿ+½h)``, and ``x̃*`` to denote the implicit Euler solution after
a single half-sized step. Furthermore, let us use ``xⁿ*¹`` to denote
the true solution of the system at time ``t = tⁿ+h`` if the system
were at ``x̃*`` when ``t = tⁿ+½h``. See the following diagram for an
illustration.

Legend: ───── propagation along the true system :···· propagation
using implicit Euler with a half step :---- propagation using implicit
Euler with a full step

Time tⁿ tⁿ+½h tⁿ+h

State :----------------------- x̅ⁿ⁺¹ <─── used for error estimation :
: : : :·········· x̃ⁿ⁺¹ <─── propagated result : : :········· x̃*
─────── xⁿ*¹ : xⁿ ─────── x* ─────── xⁿ⁺¹ <─── true solution

We will use superscripts to denote evaluating an expression with ``x``
at that superscript and ``t`` at the corresponding time, e.g. ``ẍⁿ``
denotes ``ẍ(tⁿ, xⁿ)``, and ``f*`` denotes ``f(tⁿ+½h, x*)``. We first
present a shortened derivation, followed by the longer, detailed
version.

We know the local truncation error for the implicit Euler method is:

e(tⁿ, h, xⁿ) = x̅ⁿ⁺¹ − xⁿ⁺¹ = ½ h²ẍⁿ + O(h³). (10)

The local truncation error ε from taking two half steps is composed of
these two terms:

e₁ = xⁿ*¹ − xⁿ⁺¹ = (1/8) h²ẍⁿ + O₁(h³), (15) e₂ = x̃ⁿ⁺¹ − xⁿ*¹ =
(1/8) h²ẍ* + O₂(h³) = (1/8) h²ẍⁿ + O₃(h³). (20)

In the long derivation, we will show that these second derivatives
differ by at most O(h³).

Taking the sum,

ε = x̃ⁿ⁺¹ − xⁿ⁺¹ = e₁ + e₂ = (1/4) h²ẍⁿ + O(h³). (21)

These two estimations allow us to obtain an estimation of the local
error from the difference between the available quantities x̅ⁿ⁺¹ and
x̃ⁿ⁺¹:

ε* = x̅ⁿ⁺¹ − x̃ⁿ⁺¹ = e(tⁿ, h, xⁿ) − ε, = (1/4) h²ẍⁿ + O(h³), (22)

and therefore our error estimate is second order.

Below we will show this derivation in detail along with the proof that
``‖ε − ε*‖ = O(h³)``:

Let us look at a single implicit Euler step. Upon Newton-Raphson
convergence, the truncation error for implicit Euler is

e(tⁿ, h, xⁿ) = ½ h²ẍⁿ⁺¹ + O(h³) = ½ h²ẍⁿ + O(h³). (10)

To see why the two are equivalent, we can Taylor expand about ``(tⁿ,
xⁿ)``,

ẍⁿ⁺¹ = ẍⁿ + h dẍ/dtⁿ + O(h²) = ẍⁿ + O(h). e(tⁿ, h, xⁿ) = ½ h²ẍⁿ⁺¹
+ O(h³) = ½ h²(ẍⁿ + O(h)) + O(h³) = ½ h²ẍⁿ + O(h³).

Moving on with our derivation, after one small half-sized implicit
Euler step, the solution ``x̃*`` is

x̃* = x* + e(tⁿ, ½h, xⁿ) = x* + (1/8) h²ẍⁿ + O(h³), x̃* − x* = (1/8)
h²ẍⁿ + O(h³). (11)

Taylor expanding about ``t = tⁿ+½h`` in this ``x = x̃*`` alternate
reality,

xⁿ*¹ = x̃* + ½h f(tⁿ+½h, x̃*) + O(h²). (12)

Similarly, Taylor expansions about ``t = tⁿ+½h`` and the true solution
``x = x*`` also give us

xⁿ⁺¹ = x* + ½h f* + O(h²), (13) f(tⁿ+½h, x̃*) = f* + (∇f*) (x̃* − x*)
+ O(‖x̃* − x*‖²) = f* + O(h²), (14) where in the last line we
substituted Eq. (11).

Eq. (12) minus Eq. (13) gives us,

xⁿ*¹ − xⁿ⁺¹ = x̃* − x* + ½h(f(tⁿ+½h, x̃*) − f*) + O(h³), = x̃* − x* +
O(h³), where we just substituted in Eq. (14). Finally, substituting in
Eq. (11),

e₁ = xⁿ*¹ − xⁿ⁺¹ = (1/8) h²ẍⁿ + O(h³). (15)

After the second small step, the solution ``x̃ⁿ⁺¹`` is

x̃ⁿ⁺¹ = xⁿ*¹ + e(tⁿ+½h, ½h, x̃*), = xⁿ*¹ + (1/8)h² ẍ(tⁿ+½h, x̃*) +
O(h³). (16)

Taking Taylor expansions about ``(tⁿ, xⁿ)``,

x* = xⁿ + ½h fⁿ + O(h²) = xⁿ + O(h). (17) x̃* − xⁿ = (x̃* − x*) + (x*
− xⁿ) = O(h), (18) where we substituted in Eqs. (11) and (17), and

ẍ(tⁿ+½h, x̃*) = ẍⁿ + ½h ∂ẍ/∂tⁿ + ∇ẍⁿ (x̃* − xⁿ) + O(h ‖x̃* − xⁿ‖)
= ẍⁿ + O(h), (19) where we substituted in Eq. (18).

Substituting Eqs. (19) and (15) into Eq. (16),

x̃ⁿ⁺¹ = xⁿ*¹ + (1/8) h²ẍⁿ + O(h³) (20) = xⁿ⁺¹ + (1/4) h²ẍⁿ + O(h³),
therefore

ε = x̃ⁿ⁺¹ − xⁿ⁺¹ = (1/4) h² ẍⁿ + O(h³). (21)

Subtracting Eq. (21) from Eq. (10),

e(tⁿ, h, xⁿ) − ε = (½ − 1/4) h²ẍⁿ + O(h³); ⇒ ε* = x̅ⁿ⁺¹ − x̃ⁿ⁺¹ =
(1/4) h²ẍⁿ + O(h³). (22)

Eq. (22) shows that our error estimate is second-order. Since the
first term on the RHS matches ``ε`` (Eq. (21)),

ε* = ε + O(h³). (23))""";
        } get_error_estimate_order;
        // Symbol: drake::systems::ImplicitEulerIntegrator::get_use_implicit_trapezoid_error_estimation
        struct /* get_use_implicit_trapezoid_error_estimation */ {
          // Source: drake/systems/analysis/implicit_euler_integrator.h:293
          const char* doc =
R"""(Returns true if the integrator will use implicit trapezoid for error
estimation; otherwise it indicates the integrator will use step
doubling for error estimation.)""";
        } get_use_implicit_trapezoid_error_estimation;
        // Symbol: drake::systems::ImplicitEulerIntegrator::set_use_implicit_trapezoid_error_estimation
        struct /* set_use_implicit_trapezoid_error_estimation */ {
          // Source: drake/systems/analysis/implicit_euler_integrator.h:284
          const char* doc =
R"""(Set this to true to use implicit trapezoid for error estimation;
otherwise this integrator will use step doubling for error estimation.
By default this integrator will use step doubling.)""";
        } set_use_implicit_trapezoid_error_estimation;
        // Symbol: drake::systems::ImplicitEulerIntegrator::supports_error_estimation
        struct /* supports_error_estimation */ {
          // Source: drake/systems/analysis/implicit_euler_integrator.h:127
          const char* doc =
R"""(Returns true, because this integrator supports error estimation.)""";
        } supports_error_estimation;
      } ImplicitEulerIntegrator;
      // Symbol: drake::systems::ImplicitIntegrator
      struct /* ImplicitIntegrator */ {
        // Source: drake/systems/analysis/implicit_integrator.h:23
        const char* doc =
R"""(An abstract class providing methods shared by implicit integrators.)""";
        // Symbol: drake::systems::ImplicitIntegrator::CalcJacobian
        struct /* CalcJacobian */ {
          // Source: drake/systems/analysis/implicit_integrator.h:415
          const char* doc = R"""()""";
        } CalcJacobian;
        // Symbol: drake::systems::ImplicitIntegrator::CheckNewtonConvergence
        struct /* CheckNewtonConvergence */ {
          // Source: drake/systems/analysis/implicit_integrator.h:367
          const char* doc =
R"""(Checks a Newton-Raphson iteration process for convergence. The logic
is based on the description on p. 121 from [Hairer, 1996] E. Hairer
and G. Wanner. Solving Ordinary Differential Equations II (Stiff and
Differential-Algebraic Problems). Springer, 1996. This function is
called after the dx is computed in an iteration, to determine if the
Newton process converged, diverged, or needs further iterations.

Parameter ``iteration``:
    the iteration index, starting at 0 for the first iteration.

Parameter ``xtplus``:
    the state x at the current iteration.

Parameter ``dx``:
    the state change dx the difference between xtplus at the current
    and the previous iteration.

Parameter ``dx_norm``:
    the weighted norm of dx

Parameter ``last_dx_norm``:
    the weighted norm of dx from the previous iteration. This
    parameter is ignored during the first iteration.

Returns:
    ``kConverged`` for convergence, ``kDiverged`` for divergence,
    otherwise ``kNotConverged`` if Newton-Raphson should simply
    continue.)""";
        } CheckNewtonConvergence;
        // Symbol: drake::systems::ImplicitIntegrator::ComputeAutoDiffJacobian
        struct /* ComputeAutoDiffJacobian */ {
          // Source: drake/systems/analysis/implicit_integrator.h:452
          const char* doc = R"""()""";
        } ComputeAutoDiffJacobian;
        // Symbol: drake::systems::ImplicitIntegrator::ComputeCentralDiffJacobian
        struct /* ComputeCentralDiffJacobian */ {
          // Source: drake/systems/analysis/implicit_integrator.h:440
          const char* doc = R"""()""";
        } ComputeCentralDiffJacobian;
        // Symbol: drake::systems::ImplicitIntegrator::ComputeForwardDiffJacobian
        struct /* ComputeForwardDiffJacobian */ {
          // Source: drake/systems/analysis/implicit_integrator.h:427
          const char* doc = R"""()""";
        } ComputeForwardDiffJacobian;
        // Symbol: drake::systems::ImplicitIntegrator::ConvergenceStatus
        struct /* ConvergenceStatus */ {
          // Source: drake/systems/analysis/implicit_integrator.h:342
          const char* doc = R"""()""";
          // Symbol: drake::systems::ImplicitIntegrator::ConvergenceStatus::kConverged
          struct /* kConverged */ {
            // Source: drake/systems/analysis/implicit_integrator.h:344
            const char* doc = R"""()""";
          } kConverged;
          // Symbol: drake::systems::ImplicitIntegrator::ConvergenceStatus::kDiverged
          struct /* kDiverged */ {
            // Source: drake/systems/analysis/implicit_integrator.h:343
            const char* doc = R"""()""";
          } kDiverged;
          // Symbol: drake::systems::ImplicitIntegrator::ConvergenceStatus::kNotConverged
          struct /* kNotConverged */ {
            // Source: drake/systems/analysis/implicit_integrator.h:345
            const char* doc = R"""()""";
          } kNotConverged;
        } ConvergenceStatus;
        // Symbol: drake::systems::ImplicitIntegrator::DoImplicitIntegratorReset
        struct /* DoImplicitIntegratorReset */ {
          // Source: drake/systems/analysis/implicit_integrator.h:379
          const char* doc = R"""(@copydoc IntegratorBase::DoReset())""";
        } DoImplicitIntegratorReset;
        // Symbol: drake::systems::ImplicitIntegrator::DoImplicitIntegratorStep
        struct /* DoImplicitIntegratorStep */ {
          // Source: drake/systems/analysis/implicit_integrator.h:456
          const char* doc = R"""(@copydoc IntegratorBase::DoStep())""";
        } DoImplicitIntegratorStep;
        // Symbol: drake::systems::ImplicitIntegrator::DoReset
        struct /* DoReset */ {
          // Source: drake/systems/analysis/implicit_integrator.h:405
          const char* doc = R"""()""";
        } DoReset;
        // Symbol: drake::systems::ImplicitIntegrator::DoResetCachedJacobianRelatedMatrices
        struct /* DoResetCachedJacobianRelatedMatrices */ {
          // Source: drake/systems/analysis/implicit_integrator.h:384
          const char* doc =
R"""(Resets any cached Jacobian or iteration matrices owned by child
classes. This is called when the user changes the Jacobian computation
scheme; the child class should use this to reset its cached matrices.)""";
        } DoResetCachedJacobianRelatedMatrices;
        // Symbol: drake::systems::ImplicitIntegrator::DoResetImplicitIntegratorStatistics
        struct /* DoResetImplicitIntegratorStatistics */ {
          // Source: drake/systems/analysis/implicit_integrator.h:375
          const char* doc =
R"""(Resets any statistics particular to a specific implicit integrator.
The default implementation of this function does nothing. If your
integrator collects its own statistics, you should re-implement this
method and reset them there.)""";
        } DoResetImplicitIntegratorStatistics;
        // Symbol: drake::systems::ImplicitIntegrator::DoResetStatistics
        struct /* DoResetStatistics */ {
          // Source: drake/systems/analysis/implicit_integrator.h:404
          const char* doc = R"""()""";
        } DoResetStatistics;
        // Symbol: drake::systems::ImplicitIntegrator::FreshenMatricesIfFullNewton
        struct /* FreshenMatricesIfFullNewton */ {
          // Source: drake/systems/analysis/implicit_integrator.h:299
          const char* doc =
R"""(Computes necessary matrices (Jacobian and iteration matrix) for full
Newton-Raphson (NR) iterations, if full Newton-Raphson method is
activated (if it's not activated, this method is a no-op).

Parameter ``t``:
    the time at which to compute the Jacobian.

Parameter ``xt``:
    the continuous state at which the Jacobian is computed.

Parameter ``h``:
    the integration step size (for computing iteration matrices).

Parameter ``compute_and_factor_iteration_matrix``:
    a function pointer for computing and factoring the iteration
    matrix.

Parameter ``iteration_matrix``:
    the updated and factored iteration matrix on return.

Postcondition:
    the state in the internal context will be set to (t, xt) and this
    will store the updated Jacobian matrix, on return.)""";
        } FreshenMatricesIfFullNewton;
        // Symbol: drake::systems::ImplicitIntegrator::ImplicitIntegrator<T>
        struct /* ctor */ {
          // Source: drake/systems/analysis/implicit_integrator.h:27
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::systems::ImplicitIntegrator::IsBadJacobian
        struct /* IsBadJacobian */ {
          // Source: drake/systems/analysis/implicit_integrator.h:390
          const char* doc =
R"""(Checks to see whether a Jacobian matrix is "bad" (has any NaN or Inf
values) and needs to be recomputed. A divergent Newton-Raphson
iteration can cause the state to overflow, which is how the Jacobian
can become "bad". This is an O(n²) operation, where n is the state
dimension.)""";
        } IsBadJacobian;
        // Symbol: drake::systems::ImplicitIntegrator::IsUpdateZero
        struct /* IsUpdateZero */ {
          // Source: drake/systems/analysis/implicit_integrator.h:316
          const char* doc =
R"""(Checks whether a proposed update is effectively zero, indicating that
the Newton-Raphson process converged.

Parameter ``xc``:
    the continuous state.

Parameter ``dxc``:
    the update to the continuous state.

Parameter ``eps``:
    the tolerance that will be used to determine whether the change in
    any dimension of the state is nonzero. ``eps`` will be treated as
    an absolute tolerance when the magnitude of a particular dimension
    of the state is no greater than unity and as a relative tolerance
    otherwise. For non-positive ``eps`` (default), an appropriate
    tolerance will be computed.

Returns:
    ``True`` if the update is effectively zero.)""";
        } IsUpdateZero;
        // Symbol: drake::systems::ImplicitIntegrator::IterationMatrix
        struct /* IterationMatrix */ {
          // Source: drake/systems/analysis/implicit_integrator.h:218
          const char* doc =
R"""(A class for storing the factorization of an iteration matrix and using
it to solve linear systems of equations. This class exists simply
because Eigen AutoDiff puts limitations on what kinds of
factorizations can be used; encapsulating the iteration matrix
factorizations like this frees the implementer of these kinds of
details.)""";
          // Symbol: drake::systems::ImplicitIntegrator::IterationMatrix::SetAndFactorIterationMatrix
          struct /* SetAndFactorIterationMatrix */ {
            // Source: drake/systems/analysis/implicit_integrator.h:223
            const char* doc =
R"""(Factors a dense matrix (the iteration matrix) using LU factorization,
which should be faster than the QR factorization used in the
specialized template method for AutoDiffXd below.)""";
          } SetAndFactorIterationMatrix;
          // Symbol: drake::systems::ImplicitIntegrator::IterationMatrix::Solve
          struct /* Solve */ {
            // Source: drake/systems/analysis/implicit_integrator.h:228
            const char* doc =
R"""(Solves a linear system Ax = b for x using the iteration matrix (A)
factored using LU decomposition.

See also:
    Factor())""";
          } Solve;
          // Symbol: drake::systems::ImplicitIntegrator::IterationMatrix::matrix_factored
          struct /* matrix_factored */ {
            // Source: drake/systems/analysis/implicit_integrator.h:231
            const char* doc =
R"""(Returns whether the iteration matrix has been set and factored.)""";
          } matrix_factored;
        } IterationMatrix;
        // Symbol: drake::systems::ImplicitIntegrator::JacobianComputationScheme
        struct /* JacobianComputationScheme */ {
          // Source: drake/systems/analysis/implicit_integrator.h:46
          const char* doc = R"""()""";
          // Symbol: drake::systems::ImplicitIntegrator::JacobianComputationScheme::kAutomatic
          struct /* kAutomatic */ {
            // Source: drake/systems/analysis/implicit_integrator.h:54
            const char* doc = R"""(Automatic differentiation.)""";
          } kAutomatic;
          // Symbol: drake::systems::ImplicitIntegrator::JacobianComputationScheme::kCentralDifference
          struct /* kCentralDifference */ {
            // Source: drake/systems/analysis/implicit_integrator.h:51
            const char* doc = R"""(Central differencing.)""";
          } kCentralDifference;
          // Symbol: drake::systems::ImplicitIntegrator::JacobianComputationScheme::kForwardDifference
          struct /* kForwardDifference */ {
            // Source: drake/systems/analysis/implicit_integrator.h:48
            const char* doc = R"""(Forward differencing.)""";
          } kForwardDifference;
        } JacobianComputationScheme;
        // Symbol: drake::systems::ImplicitIntegrator::MaybeFreshenMatrices
        struct /* MaybeFreshenMatrices */ {
          // Source: drake/systems/analysis/implicit_integrator.h:280
          const char* doc =
R"""(Computes necessary matrices (Jacobian and iteration matrix) for
Newton-Raphson (NR) iterations, as necessary. This method has been
designed for use in DoImplicitIntegratorStep() processes that follow
this model: 1. DoImplicitIntegratorStep(h) is called; 2. One or more
NR iterations is performed until either (a) convergence is identified,
(b) the iteration is found to diverge, or (c) too many iterations were
taken. In the case of (a), DoImplicitIntegratorStep(h) will return
success. Otherwise, the Newton-Raphson process is attempted again with
(i) a recomputed and refactored iteration matrix and (ii) a recomputed
Jacobian and a recomputed an refactored iteration matrix, in that
order. The process stage of that NR algorithm is indicated by the
``trial`` parameter below. In this model, DoImplicitIntegratorStep()
returns failure if the NR iterations reach a fourth trial.

Note that the sophisticated logic above only applies when the Jacobian
reuse is activated (default, see get_reuse()).

Parameter ``t``:
    the time at which to compute the Jacobian.

Parameter ``xt``:
    the continuous state at which the Jacobian is computed.

Parameter ``h``:
    the integration step size (for computing iteration matrices).

Parameter ``trial``:
    which trial (1-4) the Newton-Raphson process is in when calling
    this method.

Parameter ``compute_and_factor_iteration_matrix``:
    a function pointer for computing and factoring the iteration
    matrix.

Parameter ``iteration_matrix``:
    the updated and factored iteration matrix on return.

Returns:
    ``False`` if the calling stepping method should indicate failure;
    ``True`` otherwise.

Precondition:
    1 <= ``trial`` <= 4.

Postcondition:
    the state in the internal context may or may not be altered on
    return; if altered, it will be set to (t, xt).)""";
        } MaybeFreshenMatrices;
        // Symbol: drake::systems::ImplicitIntegrator::do_get_num_error_estimator_derivative_evaluations
        struct /* do_get_num_error_estimator_derivative_evaluations */ {
          // Source: drake/systems/analysis/implicit_integrator.h:394
          const char* doc = R"""()""";
        } do_get_num_error_estimator_derivative_evaluations;
        // Symbol: drake::systems::ImplicitIntegrator::do_get_num_error_estimator_derivative_evaluations_for_jacobian
        struct /* do_get_num_error_estimator_derivative_evaluations_for_jacobian */ {
          // Source: drake/systems/analysis/implicit_integrator.h:396
          const char* doc = R"""()""";
        } do_get_num_error_estimator_derivative_evaluations_for_jacobian;
        // Symbol: drake::systems::ImplicitIntegrator::do_get_num_error_estimator_iteration_matrix_factorizations
        struct /* do_get_num_error_estimator_iteration_matrix_factorizations */ {
          // Source: drake/systems/analysis/implicit_integrator.h:401
          const char* doc = R"""()""";
        } do_get_num_error_estimator_iteration_matrix_factorizations;
        // Symbol: drake::systems::ImplicitIntegrator::do_get_num_error_estimator_jacobian_evaluations
        struct /* do_get_num_error_estimator_jacobian_evaluations */ {
          // Source: drake/systems/analysis/implicit_integrator.h:400
          const char* doc = R"""()""";
        } do_get_num_error_estimator_jacobian_evaluations;
        // Symbol: drake::systems::ImplicitIntegrator::do_get_num_error_estimator_newton_raphson_iterations
        struct /* do_get_num_error_estimator_newton_raphson_iterations */ {
          // Source: drake/systems/analysis/implicit_integrator.h:398
          const char* doc = R"""()""";
        } do_get_num_error_estimator_newton_raphson_iterations;
        // Symbol: drake::systems::ImplicitIntegrator::do_get_num_newton_raphson_iterations
        struct /* do_get_num_newton_raphson_iterations */ {
          // Source: drake/systems/analysis/implicit_integrator.h:393
          const char* doc = R"""()""";
        } do_get_num_newton_raphson_iterations;
        // Symbol: drake::systems::ImplicitIntegrator::do_max_newton_raphson_iterations
        struct /* do_max_newton_raphson_iterations */ {
          // Source: drake/systems/analysis/implicit_integrator.h:211
          const char* doc =
R"""(Derived classes can override this method to change the number of
Newton-Raphson iterations (10 by default) to take before the
Newton-Raphson process decides that convergence will not be attained.)""";
        } do_max_newton_raphson_iterations;
        // Symbol: drake::systems::ImplicitIntegrator::get_jacobian_computation_scheme
        struct /* get_jacobian_computation_scheme */ {
          // Source: drake/systems/analysis/implicit_integrator.h:123
          const char* doc = R"""()""";
        } get_jacobian_computation_scheme;
        // Symbol: drake::systems::ImplicitIntegrator::get_mutable_jacobian
        struct /* get_mutable_jacobian */ {
          // Source: drake/systems/analysis/implicit_integrator.h:403
          const char* doc = R"""()""";
        } get_mutable_jacobian;
        // Symbol: drake::systems::ImplicitIntegrator::get_num_derivative_evaluations_for_jacobian
        struct /* get_num_derivative_evaluations_for_jacobian */ {
          // Source: drake/systems/analysis/implicit_integrator.h:138
          const char* doc =
R"""(Gets the number of ODE function evaluations (calls to
EvalTimeDerivatives()) *used only for computing the Jacobian matrices*
since the last call to ResetStatistics(). This count includes those
derivative calculations necessary for computing Jacobian matrices
during error estimation processes.)""";
        } get_num_derivative_evaluations_for_jacobian;
        // Symbol: drake::systems::ImplicitIntegrator::get_num_error_estimator_derivative_evaluations
        struct /* get_num_error_estimator_derivative_evaluations */ {
          // Source: drake/systems/analysis/implicit_integrator.h:169
          const char* doc =
R"""(Gets the number of ODE function evaluations (calls to
EvalTimeDerivatives()) *used only for the error estimation process*
since the last call to ResetStatistics(). This count includes those
needed to compute Jacobian matrices.)""";
        } get_num_error_estimator_derivative_evaluations;
        // Symbol: drake::systems::ImplicitIntegrator::get_num_error_estimator_derivative_evaluations_for_jacobian
        struct /* get_num_error_estimator_derivative_evaluations_for_jacobian */ {
          // Source: drake/systems/analysis/implicit_integrator.h:182
          const char* doc =
R"""(@name Error-estimation statistics functions. The functions return
statistics specific to the error estimation process. Gets the number
of ODE function evaluations (calls to CalcTimeDerivatives()) *used
only for computing the Jacobian matrices needed by the error
estimation process* since the last call to ResetStatistics().)""";
        } get_num_error_estimator_derivative_evaluations_for_jacobian;
        // Symbol: drake::systems::ImplicitIntegrator::get_num_error_estimator_iteration_matrix_factorizations
        struct /* get_num_error_estimator_iteration_matrix_factorizations */ {
          // Source: drake/systems/analysis/implicit_integrator.h:202
          const char* doc =
R"""(Gets the number of factorizations of the iteration matrix *used only
during the error estimation process* since the last call to
ResetStatistics().)""";
        } get_num_error_estimator_iteration_matrix_factorizations;
        // Symbol: drake::systems::ImplicitIntegrator::get_num_error_estimator_jacobian_evaluations
        struct /* get_num_error_estimator_jacobian_evaluations */ {
          // Source: drake/systems/analysis/implicit_integrator.h:195
          const char* doc =
R"""(Gets the number of Jacobian matrix computations *used only during the
error estimation process* since the last call to ResetStatistics().)""";
        } get_num_error_estimator_jacobian_evaluations;
        // Symbol: drake::systems::ImplicitIntegrator::get_num_error_estimator_newton_raphson_iterations
        struct /* get_num_error_estimator_newton_raphson_iterations */ {
          // Source: drake/systems/analysis/implicit_integrator.h:189
          const char* doc =
R"""(Gets the number of iterations *used in the Newton-Raphson nonlinear
systems of equation solving process for the error estimation process*
since the last call to ResetStatistics().)""";
        } get_num_error_estimator_newton_raphson_iterations;
        // Symbol: drake::systems::ImplicitIntegrator::get_num_iteration_matrix_factorizations
        struct /* get_num_iteration_matrix_factorizations */ {
          // Source: drake/systems/analysis/implicit_integrator.h:161
          const char* doc =
R"""(Gets the number of factorizations of the iteration matrix since the
last call to ResetStatistics(). This count includes those
refactorizations necessary during error estimation processes.)""";
        } get_num_iteration_matrix_factorizations;
        // Symbol: drake::systems::ImplicitIntegrator::get_num_jacobian_evaluations
        struct /* get_num_jacobian_evaluations */ {
          // Source: drake/systems/analysis/implicit_integrator.h:146
          const char* doc =
R"""(Gets the number of Jacobian computations (i.e., the number of times
that the Jacobian matrix was reformed) since the last call to
ResetStatistics(). This count includes those evaluations necessary
during error estimation processes.)""";
        } get_num_jacobian_evaluations;
        // Symbol: drake::systems::ImplicitIntegrator::get_num_newton_raphson_iterations
        struct /* get_num_newton_raphson_iterations */ {
          // Source: drake/systems/analysis/implicit_integrator.h:154
          const char* doc =
R"""(Gets the number of iterations used in the Newton-Raphson nonlinear
systems of equation solving process since the last call to
ResetStatistics(). This count includes those Newton-Raphson iterations
used during error estimation processes.)""";
        } get_num_newton_raphson_iterations;
        // Symbol: drake::systems::ImplicitIntegrator::get_reuse
        struct /* get_reuse */ {
          // Source: drake/systems/analysis/implicit_integrator.h:97
          const char* doc =
R"""(Gets whether the integrator attempts to reuse Jacobian matrices and
iteration matrix factorizations.

See also:
    set_reuse()

Note:
    This method always returns ``False`` when full-Newton mode is on.)""";
        } get_reuse;
        // Symbol: drake::systems::ImplicitIntegrator::get_use_full_newton
        struct /* get_use_full_newton */ {
          // Source: drake/systems/analysis/implicit_integrator.h:108
          const char* doc =
R"""(Gets whether this method is operating in "full Newton" mode.

See also:
    set_use_full_newton())""";
        } get_use_full_newton;
        // Symbol: drake::systems::ImplicitIntegrator::increment_jacobian_computation_derivative_evaluations
        struct /* increment_jacobian_computation_derivative_evaluations */ {
          // Source: drake/systems/analysis/implicit_integrator.h:464
          const char* doc = R"""()""";
        } increment_jacobian_computation_derivative_evaluations;
        // Symbol: drake::systems::ImplicitIntegrator::increment_jacobian_evaluations
        struct /* increment_jacobian_evaluations */ {
          // Source: drake/systems/analysis/implicit_integrator.h:468
          const char* doc = R"""()""";
        } increment_jacobian_evaluations;
        // Symbol: drake::systems::ImplicitIntegrator::increment_num_iter_factorizations
        struct /* increment_num_iter_factorizations */ {
          // Source: drake/systems/analysis/implicit_integrator.h:460
          const char* doc = R"""()""";
        } increment_num_iter_factorizations;
        // Symbol: drake::systems::ImplicitIntegrator::max_newton_raphson_iterations
        struct /* max_newton_raphson_iterations */ {
          // Source: drake/systems/analysis/implicit_integrator.h:42
          const char* doc =
R"""(The maximum number of Newton-Raphson iterations to take before the
Newton-Raphson process decides that convergence will not be attained.
This number affects the speed with which a solution is found. If the
number is too small, Jacobian/iteration matrix reformations and
refactorizations will be performed unnecessarily. If the number is too
large, the Newton-Raphson process will waste time evaluating
derivatives when convergence is infeasible. [Hairer, 1996] states, "It
is our experience that the code becomes more efficient when we allow a
relatively high number of iterations (e.g., [7 or 10])", p. 121. Note
that the focus of that quote is a 5th order integrator that uses a
quasi-Newton approach.)""";
        } max_newton_raphson_iterations;
        // Symbol: drake::systems::ImplicitIntegrator::set_jacobian_computation_scheme
        struct /* set_jacobian_computation_scheme */ {
          // Source: drake/systems/analysis/implicit_integrator.h:114
          const char* doc =
R"""(Sets the Jacobian computation scheme. This function can be safely
called at any time (i.e., the integrator need not be re-initialized
afterward).

Note:
    Discards any already-computed Jacobian matrices if the scheme
    changes.)""";
        } set_jacobian_computation_scheme;
        // Symbol: drake::systems::ImplicitIntegrator::set_jacobian_is_fresh
        struct /* set_jacobian_is_fresh */ {
          // Source: drake/systems/analysis/implicit_integrator.h:472
          const char* doc = R"""()""";
        } set_jacobian_is_fresh;
        // Symbol: drake::systems::ImplicitIntegrator::set_reuse
        struct /* set_reuse */ {
          // Source: drake/systems/analysis/implicit_integrator.h:91
          const char* doc =
R"""(Sets whether the integrator attempts to reuse Jacobian matrices and
iteration matrix factorizations (default is ``True``). Forming
Jacobian matrices and factorizing iteration matrices are generally the
two most expensive operations performed by this integrator. For small
systems (those with on the order of ten state variables), the
additional accuracy that using fresh Jacobians and factorizations
buys- which can permit increased step sizes but should have no effect
on solution accuracy- can outweigh the small factorization cost.

Note:
    The reuse setting will have no effect when get_use_full_newton()
    ``== true``.

See also:
    get_reuse()

See also:
    set_use_full_newton())""";
        } set_reuse;
        // Symbol: drake::systems::ImplicitIntegrator::set_use_full_newton
        struct /* set_use_full_newton */ {
          // Source: drake/systems/analysis/implicit_integrator.h:104
          const char* doc =
R"""(Sets whether the method operates in "full Newton" mode, in which case
Jacobian and iteration matrices are freshly computed on every
Newton-Raphson iteration. When set to ``True``, this mode overrides
the reuse mode.

See also:
    set_reuse())""";
        } set_use_full_newton;
      } ImplicitIntegrator;
      // Symbol: drake::systems::InitialValueProblem
      struct /* InitialValueProblem */ {
        // Source: drake/systems/analysis/initial_value_problem.h:59
        const char* doc =
R"""(A general initial value problem (or IVP) representation class, that
allows evaluating the 𝐱(t; 𝐤) solution function to the given ODE d𝐱/dt
= f(t, 𝐱; 𝐤), where f : t ⨯ 𝐱 → ℝⁿ, t ∈ ℝ, 𝐱 ∈ ℝⁿ, 𝐤 ∈ ℝᵐ, provided an
initial condition 𝐱(t₀; 𝐤) = 𝐱₀. The parameter vector 𝐤 allows for
generic IVP definitions, which can later be solved for any instance of
said vector.

By default, an explicit 3rd order RungeKutta integration scheme is
used.

The implementation of this class performs basic computation caching,
optimizing away repeated integration whenever the IVP is solved for
increasing values of time t while both initial conditions and
parameters are kept constant, e.g. if solved for t₁ > t₀ first,
solving for t₂ > t₁ will only require integrating from t₁ onward.

Additionally, IntegratorBase's dense output support can be leveraged
to efficiently approximate the IVP solution within closed intervals of
t. This is convenient when there's a need for a more dense sampling of
the IVP solution than what would be available through either fixed or
error-controlled step integration (for a given accuracy), or when the
IVP is to be solved repeatedly for arbitrarily many t values within a
given interval. See documentation of the internally held
IntegratorBase subclass instance (either the default or a user-defined
one, set via reset_integrator()) for further reference on the specific
dense output technique in use.

For further insight into its use, consider the following examples:

- The momentum 𝐩 of a particle of mass m that is traveling through a
  volume of a gas with dynamic viscosity μ can be described by
  d𝐩/dt = -μ * 𝐩/m. At time t₀, the particle carries an initial momentum
  𝐩₀. In this context, t is unused (the ODE is autonomous), 𝐱 ≜ 𝐩,
  𝐤 ≜ [m, μ], t₀ = 0, 𝐱₀ ≜ 𝐩₀, d𝐱/dt = f(t, 𝐱; 𝐤) = -k₂ * 𝐱 / k₁.

- The velocity 𝐯 of the same particle in the same exact conditions as
  before, but when a time varying force 𝐅(t) is applied to it, can be
  be described by d𝐯/dt = (𝐅(t) - μ * 𝐯) / m. In this context, 𝐱 ≜ 𝐯,
  𝐤 ≜ [m, μ], 𝐱₀ ≜ 𝐯₀, d𝐱/dt = f(t, 𝐱; 𝐤) = (𝐅(t) - k₂ * 𝐱) / k₁.)""";
        // Symbol: drake::systems::InitialValueProblem::DenseSolve
        struct /* DenseSolve */ {
          // Source: drake/systems/analysis/initial_value_problem.h:169
          const char* doc =
R"""(Solves and yields an approximation of the IVP solution x(t; 𝐤) for the
closed time interval between the initial time t₀ and the given final
time ``tf``, using initial state 𝐱₀ and parameter vector 𝐤 present in
``values`` (falling back to the ones given on construction if not
given).

To this end, the wrapped IntegratorBase instance solves this IVP,
advancing time and state from t₀ and 𝐱₀ = 𝐱(t₀) to ``tf`` and
𝐱(``tf)``, creating a dense output over that [t₀, ``tf``] interval
along the way.

Parameter ``tf``:
    The IVP will be solved up to this time. Usually, t₀ < ``tf`` as an
    empty dense output would result if t₀ = ``tf``.

Parameter ``values``:
    IVP initial conditions and parameters.

Returns:
    A dense approximation to 𝐱(t; 𝐤) with 𝐱(t₀; 𝐤) = 𝐱₀, defined for
    t₀ ≤ t ≤ tf.

Note:
    The larger the given ``tf`` value is, the larger the approximated
    interval will be. See documentation of the specific dense output
    technique in use for reference on performance impact as this
    interval grows.

Precondition:
    Given ``tf`` must be larger than or equal to the specified initial
    time t₀ (either given or default).

Precondition:
    If given, the dimension of the initial state vector ``values``.x0
    must match that of the default initial state vector in the default
    specified values given on construction.

Precondition:
    If given, the dimension of the parameter vector ``values``.k must
    match that of the parameter vector in the default specified values
    given on construction.

Raises:
    RuntimeError if any of the preconditions is not met.)""";
        } DenseSolve;
        // Symbol: drake::systems::InitialValueProblem::InitialValueProblem<T>
        struct /* ctor */ {
          // Source: drake/systems/analysis/initial_value_problem.h:121
          const char* doc =
R"""(Constructs an IVP described by the given ``ode_function``, using given
``default_values``.t0 and ``default_values``.x0 as initial conditions,
and parameterized with ``default_values``.k by default.

Parameter ``ode_function``:
    The ODE function f(t, 𝐱; 𝐤) that describes the state evolution
    over time.

Parameter ``default_values``:
    The values specified by default for this IVP, i.e. default initial
    time t₀ ∈ ℝ and state vector 𝐱₀ ∈ ℝⁿ, and default parameter vector
    𝐤 ∈ ℝᵐ.

Precondition:
    An initial time ``default_values``.t0 is given.

Precondition:
    An initial state vector ``default_values``.x0 is given.

Precondition:
    A parameter vector ``default_values``.k is given.

Raises:
    RuntimeError if preconditions are not met.)""";
        } ctor;
        // Symbol: drake::systems::InitialValueProblem::OdeContext
        struct /* OdeContext */ {
          // Source: drake/systems/analysis/initial_value_problem.h:83
          const char* doc =
R"""(A collection of values i.e. initial time t₀, initial state vector 𝐱₀
and parameters vector 𝐤.to further specify the ODE system (in order to
become an initial value problem). This places the same role as
systems::Context, but is intentionally much simpler.)""";
          // Symbol: drake::systems::InitialValueProblem::OdeContext::OdeContext
          struct /* ctor */ {
            // Source: drake/systems/analysis/initial_value_problem.h:85
            const char* doc_0args =
R"""(Default constructor, leaving all values unspecified.)""";
            // Source: drake/systems/analysis/initial_value_problem.h:92
            const char* doc_3args =
R"""(Constructor specifying all values.

Parameter ``t0_in``:
    Specified initial time t₀.

Parameter ``x0_in``:
    Specified initial state vector 𝐱₀.

Parameter ``k_in``:
    Specified parameter vector 𝐤.)""";
          } ctor;
          // Symbol: drake::systems::InitialValueProblem::OdeContext::k
          struct /* k */ {
            // Source: drake/systems/analysis/initial_value_problem.h:105
            const char* doc = R"""(The parameter vector 𝐤 for the IVP.)""";
          } k;
          // Symbol: drake::systems::InitialValueProblem::OdeContext::operator!=
          struct /* operator_ne */ {
            // Source: drake/systems/analysis/initial_value_problem.h:101
            const char* doc = R"""()""";
          } operator_ne;
          // Symbol: drake::systems::InitialValueProblem::OdeContext::t0
          struct /* t0 */ {
            // Source: drake/systems/analysis/initial_value_problem.h:103
            const char* doc = R"""(The initial time t₀ for the IVP.)""";
          } t0;
          // Symbol: drake::systems::InitialValueProblem::OdeContext::x0
          struct /* x0 */ {
            // Source: drake/systems/analysis/initial_value_problem.h:104
            const char* doc =
R"""(The initial state vector 𝐱₀ for the IVP.)""";
          } x0;
        } OdeContext;
        // Symbol: drake::systems::InitialValueProblem::OdeFunction
        struct /* OdeFunction */ {
          // Source: drake/systems/analysis/initial_value_problem.h:76
          const char* doc =
R"""(General ODE system d𝐱/dt = f(t, 𝐱; 𝐤) function type.

Parameter ``t``:
    The independent scalar variable t ∈ ℝ.

Parameter ``x``:
    The dependent vector variable 𝐱 ∈ ℝⁿ.

Parameter ``k``:
    The vector of parameters 𝐤 ∈ ℝᵐ.

Returns:
    The derivative vector d𝐱/dt ∈ ℝⁿ.)""";
        } OdeFunction;
        // Symbol: drake::systems::InitialValueProblem::Solve
        struct /* Solve */ {
          // Source: drake/systems/analysis/initial_value_problem.h:140
          const char* doc =
R"""(Solves the IVP for time ``tf``, using the initial time t₀, initial
state vector 𝐱₀ and parameter vector 𝐤 present in ``values``, falling
back to the ones given on construction if not given.

Parameter ``tf``:
    The IVP will be solved for this time.

Parameter ``values``:
    IVP initial conditions and parameters.

Returns:
    The IVP solution 𝐱(``tf``; 𝐤) for 𝐱(t₀; 𝐤) = 𝐱₀.

Precondition:
    Given ``tf`` must be larger than or equal to the specified initial
    time t₀ (either given or default).

Precondition:
    If given, the dimension of the initial state vector ``values``.x0
    must match that of the default initial state vector in the default
    specified values given on construction.

Precondition:
    If given, the dimension of the parameter vector ``values``.k must
    match that of the parameter vector in the default specified values
    given on construction.

Raises:
    RuntimeError if preconditions are not met.)""";
        } Solve;
        // Symbol: drake::systems::InitialValueProblem::get_integrator
        struct /* get_integrator */ {
          // Source: drake/systems/analysis/initial_value_problem.h:197
          const char* doc =
R"""(Gets a reference to the internal integrator instance.)""";
        } get_integrator;
        // Symbol: drake::systems::InitialValueProblem::get_mutable_integrator
        struct /* get_mutable_integrator */ {
          // Source: drake/systems/analysis/initial_value_problem.h:203
          const char* doc =
R"""(Gets a mutable reference to the internal integrator instance.)""";
        } get_mutable_integrator;
        // Symbol: drake::systems::InitialValueProblem::reset_integrator
        struct /* reset_integrator */ {
          // Source: drake/systems/analysis/initial_value_problem.h:189
          const char* doc =
R"""(Resets the internal integrator instance by in-place construction of
the given integrator type.

A usage example is shown below.


::

    ivp.reset_integrator<RungeKutta2Integrator<T>>(max_step);

Parameter ``args``:
    The integrator type-specific arguments.

Returns:
    The new integrator instance.

Template parameter ``Integrator``:
    The integrator type, which must be an IntegratorBase subclass.

Template parameter ``Args``:
    The integrator specific argument types.

Warning:
    This operation invalidates pointers returned by
    InitialValueProblem::get_integrator() and
    InitialValueProblem::get_mutable_integrator().)""";
        } reset_integrator;
      } InitialValueProblem;
      // Symbol: drake::systems::InitializeParams
      struct /* InitializeParams */ {
        // Source: drake/systems/analysis/simulator.h:29
        const char* doc =
R"""(Parameters for fine control of simulator initialization.

See also:
    Simulator<T>::Initialize().)""";
        // Symbol: drake::systems::InitializeParams::suppress_initialization_events
        struct /* suppress_initialization_events */ {
          // Source: drake/systems/analysis/simulator.h:32
          const char* doc =
R"""(Whether to trigger initialization events. Events are triggered by
default; it may be useful to suppress them when reusing a simulator.)""";
        } suppress_initialization_events;
      } InitializeParams;
      // Symbol: drake::systems::InputPort
      struct /* InputPort */ {
        // Source: drake/systems/framework/input_port.h:37
        const char* doc =
R"""(An InputPort is a System resource that describes the kind of input a
System accepts, on a given port. It does not directly contain any
runtime input port data; that is always contained in a Context. The
actual value will be either the value of an OutputPort to which this
is connected, or a fixed value set in a Context.)""";
        // Symbol: drake::systems::InputPort::Eval
        struct /* Eval */ {
          // Source: drake/systems/framework/input_port.h:72
          const char* doc = R"""()""";
        } Eval;
        // Symbol: drake::systems::InputPort::FixValue
        struct /* FixValue */ {
          // Source: drake/systems/framework/input_port.h:139
          const char* doc =
R"""(Provides a fixed value for this InputPort in the given Context. If the
port is already connected, this value will override the connected
source value. (By "connected" we mean that the port appeared in a
DiagramBuilder::Connect() call.)

For vector-valued input ports, you can provide an Eigen vector
expression, a BasicVector object, or a scalar (treated as a Vector1).
In each of these cases the value is copied into a
``Value<BasicVector>``. If the original value was a
BasicVector-derived object, its concrete type is maintained although
the stored type is still ``Value<BasicVector>``. The supplied vector
must have the right size for the vector port or an RuntimeError is
thrown.

For abstract-valued input ports, you can provide any ValueType that is
compatible with the model type provided when the port was declared. If
the type has a copy constructor it will be copied into a
``Value<ValueType>`` object for storage. Otherwise it must have an
accessible ``Clone()`` method and it is stored using the type returned
by that method, which must be ValueType or a base class of ValueType.
Eigen objects and expressions are not accepted directly, but you can
store then in abstract ports by providing an already-abstract object
like ``Value<MatrixXd>(your_matrix)``.

The returned FixedInputPortValue reference may be used to modify the
input port's value subsequently using the appropriate
FixedInputPortValue method, which will ensure that cache invalidation
notifications are delivered.

Template parameter ``ValueType``:
    The type of the supplied ``value`` object. This will be inferred
    so no template argument need be specified. The type must be copy
    constructible or have an accessible ``Clone()`` method.

Parameter ``context``:
    A Context that is compatible with the System that owns this port.

Parameter ``value``:
    The fixed value for this port. Must be convertible to the input
    port's data type.

Returns:
    a reference to the the FixedInputPortValue object in the Context
    that contains this port's value.

Precondition:
    ``context`` is compatible with the System that owns this
    InputPort.

Precondition:
    ``value`` is compatible with this InputPort's data type.)""";
        } FixValue;
        // Symbol: drake::systems::InputPort::HasValue
        struct /* HasValue */ {
          // Source: drake/systems/framework/input_port.h:155
          const char* doc =
R"""(Returns true iff this port is connected or has had a fixed value
provided in the given Context. Beware that at the moment, this could
be an expensive operation, because the value is brought up-to-date as
part of this operation.)""";
        } HasValue;
        // Symbol: drake::systems::InputPort::InputPort<T>
        struct /* ctor */ {
          // Source: drake/systems/framework/input_port.h:39
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::systems::InputPort::get_system
        struct /* get_system */ {
          // Source: drake/systems/framework/input_port.h:163
          const char* doc =
R"""(Returns a reference to the System that owns this input port. Note that
for a Diagram input port this will be the Diagram, not the LeafSystem
whose input port was exported.)""";
        } get_system;
      } InputPort;
      // Symbol: drake::systems::InputPortBase
      struct /* InputPortBase */ {
        // Source: drake/systems/framework/input_port_base.h:21
        const char* doc =
R"""(An InputPort is a System resource that describes the kind of input a
System accepts, on a given port. It does not directly contain any
runtime input port data; that is always contained in a Context. The
actual value will be either the value of an OutputPort to which this
is connected, or a fixed value set in a Context.

InputPortBase is the scalar type-independent part of an InputPort.)""";
        // Symbol: drake::systems::InputPortBase::DoEvalOptional
        struct /* DoEvalOptional */ {
          // Source: drake/systems/framework/input_port_base.h:88
          const char* doc =
R"""(Evaluate this port; returns nullptr if the port is not connected.)""";
        } DoEvalOptional;
        // Symbol: drake::systems::InputPortBase::DoEvalRequired
        struct /* DoEvalRequired */ {
          // Source: drake/systems/framework/input_port_base.h:81
          const char* doc =
R"""(Evaluate this port; throws an exception if the port is not connected.)""";
        } DoEvalRequired;
        // Symbol: drake::systems::InputPortBase::EvalAbstractCallback
        struct /* EvalAbstractCallback */ {
          // Source: drake/systems/framework/input_port_base.h:51
          const char* doc =
R"""(Signature of a function suitable for returning the cached value of a
particular input port. Will return nullptr if the port is not
connected.)""";
        } EvalAbstractCallback;
        // Symbol: drake::systems::InputPortBase::InputPortBase
        struct /* ctor */ {
          // Source: drake/systems/framework/input_port_base.h:74
          const char* doc =
R"""(Provides derived classes the ability to set the base class members at
construction.

Parameter ``owning_system``:
    The System that owns this input port.

Parameter ``name``:
    A name for the port. Input port names should be non-empty and
    unique within a single System.

Parameter ``index``:
    The index to be assigned to this InputPort.

Parameter ``ticket``:
    The DependencyTicket to be assigned to this InputPort.

Parameter ``data_type``:
    Whether the port described is vector- or abstract-valued.

Parameter ``size``:
    If the port described is vector-valued, the number of elements.
    Ignored for abstract-valued ports.

Parameter ``random_type``:
    Input ports may optionally be labeled as random, if the port is
    intended to model a random-source "noise" or "disturbance" input.)""";
        } ctor;
        // Symbol: drake::systems::InputPortBase::ThrowRequiredMissing
        struct /* ThrowRequiredMissing */ {
          // Source: drake/systems/framework/input_port_base.h:94
          const char* doc =
R"""(Throws an exception that this port is not connected, but was expected
to be connected (i.e., an Eval caller expected that it was always
connected).)""";
        } ThrowRequiredMissing;
        // Symbol: drake::systems::InputPortBase::get_index
        struct /* get_index */ {
          // Source: drake/systems/framework/input_port_base.h:30
          const char* doc =
R"""(Returns the index of this input port within the owning System. For a
Diagram, this will be the index within the Diagram, *not* the index
within a LeafSystem whose input port was exported.)""";
        } get_index;
        // Symbol: drake::systems::InputPortBase::get_random_type
        struct /* get_random_type */ {
          // Source: drake/systems/framework/input_port_base.h:36
          const char* doc =
R"""(Returns the RandomDistribution if this is a random port.)""";
        } get_random_type;
        // Symbol: drake::systems::InputPortBase::is_random
        struct /* is_random */ {
          // Source: drake/systems/framework/input_port_base.h:33
          const char* doc = R"""(Returns true if this is a random port.)""";
        } is_random;
      } InputPortBase;
      // Symbol: drake::systems::InputPortIndex
      struct /* InputPortIndex */ {
        // Source: drake/systems/framework/framework_common.h:46
        const char* doc =
R"""(Serves as the local index for the input ports of a given System. The
indexes used by a subsystem and its corresponding subcontext are the
same.)""";
      } InputPortIndex;
      // Symbol: drake::systems::InputPortSelection
      struct /* InputPortSelection */ {
        // Source: drake/systems/framework/framework_common.h:97
        const char* doc =
R"""(Intended for use in e.g. variant<InputPortSelection, InputPortIndex>
for algorithms that support optional and/or default port indices.)""";
        // Symbol: drake::systems::InputPortSelection::kNoInput
        struct /* kNoInput */ {
          // Source: drake/systems/framework/framework_common.h:97
          const char* doc = R"""()""";
        } kNoInput;
        // Symbol: drake::systems::InputPortSelection::kUseFirstInputIfItExists
        struct /* kUseFirstInputIfItExists */ {
          // Source: drake/systems/framework/framework_common.h:97
          const char* doc = R"""()""";
        } kUseFirstInputIfItExists;
      } InputPortSelection;
      // Symbol: drake::systems::Integrator
      struct /* Integrator */ {
        // Source: drake/systems/primitives/integrator.h:15
        const char* doc =
R"""(An integrator for a continuous vector input.)""";
        // Symbol: drake::systems::Integrator::Integrator<T>
        struct /* ctor */ {
          // Source: drake/systems/primitives/integrator.h:21
          const char* doc =
R"""(Constructs an Integrator system.

Parameter ``size``:
    number of elements in the signal to be processed.)""";
          // Source: drake/systems/primitives/integrator.h:25
          const char* doc_copyconvert =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";
        } ctor;
        // Symbol: drake::systems::Integrator::set_integral_value
        struct /* set_integral_value */ {
          // Source: drake/systems/primitives/integrator.h:31
          const char* doc =
R"""(Sets the value of the integral modifying the state in the context.
``value`` must be a column vector of the appropriate size.)""";
        } set_integral_value;
      } Integrator;
      // Symbol: drake::systems::IntegratorBase
      struct /* IntegratorBase */ {
        // Source: drake/systems/analysis/integrator_base.h:124
        const char* doc =
R"""(An abstract class for an integrator for ODEs and DAEs as represented
by a Drake System. Integrators solve initial value problems of the
form:


::

    ẋ(t) = f(t, x(t)) with f : ℝ × ℝⁿ → ℝⁿ

(i.e., ``f()`` is an ordinary differential equation) given initial
conditions (t₀, x₀). Thus, integrators advance the continuous state of
a dynamical system forward in time.

Drake's subclasses of IntegratorBase<T> should follow the naming
pattern ``FooIntegrator<T>`` by convention.)""";
        // Symbol: drake::systems::IntegratorBase::CalcAdjustedStepSize
        struct /* CalcAdjustedStepSize */ {
          // Source: drake/systems/analysis/integrator_base.h:1414
          const char* doc =
R"""(Calculates adjusted integrator step sizes toward keeping state
variables within error bounds on the next integration step. Note that
it is not guaranteed that the (possibly) reduced step size will keep
state variables within error bounds; however, the process of (1)
taking a trial integration step, (2) calculating the error, and (3)
adjusting the step size can be repeated until convergence.

Parameter ``err``:
    The norm of the integrator error that was computed using
    ``attempted_step_size``.

Parameter ``attempted_step_size``:
    The step size that was attempted.

Parameter ``at_minimum_step_size``:
    If ``True`` on entry, the error control mechanism is not allowed
    to shrink the step because the integrator is stepping at the
    minimum step size (note that this condition will only occur if
    ``get_throw_on_minimum_step_size_violation() == false``- an
    exception would be thrown otherwise). If ``True`` on entry and
    ``False`` on exit, the error control mechanism has managed to
    increase the step size above the working minimum; if ``True`` on
    entry and ``True`` on exit, error control would like to shrink the
    step size but cannot. If ``False`` on entry and ``True`` on exit,
    error control shrank the step to the working minimum step size.

Returns:
    a pair of types bool and T; the bool will be set to ``True`` if
    the integration step was to be considered successful and ``False``
    otherwise. The value of the T type will be set to the recommended
    next step size.)""";
        } CalcAdjustedStepSize;
        // Symbol: drake::systems::IntegratorBase::CalcStateChangeNorm
        struct /* CalcStateChangeNorm */ {
          // Source: drake/systems/analysis/integrator_base.h:1384
          const char* doc =
R"""(Computes the infinity norm of a change in continuous state. We use the
infinity norm to capture the idea that, by providing accuracy
requirements, the user can indirectly specify error tolerances that
act to limit the largest error in any state vector component.

Returns:
    the norm (a non-negative value))""";
        } CalcStateChangeNorm;
        // Symbol: drake::systems::IntegratorBase::DoDenseStep
        struct /* DoDenseStep */ {
          // Source: drake/systems/analysis/integrator_base.h:1481
          const char* doc =
R"""(Calls DoStep(h) while recording the resulting step in the dense
output. If the current dense output is already non-empty, then the
time in the current context must match either the final segment time
of the dense output, or the penultimate segment time (to support the
case where the same integration step is attempted multiple times,
which occurs e.g. in witness function isolation).

Parameter ``h``:
    The integration step to take.

Returns:
    ``True`` if successful, ``False`` if either the integrator was
    unable to take a single step of size ``h`` or to advance its dense
    output an equal step.

See also:
    DoStep())""";
        } DoDenseStep;
        // Symbol: drake::systems::IntegratorBase::DoInitialize
        struct /* DoInitialize */ {
          // Source: drake/systems/analysis/integrator_base.h:1424
          const char* doc =
R"""(Derived classes can override this method to perform special
initialization. This method is called during the Initialize() method.
This default method does nothing.)""";
        } DoInitialize;
        // Symbol: drake::systems::IntegratorBase::DoReset
        struct /* DoReset */ {
          // Source: drake/systems/analysis/integrator_base.h:1430
          const char* doc =
R"""(Derived classes can override this method to perform routines when
Reset() is called. This default method does nothing.)""";
        } DoReset;
        // Symbol: drake::systems::IntegratorBase::DoResetStatistics
        struct /* DoResetStatistics */ {
          // Source: drake/systems/analysis/integrator_base.h:1314
          const char* doc =
R"""(Resets any statistics particular to a specific integrator. The default
implementation of this function does nothing. If your integrator
collects its own statistics, you should re-implement this method and
reset them there.)""";
        } DoResetStatistics;
        // Symbol: drake::systems::IntegratorBase::DoStep
        struct /* DoStep */ {
          // Source: drake/systems/analysis/integrator_base.h:1463
          const char* doc =
R"""(Derived classes must implement this method to (1) integrate the
continuous portion of this system forward by a single step of size
``h`` and (2) set the error estimate (via
get_mutable_error_estimate()). This method is called during the
integration process (via StepOnceErrorControlledAtMost(),
IntegrateNoFurtherThanTime(), and
IntegrateWithSingleFixedStepToTime()).

Parameter ``h``:
    The integration step to take.

Returns:
    ``True`` if successful, ``False`` if the integrator was unable to
    take a single step of size ``h`` (due to, e.g., an integrator
    convergence failure).

Postcondition:
    If the time on entry is denoted ``t``, the time and state will be
    advanced to ``t+h`` if the method returns ``True``; otherwise, the
    time and state should be reset to those at ``t``.

Warning:
    It is expected that DoStep() will return ``True`` for some, albeit
    possibly very small, positive value of ``h``. The derived
    integrator's stepping algorithm can make this guarantee, for
    example, by switching to an algorithm not subject to convergence
    failures (e.g., explicit Euler) for very small step sizes.)""";
        } DoStep;
        // Symbol: drake::systems::IntegratorBase::EvalTimeDerivatives
        struct /* EvalTimeDerivatives */ {
          // Source: drake/systems/analysis/integrator_base.h:1321
          const char* doc_1args =
R"""(Evaluates the derivative function and updates call statistics.
Subclasses should call this function rather than calling
system.EvalTimeDerivatives() directly.)""";
          // Source: drake/systems/analysis/integrator_base.h:1333
          const char* doc_2args =
R"""(Evaluates the derivative function (and updates call statistics).
Subclasses should call this function rather than calling
system.EvalTimeDerivatives() directly. This version of this function
exists to allow integrators to include AutoDiff'd systems in
derivative function evaluations.)""";
        } EvalTimeDerivatives;
        // Symbol: drake::systems::IntegratorBase::Initialize
        struct /* Initialize */ {
          // Source: drake/systems/analysis/integrator_base.h:900
          const char* doc =
R"""(An integrator must be initialized before being used. The pointer to
the context must be set before Initialize() is called (or an
RuntimeError will be thrown). If Initialize() is not called, an
exception will be thrown when attempting to call
IntegrateNoFurtherThanTime(). To reinitialize the integrator, Reset()
should be called followed by Initialize().

Raises:
    RuntimeError If the context has not been set or a user-set
    parameter has been set illogically (i.e., one of the weighting
    matrix coefficients is set to a negative value- this check is only
    performed for integrators that support error estimation; the
    maximum step size is smaller than the minimum step size; the
    requested initial step size is outside of the interval [minimum
    step size, maximum step size]).

See also:
    Reset())""";
        } Initialize;
        // Symbol: drake::systems::IntegratorBase::IntegrateNoFurtherThanTime
        struct /* IntegrateNoFurtherThanTime */ {
          // Source: drake/systems/analysis/integrator_base.h:979
          const char* doc =
R"""((Internal use only) Integrates the system forward in time by a single
step with step size subject to integration error tolerances (assuming
that the integrator supports error estimation). The integrator must
already have been initialized or an exception will be thrown. The
context will be integrated to a time that will never exceed the
minimum of ``publish_time``, `update_time`, and the current time plus
``1.01 * get_maximum_step_size()``.

Parameter ``publish_time``:
    The present or future time (exception will be thrown if this is
    not the case) at which the next publish will occur.

Parameter ``update_time``:
    The present or future time (exception will be thrown if this is
    not the case) at which the next update will occur.

Parameter ``boundary_time``:
    The present or future time (exception will be thrown if this is
    not the case) marking the end of the user-designated simulated
    interval.

Raises:
    RuntimeError If the integrator has not been initialized or one of
    publish_time, update_time, or boundary_time is in the past.

Returns:
    The reason for the integration step ending.

Postcondition:
    The time in the context will be no greater than
    ``min(publish_time, update_time, boundary_time)``.

Warning:
    Users should generally not call this function directly; within
    simulation circumstances, users will typically call
    ``Simulator::AdvanceTo()``. In other circumstances, users will
    typically call
    ``IntegratorBase::IntegrateWithMultipleStepsToTime()``.

This method at a glance: - For integrating ODEs/DAEs via Simulator -
Supports fixed step and variable step integration schemes - Takes only
a single step forward.)""";
        } IntegrateNoFurtherThanTime;
        // Symbol: drake::systems::IntegratorBase::IntegrateWithMultipleStepsToTime
        struct /* IntegrateWithMultipleStepsToTime */ {
          // Source: drake/systems/analysis/integrator_base.h:1006
          const char* doc =
R"""(Stepping function for integrators operating outside of Simulator that
advances the continuous state exactly to ``t_final``. This method is
designed for integrator users that do not wish to consider publishing
or discontinuous, mid-interval updates. This method will step the
integrator multiple times, as necessary, to attain requested error
tolerances and to ensure the integrator converges.

Warning:
    Users should simulate systems using ``Simulator::AdvanceTo()`` in
    place of this function (which was created for off-simulation
    purposes), generally.

Parameter ``t_final``:
    The current or future time to integrate to.

Raises:
    RuntimeError If the integrator has not been initialized or t_final
    is in the past.

See also:
    IntegrateNoFurtherThanTime(), which is designed to be operated by
    Simulator and accounts for publishing and state reinitialization.

See also:
    IntegrateWithSingleFixedStepToTime(), which is also designed to be
    operated *outside of* Simulator, but throws an exception if the
    integrator cannot advance time to ``t_final`` in a single step.

This method at a glance: - For integrating ODEs/DAEs not using
Simulator - Supports fixed step and variable step integration schemes
- Takes as many steps as necessary until time has advanced to
``t_final``)""";
        } IntegrateWithMultipleStepsToTime;
        // Symbol: drake::systems::IntegratorBase::IntegrateWithSingleFixedStepToTime
        struct /* IntegrateWithSingleFixedStepToTime */ {
          // Source: drake/systems/analysis/integrator_base.h:1053
          const char* doc =
R"""(Stepping function for integrators operating outside of Simulator that
advances the continuous state *using a single step* to ``t_target``.
This method is designed for integrator users that do not wish to
consider publishing or discontinuous, mid-interval updates. One such
example application is that of direct transcription for trajectory
optimization, for which the integration process should be
*consistent*: it should execute the same sequence of arithmetic
operations for all values of the nonlinear programming variables. In
keeping with the naming semantics of this function, error controlled
integration is not supported (though error estimates will be computed
for integrators that support that feature), which is a minimal
requirement for "consistency".

Warning:
    Users should simulate systems using ``Simulator::AdvanceTo()`` in
    place of this function (which was created for off-simulation
    purposes), generally.

Parameter ``t_target``:
    The current or future time to integrate to.

Raises:
    RuntimeError If the integrator has not been initialized or
    ``t_target`` is in the past or the integrator is not operating in
    fixed step mode.

See also:
    IntegrateNoFurtherThanTime(), which is designed to be operated by
    Simulator and accounts for publishing and state reinitialization.

See also:
    IntegrateWithMultipleStepsToTime(), which is also designed to be
    operated *outside of* Simulator, but will take as many integration
    steps as necessary until time has been stepped forward to
    ``t_target``.

Returns:
    ``True`` if the integrator was able to take a single fixed step to
    ``t_target``.

This method at a glance:

- For integrating ODEs/DAEs not using Simulator
- Fixed step integration (no step size reductions for error control or
integrator convergence)
- Takes only a single step forward.)""";
        } IntegrateWithSingleFixedStepToTime;
        // Symbol: drake::systems::IntegratorBase::IntegratorBase<T>
        struct /* ctor */ {
          // Source: drake/systems/analysis/integrator_base.h:169
          const char* doc =
R"""(Maintains references to the system being integrated and the context
used to specify the initial conditions for that system (if any).

Parameter ``system``:
    A reference to the system to be integrated; the integrator will
    maintain a reference to the system in perpetuity, so the
    integrator must not outlive the system.

Parameter ``context``:
    A pointer to a writeable context (nullptr is ok, but a non-null
    pointer must be set before Initialize() is called). The integrator
    will advance the system state using the pointer to this context.
    The pointer to the context will be maintained internally. The
    integrator must not outlive the context.)""";
        } ctor;
        // Symbol: drake::systems::IntegratorBase::Reset
        struct /* Reset */ {
          // Source: drake/systems/analysis/integrator_base.h:851
          const char* doc =
R"""(Resets the integrator to initial values, i.e., default construction
values.)""";
        } Reset;
        // Symbol: drake::systems::IntegratorBase::ResetStatistics
        struct /* ResetStatistics */ {
          // Source: drake/systems/analysis/integrator_base.h:1098
          const char* doc =
R"""(@name Integrator statistics methods These methods allow the caller to
manipulate and query integrator statistics. Generally speaking, the
larger the integration step taken, the faster a simulation will run.
These methods allow querying (and resetting) the integrator statistics
as one means of determining how to make a simulation run faster.

Forget accumulated statistics. These are reset to the values they have
post construction or immediately after ``Initialize()``.)""";
        } ResetStatistics;
        // Symbol: drake::systems::IntegratorBase::StartDenseIntegration
        struct /* StartDenseIntegration */ {
          // Source: drake/systems/analysis/integrator_base.h:1241
          const char* doc =
R"""(Starts dense integration, allocating a new dense output for this
integrator to use.

Precondition:
    The integrator has been initialized.

Precondition:
    The system being integrated has continuous state.

Precondition:
    No dense integration is in progress (no dense output is held by
    the integrator)

Raises:
    RuntimeError if any of the preconditions is not met.

Warning:
    Dense integration may incur significant overhead.)""";
        } StartDenseIntegration;
        // Symbol: drake::systems::IntegratorBase::StepOnceErrorControlledAtMost
        struct /* StepOnceErrorControlledAtMost */ {
          // Source: drake/systems/analysis/integrator_base.h:1375
          const char* doc =
R"""(Default code for advancing the continuous state of the system by a
single step of ``h_max`` (or smaller, depending on error control).
This particular function is designed to be called directly by an error
estimating integrator's DoStep() method to effect error-controlled
integration. The integrator can effect error controlled integration
without calling this method, if the implementer so chooses, but this
default method is expected to function well in most circumstances.

Parameter ``h_max``:
    The maximum step size to be taken. The integrator may take a
    smaller step than specified to satisfy accuracy requirements, to
    resolve integrator convergence problems, or to respect the
    integrator's maximum step size.

Raises:
    RuntimeError if integrator does not support error estimation.

Note:
    This function will shrink the integration step as necessary
    whenever the integrator's DoStep() fails to take the requested
    step e.g., due to integrator convergence failure.

Returns:
    ``True`` if the full step of size ``h_max`` is taken and ``False``
    otherwise (i.e., a smaller step than ``h_max`` was taken).)""";
        } StepOnceErrorControlledAtMost;
        // Symbol: drake::systems::IntegratorBase::StepResult
        struct /* StepResult */ {
          // Source: drake/systems/analysis/integrator_base.h:140
          const char* doc =
R"""(Status returned by IntegrateNoFurtherThanTime(). When a step is
successful, it will return an indication of what caused it to stop
where it did. When unsuccessful it will throw an exception so you
won't see any return value. When return of control is due ONLY to
reaching a publish time, (status is kReachedPublishTime) the context
may return an interpolated value at an earlier time.

Note:
    the simulation step must always end at an update time but can end
    after a publish time.)""";
          // Symbol: drake::systems::IntegratorBase::StepResult::kReachedBoundaryTime
          struct /* kReachedBoundaryTime */ {
            // Source: drake/systems/analysis/integrator_base.h:150
            const char* doc =
R"""(Reached the desired integration time without reaching an update time.)""";
          } kReachedBoundaryTime;
          // Symbol: drake::systems::IntegratorBase::StepResult::kReachedPublishTime
          struct /* kReachedPublishTime */ {
            // Source: drake/systems/analysis/integrator_base.h:142
            const char* doc =
R"""(Indicates a publish time has been reached but not an update time.)""";
          } kReachedPublishTime;
          // Symbol: drake::systems::IntegratorBase::StepResult::kReachedStepLimit
          struct /* kReachedStepLimit */ {
            // Source: drake/systems/analysis/integrator_base.h:153
            const char* doc =
R"""(Took maximum number of steps without finishing integrating over the
interval.)""";
          } kReachedStepLimit;
          // Symbol: drake::systems::IntegratorBase::StepResult::kReachedUpdateTime
          struct /* kReachedUpdateTime */ {
            // Source: drake/systems/analysis/integrator_base.h:146
            const char* doc =
R"""(Indicates that integration terminated at an update time.)""";
          } kReachedUpdateTime;
          // Symbol: drake::systems::IntegratorBase::StepResult::kReachedZeroCrossing
          struct /* kReachedZeroCrossing */ {
            // Source: drake/systems/analysis/integrator_base.h:144
            const char* doc =
R"""(Localized an event; this is the *before* state (interpolated).)""";
          } kReachedZeroCrossing;
          // Symbol: drake::systems::IntegratorBase::StepResult::kTimeHasAdvanced
          struct /* kTimeHasAdvanced */ {
            // Source: drake/systems/analysis/integrator_base.h:148
            const char* doc =
R"""(User requested control whenever an internal step is successful.)""";
          } kTimeHasAdvanced;
        } StepResult;
        // Symbol: drake::systems::IntegratorBase::StopDenseIntegration
        struct /* StopDenseIntegration */ {
          // Source: drake/systems/analysis/integrator_base.h:1282
          const char* doc =
R"""(Stops dense integration, yielding ownership of the current dense
output to the caller.

Remark:
    This process is irreversible.

Returns:
    A PiecewisePolynomial instance, i.e. a representation of the
    continuous state trajectory of the system being integrated that
    can be evaluated at any time within its extension. This
    representation is defined starting at the context time of the last
    StartDenseIntegration() call and finishing at the current context
    time.

Precondition:
    Dense integration is in progress (a dense output is held by this
    integrator, after a call to StartDenseIntegration()).

Postcondition:
    Previously held dense output is not updated nor referenced by the
    integrator anymore.

Raises:
    RuntimeError if any of the preconditions is not met.)""";
        } StopDenseIntegration;
        // Symbol: drake::systems::IntegratorBase::add_derivative_evaluations
        struct /* add_derivative_evaluations */ {
          // Source: drake/systems/analysis/integrator_base.h:1183
          const char* doc =
R"""(Manually increments the statistic for the number of ODE evaluations.

Warning:
    Implementations should generally avoid calling this method;
    evaluating the ODEs using EvalTimeDerivatives() updates this
    statistic automatically and intelligently (by leveraging the
    caching system to avoid incrementing the count when cached
    evaluations are used).)""";
        } add_derivative_evaluations;
        // Symbol: drake::systems::IntegratorBase::get_accuracy_in_use
        struct /* get_accuracy_in_use */ {
          // Source: drake/systems/analysis/integrator_base.h:240
          const char* doc =
R"""(Gets the accuracy in use by the integrator. This number may differ
from the target accuracy if, for example, the user has requested an
accuracy not attainable or not recommended for the particular
integrator.)""";
        } get_accuracy_in_use;
        // Symbol: drake::systems::IntegratorBase::get_actual_initial_step_size_taken
        struct /* get_actual_initial_step_size_taken */ {
          // Source: drake/systems/analysis/integrator_base.h:1148
          const char* doc =
R"""(The actual size of the successful first step.)""";
        } get_actual_initial_step_size_taken;
        // Symbol: drake::systems::IntegratorBase::get_context
        struct /* get_context */ {
          // Source: drake/systems/analysis/integrator_base.h:1191
          const char* doc =
R"""(Returns a const reference to the internally-maintained Context holding
the most recent state in the trajectory. This is suitable for
publishing or extracting information about this trajectory step.)""";
        } get_context;
        // Symbol: drake::systems::IntegratorBase::get_dense_output
        struct /* get_dense_output */ {
          // Source: drake/systems/analysis/integrator_base.h:1261
          const char* doc =
R"""(Returns a const pointer to the integrator's current
PiecewisePolynomial instance, holding a representation of the
continuous state trajectory since the last StartDenseIntegration()
call. This is suitable to query the integrator's current dense output,
if any (may be nullptr).)""";
        } get_dense_output;
        // Symbol: drake::systems::IntegratorBase::get_error_estimate
        struct /* get_error_estimate */ {
          // Source: drake/systems/analysis/integrator_base.h:300
          const char* doc =
R"""(Gets the error estimate (used only for integrators that support error
estimation). If the integrator does not support error estimation,
nullptr is returned.)""";
        } get_error_estimate;
        // Symbol: drake::systems::IntegratorBase::get_error_estimate_order
        struct /* get_error_estimate_order */ {
          // Source: drake/systems/analysis/integrator_base.h:293
          const char* doc =
R"""(Derived classes must override this function to return the order of the
asymptotic term in the integrator's error estimate. An error estimator
approximates the truncation error in an integrator's solution. That
truncation error e(.) is approximated by a Taylor Series expansion in
the neighborhood around t:


::

    e(t+h) ≈ e(t) + he(t) + he'(t) + ½h²e''(t) + ...
    ≈ e(t) + he(t) + he'(t) + ½h²e''(t) + O(h³)

where we have replaced the "..." with the asymptotic error of all
terms truncated from the series.

Implementions should return the order of the asymptotic term in the
Taylor Series expansion around the expression for the error. For an
integrator that propagates a second-order solution and provides an
estimate of the error using an embedded first-order method, this
method should return "2", as can be seen in the derivation below,
using y* as the true solution:


::

    y̅ = y* + O(h³)   [second order solution]
    ŷ = y* + O(h²)   [embedded first-order method]
    e = (y̅ - ŷ) = O(h²)

If the integrator does not provide an error estimate, the derived
class implementation should return 0.)""";
        } get_error_estimate_order;
        // Symbol: drake::systems::IntegratorBase::get_fixed_step_mode
        struct /* get_fixed_step_mode */ {
          // Source: drake/systems/analysis/integrator_base.h:335
          const char* doc =
R"""(Gets whether an integrator is running in fixed step mode. If the
integrator does not support error estimation, this function will
always return ``True``.

See also:
    set_fixed_step_mode())""";
        } get_fixed_step_mode;
        // Symbol: drake::systems::IntegratorBase::get_generalized_state_weight_vector
        struct /* get_generalized_state_weight_vector */ {
          // Source: drake/systems/analysis/integrator_base.h:543
          const char* doc =
R"""(@name Methods for weighting state variable errors \ (in the context of
error control) @anchor weighting-state-errors This group of methods
describes how errors for state variables with heterogeneous units are
weighted in the context of error-controlled integration. This is an
advanced topic and most users can simply specify desired accuracy and
accept the default state variable weights.

A collection of state variables is generally defined in heterogeneous
units (e.g. length, angles, velocities, energy). Some of the state
variables cannot even be expressed in meaningful units, like
quaternions. Certain integrators provide an estimate of the absolute
error made in each state variable during an integration step. These
errors must be properly weighted to obtain an "accuracy" *with respect
to each particular variable*. These per-variable accuracy
determinations can be compared against the user's requirements and
used to select an appropriate size for the next step [Sherman 2011].
The weights are normally determined automatically using the system's
characteristic dimensions, so *most users can stop reading now!*
Custom weighting is primarily useful for performance improvement; an
optimal weighting would allow an error-controlled integrator to
provide the desired level of accuracy across all state variables
without wasting computation achieving superfluous accuracy for some of
those variables.

Users interested in more precise control over state variable weighting
may use the methods in this group to access and modify weighting
factors for individual state variables. Changes to these weights can
only be made prior to integrator initialization or as a result of an
event being triggered and then followed by re-initialization.

*Relative versus absolute accuracy*:

State variable integration error, as estimated by an integrator, is an
absolute quantity with the same units as the variable. At each time
step we therefore need to determine an absolute error that would be
deemed "good enough", i.e. satisfies the user's accuracy requirement.
If a variable is maintained to a *relative* accuracy then that "good
enough" value is defined to be the required accuracy ``a`` (a fraction
like 0.001) times the current value of the variable, as long as that
value is far from zero. For variables maintained to an *absolute*
accuracy, or relative variables that are at or near zero (where
relative accuracy would be undefined or too strict, respectively), we
need a different way to determine the "good enough" absolute error.
The methods in this section control how that absolute error value is
calculated.

*How to choose weights*:

The weight ``wᵢ`` for a state variable ``xᵢ`` should be chosen so that
the product ``wᵢ * dxᵢ`` is unitless, and in particular is 1 when
``dxᵢ`` represents a "unit effect" of state variable ``xᵢ``; that is,
the change in ``xᵢ`` that produces a unit change in some quantity of
interest in the system being simulated. Why unity (1)? Aside from
normalizing the values, unity "grounds" the weighted error to the
user-specified accuracy. A weighting can be applied individually to
each state variable, but typically it is done approximately by
combining the known type of the variable (e.g. length, angle) with a
"characteristic scale" for that quantity. For example, if a
"characteristic length" for the system being simulated is 0.1 meters,
and ``x₀`` is a length variable measured in meters, then ``w₀`` should
be 10 so that ``w₀*dx₀=1`` when ``dx₀=0.1``. For angles representing
pointing accuracy (say a camera direction) we typically assume a
"characteristic angle" is one radian (about 60 degrees), so if x₁ is a
pointing direction then w₁=1 is an appropriate weight. We can now
scale an error vector ``e=[dx₀ dx₁]`` to a unitless fractional error
vector ``f=[w₀*dx₀ w₁*dx₁]``. Now to achieve a given accuracy ``a``,
say ``a=.0001``, we need only check that ``|fᵢ|<=a`` for each element
``i`` of ``f``. Further, this gives us a quantitative measure of
"worst accuracy" that we can use to increase or reduce size of the
next attempted step, so that we will just achieve the required
accuracy but not much more. We'll be more precise about this below.

*Some subtleties for second-order dynamic systems*:

Systems governed by 2nd-order differential equations are typically
split into second order (configuration) variables q, and rate
(velocity) variables v, where the time derivatives qdot of q are
linearly related to v by the kinematic differential equation ``qdot =
dq/dt = N(q)*v``. Velocity variables are chosen to be physically
significant, but configuration variables may be chosen for convenience
and do not necessarily have direct physical interpretation. For
examples, quaternions are chosen as a numerically stable orientation
representation. This is problematic for choosing weights which must be
done by physical reasoning as sketched above. We resolve this by
introducing the notion of "quasi-coordinates" ꝗ (pronounced "qbar")
which are defined by the equation ``ꝗdot = dꝗ/dt = v``. Other than
time scaling, quasi-coordinates have the same units as their
corresponding velocity variables. That is, for weighting we need to
think of the configuration coordinates in the same physical space as
the velocity variables; weight those by their physical significance;
and then map back to an instantaneous weighting on the actual
configuration variables q. This mapping is performed automatically;
you need only to be concerned about physical weightings.

Note that generalized quasi-coordinates ``ꝗ`` can only be defined
locally for a particular configuration ``q``. There is in general no
meaningful set of ``n`` generalized coordinates which can be
differentiated with respect to time to yield ``v``. For example, the
Hairy Ball Theorem implies that it is not possible for three
orientation variables to represent all 3D rotations without
singularities, yet three velocity variables can represent angular
velocity in 3D without singularities.

To summarize, separate weights can be provided for each of - ``n``
generalized quasi-coordinates ``ꝗ`` (configuration variables in the
velocity variable space), and - ``nz`` miscellaneous continuous state
variables ``z``.

Weights on the generalized velocity variables ``v (= dꝗ/dt)`` are
derived directly from the weights on ``ꝗ``, weighted by a
characteristic time. Weights on the actual ``nq`` generalized
coordinates can be calculated efficiently from weights on the
quasi-coordinates (details below).

*How the weights are used*:

The errors in the ``ꝗ`` and ``z`` variables are weighted by the
diagonal elements of diagonal weighting matrices Wꝗ and Wz,
respectively. (The block-diagonal weighting matrix ``Wq`` on the
original generalized coordinates ``q`` is calculated from ``N`` and
``Wꝗ``; see below.) In the absence of other information, the default
for all weighting values is one, so ``Wꝗ`` and ``Wz`` are ``n × n``
and ``nz × nz`` identity matrices. The weighting matrix ``Wv`` for the
velocity variables is just ``Wv = τ*Wꝗ`` where ``τ`` is a
"characteristic time" for the system, that is, a quantity in time
units that represents a significant evolution of the trajectory. This
serves to control the accuracy with which velocity is determined
relative to configuration. Note that larger values of ``τ`` are more
conservative since they increase the velocity weights. Typically we
use ``τ=1.0`` or ``0.1`` seconds for human-scale mechanical systems.

The weighting matrices ``Wq``, `Wv`, and ``Wz`` are used to compute a
weighted infinity norm as follows. Although ``Wv`` and ``Wz`` are
constant, the actual weightings may be state dependent for
relative-error calculations. Define block diagonal error weighting
matrix ``E=diag(Eq,Ev,Ez)`` as follows:


::

    Eq = Wq
    Ev: Ev(i,i) = { min(Wv(i,i), 1/|vᵢ|)     if vᵢ is relative
    { Wv(i,i)                  if vᵢ is absolute
    Ez: Ez(i,i) = { min(Wz(i,i), 1/|zᵢ|)     if zᵢ is relative
    { Wz(i,i)                  if zᵢ is absolute

(``Ev`` and ``Ez`` are diagonal.) A ``v`` or ``z`` will be maintained
to relative accuracy unless (a) it is "close" to zero (less than 1),
or (b) the variable has been defined as requiring absolute accuracy.
Position variables ``q`` are always maintained to absolute accuracy
(see [Sherman 2011] for rationale).

Now given an error estimate vector ``e=[eq ev ez]``, the vector
``f=E*e`` can be considered to provide a unitless fractional error for
each of the state variables. To achieve a given user-specified
accuracy ``a``, we require that norm_inf(``f``) <= ``a``. That is, no
element of ``f`` can have absolute value larger than ``a``. We also
use ``f`` to determine an ideal next step size using an appropriate
integrator-specific computation.

*Determining weights for q*:

The kinematic differential equations ``qdot=N(q)*v`` employ an ``nq ×
n`` matrix ``N``. By construction, this relationship is invertible
using ``N`'s left pseudo-inverse `N⁺`` so that ``v=N⁺ qdot`` and ``N⁺
N = I`` (the identity matrix); however, ``N N⁺ != I``, as ``N`` has
more rows than columns generally. [Nikravesh 1988] shows how such a
matrix ``N`` can be determined and provides more information. Given
this relationship between ``N`` and ``N⁺``, we can relate weighted
errors in configuration coordinates ``q`` to weighted errors in
generalized quasi-coordinates ``ꝗ``, as the following derivation
shows:


::

    v = N⁺ qdot         Inverse kinematic differential equation
    dꝗ/dt = N⁺ dq/dt        Use synonyms for v and qdot
    dꝗ = N⁺ dq           Change time derivatives to differentials
    Wꝗ dꝗ = Wꝗ N⁺ dq        Pre-multiply both sides by Wꝗ
    N Wꝗ dꝗ = N Wꝗ N⁺ dq      Pre-multiply both sides by N
    N Wꝗ dꝗ = Wq dq           Define Wq := N Wꝗ N⁺
    N Wꝗ v = Wq qdot         Back to time derivatives.

The last two equations show that ``Wq`` as defined above provides the
expected relationship between the weighted ``ꝗ`` or ``v`` variables in
velocity space and the weighted ``q`` or ``qdot`` (resp.) variables in
configuration space.

Finally, note that a diagonal entry of one of the weighting matrices
can be set to zero to disable error estimation for that state variable
(i.e., auxiliary variable or configuration/velocity variable pair),
but that setting an entry to a negative value will cause an exception
to be thrown when the integrator is initialized.

- [Nikravesh 1988] P. Nikravesh. Computer-Aided  Analysis of Mechanical
Systems. Prentice Hall, 1988. Sec. 6.3.
- [Sherman 2011]   M. Sherman, et al. Procedia IUTAM 2:241-261 (2011),
Section 3.3.
http://dx.doi.org/10.1016/j.piutam.2011.04.023

See also:
    CalcStateChangeNorm()

Gets the weighting vector (equivalent to a diagonal matrix) applied to
weighting both generalized coordinate and velocity state variable
errors, as described in the group documentation. Only used for
integrators that support error estimation.)""";
        } get_generalized_state_weight_vector;
        // Symbol: drake::systems::IntegratorBase::get_ideal_next_step_size
        struct /* get_ideal_next_step_size */ {
          // Source: drake/systems/analysis/integrator_base.h:310
          const char* doc =
R"""(Return the step size the integrator would like to take next, based
primarily on the integrator's accuracy prediction. This value will not
be computed for integrators that do not support error estimation and
NaN will be returned.)""";
        } get_ideal_next_step_size;
        // Symbol: drake::systems::IntegratorBase::get_initial_step_size_target
        struct /* get_initial_step_size_target */ {
          // Source: drake/systems/analysis/integrator_base.h:671
          const char* doc =
R"""(Gets the target size of the first integration step. You can find out
what step size was *actually* used for the first integration step with
``get_actual_initial_step_size_taken()``.

See also:
    request_initial_step_size_target())""";
        } get_initial_step_size_target;
        // Symbol: drake::systems::IntegratorBase::get_largest_step_size_taken
        struct /* get_largest_step_size_taken */ {
          // Source: drake/systems/analysis/integrator_base.h:1166
          const char* doc =
R"""(The size of the largest step taken since the last Initialize() or
ResetStatistics() call.)""";
        } get_largest_step_size_taken;
        // Symbol: drake::systems::IntegratorBase::get_maximum_step_size
        struct /* get_maximum_step_size */ {
          // Source: drake/systems/analysis/integrator_base.h:707
          const char* doc =
R"""(Gets the maximum step size that may be taken by this integrator. This
is a soft maximum: the integrator may stretch it by as much as 1% to
hit a discrete event.

See also:
    set_requested_minimum_step_size())""";
        } get_maximum_step_size;
        // Symbol: drake::systems::IntegratorBase::get_misc_state_weight_vector
        struct /* get_misc_state_weight_vector */ {
          // Source: drake/systems/analysis/integrator_base.h:570
          const char* doc =
R"""(Gets the weighting vector (equivalent to a diagonal matrix) for
weighting errors in miscellaneous continuous state variables ``z``.
Only used for integrators that support error estimation.)""";
        } get_misc_state_weight_vector;
        // Symbol: drake::systems::IntegratorBase::get_mutable_context
        struct /* get_mutable_context */ {
          // Source: drake/systems/analysis/integrator_base.h:1197
          const char* doc =
R"""(Returns a mutable pointer to the internally-maintained Context holding
the most recent state in the trajectory.)""";
        } get_mutable_context;
        // Symbol: drake::systems::IntegratorBase::get_mutable_dense_output
        struct /* get_mutable_dense_output */ {
          // Source: drake/systems/analysis/integrator_base.h:1439
          const char* doc =
R"""(Returns a mutable pointer to the internally-maintained
PiecewisePolynomial instance, holding a representation of the
continuous state trajectory since the last time
StartDenseIntegration() was called. This is useful for derived classes
to update the integrator's current dense output, if any (may be
nullptr).)""";
        } get_mutable_dense_output;
        // Symbol: drake::systems::IntegratorBase::get_mutable_error_estimate
        struct /* get_mutable_error_estimate */ {
          // Source: drake/systems/analysis/integrator_base.h:1524
          const char* doc =
R"""(Gets an error estimate of the state variables recorded by the last
call to StepOnceFixedSize(). If the integrator does not support error
estimation, this function will return nullptr.)""";
        } get_mutable_error_estimate;
        // Symbol: drake::systems::IntegratorBase::get_mutable_generalized_state_weight_vector
        struct /* get_mutable_generalized_state_weight_vector */ {
          // Source: drake/systems/analysis/integrator_base.h:560
          const char* doc =
R"""(Gets a mutable weighting vector (equivalent to a diagonal matrix)
applied to weighting both generalized coordinate and velocity state
variable errors, as described in the group documentation. Only used
for integrators that support error estimation. Returns a VectorBlock
to make the values mutable without permitting changing the size of the
vector. Requires re-initializing the integrator after calling this
method; if Initialize() is not called afterward, an exception will be
thrown when attempting to call IntegrateNoFurtherThanTime(). If the
caller sets one of the entries to a negative value, an exception will
be thrown when the integrator is initialized.)""";
        } get_mutable_generalized_state_weight_vector;
        // Symbol: drake::systems::IntegratorBase::get_mutable_misc_state_weight_vector
        struct /* get_mutable_misc_state_weight_vector */ {
          // Source: drake/systems/analysis/integrator_base.h:585
          const char* doc =
R"""(Gets a mutable weighting vector (equivalent to a diagonal matrix) for
weighting errors in miscellaneous continuous state variables ``z``.
Only used for integrators that support error estimation. Returns a
VectorBlock to make the values mutable without permitting changing the
size of the vector. Requires re-initializing the integrator after
calling this method. If Initialize() is not called afterward, an
exception will be thrown when attempting to call
IntegrateNoFurtherThanTime(). If the caller sets one of the entries to
a negative value, an exception will be thrown when the integrator is
initialized.)""";
        } get_mutable_misc_state_weight_vector;
        // Symbol: drake::systems::IntegratorBase::get_num_derivative_evaluations
        struct /* get_num_derivative_evaluations */ {
          // Source: drake/systems/analysis/integrator_base.h:1143
          const char* doc =
R"""(Returns the number of ODE function evaluations (calls to
CalcTimeDerivatives()) since the last call to ResetStatistics() or
Initialize(). This count includes *all* such calls including (1) those
necessary to compute Jacobian matrices; (2) those used in rejected
integrated steps (for, e.g., purposes of error control); (3) those
used strictly for integrator error estimation; and (4) calls that
exhibit little cost (due to results being cached).)""";
        } get_num_derivative_evaluations;
        // Symbol: drake::systems::IntegratorBase::get_num_step_shrinkages_from_error_control
        struct /* get_num_step_shrinkages_from_error_control */ {
          // Source: drake/systems/analysis/integrator_base.h:1130
          const char* doc =
R"""(Gets the number of step size shrinkages due to failure to meet
targeted error tolerances, since the last call to ResetStatistics or
Initialize().)""";
        } get_num_step_shrinkages_from_error_control;
        // Symbol: drake::systems::IntegratorBase::get_num_step_shrinkages_from_substep_failures
        struct /* get_num_step_shrinkages_from_substep_failures */ {
          // Source: drake/systems/analysis/integrator_base.h:1124
          const char* doc =
R"""(Gets the number of step size shrinkages due to sub-step failures
(e.g., integrator convergence failures) since the last call to
ResetStatistics() or Initialize().)""";
        } get_num_step_shrinkages_from_substep_failures;
        // Symbol: drake::systems::IntegratorBase::get_num_steps_taken
        struct /* get_num_steps_taken */ {
          // Source: drake/systems/analysis/integrator_base.h:1174
          const char* doc =
R"""(The number of integration steps taken since the last Initialize() or
ResetStatistics() call.)""";
        } get_num_steps_taken;
        // Symbol: drake::systems::IntegratorBase::get_num_substep_failures
        struct /* get_num_substep_failures */ {
          // Source: drake/systems/analysis/integrator_base.h:1115
          const char* doc =
R"""(Gets the number of failed sub-steps (implying one or more step size
reductions was required to permit solving the necessary nonlinear
system of equations).)""";
        } get_num_substep_failures;
        // Symbol: drake::systems::IntegratorBase::get_previous_integration_step_size
        struct /* get_previous_integration_step_size */ {
          // Source: drake/systems/analysis/integrator_base.h:1303
          const char* doc =
R"""(Gets the size of the last (previous) integration step. If no
integration steps have been taken, value will be NaN.)""";
        } get_previous_integration_step_size;
        // Symbol: drake::systems::IntegratorBase::get_requested_minimum_step_size
        struct /* get_requested_minimum_step_size */ {
          // Source: drake/systems/analysis/integrator_base.h:806
          const char* doc =
R"""(Gets the requested minimum step size ``h_min`` for this integrator.

See also:
    set_requested_minimum_step_size()

See also:
    get_working_minimum_step_size(T))""";
        } get_requested_minimum_step_size;
        // Symbol: drake::systems::IntegratorBase::get_smallest_adapted_step_size_taken
        struct /* get_smallest_adapted_step_size_taken */ {
          // Source: drake/systems/analysis/integrator_base.h:1158
          const char* doc =
R"""(The size of the smallest step taken *as the result of a controlled
integration step adjustment* since the last Initialize() or
ResetStatistics() call. This value will be NaN for integrators without
error estimation.)""";
        } get_smallest_adapted_step_size_taken;
        // Symbol: drake::systems::IntegratorBase::get_stretch_factor
        struct /* get_stretch_factor */ {
          // Source: drake/systems/analysis/integrator_base.h:717
          const char* doc =
R"""(Gets the stretch factor (> 1), which is multiplied by the maximum
(typically user-designated) integration step size to obtain the amount
that the integrator is able to stretch the maximum time step toward
hitting an upcoming publish or update event in
IntegrateNoFurtherThanTime().

See also:
    IntegrateNoFurtherThanTime())""";
        } get_stretch_factor;
        // Symbol: drake::systems::IntegratorBase::get_system
        struct /* get_system */ {
          // Source: drake/systems/analysis/integrator_base.h:1294
          const char* doc =
R"""(Gets a constant reference to the system that is being integrated (and
was provided to the constructor of the integrator).)""";
        } get_system;
        // Symbol: drake::systems::IntegratorBase::get_target_accuracy
        struct /* get_target_accuracy */ {
          // Source: drake/systems/analysis/integrator_base.h:233
          const char* doc =
R"""(Gets the target accuracy.

See also:
    get_accuracy_in_use())""";
        } get_target_accuracy;
        // Symbol: drake::systems::IntegratorBase::get_throw_on_minimum_step_size_violation
        struct /* get_throw_on_minimum_step_size_violation */ {
          // Source: drake/systems/analysis/integrator_base.h:826
          const char* doc =
R"""(Reports the current setting of the
throw_on_minimum_step_size_violation flag.

See also:
    set_throw_on_minimum_step_size_violation().)""";
        } get_throw_on_minimum_step_size_violation;
        // Symbol: drake::systems::IntegratorBase::get_working_minimum_step_size
        struct /* get_working_minimum_step_size */ {
          // Source: drake/systems/analysis/integrator_base.h:836
          const char* doc =
R"""(Gets the current value of the working minimum step size ``h_work(t)``
for this integrator, which may vary with the current time t as stored
in the integrator's context. See integrator-minstep "this section" for
more detail.)""";
        } get_working_minimum_step_size;
        // Symbol: drake::systems::IntegratorBase::is_initialized
        struct /* is_initialized */ {
          // Source: drake/systems/analysis/integrator_base.h:1297
          const char* doc =
R"""(Indicates whether the integrator has been initialized.)""";
        } is_initialized;
        // Symbol: drake::systems::IntegratorBase::request_initial_step_size_target
        struct /* request_initial_step_size_target */ {
          // Source: drake/systems/analysis/integrator_base.h:656
          const char* doc =
R"""(Request that the first attempted integration step have a particular
size. If no request is made, the integrator will estimate a suitable
size for the initial step attempt. *If the integrator does not support
error control*, this method will throw a RuntimeError (call
supports_error_estimation() to verify before calling this method). For
variable-step integration, the initial target will be treated as a
maximum step size subject to accuracy requirements and event
occurrences. You can find out what size *actually* worked with
``get_actual_initial_step_size_taken()``.

Raises:
    RuntimeError If the integrator does not support error estimation.)""";
        } request_initial_step_size_target;
        // Symbol: drake::systems::IntegratorBase::reset_context
        struct /* reset_context */ {
          // Source: drake/systems/analysis/integrator_base.h:1208
          const char* doc =
R"""(Replace the pointer to the internally-maintained Context with a
different one. This is useful for supplying a new set of initial
conditions or wiping out the current context (by passing in a null
pointer). You should invoke Initialize() after replacing the Context
unless the context is null.

Parameter ``context``:
    The pointer to the new context or nullptr to wipe out the current
    context without replacing it with another.)""";
        } reset_context;
        // Symbol: drake::systems::IntegratorBase::set_accuracy_in_use
        struct /* set_accuracy_in_use */ {
          // Source: drake/systems/analysis/integrator_base.h:1353
          const char* doc =
R"""(Sets the working ("in use") accuracy for this integrator. The working
accuracy may not be equivalent to the target accuracy when the latter
is too loose or tight for an integrator's capabilities.

See also:
    get_accuracy_in_use()

See also:
    get_target_accuracy())""";
        } set_accuracy_in_use;
        // Symbol: drake::systems::IntegratorBase::set_actual_initial_step_size_taken
        struct /* set_actual_initial_step_size_taken */ {
          // Source: drake/systems/analysis/integrator_base.h:1527
          const char* doc = R"""()""";
        } set_actual_initial_step_size_taken;
        // Symbol: drake::systems::IntegratorBase::set_fixed_step_mode
        struct /* set_fixed_step_mode */ {
          // Source: drake/systems/analysis/integrator_base.h:324
          const char* doc =
R"""(Sets an integrator with error control to fixed step mode. If the
integrator runs in fixed step mode, it will always take the maximum
step size directed (which may be that determined by
get_maximum_step_size(), or may be smaller, as directed by, e.g.,
Simulator for event handling purposes).

Warning:
    The error estimation process will still be active (so
    get_error_estimate() will still return a correct result), meaning
    that the additional (typically, but not necessarily small)
    computation required for error estimation will still be performed.

Raises:
    RuntimeError if integrator does not support error estimation and
    ``flag`` is set to ``False``.)""";
        } set_fixed_step_mode;
        // Symbol: drake::systems::IntegratorBase::set_ideal_next_step_size
        struct /* set_ideal_next_step_size */ {
          // Source: drake/systems/analysis/integrator_base.h:1545
          const char* doc = R"""()""";
        } set_ideal_next_step_size;
        // Symbol: drake::systems::IntegratorBase::set_largest_step_size_taken
        struct /* set_largest_step_size_taken */ {
          // Source: drake/systems/analysis/integrator_base.h:1540
          const char* doc = R"""()""";
        } set_largest_step_size_taken;
        // Symbol: drake::systems::IntegratorBase::set_maximum_step_size
        struct /* set_maximum_step_size */ {
          // Source: drake/systems/analysis/integrator_base.h:695
          const char* doc =
R"""(@anchor integrator-maxstep @name Methods related to maximum
integration step size

Sets the *nominal* maximum step size- the actual maximum step size
taken may be slightly larger (see set_maximum_step_size() and
get_stretch_factor())- that an integrator will take. Each integrator
has a default maximum step size, which might be infinite. Sets the
maximum step size that may be taken by this integrator. This setting
should be used if you know the maximum time scale of your problem. The
integrator may stretch the maximum step size by as much as 1% to reach
a discrete event. For fixed step integrators, all steps will be taken
at the maximum step size *unless* an event would be missed.

Warning:
    See integrator-initial-step-size "Initial step size selection")""";
        } set_maximum_step_size;
        // Symbol: drake::systems::IntegratorBase::set_requested_minimum_step_size
        struct /* set_requested_minimum_step_size */ {
          // Source: drake/systems/analysis/integrator_base.h:796
          const char* doc =
R"""(Sets the requested minimum step size ``h_min`` that may be taken by
this integrator. No step smaller than this will be taken except under
circumstances as described integrator-minstep "above". This setting
will be ignored if it is smaller than the absolute minimum ``h_floor``
also described above. Default value is zero.

Parameter ``min_step_size``:
    a non-negative value. Setting this value to zero will cause the
    integrator to use a reasonable value instead (see
    get_working_minimum_step_size()).

See also:
    get_requested_minimum_step_size()

See also:
    get_working_minimum_step_size())""";
        } set_requested_minimum_step_size;
        // Symbol: drake::systems::IntegratorBase::set_smallest_adapted_step_size_taken
        struct /* set_smallest_adapted_step_size_taken */ {
          // Source: drake/systems/analysis/integrator_base.h:1535
          const char* doc =
R"""(Sets the size of the smallest-step-taken statistic as the result of a
controlled integration step adjustment.)""";
        } set_smallest_adapted_step_size_taken;
        // Symbol: drake::systems::IntegratorBase::set_target_accuracy
        struct /* set_target_accuracy */ {
          // Source: drake/systems/analysis/integrator_base.h:220
          const char* doc =
R"""(@anchor integrator-accuracy @name Methods for getting and setting
integrator accuracy The precise meaning of *accuracy* is a complicated
discussion, but it translates roughly to the number of significant
digits you want in the results. By convention it is supplied as
``10^-digits``, meaning that an accuracy of 1e-3 provides about three
significant digits. For more discussion of accuracy, see
accuracy_and_tolerance and ref. `[1]
<https://dx.doi.org/10.1016/j.piutam.2011.04.023>`_.

Integrators vary in the range of accuracy (loosest to tightest) that
they can support, and each integrator will choose a default accuracy
to be used that lies somewhere within this range and attempts to
balance computation and accuracy. If you request accuracy outside the
supported range for the chosen integrator it will be quietly adjusted
to be in range. You can find out the accuracy setting actually being
used using ``get_accuracy_in_use()``.

Implicit integrators additionally use the accuracy setting for
determining when the underlying Newton-Raphson root finding process
has converged. For those integrators, the accuracy setting also limits
the allowable iteration error in the Newton-Raphson process. Looser
accuracy in that process certainly implies greater error in the ODE
solution and might impact the stability of the solution negatively as
well.

- [1] M. Sherman, A. Seth, S. Delp. Procedia IUTAM 2:241-261 (2011),
Section 3.3. https://dx.doi.org/10.1016/j.piutam.2011.04.023

Request that the integrator attempt to achieve a particular accuracy
for the continuous portions of the simulation. Otherwise a default
accuracy is chosen for you. This may be ignored for fixed-step
integration since accuracy control requires variable step sizes. You
should call supports_error_estimation() to ensure that the integrator
supports this capability before calling this function; if the
integrator does not support it, this method will throw an exception.

Raises:
    RuntimeError if integrator does not support error estimation.)""";
        } set_target_accuracy;
        // Symbol: drake::systems::IntegratorBase::set_throw_on_minimum_step_size_violation
        struct /* set_throw_on_minimum_step_size_violation */ {
          // Source: drake/systems/analysis/integrator_base.h:817
          const char* doc =
R"""(Sets whether the integrator should throw a RuntimeError exception when
the integrator's step size selection algorithm determines that it must
take a step smaller than the minimum step size (for, e.g., purposes of
error control). Default is ``True``. If ``False``, the integrator will
advance time and state using the minimum specified step size in such
situations. See integrator-minstep "this section" for more detail.)""";
        } set_throw_on_minimum_step_size_violation;
        // Symbol: drake::systems::IntegratorBase::supports_error_estimation
        struct /* supports_error_estimation */ {
          // Source: drake/systems/analysis/integrator_base.h:264
          const char* doc =
R"""(@anchor error-estimation-and-control @name Methods related to error
estimation and control Established methods for integrating ordinary
differential equations invariably make provisions for estimating the
"local error" (i.e., the error over a small time interval) of a
solution. Although the relationship between local error and global
error (i.e., the accumulated error over multiple time steps) can be
tenuous, such error estimates can allow integrators to work
adaptively, subdividing time intervals as necessary (if, e.g., the
system is particularly dynamic or stationary in an interval). Even for
applications that do not recommend such adaptive integration- like
direct transcription methods for trajectory optimization- error
estimation allows the user to assess the accuracy of the solution.
Derived classes must override this function to indicate whether the
integrator supports error estimation. Without error estimation, the
target accuracy setting (see integrator-accuracy "accuracy settings")
will be unused.)""";
        } supports_error_estimation;
      } IntegratorBase;
      // Symbol: drake::systems::IsControllable
      struct /* IsControllable */ {
        // Source: drake/systems/primitives/linear_system.h:246
        const char* doc =
R"""(Returns true iff the controllability matrix is full row rank.)""";
      } IsControllable;
      // Symbol: drake::systems::IsObservable
      struct /* IsObservable */ {
        // Source: drake/systems/primitives/linear_system.h:255
        const char* doc =
R"""(Returns true iff the observability matrix is full column rank.)""";
      } IsObservable;
      // Symbol: drake::systems::LeafCompositeEventCollection
      struct /* LeafCompositeEventCollection */ {
        // Source: drake/systems/framework/event_collection.h:604
        const char* doc =
R"""(A CompositeEventCollection for a LeafSystem. i.e.


::

    PublishEvent<T>: {event1i, ...}
      DiscreteUpdateEvent<T>: {event2i, ...}
      UnrestrictedUpdateEvent<T>: {event3i, ...})""";
        // Symbol: drake::systems::LeafCompositeEventCollection::LeafCompositeEventCollection<T>
        struct /* ctor */ {
          // Source: drake/systems/framework/event_collection.h:606
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::systems::LeafCompositeEventCollection::get_discrete_update_events
        struct /* get_discrete_update_events */ {
          // Source: drake/systems/framework/event_collection.h:627
          const char* doc =
R"""(Returns a const reference to the collection of discrete update events.)""";
        } get_discrete_update_events;
        // Symbol: drake::systems::LeafCompositeEventCollection::get_publish_events
        struct /* get_publish_events */ {
          // Source: drake/systems/framework/event_collection.h:618
          const char* doc =
R"""(Returns a const reference to the collection of publish events.)""";
        } get_publish_events;
        // Symbol: drake::systems::LeafCompositeEventCollection::get_unrestricted_update_events
        struct /* get_unrestricted_update_events */ {
          // Source: drake/systems/framework/event_collection.h:636
          const char* doc =
R"""(Returns a const reference to the collection of unrestricted update
events.)""";
        } get_unrestricted_update_events;
      } LeafCompositeEventCollection;
      // Symbol: drake::systems::LeafContext
      struct /* LeafContext */ {
        // Source: drake/systems/framework/leaf_context.h:19
        const char* doc =
R"""(LeafContext contains all prerequisite data necessary to uniquely
determine the results of computations performed by the associated
LeafSystem.

See also:
    Context for more information.)""";
        // Symbol: drake::systems::LeafContext::DoCloneState
        struct /* DoCloneState */ {
          // Source: drake/systems/framework/leaf_context.h:55
          const char* doc = R"""()""";
        } DoCloneState;
        // Symbol: drake::systems::LeafContext::DoCloneWithoutPointers
        struct /* DoCloneWithoutPointers */ {
          // Source: drake/systems/framework/leaf_context.h:53
          const char* doc =
R"""(Derived classes should reimplement and replace this; don't recursively
invoke it.)""";
        } DoCloneWithoutPointers;
        // Symbol: drake::systems::LeafContext::LeafContext<T>
        struct /* ctor */ {
          // Source: drake/systems/framework/leaf_context.h:49
          const char* doc_copy =
R"""(Protected copy constructor takes care of the local data members and
all base class members, but doesn't update base class pointers so is
not a complete copy.)""";
        } ctor;
      } LeafContext;
      // Symbol: drake::systems::LeafEventCollection
      struct /* LeafEventCollection */ {
        // Source: drake/systems/framework/event_collection.h:302
        const char* doc =
R"""(A concrete class that holds all simultaneous *homogeneous* events for
a LeafSystem.

End users should never need to use or know about this class. It is for
internal use only.)""";
        // Symbol: drake::systems::LeafEventCollection::Clear
        struct /* Clear */ {
          // Source: drake/systems/framework/event_collection.h:349
          const char* doc =
R"""(Removes all events from this collection.)""";
        } Clear;
        // Symbol: drake::systems::LeafEventCollection::DoAddToEnd
        struct /* DoAddToEnd */ {
          // Source: drake/systems/framework/event_collection.h:374
          const char* doc =
R"""(All events in ``other_collection`` are concatanated to this.

Here is an example. Suppose this collection stores the following
events:


::

    EventType: {event1, event2, event3}

``other_collection`` has:


::

    EventType: {event4}

After calling DoAddToEnd(other_collection), ``this`` stores:


::

    EventType: {event1, event2, event3, event4}

Raises:
    RuntimeError if ``other_collection`` is not an instance of
    LeafEventCollection.)""";
        } DoAddToEnd;
        // Symbol: drake::systems::LeafEventCollection::HasEvents
        struct /* HasEvents */ {
          // Source: drake/systems/framework/event_collection.h:344
          const char* doc =
R"""(Returns ``True`` if and only if this collection is nonempty.)""";
        } HasEvents;
        // Symbol: drake::systems::LeafEventCollection::LeafEventCollection<EventType>
        struct /* ctor */ {
          // Source: drake/systems/framework/event_collection.h:309
          const char* doc = R"""(Constructor.)""";
        } ctor;
        // Symbol: drake::systems::LeafEventCollection::MakeForcedEventCollection
        struct /* MakeForcedEventCollection */ {
          // Source: drake/systems/framework/event_collection.h:317
          const char* doc =
R"""(Static method that generates a LeafEventCollection with exactly one
event with no optional attribute, data or callback, and trigger type
kForced.)""";
        } MakeForcedEventCollection;
        // Symbol: drake::systems::LeafEventCollection::add_event
        struct /* add_event */ {
          // Source: drake/systems/framework/event_collection.h:335
          const char* doc =
R"""(Add ``event`` to the existing collection. Ownership of ``event`` is
transferred. Aborts if event is null.)""";
        } add_event;
        // Symbol: drake::systems::LeafEventCollection::get_events
        struct /* get_events */ {
          // Source: drake/systems/framework/event_collection.h:329
          const char* doc =
R"""(Returns a const reference to the vector of const pointers to all of
the events.)""";
        } get_events;
      } LeafEventCollection;
      // Symbol: drake::systems::LeafOutputPort
      struct /* LeafOutputPort */ {
        // Source: drake/systems/framework/leaf_output_port.h:30
        const char* doc =
R"""((Advanced.) Implements an output port whose value is managed by a
cache entry in the same LeafSystem as the port. This is intended for
internal use in implementing the DeclareOutputPort() variants in
LeafSystem.)""";
        // Symbol: drake::systems::LeafOutputPort::AllocCallback
        struct /* AllocCallback */ {
          // Source: drake/systems/framework/leaf_output_port.h:42
          const char* doc =
R"""(Signature of a function suitable for allocating an object that can
hold a value of a particular output port. The result is returned as an
AbstractValue even if this is a vector-valued port.)""";
        } AllocCallback;
        // Symbol: drake::systems::LeafOutputPort::CalcCallback
        struct /* CalcCallback */ {
          // Source: drake/systems/framework/leaf_output_port.h:46
          const char* doc =
R"""(Signature of a function suitable for calculating a value of a
particular output port, given a place to put the value.)""";
        } CalcCallback;
        // Symbol: drake::systems::LeafOutputPort::CalcVectorCallback
        struct /* CalcVectorCallback */ {
          // Source: drake/systems/framework/leaf_output_port.h:51
          const char* doc =
R"""(Signature of a function suitable for calculating a value of a
particular vector-valued output port, given a place to put the value.)""";
        } CalcVectorCallback;
        // Symbol: drake::systems::LeafOutputPort::LeafOutputPort<T>
        struct /* ctor */ {
          // Source: drake/systems/framework/leaf_output_port.h:32
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::systems::LeafOutputPort::cache_entry
        struct /* cache_entry */ {
          // Source: drake/systems/framework/leaf_output_port.h:55
          const char* doc =
R"""(Returns the cache entry associated with this output port.)""";
        } cache_entry;
        // Symbol: drake::systems::LeafOutputPort::disable_caching_by_default
        struct /* disable_caching_by_default */ {
          // Source: drake/systems/framework/leaf_output_port.h:65
          const char* doc =
R"""((Debugging) Specifies that caching should be disabled for this output
port when a Context is first allocated. This is useful if you have
observed different behavior with caching on or off and would like to
determine if the problem is caused by this port.

See also:
    CacheEntry::disable_caching_by_default())""";
        } disable_caching_by_default;
      } LeafOutputPort;
      // Symbol: drake::systems::LeafSystem
      struct /* LeafSystem */ {
        // Source: drake/systems/framework/leaf_system.h:41
        const char* doc =
R"""(A superclass template that extends System with some convenience
utilities that are not applicable to Diagrams.)""";
        // Symbol: drake::systems::LeafSystem::AddTriggeredWitnessFunctionToCompositeEventCollection
        struct /* AddTriggeredWitnessFunctionToCompositeEventCollection */ {
          // Source: drake/systems/framework/leaf_system.h:145
          const char* doc = R"""()""";
        } AddTriggeredWitnessFunctionToCompositeEventCollection;
        // Symbol: drake::systems::LeafSystem::AllocateAbstractState
        struct /* AllocateAbstractState */ {
          // Source: drake/systems/framework/leaf_system.h:204
          const char* doc =
R"""(Returns a copy of the states declared in DeclareAbstractState() calls.)""";
        } AllocateAbstractState;
        // Symbol: drake::systems::LeafSystem::AllocateCompositeEventCollection
        struct /* AllocateCompositeEventCollection */ {
          // Source: drake/systems/framework/leaf_system.h:51
          const char* doc =
R"""(Allocates a CompositeEventCollection object for this system.

See also:
    System::AllocateCompositeEventCollection().)""";
        } AllocateCompositeEventCollection;
        // Symbol: drake::systems::LeafSystem::AllocateContext
        struct /* AllocateContext */ {
          // Source: drake/systems/framework/leaf_system.h:55
          const char* doc =
R"""(Shadows System<T>::AllocateContext to provide a more concrete return
type LeafContext<T>.)""";
        } AllocateContext;
        // Symbol: drake::systems::LeafSystem::AllocateContinuousState
        struct /* AllocateContinuousState */ {
          // Source: drake/systems/framework/leaf_system.h:198
          const char* doc =
R"""(Returns a copy of the state declared in the most recent
DeclareContinuousState() call, or else a zero-sized state if that
method has never been called.)""";
        } AllocateContinuousState;
        // Symbol: drake::systems::LeafSystem::AllocateDiscreteState
        struct /* AllocateDiscreteState */ {
          // Source: drake/systems/framework/leaf_system.h:201
          const char* doc =
R"""(Returns a copy of the states declared in DeclareDiscreteState() calls.)""";
        } AllocateDiscreteState;
        // Symbol: drake::systems::LeafSystem::AllocateDiscreteVariables
        struct /* AllocateDiscreteVariables */ {
          // Source: drake/systems/framework/leaf_system.h:94
          const char* doc = R"""()""";
        } AllocateDiscreteVariables;
        // Symbol: drake::systems::LeafSystem::AllocateForcedDiscreteUpdateEventCollection
        struct /* AllocateForcedDiscreteUpdateEventCollection */ {
          // Source: drake/systems/framework/leaf_system.h:67
          const char* doc = R"""()""";
        } AllocateForcedDiscreteUpdateEventCollection;
        // Symbol: drake::systems::LeafSystem::AllocateForcedPublishEventCollection
        struct /* AllocateForcedPublishEventCollection */ {
          // Source: drake/systems/framework/leaf_system.h:64
          const char* doc = R"""()""";
        } AllocateForcedPublishEventCollection;
        // Symbol: drake::systems::LeafSystem::AllocateForcedUnrestrictedUpdateEventCollection
        struct /* AllocateForcedUnrestrictedUpdateEventCollection */ {
          // Source: drake/systems/framework/leaf_system.h:70
          const char* doc = R"""()""";
        } AllocateForcedUnrestrictedUpdateEventCollection;
        // Symbol: drake::systems::LeafSystem::AllocateParameters
        struct /* AllocateParameters */ {
          // Source: drake/systems/framework/leaf_system.h:208
          const char* doc =
R"""(Returns a copy of the parameters declared in DeclareNumericParameter()
and DeclareAbstractParameter() calls.)""";
        } AllocateParameters;
        // Symbol: drake::systems::LeafSystem::AllocateTimeDerivatives
        struct /* AllocateTimeDerivatives */ {
          // Source: drake/systems/framework/leaf_system.h:92
          const char* doc = R"""()""";
        } AllocateTimeDerivatives;
        // Symbol: drake::systems::LeafSystem::DeclareAbstractInputPort
        struct /* DeclareAbstractInputPort */ {
          // Source: drake/systems/framework/leaf_system.h:1200
          const char* doc_2args =
R"""(Declares an abstract-valued input port using the given
``model_value``. This is the best way to declare LeafSystem abstract
input ports.

Any port connected to this input, and any call to FixValue for this
input, must provide for values whose type matches this
``model_value``.

See also:
    System::DeclareInputPort() for more information.)""";
          // Source: drake/systems/framework/leaf_system.h:1223
          const char* doc_1args =
R"""(See the nearly identical signature with an additional (first) argument
specifying the port name. This version will be deprecated as discussed
in #9447.)""";
        } DeclareAbstractInputPort;
        // Symbol: drake::systems::LeafSystem::DeclareAbstractOutputPort
        struct /* DeclareAbstractOutputPort */ {
          // Source: drake/systems/framework/leaf_system.h:1435
          const char* doc_4args_stdvariant_constOutputType_voidMySystemconstContextOutputTypeconst_stdset =
R"""(Declares an abstract-valued output port by specifying a model value of
concrete type ``OutputType`` and a calculator function that is a class
member function (method) with signature:


::

    void MySystem::CalcOutputValue(const Context<T>&, OutputType*) const;

where ``MySystem`` must be a class derived from ``LeafSystem<T>``.
`OutputType` must be such that ``Value<OutputType>`` is permitted.
Template arguments will be deduced and do not need to be specified.

See also:
    drake::Value)""";
          // Source: drake/systems/framework/leaf_system.h:1474
          const char* doc_3args_stdvariant_voidMySystemconstContextOutputTypeconst_stdset =
R"""(Declares an abstract-valued output port by specifying only a
calculator function that is a class member function (method) with
signature:


::

    void MySystem::CalcOutputValue(const Context<T>&, OutputType*) const;

where ``MySystem`` is a class derived from ``LeafSystem<T>``.
`OutputType` is a concrete type such that ``Value<OutputType>`` is
permitted, and must be default constructible, so that we can create a
model value using ``Value<OutputType>{}`` (value initialized so
numerical types will be zeroed in the model). Template arguments will
be deduced and do not need to be specified.

Note:
    The default constructor will be called once immediately, and
    subsequent allocations will just copy the model value without
    invoking the constructor again. If you want the constructor
    invoked again at each allocation (not common), use one of the
    other signatures to explicitly provide a method for the allocator
    to call; that method can then invoke the ``OutputType`` default
    constructor.

See also:
    drake::Value)""";
          // Source: drake/systems/framework/leaf_system.h:1501
          const char* doc_4args_stdvariant_OutputTypeMySystemconst_voidMySystemconstContextOutputTypeconst_stdset =
R"""(Declares an abstract-valued output port by specifying member functions
to use both for the allocator and calculator. The signatures are:


::

    OutputType MySystem::MakeOutputValue() const;
    void MySystem::CalcOutputValue(const Context<T>&, OutputType*) const;

where ``MySystem`` is a class derived from ``LeafSystem<T>`` and
``OutputType`` may be any concrete type such that
``Value<OutputType>`` is permitted. See alternate signature if your
allocator method needs a Context. Template arguments will be deduced
and do not need to be specified.

See also:
    drake::Value)""";
          // Source: drake/systems/framework/leaf_system.h:1525
          const char* doc_4args_name_alloc_function_calc_function_prerequisites_of_calc =
R"""((Advanced) Declares an abstract-valued output port using the given
allocator and calculator functions provided in their most generic
forms. If you have a member function available use one of the other
signatures.

See also:
    LeafOutputPort::AllocCallback, LeafOutputPort::CalcCallback)""";
          // Source: drake/systems/framework/leaf_system.h:1583
          const char* doc_3args_constOutputType_voidMySystemconstContextOutputTypeconst_stdset =
R"""(See the nearly identical signature with an additional (first) argument
specifying the port name. This version will be deprecated as discussed
in #9447. Note that the deprecated method is not available for
``OutputType`` std::string as that would create an ambiguity. In that
case the name is required.)""";
          // Source: drake/systems/framework/leaf_system.h:1596
          const char* doc_2args_voidMySystemconstContextOutputTypeconst_stdset =
R"""(See the nearly identical signature with an additional (first) argument
specifying the port name. This version will be deprecated as discussed
in #9447.)""";
        } DeclareAbstractOutputPort;
        // Symbol: drake::systems::LeafSystem::DeclareAbstractParameter
        struct /* DeclareAbstractParameter */ {
          // Source: drake/systems/framework/leaf_system.h:257
          const char* doc =
R"""(Declares an abstract parameter using the given ``model_value``.
LeafSystem's default implementation of SetDefaultParameters() will
reset parameters to their model values. Returns the index of the new
parameter.)""";
        } DeclareAbstractParameter;
        // Symbol: drake::systems::LeafSystem::DeclareAbstractState
        struct /* DeclareAbstractState */ {
          // Source: drake/systems/framework/leaf_system.h:1129
          const char* doc =
R"""(Declares an abstract state.

Parameter ``abstract_state``:
    The abstract state model value.

Returns:
    index of the declared abstract state.)""";
          // Source: drake/systems/framework/leaf_system.h:1138
          const char* doc_deprecated =
R"""(Declares an abstract state.

Parameter ``abstract_state``:
    The abstract state model value. The internal model value will
    contain a copy of ``value`` (not retain a pointer to ``value``).

Returns:
    index of the declared abstract state. */ (Deprecated.)

Deprecated:
    Pass the abstract_state by value, not by-unique-ptr This will be
    removed from Drake on or after 2021-04-01.)""";
        } DeclareAbstractState;
        // Symbol: drake::systems::LeafSystem::DeclareContinuousState
        struct /* DeclareContinuousState */ {
          // Source: drake/systems/framework/leaf_system.h:1066
          const char* doc_1args_num_state_variables =
R"""(Declares that this System should reserve continuous state with
``num_state_variables`` state variables, which have no second-order
structure.)""";
          // Source: drake/systems/framework/leaf_system.h:1071
          const char* doc_3args_num_q_num_v_num_z =
R"""(Declares that this System should reserve continuous state with
``num_q`` generalized positions, ``num_v`` generalized velocities, and
``num_z`` miscellaneous state variables.)""";
          // Source: drake/systems/framework/leaf_system.h:1076
          const char* doc_1args_model_vector =
R"""(Declares that this System should reserve continuous state with
``model_vector``.size() miscellaneous state variables, stored in a
vector cloned from ``model_vector``.)""";
          // Source: drake/systems/framework/leaf_system.h:1085
          const char* doc_4args_model_vector_num_q_num_v_num_z =
R"""(Declares that this System should reserve continuous state with
``num_q`` generalized positions, ``num_v`` generalized velocities, and
``num_z`` miscellaneous state variables, stored in a vector cloned
from ``model_vector``. Aborts if ``model_vector`` has the wrong size.
If the ``model_vector`` declares any VectorBase::GetElementBounds()
constraints, they will be re-declared as inequality constraints on
this system (see DeclareInequalityConstraint()).)""";
        } DeclareContinuousState;
        // Symbol: drake::systems::LeafSystem::DeclareDiscreteState
        struct /* DeclareDiscreteState */ {
          // Source: drake/systems/framework/leaf_system.h:1104
          const char* doc_1args_model_vector =
R"""(Declares a discrete state group with ``model_vector``.size() state
variables, stored in a vector cloned from ``model_vector`` (preserving
the concrete type and value).)""";
          // Source: drake/systems/framework/leaf_system.h:1108
          const char* doc_1args_vector =
R"""(Declares a discrete state group with ``vector``.size() state
variables, stored in a BasicVector initialized with the contents of
``vector``.)""";
          // Source: drake/systems/framework/leaf_system.h:1116
          const char* doc_1args_num_state_variables =
R"""(Declares a discrete state group with ``num_state_variables`` state
variables, stored in a BasicVector initialized to be all-zero. If you
want non-zero initial values, use an alternate DeclareDiscreteState()
signature that accepts a ``model_vector`` parameter.

Precondition:
    ``num_state_variables`` must be non-negative.)""";
        } DeclareDiscreteState;
        // Symbol: drake::systems::LeafSystem::DeclareEqualityConstraint
        struct /* DeclareEqualityConstraint */ {
          // Source: drake/systems/framework/leaf_system.h:1814
          const char* doc_3args_voidMySystemconstContextconst_int_stdstring =
R"""(Declares a system constraint of the form f(context) = 0 by specifying
a member function to use to calculate the (VectorX) constraint value
with a signature:


::

    void MySystem::CalcConstraint(const Context<T>&, VectorX<T>*) const;

Parameter ``count``:
    is the dimension of the VectorX output.

Parameter ``description``:
    should be a human-readable phrase.

Returns:
    The index of the constraint. Template arguments will be deduced
    and do not need to be specified.

See also:
    SystemConstraint<T> for more information about the meaning of
    these constraints.)""";
          // Source: drake/systems/framework/leaf_system.h:1841
          const char* doc_3args_calc_count_description =
R"""(Declares a system constraint of the form f(context) = 0 by specifying
a std::function to use to calculate the (Vector) constraint value with
a signature:


::

    void CalcConstraint(const Context<T>&, VectorX<T>*);

Parameter ``count``:
    is the dimension of the VectorX output.

Parameter ``description``:
    should be a human-readable phrase.

Returns:
    The index of the constraint.

See also:
    SystemConstraint<T> for more information about the meaning of
    these constraints.)""";
        } DeclareEqualityConstraint;
        // Symbol: drake::systems::LeafSystem::DeclareForcedDiscreteUpdateEvent
        struct /* DeclareForcedDiscreteUpdateEvent */ {
          // Source: drake/systems/framework/leaf_system.h:985
          const char* doc =
R"""(Declares a function that is called whenever a user directly calls
CalcDiscreteVariableUpdates(const Context&, DiscreteValues<T>*).
Multiple calls to DeclareForcedDiscreteUpdateEvent() will cause
multiple handlers to be called upon a call to
CalcDiscreteVariableUpdates(); these handlers which will be called
with the same const Context in arbitrary order. The handler should be
a class member function (method) with this signature:


::

    EventStatus MySystem::MyDiscreteVariableUpdates(const Context<T>&,
    DiscreteValues<T>*);

where ``MySystem`` is a class derived from ``LeafSystem<T>`` and the
method name is arbitrary.

See declare_forced_events "Declare forced events" for more
information.

Precondition:
    ``this`` must be dynamic_cast-able to MySystem.

Precondition:
    ``update`` must not be null.)""";
        } DeclareForcedDiscreteUpdateEvent;
        // Symbol: drake::systems::LeafSystem::DeclareForcedPublishEvent
        struct /* DeclareForcedPublishEvent */ {
          // Source: drake/systems/framework/leaf_system.h:947
          const char* doc =
R"""(Declares a function that is called whenever a user directly calls
Publish(const Context&). Multiple calls to DeclareForcedPublishEvent()
will cause multiple handlers to be called upon a call to Publish();
these handlers which will be called with the same const Context in
arbitrary order. The handler should be a class member function
(method) with this signature:


::

    EventStatus MySystem::MyPublish(const Context<T>&) const;

where ``MySystem`` is a class derived from ``LeafSystem<T>`` and the
method name is arbitrary.

See declare_forced_events "Declare forced events" for more
information.

Precondition:
    ``this`` must be dynamic_cast-able to MySystem.

Precondition:
    ``publish`` must not be null.)""";
        } DeclareForcedPublishEvent;
        // Symbol: drake::systems::LeafSystem::DeclareForcedUnrestrictedUpdateEvent
        struct /* DeclareForcedUnrestrictedUpdateEvent */ {
          // Source: drake/systems/framework/leaf_system.h:1027
          const char* doc =
R"""(Declares a function that is called whenever a user directly calls
CalcUnrestrictedUpdate(const Context&, State<T>*). Multiple calls to
DeclareForcedUnrestrictedUpdateEvent() will cause multiple handlers to
be called upon a call to CalcUnrestrictedUpdate(); these handlers
which will be called with the same const Context in arbitrary
order.The handler should be a class member function (method) with this
signature:


::

    EventStatus MySystem::MyUnrestrictedUpdates(const Context<T>&,
    State<T>*);

where ``MySystem`` is a class derived from ``LeafSystem<T>`` and the
method name is arbitrary.

See declare_forced_events "Declare forced events" for more
information.

Precondition:
    ``this`` must be dynamic_cast-able to MySystem.

Precondition:
    ``update`` must not be null.)""";
        } DeclareForcedUnrestrictedUpdateEvent;
        // Symbol: drake::systems::LeafSystem::DeclareImplicitTimeDerivativesResidualSize
        struct /* DeclareImplicitTimeDerivativesResidualSize */ {
          // Source: drake/systems/framework/leaf_system.h:1159
          const char* doc =
R"""((Advanced) Overrides the default size for the implicit time
derivatives residual. If no value is set, the default size is
n=num_continuous_states().

Parameter ``n``:
    The size of the residual vector output argument of
    System::CalcImplicitTimeDerivativesResidual(). If n <= 0 restore
    to the default, num_continuous_states().

See also:
    implicit_time_derivatives_residual_size()

See also:
    System::CalcImplicitTimeDerivativesResidual())""";
        } DeclareImplicitTimeDerivativesResidualSize;
        // Symbol: drake::systems::LeafSystem::DeclareInequalityConstraint
        struct /* DeclareInequalityConstraint */ {
          // Source: drake/systems/framework/leaf_system.h:1860
          const char* doc_3args_voidMySystemconstContextconst_drakesystemsSystemConstraintBounds_stdstring =
R"""(Declares a system constraint of the form bounds.lower() <=
calc(context) <= bounds.upper() by specifying a member function to use
to calculate the (VectorX) constraint value with a signature:


::

    void MySystem::CalcConstraint(const Context<T>&, VectorX<T>*) const;

Parameter ``description``:
    should be a human-readable phrase.

Returns:
    The index of the constraint. Template arguments will be deduced
    and do not need to be specified.

See also:
    SystemConstraint<T> for more information about the meaning of
    these constraints.)""";
          // Source: drake/systems/framework/leaf_system.h:1887
          const char* doc_3args_calc_bounds_description =
R"""(Declares a system constraint of the form bounds.lower() <=
calc(context) <= bounds.upper() by specifying a std::function to use
to calculate the (Vector) constraint value with a signature:


::

    void CalcConstraint(const Context<T>&, VectorX<T>*);

Parameter ``description``:
    should be a human-readable phrase.

Returns:
    The index of the constraint.

See also:
    SystemConstraint<T> for more information about the meaning of
    these constraints.)""";
        } DeclareInequalityConstraint;
        // Symbol: drake::systems::LeafSystem::DeclareInitializationDiscreteUpdateEvent
        struct /* DeclareInitializationDiscreteUpdateEvent */ {
          // Source: drake/systems/framework/leaf_system.h:812
          const char* doc =
R"""(Declares that a DiscreteUpdate event should occur at initialization
and that it should invoke the given event handler method. The handler
should be a class member function (method) with this signature:


::

    EventStatus MySystem::MyUpdate(const Context<T>&,
    DiscreteValues<T>*) const;

where ``MySystem`` is a class derived from ``LeafSystem<T>`` and the
method name is arbitrary.

See declare_initialization_events "Declare initialization events" for
more information.

Precondition:
    ``this`` must be dynamic_cast-able to MySystem.

Precondition:
    ``update`` must not be null.

See also:
    DeclareInitializationPublishEvent()

See also:
    DeclareInitializationUnrestrictedUpdateEvent()

See also:
    DeclareInitializationEvent())""";
        } DeclareInitializationDiscreteUpdateEvent;
        // Symbol: drake::systems::LeafSystem::DeclareInitializationEvent
        struct /* DeclareInitializationEvent */ {
          // Source: drake/systems/framework/leaf_system.h:897
          const char* doc =
R"""((Advanced) Declares that a particular Event object should be
dispatched at initialization. This is the most general form for
declaring initialization events and most users should use one of the
other methods in this group instead.

See also:
    DeclareInitializationPublishEvent()

See also:
    DeclareInitializationDiscreteUpdateEvent()

See also:
    DeclareInitializationUnrestrictedUpdate()

See declare_initialization_events "Declare initialization events" for
more information.

Depending on the type of ``event``, on initialization it will be
passed to the Publish, DiscreteUpdate, or UnrestrictedUpdate event
dispatcher. If the ``event`` object contains a handler function,
Drake's default dispatchers will invoke that handler. If not, then no
further action is taken. Thus an ``event`` with no handler has no
effect unless its dispatcher has been overridden. We strongly
recommend that you *do not* override the dispatcher and instead *do*
supply a handler.

The given ``event`` object is deep-copied (cloned), and the copy is
stored internally so you do not need to keep the object around after
this call.

Precondition:
    `event`'s associated trigger type must be TriggerType::kUnknown or
    already set to TriggerType::kInitialization.)""";
        } DeclareInitializationEvent;
        // Symbol: drake::systems::LeafSystem::DeclareInitializationPublishEvent
        struct /* DeclareInitializationPublishEvent */ {
          // Source: drake/systems/framework/leaf_system.h:775
          const char* doc =
R"""(Declares that a Publish event should occur at initialization and that
it should invoke the given event handler method. The handler should be
a class member function (method) with this signature:


::

    EventStatus MySystem::MyPublish(const Context<T>&) const;

where ``MySystem`` is a class derived from ``LeafSystem<T>`` and the
method name is arbitrary.

See declare_initialization_events "Declare initialization events" for
more information.

Precondition:
    ``this`` must be dynamic_cast-able to MySystem.

Precondition:
    ``publish`` must not be null.

See also:
    DeclareInitializationDiscreteUpdateEvent()

See also:
    DeclareInitializationUnrestrictedUpdateEvent()

See also:
    DeclareInitializationEvent())""";
        } DeclareInitializationPublishEvent;
        // Symbol: drake::systems::LeafSystem::DeclareInitializationUnrestrictedUpdateEvent
        struct /* DeclareInitializationUnrestrictedUpdateEvent */ {
          // Source: drake/systems/framework/leaf_system.h:852
          const char* doc =
R"""(Declares that an UnrestrictedUpdate event should occur at
initialization and that it should invoke the given event handler
method. The handler should be a class member function (method) with
this signature:


::

    EventStatus MySystem::MyUpdate(const Context<T>&,
    State<T>*) const;

where ``MySystem`` is a class derived from ``LeafSystem<T>`` and the
method name is arbitrary.

See declare_initialization_events "Declare initialization events" for
more information.

Precondition:
    ``this`` must be dynamic_cast-able to MySystem.

Precondition:
    ``update`` must not be null.

See also:
    DeclareInitializationPublishEvent()

See also:
    DeclareInitializationDiscreteUpdateEvent()

See also:
    DeclareInitializationEvent())""";
        } DeclareInitializationUnrestrictedUpdateEvent;
        // Symbol: drake::systems::LeafSystem::DeclareNumericParameter
        struct /* DeclareNumericParameter */ {
          // Source: drake/systems/framework/leaf_system.h:219
          const char* doc =
R"""(Declares a numeric parameter using the given ``model_vector``.
LeafSystem's default implementation of SetDefaultParameters() will
reset parameters to their model vectors. If the ``model_vector``
declares any VectorBase::GetElementBounds() constraints, they will be
re-declared as inequality constraints on this system (see
DeclareInequalityConstraint()). Returns the index of the new
parameter.)""";
        } DeclareNumericParameter;
        // Symbol: drake::systems::LeafSystem::DeclarePerStepDiscreteUpdateEvent
        struct /* DeclarePerStepDiscreteUpdateEvent */ {
          // Source: drake/systems/framework/leaf_system.h:646
          const char* doc =
R"""(Declares that a DiscreteUpdate event should occur at the start of
every trajectory-advancing step and that it should invoke the given
event handler method. The handler should be a class member function
(method) with this signature:


::

    EventStatus MySystem::MyUpdate(const Context<T>&,
    DiscreteValues<T>*) const;

where ``MySystem`` is a class derived from ``LeafSystem<T>`` and the
method name is arbitrary.

See declare_per-step_events "Declare per-step events" for more
information.

Precondition:
    ``this`` must be dynamic_cast-able to MySystem.

Precondition:
    ``update`` must not be null.

See also:
    DeclarePerStepPublishEvent()

See also:
    DeclarePerStepUnrestrictedUpdateEvent()

See also:
    DeclarePerStepEvent())""";
        } DeclarePerStepDiscreteUpdateEvent;
        // Symbol: drake::systems::LeafSystem::DeclarePerStepEvent
        struct /* DeclarePerStepEvent */ {
          // Source: drake/systems/framework/leaf_system.h:731
          const char* doc =
R"""((Advanced) Declares that a particular Event object should be
dispatched at every trajectory-advancing step. Publish events are
dispatched at the end of initialization and at the end of each step.
Discrete- and unrestricted update events are dispatched at the start
of each step. This is the most general form for declaring per-step
events and most users should use one of the other methods in this
group instead.

See also:
    DeclarePerStepPublishEvent()

See also:
    DeclarePerStepDiscreteUpdateEvent()

See also:
    DeclarePerStepUnrestrictedUpdateEvent()

See declare_per-step_events "Declare per-step events" for more
information.

Depending on the type of ``event``, at each step it will be passed to
the Publish, DiscreteUpdate, or UnrestrictedUpdate event dispatcher.
If the ``event`` object contains a handler function, Drake's default
dispatchers will invoke that handler. If not, then no further action
is taken. Thus an ``event`` with no handler has no effect unless its
dispatcher has been overridden. We strongly recommend that you *do
not* override the dispatcher and instead *do* supply a handler.

The given ``event`` object is deep-copied (cloned), and the copy is
stored internally so you do not need to keep the object around after
this call.

Precondition:
    `event`'s associated trigger type must be TriggerType::kUnknown or
    already set to TriggerType::kPerStep.)""";
        } DeclarePerStepEvent;
        // Symbol: drake::systems::LeafSystem::DeclarePerStepPublishEvent
        struct /* DeclarePerStepPublishEvent */ {
          // Source: drake/systems/framework/leaf_system.h:609
          const char* doc =
R"""(Declares that a Publish event should occur at initialization and at
the end of every trajectory-advancing step and that it should invoke
the given event handler method. The handler should be a class member
function (method) with this signature:


::

    EventStatus MySystem::MyPublish(const Context<T>&) const;

where ``MySystem`` is a class derived from ``LeafSystem<T>`` and the
method name is arbitrary.

Warning:
    These per-step publish events are independent of the Simulator's
    optional "publish every time step" and "publish at initialization"
    features. Generally if you are declaring per-step publish events
    yourself you should turn off those Simulation options.

See declare_per-step_events "Declare per-step events" for more
information.

Precondition:
    ``this`` must be dynamic_cast-able to MySystem.

Precondition:
    ``publish`` must not be null.

See also:
    DeclarePerStepDiscreteUpdateEvent()

See also:
    DeclarePerStepUnrestrictedUpdateEvent()

See also:
    DeclarePerStepEvent()

See also:
    Simulator::set_publish_at_initialization()

See also:
    Simulator::set_publish_every_time_step())""";
        } DeclarePerStepPublishEvent;
        // Symbol: drake::systems::LeafSystem::DeclarePerStepUnrestrictedUpdateEvent
        struct /* DeclarePerStepUnrestrictedUpdateEvent */ {
          // Source: drake/systems/framework/leaf_system.h:685
          const char* doc =
R"""(Declares that an UnrestrictedUpdate event should occur at the start of
every trajectory-advancing step and that it should invoke the given
event handler method. The handler should be a class member function
(method) with this signature:


::

    EventStatus MySystem::MyUpdate(const Context<T>&,
    State<T>*) const;

where ``MySystem`` is a class derived from ``LeafSystem<T>`` and the
method name is arbitrary.

See declare_per-step_events "Declare per-step events" for more
information.

Precondition:
    ``this`` must be dynamic_cast-able to MySystem.

Precondition:
    ``update`` must not be null.

See also:
    DeclarePerStepPublishEvent()

See also:
    DeclarePerStepDiscreteUpdateEvent()

See also:
    DeclarePerStepEvent())""";
        } DeclarePerStepUnrestrictedUpdateEvent;
        // Symbol: drake::systems::LeafSystem::DeclarePeriodicDiscreteUpdate
        struct /* DeclarePeriodicDiscreteUpdate */ {
          // Source: drake/systems/framework/leaf_system.h:533
          const char* doc =
R"""((To be deprecated) Declares a periodic discrete update event that
invokes the DiscreteUpdate() dispatcher but does not provide a handler
function. This does guarantee that a Simulator step will end exactly
at the update time, but otherwise has no effect unless the
DoDiscreteUpdate() dispatcher has been overloaded (not recommended).)""";
        } DeclarePeriodicDiscreteUpdate;
        // Symbol: drake::systems::LeafSystem::DeclarePeriodicDiscreteUpdateEvent
        struct /* DeclarePeriodicDiscreteUpdateEvent */ {
          // Source: drake/systems/framework/leaf_system.h:365
          const char* doc_3args_double_double_drakesystemsEventStatusMySystemconstContextconst =
R"""(Declares that a DiscreteUpdate event should occur periodically and
that it should invoke the given event handler method. The handler
should be a class member function (method) with this signature:


::

    EventStatus MySystem::MyUpdate(const Context<T>&,
    DiscreteValues<T>*) const;

where ``MySystem`` is a class derived from ``LeafSystem<T>`` and the
method name is arbitrary.

See declare_periodic_events "Declare periodic events" for more
information.

Precondition:
    ``this`` must be dynamic_cast-able to MySystem.

Precondition:
    ``update`` must not be null.

See also:
    DeclarePeriodicPublishEvent()

See also:
    DeclarePeriodicUnrestrictedUpdateEvent()

See also:
    DeclarePeriodicEvent())""";
          // Source: drake/systems/framework/leaf_system.h:396
          const char* doc_3args_double_double_voidMySystemconstContextconst =
R"""(This variant accepts a handler that is assumed to succeed rather than
one that returns an EventStatus result. The handler signature is:


::

    void MySystem::MyUpdate(const Context<T>&,
    DiscreteValues<T>*) const;

See the other signature for more information.)""";
        } DeclarePeriodicDiscreteUpdateEvent;
        // Symbol: drake::systems::LeafSystem::DeclarePeriodicEvent
        struct /* DeclarePeriodicEvent */ {
          // Source: drake/systems/framework/leaf_system.h:508
          const char* doc =
R"""((Advanced) Declares that a particular Event object should be
dispatched periodically. This is the most general form for declaring
periodic events and most users should use one of the other methods in
this group instead.

See also:
    DeclarePeriodicPublishEvent()

See also:
    DeclarePeriodicDiscreteUpdateEvent()

See also:
    DeclarePeriodicUnrestrictedUpdateEvent()

See declare_periodic_events "Declare periodic events" for more
information.

Depending on the type of ``event``, when triggered it will be passed
to the Publish, DiscreteUpdate, or UnrestrictedUpdate event
dispatcher. If the ``event`` object contains a handler function,
Drake's default dispatchers will invoke that handler. If not, then no
further action is taken. Thus an ``event`` with no handler has no
effect unless its dispatcher has been overridden. We strongly
recommend that you *do not* override the dispatcher and instead *do*
supply a handler.

The given ``event`` object is deep-copied (cloned), and the copy is
stored internally so you do not need to keep the object around after
this call.

Precondition:
    `event`'s associated trigger type must be TriggerType::kUnknown or
    already set to TriggerType::kPeriodic.)""";
        } DeclarePeriodicEvent;
        // Symbol: drake::systems::LeafSystem::DeclarePeriodicPublish
        struct /* DeclarePeriodicPublish */ {
          // Source: drake/systems/framework/leaf_system.h:526
          const char* doc =
R"""((To be deprecated) Declares a periodic publish event that invokes the
Publish() dispatcher but does not provide a handler function. This
does guarantee that a Simulator step will end exactly at the publish
time, but otherwise has no effect unless the DoPublish() dispatcher
has been overloaded (not recommended).)""";
        } DeclarePeriodicPublish;
        // Symbol: drake::systems::LeafSystem::DeclarePeriodicPublishEvent
        struct /* DeclarePeriodicPublishEvent */ {
          // Source: drake/systems/framework/leaf_system.h:300
          const char* doc_3args_double_double_drakesystemsEventStatusMySystemconstContextconst =
R"""(Declares that a Publish event should occur periodically and that it
should invoke the given event handler method. The handler should be a
class member function (method) with this signature:


::

    EventStatus MySystem::MyPublish(const Context<T>&) const;

where ``MySystem`` is a class derived from ``LeafSystem<T>`` and the
method name is arbitrary.

See declare_periodic_events "Declare periodic events" for more
information.

Precondition:
    ``this`` must be dynamic_cast-able to MySystem.

Precondition:
    ``publish`` must not be null.

See also:
    DeclarePeriodicDiscreteUpdateEvent()

See also:
    DeclarePeriodicUnrestrictedUpdateEvent()

See also:
    DeclarePeriodicEvent())""";
          // Source: drake/systems/framework/leaf_system.h:326
          const char* doc_3args_double_double_voidMySystemconstContextconst =
R"""(This variant accepts a handler that is assumed to succeed rather than
one that returns an EventStatus result. The handler signature is:


::

    void MySystem::MyPublish(const Context<T>&) const;

See the other signature for more information.)""";
        } DeclarePeriodicPublishEvent;
        // Symbol: drake::systems::LeafSystem::DeclarePeriodicUnrestrictedUpdate
        struct /* DeclarePeriodicUnrestrictedUpdate */ {
          // Source: drake/systems/framework/leaf_system.h:540
          const char* doc =
R"""((To be deprecated) Declares a periodic unrestricted update event that
invokes the UnrestrictedUpdate() dispatcher but does not provide a
handler function. This does guarantee that a Simulator step will end
exactly at the update time, but otherwise has no effect unless the
DoUnrestrictedUpdate() dispatcher has been overloaded (not
recommended).)""";
        } DeclarePeriodicUnrestrictedUpdate;
        // Symbol: drake::systems::LeafSystem::DeclarePeriodicUnrestrictedUpdateEvent
        struct /* DeclarePeriodicUnrestrictedUpdateEvent */ {
          // Source: drake/systems/framework/leaf_system.h:435
          const char* doc_3args_double_double_drakesystemsEventStatusMySystemconstContextconst =
R"""(Declares that an UnrestrictedUpdate event should occur periodically
and that it should invoke the given event handler method. The handler
should be a class member function (method) with this signature:


::

    EventStatus MySystem::MyUpdate(const Context<T>&, State<T>*) const;

where ``MySystem`` is a class derived from ``LeafSystem<T>`` and the
method name is arbitrary.

See declare_periodic_events "Declare periodic events" for more
information.

Precondition:
    ``this`` must be dynamic_cast-able to MySystem.

Precondition:
    ``update`` must not be null.

See also:
    DeclarePeriodicPublishEvent()

See also:
    DeclarePeriodicDiscreteUpdateEvent()

See also:
    DeclarePeriodicEvent())""";
          // Source: drake/systems/framework/leaf_system.h:463
          const char* doc_3args_double_double_voidMySystemconstContextconst =
R"""(This variant accepts a handler that is assumed to succeed rather than
one that returns an EventStatus result. The handler signature is:


::

    void MySystem::MyUpdate(const Context<T>&, State<T>*) const;

See the other signature for more information.)""";
        } DeclarePeriodicUnrestrictedUpdateEvent;
        // Symbol: drake::systems::LeafSystem::DeclareVectorInputPort
        struct /* DeclareVectorInputPort */ {
          // Source: drake/systems/framework/leaf_system.h:1188
          const char* doc_3args =
R"""(Declares a vector-valued input port using the given ``model_vector``.
This is the best way to declare LeafSystem input ports that require
subclasses of BasicVector. The port's size and type will be the same
as model_vector. If the port is intended to model a random noise or
disturbance input, ``random_type`` can (optionally) be used to label
it as such. If the ``model_vector`` declares any
VectorBase::GetElementBounds() constraints, they will be re-declared
as inequality constraints on this system (see
DeclareInequalityConstraint()).

See also:
    System::DeclareInputPort() for more information.)""";
          // Source: drake/systems/framework/leaf_system.h:1216
          const char* doc_2args =
R"""(See the nearly identical signature with an additional (first) argument
specifying the port name. This version will be deprecated as discussed
in #9447.)""";
        } DeclareVectorInputPort;
        // Symbol: drake::systems::LeafSystem::DeclareVectorOutputPort
        struct /* DeclareVectorOutputPort */ {
          // Source: drake/systems/framework/leaf_system.h:1337
          const char* doc_4args_stdvariant_constBasicVectorSubtype_voidMySystemconstContextBasicVectorSubtypeconst_stdset =
R"""(Declares a vector-valued output port by specifying (1) a model vector
of type BasicVectorSubtype derived from BasicVector and initialized to
the correct size and desired initial value, and (2) a calculator
function that is a class member function (method) with signature:


::

    void MySystem::CalcOutputVector(const Context<T>&,
    BasicVectorSubtype*) const;

where ``MySystem`` is a class derived from ``LeafSystem<T>``. Template
arguments will be deduced and do not need to be specified.)""";
          // Source: drake/systems/framework/leaf_system.h:1395
          const char* doc_3args_stdvariant_voidMySystemconstContextBasicVectorSubtypeconst_stdset =
R"""(Declares a vector-valued output port by specifying *only* a calculator
function that is a class member function (method) with signature:


::

    void MySystem::CalcOutputVector(const Context<T>&,
    BasicVectorSubtype*) const;

where ``MySystem`` is a class derived from ``LeafSystem<T>`` and
``BasicVectorSubtype`` is derived from ``BasicVector<T>`` and has a
suitable default constructor that allocates a vector of the expected
size. This will use ``BasicVectorSubtype{}`` (that is, the default
constructor) to produce a model vector for the output port's value.
Template arguments will be deduced and do not need to be specified.

Note:
    The default constructor will be called once immediately, and
    subsequent allocations will just copy the model value without
    invoking the constructor again. If you want the constructor
    invoked again at each allocation (not common), use one of the
    other signatures to explicitly provide a method for the allocator
    to call; that method can then invoke the ``BasicVectorSubtype``
    default constructor.)""";
          // Source: drake/systems/framework/leaf_system.h:1417
          const char* doc_4args_name_model_vector_vector_calc_function_prerequisites_of_calc =
R"""((Advanced) Declares a vector-valued output port using the given
``model_vector`` and a function for calculating the port's value at
runtime. The port's size will be model_vector.size(), and the default
allocator for the port will be model_vector.Clone(). Note that this
takes the calculator function in its most generic form; if you have a
member function available use one of the other signatures.

See also:
    LeafOutputPort::CalcVectorCallback)""";
          // Source: drake/systems/framework/leaf_system.h:1545
          const char* doc_3args_constBasicVectorSubtype_voidMySystemconstContextBasicVectorSubtypeconst_stdset =
R"""(See the nearly identical signature with an additional (first) argument
specifying the port name. This version will be deprecated as discussed
in #9447.)""";
        } DeclareVectorOutputPort;
        // Symbol: drake::systems::LeafSystem::DoAllocateContext
        struct /* DoAllocateContext */ {
          // Source: drake/systems/framework/leaf_system.h:73
          const char* doc = R"""()""";
        } DoAllocateContext;
        // Symbol: drake::systems::LeafSystem::DoCalcDiscreteVariableUpdates
        struct /* DoCalcDiscreteVariableUpdates */ {
          // Source: drake/systems/framework/leaf_system.h:1938
          const char* doc =
R"""(Derived-class event dispatcher for all simultaneous discrete update
events. Override this in your derived LeafSystem only if you require
behavior other than the default dispatch behavior (not common). The
default behavior is to traverse events in the arbitrary order they
appear in ``events``, and for each event that has a callback function,
to invoke the callback with ``context``, that event, and
``discrete_state``. Note that the same (possibly modified)
``discrete_state`` is passed to subsequent callbacks.

Do not override this just to handle an event -- instead declare the
event and a handler callback for it using one of the
``Declare...DiscreteUpdateEvent()`` methods.

This method is called only from the virtual
DispatchDiscreteVariableUpdateHandler(), which is only called from the
public non-virtual CalcDiscreteVariableUpdates(), which will already
have error-checked the parameters so you don't have to. In particular,
implementations may assume that ``context`` is valid; that
``discrete_state`` is non-null, and that the referenced object has the
same constituent structure as was produced by
AllocateDiscreteVariables().

Parameter ``context``:
    The "before" state.

Parameter ``events``:
    All the discrete update events that need handling.

Parameter ``discrete_state``:
    The current state of the system on input; the desired state of the
    system on return.)""";
        } DoCalcDiscreteVariableUpdates;
        // Symbol: drake::systems::LeafSystem::DoCalcNextUpdateTime
        struct /* DoCalcNextUpdateTime */ {
          // Source: drake/systems/framework/leaf_system.h:162
          const char* doc =
R"""(Computes the next update time based on the configured periodic events,
for scalar types that are arithmetic, or aborts for scalar types that
are not arithmetic. Subclasses that require aperiodic events should
override, but be sure to invoke the parent class implementation at the
start of the override if you want periodic events to continue to be
handled.

Postcondition:
    ``time`` is set to a value greater than or equal to
    ``context.get_time()`` on return.

Warning:
    If you override this method, think carefully before setting
    ``time`` to ``context.get_time()`` on return, which can
    inadvertently cause simulations of systems derived from LeafSystem
    to loop interminably. Such a loop will occur if, for example, the
    event(s) does not modify the state.)""";
        } DoCalcNextUpdateTime;
        // Symbol: drake::systems::LeafSystem::DoCalcUnrestrictedUpdate
        struct /* DoCalcUnrestrictedUpdate */ {
          // Source: drake/systems/framework/leaf_system.h:1973
          const char* doc =
R"""(Derived-class event dispatcher for all simultaneous unrestricted
update events. Override this in your derived LeafSystem only if you
require behavior other than the default dispatch behavior (not
common). The default behavior is to traverse events in the arbitrary
order they appear in ``events``, and for each event that has a
callback function, to invoke the callback with ``context``, that
event, and ``state``. Note that the same (possibly modified) ``state``
is passed to subsequent callbacks.

Do not override this just to handle an event -- instead declare the
event and a handler callback for it using one of the
``Declare...UnrestrictedUpdateEvent()`` methods.

This method is called only from the virtual
DispatchUnrestrictedUpdateHandler(), which is only called from the
non-virtual public CalcUnrestrictedUpdate(), which will already have
error-checked the parameters so you don't have to. In particular,
implementations may assume that the ``context`` is valid; that
``state`` is non-null, and that the referenced object has the same
constituent structure as the state in ``context``.

Parameter ``context``:
    The "before" state that is to be used to calculate the returned
    state update.

Parameter ``events``:
    All the unrestricted update events that need handling.

Parameter ``state``:
    The current state of the system on input; the desired state of the
    system on return.)""";
        } DoCalcUnrestrictedUpdate;
        // Symbol: drake::systems::LeafSystem::DoCalcWitnessValue
        struct /* DoCalcWitnessValue */ {
          // Source: drake/systems/framework/leaf_system.h:142
          const char* doc = R"""()""";
        } DoCalcWitnessValue;
        // Symbol: drake::systems::LeafSystem::DoMakeLeafContext
        struct /* DoMakeLeafContext */ {
          // Source: drake/systems/framework/leaf_system.h:125
          const char* doc =
R"""(Provides a new instance of the leaf context for this system. Derived
leaf systems with custom derived leaf system contexts should override
this to provide a context of the appropriate type. The returned
context should be "empty"; invoked by AllocateContext(), the caller
will take the responsibility to initialize the core LeafContext data.
The default implementation provides a default-constructed
``LeafContext<T>``.)""";
        } DoMakeLeafContext;
        // Symbol: drake::systems::LeafSystem::DoPublish
        struct /* DoPublish */ {
          // Source: drake/systems/framework/leaf_system.h:1909
          const char* doc =
R"""(Derived-class event dispatcher for all simultaneous publish events in
``events``. Override this in your derived LeafSystem only if you
require behavior other than the default dispatch behavior (not
common). The default behavior is to traverse events in the arbitrary
order they appear in ``events``, and for each event that has a
callback function, to invoke the callback with ``context`` and that
event.

Do not override this just to handle an event -- instead declare the
event and a handler callback for it using one of the
``Declare...PublishEvent()`` methods.

This method is called only from the virtual DispatchPublishHandler,
which is only called from the public non-virtual Publish(), which will
have already error-checked ``context`` so you may assume that it is
valid.

Parameter ``context``:
    Const current context.

Parameter ``events``:
    All the publish events that need handling.)""";
        } DoPublish;
        // Symbol: drake::systems::LeafSystem::DoValidateAllocatedLeafContext
        struct /* DoValidateAllocatedLeafContext */ {
          // Source: drake/systems/framework/leaf_system.h:134
          const char* doc =
R"""(Derived classes that impose restrictions on what resources are
permitted should check those restrictions by implementing this. For
example, a derived class might require a single input and single
output. Note that the supplied Context will be complete except that
input and output dependencies on peer and parent subcontexts will not
yet have been set up, so you may not consider them for validation. The
default implementation does nothing.)""";
        } DoValidateAllocatedLeafContext;
        // Symbol: drake::systems::LeafSystem::GetDirectFeedthroughs
        struct /* GetDirectFeedthroughs */ {
          // Source: drake/systems/framework/leaf_system.h:96
          const char* doc = R"""()""";
        } GetDirectFeedthroughs;
        // Symbol: drake::systems::LeafSystem::GetGraphvizFragment
        struct /* GetGraphvizFragment */ {
          // Source: drake/systems/framework/leaf_system.h:181
          const char* doc =
R"""(Emits a graphviz fragment for this System. Leaf systems are visualized
as records. For instance, a leaf system with 2 inputs and 1 output is:


::

    123456 [shape= record, label="name | {<u0> 0 |<y0> 0} | {<u1> 1 | }"];

which looks like:


::

    +------------+----+
    | name  | u0 | u1 |
    |       | y0 |    |
    +-------+----+----+)""";
        } GetGraphvizFragment;
        // Symbol: drake::systems::LeafSystem::GetGraphvizInputPortToken
        struct /* GetGraphvizInputPortToken */ {
          // Source: drake/systems/framework/leaf_system.h:184
          const char* doc = R"""()""";
        } GetGraphvizInputPortToken;
        // Symbol: drake::systems::LeafSystem::GetGraphvizOutputPortToken
        struct /* GetGraphvizOutputPortToken */ {
          // Source: drake/systems/framework/leaf_system.h:188
          const char* doc = R"""()""";
        } GetGraphvizOutputPortToken;
        // Symbol: drake::systems::LeafSystem::GetMutableNumericParameter
        struct /* GetMutableNumericParameter */ {
          // Source: drake/systems/framework/leaf_system.h:241
          const char* doc =
R"""(Extracts the numeric parameters of type U from the ``context`` at
``index``. Asserts if the context is not a LeafContext, or if it does
not have a vector-valued parameter of type U at ``index``.)""";
        } GetMutableNumericParameter;
        // Symbol: drake::systems::LeafSystem::GetNumericParameter
        struct /* GetNumericParameter */ {
          // Source: drake/systems/framework/leaf_system.h:225
          const char* doc =
R"""(Extracts the numeric parameters of type U from the ``context`` at
``index``. Asserts if the context is not a LeafContext, or if it does
not have a vector-valued parameter of type U at ``index``.)""";
        } GetNumericParameter;
        // Symbol: drake::systems::LeafSystem::LeafSystem<T>
        struct /* ctor */ {
          // Source: drake/systems/framework/leaf_system.h:105
          const char* doc_0args =
R"""(Default constructor that declares no inputs, outputs, state,
parameters, events, nor scalar-type conversion support (AutoDiff,
etc.). To enable AutoDiff support, use the SystemScalarConverter-based
constructor.)""";
          // Source: drake/systems/framework/leaf_system.h:117
          const char* doc_1args =
R"""(Constructor that declares no inputs, outputs, state, parameters, or
events, but allows subclasses to declare scalar-type conversion
support (AutoDiff, etc.).

The scalar-type conversion support will use ``converter``. To enable
scalar-type conversion support, pass a ``SystemTypeTag<S>{}`` where
``S`` must be the exact class of ``this`` being constructed.

See system_scalar_conversion for detailed background and examples
related to scalar-type conversion support.)""";
        } ctor;
        // Symbol: drake::systems::LeafSystem::MakeWitnessFunction
        struct /* MakeWitnessFunction */ {
          // Source: drake/systems/framework/leaf_system.h:1669
          const char* doc_3args =
R"""(Constructs the witness function with the given description (used
primarily for debugging and logging), direction type, and calculator
function; and with no event object.

Note:
    In order for the witness function to be used, you MUST overload
    System::DoGetWitnessFunctions().)""";
          // Source: drake/systems/framework/leaf_system.h:1791
          const char* doc_4args =
R"""(Constructs the witness function with the given description (used
primarily for debugging and logging), direction type, and calculator
function, and with an object corresponding to the event that is to be
dispatched when this witness function triggers. Example types of event
objects are publish, discrete variable update, unrestricted update
events. A clone of the event will be owned by the newly constructed
WitnessFunction.

Note:
    In order for the witness function to be used, you MUST overload
    System::DoGetWitnessFunctions().)""";
        } MakeWitnessFunction;
        // Symbol: drake::systems::LeafSystem::SetDefaultParameters
        struct /* SetDefaultParameters */ {
          // Source: drake/systems/framework/leaf_system.h:89
          const char* doc =
R"""(Default implementation: sets all numeric parameters to the model
vector given to DeclareNumericParameter, or else if no model was
provided sets the numeric parameter to one. It sets all abstract
parameters to the model value given to DeclareAbstractParameter.
Overrides must not change the number of parameters.)""";
        } SetDefaultParameters;
        // Symbol: drake::systems::LeafSystem::SetDefaultState
        struct /* SetDefaultState */ {
          // Source: drake/systems/framework/leaf_system.h:81
          const char* doc =
R"""(Default implementation: sets all continuous state to the model vector
given in DeclareContinuousState (or zero if no model vector was given)
and discrete states to zero. Overrides must not change the number of
state variables.)""";
        } SetDefaultState;
      } LeafSystem;
      // Symbol: drake::systems::LinearSystem
      struct /* LinearSystem */ {
        // Source: drake/systems/primitives/linear_system.h:36
        const char* doc =
R"""(A discrete OR continuous linear system.

If time_period>0.0, then the linear system will have the following
discrete- time state update:

.. math:: x[n+1] = A x[n] + B u[n],

or if time_period==0.0, then the linear system will have the following
continuous-time state update:

.. math:: \dot{x} = A x + B u.

In both cases, the system will have the output:

.. math:: y = C x + D u,

where ``u`` denotes the input vector, ``x`` denotes the state vector,
and ``y`` denotes the output vector.

See also:
    AffineSystem

See also:
    MatrixGain)""";
        // Symbol: drake::systems::LinearSystem::LinearSystem<T>
        struct /* ctor */ {
          // Source: drake/systems/primitives/linear_system.h:51
          const char* doc_5args =
R"""(Constructs a LinearSystem with a fixed set of coefficient matrices
``A``, `B`,``C``, and ``D``. The coefficient matrices must obey the
following dimensions: | Matrix | Num Rows | Num Columns |
|:-------:|:-----------:|:-----------:| | A | num states | num states
| | B | num states | num inputs | | C | num outputs | num states | | D
| num outputs | num inputs |

Subclasses must use the protected constructor, not this one.)""";
          // Source: drake/systems/primitives/linear_system.h:59
          const char* doc_copyconvert =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";
          // Source: drake/systems/primitives/linear_system.h:79
          const char* doc_6args =
R"""(Constructor that specifies scalar-type conversion support.

Parameter ``converter``:
    scalar-type conversion support helper (i.e., AutoDiff, etc.); pass
    a default-constructed object if such support is not desired. See
    system_scalar_conversion for detailed background and examples
    related to scalar-type conversion support.)""";
        } ctor;
        // Symbol: drake::systems::LinearSystem::MakeLinearSystem
        struct /* MakeLinearSystem */ {
          // Source: drake/systems/primitives/linear_system.h:66
          const char* doc =
R"""(Creates a unique pointer to LinearSystem<T> by decomposing
``dynamics`` and ``outputs`` using ``state_vars`` and ``input_vars``.

Raises:
    RuntimeError if either ``dynamics`` or ``outputs`` is not linear
    in ``state_vars`` and ``input_vars``.)""";
        } MakeLinearSystem;
      } LinearSystem;
      // Symbol: drake::systems::Linearize
      struct /* Linearize */ {
        // Source: drake/systems/primitives/linear_system.h:177
        const char* doc =
R"""(Takes the first-order Taylor expansion of a System around a nominal
operating point (defined by the Context).

This method currently supports linearizing around at most a single
vector input port and at most a single vector output port. For systems
with more ports, use ``input_port_index`` and ``output_port_index`` to
select the input for the newly constructed system. Any additional
*vector* input ports will be treated as constants (fixed at the value
specified in ``context``). Abstract-valued input ports must be
unconnected (i.e., the system must treat the port as optional and it
must be unused).

Parameter ``system``:
    The system or subsystem to linearize.

Parameter ``context``:
    Defines the nominal operating point about which the system should
    be linearized. See note below.

Parameter ``input_port_index``:
    A valid input port index for ``system`` or InputPortSelection. All
    other inputs are assumed to be fixed to the value described by the
    ``context``. $*Default:* kUseFirstInputIfItExists.

Parameter ``output_port_index``:
    A valid output port index for ``system`` or an
    OutputPortSelection. $*Default:* kUseFirstOutputIfItExists.

Parameter ``equilibrium_check_tolerance``:
    Specifies the tolerance on ensuring that the derivative vector
    isZero at the nominal operating point. $*Default:* 1e-6.

Returns:
    A LinearSystem that approximates the original system in the
    vicinity of the operating point. See note below.

Raises:
    RuntimeError if the operating point is not an equilibrium point of
    the system (within the specified tolerance)

Raises:
    RuntimeError if the system is not (only) continuous or (only)
    discrete time with a single periodic update.

Note:
    All *vector* inputs in the system must be connected, either to the
    output of some upstream System within a Diagram (e.g., if system
    is a reference to a subsystem in a Diagram), or to a constant
    value using, e.g. ``port.FixValue(context, default_input)``. Any
    *abstract* inputs in the system must be unconnected (the port must
    be both optional and unused).

Note:
    The inputs, states, and outputs of the returned system are NOT the
    same as the original system. Denote x0,u0 as the nominal state and
    input defined by the Context, and y0 as the value of the output at
    (x0,u0), then the created systems inputs are (u-u0), states are
    (x-x0), and outputs are (y-y0).

Note:
    This method does *not* (yet) set the initial conditions (default
    nor random) of the LinearSystem based on ``system``.)""";
      } Linearize;
      // Symbol: drake::systems::LogOutput
      struct /* LogOutput */ {
        // Source: drake/systems/primitives/signal_logger.h:142
        const char* doc =
R"""(Provides a convenience function for adding a SignalLogger, initialized
to the correct size, and connected to an output in a DiagramBuilder.


::

    DiagramBuilder<double> builder;
      auto foo = builder.AddSystem<Foo>("name", 3.14);
      auto logger = LogOutput(foo->get_output_port(), &builder);)""";
      } LogOutput;
      // Symbol: drake::systems::MatrixGain
      struct /* MatrixGain */ {
        // Source: drake/systems/primitives/matrix_gain.h:24
        const char* doc =
R"""(A system that specializes LinearSystem by setting coefficient matrices
``A``, `B`, and ``C`` to all be zero. Thus, the only non-zero
coefficient matrix is ``D``. Specifically, given an input signal ``u``
and a state ``x``, the output of this system, ``y``, is:

.. math:: y = D u

See also:
    AffineSystem

See also:
    LinearSystem)""";
        // Symbol: drake::systems::MatrixGain::MatrixGain<T>
        struct /* ctor */ {
          // Source: drake/systems/primitives/matrix_gain.h:30
          const char* doc_1args_size =
R"""(A constructor where the gain matrix ``D`` is a square identity matrix
of size ``size``.)""";
          // Source: drake/systems/primitives/matrix_gain.h:33
          const char* doc_1args_D =
R"""(A constructor where the gain matrix ``D`` is ``D``.)""";
          // Source: drake/systems/primitives/matrix_gain.h:37
          const char* doc_copyconvert =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";
        } ctor;
      } MatrixGain;
      // Symbol: drake::systems::Multiplexer
      struct /* Multiplexer */ {
        // Source: drake/systems/primitives/multiplexer.h:18
        const char* doc =
R"""(This system combines multiple vector-valued inputs into a
vector-valued output. The input to this system directly feeds through
to its output.)""";
        // Symbol: drake::systems::Multiplexer::Multiplexer<T>
        struct /* ctor */ {
          // Source: drake/systems/primitives/multiplexer.h:24
          const char* doc_1args_num_scalar_inputs =
R"""(Constructs a Multiplexer with ``num_scalar_inputs`` scalar-valued
input ports, and one vector-valued output port of size
``num_scalar_inputs``.)""";
          // Source: drake/systems/primitives/multiplexer.h:29
          const char* doc_1args_input_sizes =
R"""(Constructs a Multiplexer with ``input_sizes.size()`` vector-valued
input ports where the i-th input has size ``input_sizes[i]``, and one
vector- valued output port of size ``sum(input_sizes)``.)""";
          // Source: drake/systems/primitives/multiplexer.h:38
          const char* doc_1args_model_vector =
R"""(Constructs a Multiplexer with model_vector.size() scalar-valued inputs
and one vector-valued output port whose size equals the size of
``model_vector``. In addition, the output type derives from that of
``model_vector``.

Note:
    Objects created using this constructor overload do not support
    system scalar conversion. See system_scalar_conversion.)""";
          // Source: drake/systems/primitives/multiplexer.h:42
          const char* doc_copyconvert =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";
        } ctor;
      } Multiplexer;
      // Symbol: drake::systems::NumericParameterIndex
      struct /* NumericParameterIndex */ {
        // Source: drake/systems/framework/framework_common.h:62
        const char* doc =
R"""(Serves as the local index for numeric parameter groups within a given
System and its corresponding Context.)""";
      } NumericParameterIndex;
      // Symbol: drake::systems::ObservabilityMatrix
      struct /* ObservabilityMatrix */ {
        // Source: drake/systems/primitives/linear_system.h:251
        const char* doc =
R"""(Returns the observability matrix: O = [ C; CA; ...; CA^{n-1} ].)""";
      } ObservabilityMatrix;
      // Symbol: drake::systems::OutputPort
      struct /* OutputPort */ {
        // Source: drake/systems/framework/output_port.h:66
        const char* doc =
R"""(An OutputPort belongs to a System and represents the properties of one
of that System's output ports. OutputPort objects are assigned
OutputPortIndex values in the order they are declared; these are
unique within a single System.

An output port can be considered a "window" into a System that permits
controlled exposure of one of the values contained in that System's
Context at run time. Input ports of other subsystems may be connected
to an output port to construct system diagrams with carefully managed
interdependencies.

The exposed value may be the result of an output computation, or it
may simply expose some other value contained in the Context, such as
the values of state variables. The Context handles caching of output
port values and tracks dependencies to ensure that the values are
valid with respect to their prerequisites. Leaf systems provide for
the production of output port values, by computation or forwarding
from other values within the associated leaf context. A diagram's
output ports, on the other hand, are exported from output ports of its
contained subsystems.

An output port's value is always stored as an AbstractValue, but we
also provide special handling for output ports known to have numeric
(vector) values. Vector-valued ports may specify a particular vector
length, or may leave that to be determined at runtime.

OutputPort objects support three important operations:

- Allocate() returns an object that can hold the port's value.
- Calc() unconditionally computes the port's value.
- Eval() updates a cached value if necessary.)""";
        // Symbol: drake::systems::OutputPort::Allocate
        struct /* Allocate */ {
          // Source: drake/systems/framework/output_port.h:138
          const char* doc =
R"""(Allocates a concrete object suitable for holding the value to be
exposed by this output port, and returns that as an AbstractValue. The
returned object will never be null. If Drake assertions are enabled
(typically only in Debug builds), validates for a vector-valued port
that the returned AbstractValue is actually a BasicVector-derived type
and that it has an acceptable size.

Note:
    If this is a vector-valued port, the underlying type is
    ``Value<BasicVector<T>>``; downcast to ``BasicVector<T>`` before
    downcasting to the specific ``BasicVector`` subclass.)""";
        } Allocate;
        // Symbol: drake::systems::OutputPort::Calc
        struct /* Calc */ {
          // Source: drake/systems/framework/output_port.h:155
          const char* doc =
R"""(Unconditionally computes the value of this output port with respect to
the given context, into an already-allocated AbstractValue object
whose concrete type must be exactly the same as the type returned by
this port's allocator. If Drake assertions are enabled (typically only
in Debug builds), validates that the given ``value`` has exactly the
same concrete type as is returned by the Allocate() method.)""";
        } Calc;
        // Symbol: drake::systems::OutputPort::DoAllocate
        struct /* DoAllocate */ {
          // Source: drake/systems/framework/output_port.h:203
          const char* doc =
R"""(A concrete OutputPort must provide a way to allocate a suitable object
for holding the runtime value of this output port. The particulars may
depend on values and types of objects in the given Context.

Returns:
    A unique_ptr to the new value-holding object as an AbstractValue.)""";
        } DoAllocate;
        // Symbol: drake::systems::OutputPort::DoCalc
        struct /* DoCalc */ {
          // Source: drake/systems/framework/output_port.h:213
          const char* doc =
R"""(A concrete OutputPort must implement this method to calculate the
value this output port should have, given the supplied Context. The
value may be determined by computation or by copying from a source
value in the Context.

Parameter ``context``:
    A Context that has already been validated as compatible with the
    System whose output port this is.

Parameter ``value``:
    A pointer that has already be validated as non-null and pointing
    to an object of the right type to hold a value of this output
    port.)""";
        } DoCalc;
        // Symbol: drake::systems::OutputPort::DoEval
        struct /* DoEval */ {
          // Source: drake/systems/framework/output_port.h:223
          const char* doc =
R"""(A concrete OutputPort must provide access to the current value of this
output port stored within the given Context. If the value is already
up to date with respect to its prerequisites in ``context``, no
computation should be performed. Otherwise, the implementation should
arrange for the value to be computed, typically but not necessarily by
invoking DoCalc().

Parameter ``context``:
    A Context that has already been validated as compatible with the
    System whose output port this is.)""";
        } DoEval;
        // Symbol: drake::systems::OutputPort::Eval
        struct /* Eval */ {
          // Source: drake/systems/framework/output_port.h:102
          const char* doc = R"""()""";
        } Eval;
        // Symbol: drake::systems::OutputPort::OutputPort<T>
        struct /* ctor */ {
          // Source: drake/systems/framework/output_port.h:187
          const char* doc =
R"""(Provides derived classes the ability to set the base class members at
construction. See OutputPortBase::OutputPortBase() for the meaning of
these parameters.

Precondition:
    The ``name`` must not be empty.

Precondition:
    The ``system`` parameter must be the same object as the
    ``system_interface`` parameter.)""";
        } ctor;
        // Symbol: drake::systems::OutputPort::ThrowIfInvalidPortValueType
        struct /* ThrowIfInvalidPortValueType */ {
          // Source: drake/systems/framework/output_port.h:229
          const char* doc_2args =
R"""(Check that an AbstractValue provided to Calc() is suitable for this
port. Derived classes should throw a helpful message if not (see
LeafOutputPort for an example). It is OK for this to be an expensive
check because we will only call it in Debug builds.)""";
          // Source: drake/systems/framework/output_port.h:233
          const char* doc_3args =
R"""(Static method allows DiagramOutputPort to call this recursively.)""";
        } ThrowIfInvalidPortValueType;
        // Symbol: drake::systems::OutputPort::get_system
        struct /* get_system */ {
          // Source: drake/systems/framework/output_port.h:165
          const char* doc =
R"""(Returns a reference to the System that owns this output port. Note
that for a diagram output port this will be the diagram, not the leaf
system whose output port was forwarded.)""";
        } get_system;
      } OutputPort;
      // Symbol: drake::systems::OutputPortBase
      struct /* OutputPortBase */ {
        // Source: drake/systems/framework/output_port_base.h:14
        const char* doc =
R"""(OutputPortBase handles the scalar type-independent aspects of an
OutputPort. An OutputPort belongs to a System and represents the
properties of one of that System's output ports.)""";
        // Symbol: drake::systems::OutputPortBase::DoGetPrerequisite
        struct /* DoGetPrerequisite */ {
          // Source: drake/systems/framework/output_port_base.h:69
          const char* doc =
R"""(Concrete output ports must implement this to return the prerequisite
dependency ticket for this port, which may be in the current System or
one of its immediate child subsystems.)""";
        } DoGetPrerequisite;
        // Symbol: drake::systems::OutputPortBase::GetPrerequisite
        struct /* GetPrerequisite */ {
          // Source: drake/systems/framework/output_port_base.h:38
          const char* doc = R"""()""";
        } GetPrerequisite;
        // Symbol: drake::systems::OutputPortBase::OutputPortBase
        struct /* ctor */ {
          // Source: drake/systems/framework/output_port_base.h:61
          const char* doc =
R"""(Provides derived classes the ability to set the base class members at
construction.

Parameter ``owning_system``:
    The System that owns this output port.

Parameter ``name``:
    A name for the port. Must not be empty. Output port names should
    be unique within a single System.

Parameter ``index``:
    The index to be assigned to this OutputPort.

Parameter ``ticket``:
    The DependencyTicket to be assigned to this OutputPort.

Parameter ``data_type``:
    Whether the port described is vector or abstract valued.

Parameter ``size``:
    If the port described is vector-valued, the number of elements
    expected, otherwise ignored.)""";
        } ctor;
        // Symbol: drake::systems::OutputPortBase::get_index
        struct /* get_index */ {
          // Source: drake/systems/framework/output_port_base.h:23
          const char* doc =
R"""(Returns the index of this output port within the owning System. For a
Diagram, this will be the index within the Diagram, *not* the index
within the LeafSystem whose output port was forwarded.)""";
        } get_index;
      } OutputPortBase;
      // Symbol: drake::systems::OutputPortIndex
      struct /* OutputPortIndex */ {
        // Source: drake/systems/framework/framework_common.h:50
        const char* doc =
R"""(Serves as the local index for the output ports of a given System. The
indexes used by a subsystem and its corresponding subcontext are the
same.)""";
      } OutputPortIndex;
      // Symbol: drake::systems::OutputPortSelection
      struct /* OutputPortSelection */ {
        // Source: drake/systems/framework/framework_common.h:101
        const char* doc =
R"""(Intended for use in e.g. variant<OutputPortSelection, OutputPortIndex>
for algorithms that support optional and/or default port indices.)""";
        // Symbol: drake::systems::OutputPortSelection::kNoOutput
        struct /* kNoOutput */ {
          // Source: drake/systems/framework/framework_common.h:101
          const char* doc = R"""()""";
        } kNoOutput;
        // Symbol: drake::systems::OutputPortSelection::kUseFirstOutputIfItExists
        struct /* kUseFirstOutputIfItExists */ {
          // Source: drake/systems/framework/framework_common.h:101
          const char* doc = R"""()""";
        } kUseFirstOutputIfItExists;
      } OutputPortSelection;
      // Symbol: drake::systems::Parameters
      struct /* Parameters */ {
        // Source: drake/systems/framework/parameters.h:27
        const char* doc =
R"""(Parameters is a container for variables that parameterize a System so
that it can represent a family of related models. Parameters are
members of the Context. Parameters are not Inputs because they do not
flow from upstream Systems, and they are not State because the System
does not define update functions for them. If Parameters are modified,
they are modified by application-specific logic, extrinsic to the
System framework and to the flow of simulation time.

The Parameters include both vector-valued and abstract-valued
elements.)""";
        // Symbol: drake::systems::Parameters::Clone
        struct /* Clone */ {
          // Source: drake/systems/framework/parameters.h:135
          const char* doc = R"""(Returns a deep copy of the Parameters.)""";
        } Clone;
        // Symbol: drake::systems::Parameters::Parameters<T>
        struct /* ctor */ {
          // Source: drake/systems/framework/parameters.h:33
          const char* doc_0args = R"""(Constructs an empty Parameters.)""";
          // Source: drake/systems/framework/parameters.h:36
          const char* doc_2args_numeric_abstract =
R"""(Constructs Parameters both ``numeric`` and ``abstract``.)""";
          // Source: drake/systems/framework/parameters.h:44
          const char* doc_1args_numeric =
R"""(Constructs Parameters that are purely ``numeric``.)""";
          // Source: drake/systems/framework/parameters.h:48
          const char* doc_1args_abstract =
R"""(Constructs Parameters that are purely ``abstract``.)""";
          // Source: drake/systems/framework/parameters.h:53
          const char* doc_1args_vec =
R"""(Constructs Parameters in the common case where the parameters consist
of exactly one numeric vector.)""";
          // Source: drake/systems/framework/parameters.h:60
          const char* doc_1args_value =
R"""(Constructs Parameters in the common case where the parameters consist
of exactly one abstract value.)""";
        } ctor;
        // Symbol: drake::systems::Parameters::SetFrom
        struct /* SetFrom */ {
          // Source: drake/systems/framework/parameters.h:144
          const char* doc = R"""(Initializes this state from ``other``.)""";
        } SetFrom;
        // Symbol: drake::systems::Parameters::get_abstract_parameter
        struct /* get_abstract_parameter */ {
          // Source: drake/systems/framework/parameters.h:99
          const char* doc_1args_index =
R"""(Returns the abstract-valued parameter at ``index``. Asserts if the
index is out of bounds.)""";
          // Source: drake/systems/framework/parameters.h:112
          const char* doc_1args_int =
R"""(Returns the abstract-valued parameter at ``index``. Asserts if the
index is out of bounds, and throws if the parameter is not of type V.)""";
        } get_abstract_parameter;
        // Symbol: drake::systems::Parameters::get_abstract_parameters
        struct /* get_abstract_parameters */ {
          // Source: drake/systems/framework/parameters.h:124
          const char* doc = R"""()""";
        } get_abstract_parameters;
        // Symbol: drake::systems::Parameters::get_mutable_abstract_parameter
        struct /* get_mutable_abstract_parameter */ {
          // Source: drake/systems/framework/parameters.h:105
          const char* doc_1args_index =
R"""(Returns the abstract-valued parameter at ``index``. Asserts if the
index is out of bounds.)""";
          // Source: drake/systems/framework/parameters.h:119
          const char* doc_1args_int =
R"""(Returns the abstract-valued parameter at ``index``. Asserts if the
index is out of bounds, and throws if the parameter is not of type V.)""";
        } get_mutable_abstract_parameter;
        // Symbol: drake::systems::Parameters::get_mutable_numeric_parameter
        struct /* get_mutable_numeric_parameter */ {
          // Source: drake/systems/framework/parameters.h:83
          const char* doc =
R"""(Returns the vector-valued parameter at ``index``. Asserts if the index
is out of bounds.)""";
        } get_mutable_numeric_parameter;
        // Symbol: drake::systems::Parameters::get_numeric_parameter
        struct /* get_numeric_parameter */ {
          // Source: drake/systems/framework/parameters.h:77
          const char* doc =
R"""(Returns the vector-valued parameter at ``index``. Asserts if the index
is out of bounds.)""";
        } get_numeric_parameter;
        // Symbol: drake::systems::Parameters::get_numeric_parameters
        struct /* get_numeric_parameters */ {
          // Source: drake/systems/framework/parameters.h:87
          const char* doc = R"""()""";
        } get_numeric_parameters;
        // Symbol: drake::systems::Parameters::num_abstract_parameters
        struct /* num_abstract_parameters */ {
          // Source: drake/systems/framework/parameters.h:71
          const char* doc = R"""()""";
        } num_abstract_parameters;
        // Symbol: drake::systems::Parameters::num_numeric_parameter_groups
        struct /* num_numeric_parameter_groups */ {
          // Source: drake/systems/framework/parameters.h:67
          const char* doc = R"""()""";
        } num_numeric_parameter_groups;
        // Symbol: drake::systems::Parameters::set_abstract_parameters
        struct /* set_abstract_parameters */ {
          // Source: drake/systems/framework/parameters.h:128
          const char* doc = R"""()""";
        } set_abstract_parameters;
        // Symbol: drake::systems::Parameters::set_numeric_parameters
        struct /* set_numeric_parameters */ {
          // Source: drake/systems/framework/parameters.h:91
          const char* doc = R"""()""";
        } set_numeric_parameters;
      } Parameters;
      // Symbol: drake::systems::PassThrough
      struct /* PassThrough */ {
        // Source: drake/systems/primitives/pass_through.h:42
        const char* doc =
R"""(A pass through system with input ``u`` and output ``y = u``. This is
mathematically equivalent to a Gain system with its gain equal to one.
However this system incurs no computational cost. The input to this
system directly feeds through to its output.

The system can also be used to provide default values for a port in
any diagram. If the input port does not have a value, then the default
value passed in the constructor is passed to the output.

This system is used, for instance, in PidController which is a Diagram
composed of simple framework primitives. In this case a PassThrough is
used to connect the exported input of the Diagram to the inputs of the
Gain systems for the proportional and integral constants of the
controller. This is necessary to provide an output port to which the
internal Gain subsystems connect. In this case the PassThrough is
effectively creating an output port that feeds through the input to
the Diagram and that can now be connected to the inputs of the inner
subsystems to the Diagram. A detailed discussion of the PidController
can be found at https://github.com/RobotLocomotion/drake/pull/3132.

.. pydrake_system::

    name: PassThrough
    input_ports:
    - u (optional)
    output_ports:
    - y)""";
        // Symbol: drake::systems::PassThrough::PassThrough<T>
        struct /* ctor */ {
          // Source: drake/systems/primitives/pass_through.h:49
          const char* doc_1args_vector_size =
R"""(Constructs a pass-through system.

Parameter ``vector_size``:
    number of elements in the signal to be processed. When no input is
    connected, the output will be a vector of all zeros.)""";
          // Source: drake/systems/primitives/pass_through.h:55
          const char* doc_1args_value =
R"""(Constructs a pass-through system with vector-valued input/output
ports.

Parameter ``value``:
    The model value, which defines the size of the ports and serves as
    the default when no input is connected.)""";
          // Source: drake/systems/primitives/pass_through.h:61
          const char* doc_1args_abstract_model_value =
R"""(Constructs a pass-through system with abstract-valued input/output
ports.

Parameter ``abstract_model_value``:
    A model value, which defines the type of the ports and serves as
    the default when no input is connected.)""";
          // Source: drake/systems/primitives/pass_through.h:67
          const char* doc_copyconvert =
R"""(Scalar-type converting copy constructor. See system_scalar_conversion.)""";
        } ctor;
        // Symbol: drake::systems::PassThrough::get_input_port
        struct /* get_input_port */ {
          // Source: drake/systems/primitives/pass_through.h:75
          const char* doc = R"""(Returns the sole input port.)""";
        } get_input_port;
      } PassThrough;
      // Symbol: drake::systems::PeriodicEventData
      struct /* PeriodicEventData */ {
        // Source: drake/systems/framework/event.h:252
        const char* doc =
R"""(A token describing an event that recurs on a fixed period. The events
are triggered at time = offset_sec + i * period_sec, where i is a
non-negative integer.)""";
        // Symbol: drake::systems::PeriodicEventData::PeriodicEventData
        struct /* ctor */ {
          // Source: drake/systems/framework/event.h:254
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::systems::PeriodicEventData::offset_sec
        struct /* offset_sec */ {
          // Source: drake/systems/framework/event.h:264
          const char* doc =
R"""(Gets the time after zero when this event should first occur.)""";
        } offset_sec;
        // Symbol: drake::systems::PeriodicEventData::period_sec
        struct /* period_sec */ {
          // Source: drake/systems/framework/event.h:258
          const char* doc =
R"""(Gets the period with which this event should recur.)""";
        } period_sec;
        // Symbol: drake::systems::PeriodicEventData::set_offset_sec
        struct /* set_offset_sec */ {
          // Source: drake/systems/framework/event.h:267
          const char* doc =
R"""(Sets the time after zero when this event should first occur.)""";
        } set_offset_sec;
        // Symbol: drake::systems::PeriodicEventData::set_period_sec
        struct /* set_period_sec */ {
          // Source: drake/systems/framework/event.h:261
          const char* doc =
R"""(Sets the period with which this event should recur.)""";
        } set_period_sec;
      } PeriodicEventData;
      // Symbol: drake::systems::PeriodicEventDataComparator
      struct /* PeriodicEventDataComparator */ {
        // Source: drake/systems/framework/event.h:560
        const char* doc =
R"""(Structure for comparing two PeriodicEventData objects for use in a map
container, using an arbitrary comparison method.)""";
        // Symbol: drake::systems::PeriodicEventDataComparator::operator()
        struct /* operator_call */ {
          // Source: drake/systems/framework/event.h:561
          const char* doc = R"""()""";
        } operator_call;
      } PeriodicEventDataComparator;
      // Symbol: drake::systems::PortBase
      struct /* PortBase */ {
        // Source: drake/systems/framework/port_base.h:13
        const char* doc =
R"""(A PortBase is base class for System ports; users will typically use
the the InputPort<T> or OutputPort<T> types, not this base class.)""";
        // Symbol: drake::systems::PortBase::GetFullDescription
        struct /* GetFullDescription */ {
          // Source: drake/systems/framework/port_base.h:24
          const char* doc =
R"""(Returns a verbose human-readable description of port. This is useful
for error messages or debugging.)""";
        } GetFullDescription;
        // Symbol: drake::systems::PortBase::PortBase
        struct /* ctor */ {
          // Source: drake/systems/framework/port_base.h:71
          const char* doc =
R"""(Provides derived classes the ability to set the base class members at
construction.

Parameter ``kind_string``:
    Either "Input" or "Output", depending on the kind of subclass.

Parameter ``owning_system``:
    The System that owns this port.

Parameter ``name``:
    A name for the port. Port names should be non-empty and unique
    within a single System.

Parameter ``index``:
    The index to be assigned to this port. Input ports and output
    ports each have their own pool of indices (InputPortIndex and
    OutputPortIndex); this is just that TypeSafeIndex passed as a bare
    int.

Parameter ``ticket``:
    The DependencyTicket to be assigned to this port.

Parameter ``data_type``:
    Whether the port described is vector- or abstract-valued.

Parameter ``size``:
    If the port described is vector-valued, the number of elements.
    Ignored for abstract-valued ports.)""";
        } ctor;
        // Symbol: drake::systems::PortBase::PortEvalCast
        struct /* PortEvalCast */ {
          // Source: drake/systems/framework/port_base.h:90
          const char* doc_1args_constdrakeAbstractValue =
R"""(Pull a value of a given type from an abstract value or issue a nice
message if the type is not correct.)""";
          // Source: drake/systems/framework/port_base.h:95
          const char* doc_1args_constBasicVector =
R"""(Downcast a basic vector to a more specific subclass (e.g., as
generated by //tools/vector_gen) or issue a nice message if the type
is not correct.)""";
        } PortEvalCast;
        // Symbol: drake::systems::PortBase::ThrowBadCast
        struct /* ThrowBadCast */ {
          // Source: drake/systems/framework/port_base.h:99
          const char* doc_1args =
R"""(Reports that the user provided a bad ValueType argument to Eval.)""";
          // Source: drake/systems/framework/port_base.h:114
          const char* doc_2args =
R"""(Reports that the user provided a bad ValueType argument to Eval. The
value_typename is the type of the port's current value; the
eval_typename is the type the user asked for.)""";
        } ThrowBadCast;
        // Symbol: drake::systems::PortBase::get_data_type
        struct /* get_data_type */ {
          // Source: drake/systems/framework/port_base.h:27
          const char* doc = R"""(Returns the port data type.)""";
        } get_data_type;
        // Symbol: drake::systems::PortBase::get_int_index
        struct /* get_int_index */ {
          // Source: drake/systems/framework/port_base.h:80
          const char* doc =
R"""(Returns the index of this port within the owning System (i.e., an
InputPortIndex or OutputPortIndex, but as a bare integer). For a
Diagram, this will be the index within the Diagram, *not* the index
within the LeafSystem whose output port was forwarded.)""";
        } get_int_index;
        // Symbol: drake::systems::PortBase::get_mutable_system_interface
        struct /* get_mutable_system_interface */ {
          // Source: drake/systems/framework/port_base.h:83
          const char* doc =
R"""(Returns get_system_interface(), but without the const.)""";
        } get_mutable_system_interface;
        // Symbol: drake::systems::PortBase::get_name
        struct /* get_name */ {
          // Source: drake/systems/framework/port_base.h:20
          const char* doc = R"""(Get port name.)""";
        } get_name;
        // Symbol: drake::systems::PortBase::get_system_interface
        struct /* get_system_interface */ {
          // Source: drake/systems/framework/port_base.h:37
          const char* doc = R"""()""";
        } get_system_interface;
        // Symbol: drake::systems::PortBase::size
        struct /* size */ {
          // Source: drake/systems/framework/port_base.h:31
          const char* doc =
R"""(Returns the fixed size expected for a vector-valued port. Not
meaningful for abstract-valued ports.)""";
        } size;
        // Symbol: drake::systems::PortBase::ticket
        struct /* ticket */ {
          // Source: drake/systems/framework/port_base.h:44
          const char* doc =
R"""((Advanced.) Returns the DependencyTicket for this port within the
owning System.)""";
        } ticket;
      } PortBase;
      // Symbol: drake::systems::PortDataType
      struct /* PortDataType */ {
        // Source: drake/systems/framework/framework_common.h:76
        const char* doc = R"""()""";
      } PortDataType;
      // Symbol: drake::systems::PortSwitch
      struct /* PortSwitch */ {
        // Source: drake/systems/primitives/port_switch.h:41
        const char* doc =
R"""(A simple system that passes through the value from just one of its
input ports to the output. All inputs (except for the port_selector)
must have the same data type as the output.

This system only evaluates the port_selector port and the input port
that is indicated by port_selector at runtime. Because of the System
framework's "pull architecture", this means that entire sub-diagrams
can potentially be added with minimal runtime cost (their outputs will
not be evaluated until they are selected). Just remember that their
state dynamics *will* still be evaluated when the diagram's dynamics
are evaluated (e.g. during simulation), and their output ports could
be evaluated via other connections.

.. pydrake_system::

    name: PortSwitch
    input_ports:
    - port_selector
    - value0 (with assigned port name)
    - ...
    - valueN (with assigned port name)
    output_ports:
    - value)""";
        // Symbol: drake::systems::PortSwitch::DeclareInputPort
        struct /* DeclareInputPort */ {
          // Source: drake/systems/primitives/port_switch.h:85
          const char* doc =
R"""(Declares a new input port to the switch with port name ``name``. The
type of this port is already defined by the type of the output port.
This must be called before any Context is allocated.)""";
        } DeclareInputPort;
        // Symbol: drake::systems::PortSwitch::PortSwitch<T>
        struct /* ctor */ {
          // Source: drake/systems/primitives/port_switch.h:43
          const char* doc_was_unable_to_choose_unambiguous_names = R"""()""";
        } ctor;
        // Symbol: drake::systems::PortSwitch::get_port_selector_input_port
        struct /* get_port_selector_input_port */ {
          // Source: drake/systems/primitives/port_switch.h:78
          const char* doc = R"""()""";
        } get_port_selector_input_port;
      } PortSwitch;
      // Symbol: drake::systems::PrintSimulatorStatistics
      struct /* PrintSimulatorStatistics */ {
        // Source: drake/systems/analysis/simulator_print_stats.h:12
        const char* doc =
R"""(This method outputs to stdout relevant simulation statistics for a
simulator that advanced the state of a system forward in time.

Parameter ``simulator``:
    The simulator to output statistics for.)""";
      } PrintSimulatorStatistics;
      // Symbol: drake::systems::PublishEvent
      struct /* PublishEvent */ {
        // Source: drake/systems/framework/event.h:575
        const char* doc =
R"""(This class represents a publish event. It has an optional callback
function to do custom handling of this event given const Context and
const PublishEvent object references.

See also:
    System::Publish for more details.)""";
        // Symbol: drake::systems::PublishEvent::PublishCallback
        struct /* PublishCallback */ {
          // Source: drake/systems/framework/event.h:586
          const char* doc =
R"""(Callback function that processes a publish event.)""";
        } PublishCallback;
        // Symbol: drake::systems::PublishEvent::PublishEvent<T>
        struct /* ctor */ {
          // Source: drake/systems/framework/event.h:590
          const char* doc_0args =
R"""(Makes a PublishEvent with no trigger type, no event data, and no
specified callback function.)""";
          // Source: drake/systems/framework/event.h:594
          const char* doc_1args =
R"""(Makes a PublishEvent with no trigger type, no event data, and the
specified callback function.)""";
        } ctor;
        // Symbol: drake::systems::PublishEvent::handle
        struct /* handle */ {
          // Source: drake/systems/framework/event.h:615
          const char* doc =
R"""(Calls the optional callback function, if one exists, with ``context``
and ``this``.)""";
        } handle;
        // Symbol: drake::systems::PublishEvent::is_discrete_update
        struct /* is_discrete_update */ {
          // Source: drake/systems/framework/event.h:580
          const char* doc = R"""()""";
        } is_discrete_update;
      } PublishEvent;
      // Symbol: drake::systems::RadauIntegrator
      struct /* RadauIntegrator */ {
        // Source: drake/systems/analysis/radau_integrator.h:64
        const char* doc =
R"""(A selectable order (third- or first-order), fully implicit integrator
with error estimation.

Template parameter ``num_stages``:
    The number of stages used in this integrator, which must be either
    1 or 2. Set this to 1 for the integrator to be implicit Euler and
    2 for it to Radau3 (default).

A two-stage Radau IIa (see [Hairer, 1996], Ch. 5) method is used for
propagating the state forward, by default. The state can also be
propagated using a single-stage method, in which case it is equivalent
to an implicit Euler method, by setting num_stages=1. Regardless of
the order of propagating state, the local (truncation) error is
estimated through the implicit trapezoid rule.

Radau IIa methods are known to be L-Stable, meaning both that applying
it at a fixed integration step to the "test" equation ``y(t) = eᵏᵗ``
yields zero (for ``k < 0`` and ``t → ∞``) *and* that it is also
A-Stable. A-Stability, in turn, means that the method can integrate
the linear constant coefficient system ``dx/dt = Ax`` at any step size
without the solution becoming unstable (growing without bound). The
practical effect of L-Stability is that the integrator tends to be
stable for any given step size on an arbitrary system of ordinary
differential equations. Note that the implicit trapezoid rule used for
error estimation is "only" A-Stable; whether this lesser stability has
some practical effect on the efficiency of this integrator is
currently unknown. See [Lambert, 1991], Ch. 6 for an approachable
discussion on stiff differential equations and L- and A-Stability.

This implementation uses Newton-Raphson (NR). General implementation
details were taken from [Hairer, 1996] Ch. 8.

- [Hairer, 1996]   E. Hairer and G. Wanner. Solving Ordinary Differential
                   Equations II (Stiff and Differential-Algebraic Problems).
                   Springer, 1996.
- [Lambert, 1991]  J. D. Lambert. Numerical Methods for Ordinary Differential
                   Equations. John Wiley & Sons, 1991.

See also:
    ImplicitIntegrator class documentation for information about
    implicit integration methods in general.

See also:
    Radau3Integrator and Radau1Integrator alises for third- and
    first-order templates with num_stages already specified.

Note:
    This integrator uses the integrator accuracy setting, even when
    run in fixed-step mode, to limit the error in the underlying
    Newton-Raphson process. See IntegratorBase::set_target_accuracy()
    for more info.)""";
        // Symbol: drake::systems::RadauIntegrator::RadauIntegrator<T, num_stages>
        struct /* ctor */ {
          // Source: drake/systems/analysis/radau_integrator.h:69
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::systems::RadauIntegrator::get_error_estimate_order
        struct /* get_error_estimate_order */ {
          // Source: drake/systems/analysis/radau_integrator.h:82
          const char* doc =
R"""(This integrator uses embedded second order methods to compute
estimates of the local truncation error. The order of the asymptotic
difference between the third-order Radau method and an embedded second
order method is O(h³). The order of the asymptotic difference between
the first-order Radau method and an embedded second order method is
O(h²).)""";
        } get_error_estimate_order;
        // Symbol: drake::systems::RadauIntegrator::supports_error_estimation
        struct /* supports_error_estimation */ {
          // Source: drake/systems/analysis/radau_integrator.h:75
          const char* doc = R"""()""";
        } supports_error_estimation;
      } RadauIntegrator;
      // Symbol: drake::systems::RandomSource
      struct /* RandomSource */ {
        // Source: drake/systems/primitives/random_source.h:72
        const char* doc =
R"""(A source block which generates random numbers at a fixed sampling
interval, with a zero-order hold between samples. For continuous-time
systems, this can be interpreted as a band-limited approximation of
continuous white noise (with a power-spectral density of the form Ts *
sinc^2( omega * Ts ), where Ts is the sampling interval.

.. pydrake_system::

    name: RandomSource
    output_ports:
    - output

This system exposes a parameter named ``seed`` for the pseudo-random
number generator that determines the noise output. The ``seed``
parameter behaves as follows:

1. Each newly-created RandomSource chooses a new ``per_instance_seed`` member
field value for itself.  The value will be unique within the current
executable process.

2. By default, ``source.CreateDefaultContext()`` will set the returned
context's ``seed`` parameter to ``per_instance_seed``.  Therefore, for a given
instance of this system, the parameters, state, and outputs will be
identical for all simulations that start from a default context.

3. By default, ``source.SetRandomContext()`` will choose a new, arbitrary
value for the context's ``seed`` parameter, which means that the system's
parameters, state, and outputs will (almost certainly) differ from their
defaults.

4. The user may call ``source.set_fixed_seed(new_seed)`` on this system.
When a ``new_seed`` value is provided, it is used by both
``CreateDefaultContext`` and ``SetRandomContext``.  Therefore, the system's
parameters, state, and outputs will be identical to any other instances
that share the same ``new_seed`` value for their ``seed`` context parameter.
Note that ``set_fixed_seed`` affects subsequently-created contexts; any
pre-existing contexts are unaffected.  The user may call
``source.set_fixed_seed(nullopt)`` to revert to the default the behaviors
described in #2 and #3 again.

5. The context returned by ``source.AllocateContext()`` does not contain a
valid ``seed`` parameter; that context should not be used until its values
are populated via another Context.

Note:
    This system is only defined for the double scalar type.

Note:
    The exact distribution results may vary across multiple platforms
    or revisions of Drake, but will be consistent for all compilations
    on a given platform and Drake revision.

Note:
    The hard-coding of (default) distribution parameters is imposed
    intentionally to simplify analysis (by forcing systems taking
    noise inputs to implement the shifting/scaling, the system itself
    contains all of the necessary information for stochastic
    analysis).

See also:
    stochastic_systems)""";
        // Symbol: drake::systems::RandomSource::RandomSource
        struct /* ctor */ {
          // Source: drake/systems/primitives/random_source.h:83
          const char* doc =
R"""(Constructs the RandomSource system.

Parameter ``distribution``:
    The RandomDistribution used for each of the outputs.

Parameter ``num_outputs``:
    The dimension of the (single) vector output port.

Parameter ``sampling_interval_sec``:
    The sampling interval in seconds.)""";
        } ctor;
        // Symbol: drake::systems::RandomSource::Seed
        struct /* Seed */ {
          // Source: drake/systems/primitives/random_source.h:77
          const char* doc = R"""(An integer type for a random seed.)""";
        } Seed;
        // Symbol: drake::systems::RandomSource::get_distribution
        struct /* get_distribution */ {
          // Source: drake/systems/primitives/random_source.h:89
          const char* doc =
R"""(Returns the ``distribution`` given at construction.)""";
        } get_distribution;
        // Symbol: drake::systems::RandomSource::get_fixed_seed
        struct /* get_fixed_seed */ {
          // Source: drake/systems/primitives/random_source.h:96
          const char* doc =
R"""(Gets this system's fixed random seed (or else nullopt when the seed is
not fixed). Refer to the class overview documentation for details.)""";
        } get_fixed_seed;
        // Symbol: drake::systems::RandomSource::get_seed
        struct /* get_seed */ {
          // Source: drake/systems/primitives/random_source.h:92
          const char* doc =
R"""(Returns the value of the ``seed`` parameter in the given context.)""";
        } get_seed;
        // Symbol: drake::systems::RandomSource::set_fixed_seed
        struct /* set_fixed_seed */ {
          // Source: drake/systems/primitives/random_source.h:100
          const char* doc =
R"""(Sets (or clears) this system's fixed random seed. Refer to the class
overview documentation for details.)""";
        } set_fixed_seed;
      } RandomSource;
      // Symbol: drake::systems::ResetIntegratorFromFlags
      struct /* ResetIntegratorFromFlags */ {
        // Source: drake/systems/analysis/simulator_config_functions.h:35
        const char* doc =
R"""(Resets the integrator used to advanced the continuous time dynamics of
the system associated with ``simulator`` according to the given
arguments.

Parameter ``simulator``:
    On input, a valid pointer to a Simulator. On output the integrator
    for ``simulator`` is reset according to the given arguments.

Parameter ``scheme``:
    Integration scheme to be used, e.g., "runge_kutta2". See
    GetIntegrationSchemes() for a the list of valid options.

Parameter ``max_step_size``:
    The IntegratorBase::set_maximum_step_size() value.

Returns:
    A reference to the newly created integrator owned by
    ``simulator``.

@tparam_default_nonsymbolic_scalar)""";
      } ResetIntegratorFromFlags;
      // Symbol: drake::systems::RungeKutta2Integrator
      struct /* RungeKutta2Integrator */ {
        // Source: drake/systems/analysis/runge_kutta2_integrator.h:18
        const char* doc =
R"""(A second-order, explicit Runge Kutta integrator.)""";
        // Symbol: drake::systems::RungeKutta2Integrator::RungeKutta2Integrator<T>
        struct /* ctor */ {
          // Source: drake/systems/analysis/runge_kutta2_integrator.h:35
          const char* doc =
R"""(Constructs fixed-step integrator for a given system using the given
context for initial conditions.

Parameter ``system``:
    A reference to the system to be simulated

Parameter ``max_step_size``:
    The maximum (fixed) step size; the integrator will not take larger
    step sizes than this.

Parameter ``context``:
    pointer to the context (nullptr is ok, but the caller must set a
    non-null context before Initialize()-ing the integrator).

See also:
    Initialize())""";
        } ctor;
        // Symbol: drake::systems::RungeKutta2Integrator::get_error_estimate_order
        struct /* get_error_estimate_order */ {
          // Source: drake/systems/analysis/runge_kutta2_integrator.h:48
          const char* doc =
R"""(Integrator does not provide an error estimate.)""";
        } get_error_estimate_order;
        // Symbol: drake::systems::RungeKutta2Integrator::supports_error_estimation
        struct /* supports_error_estimation */ {
          // Source: drake/systems/analysis/runge_kutta2_integrator.h:45
          const char* doc =
R"""(The RK2 integrator does not support error estimation.)""";
        } supports_error_estimation;
      } RungeKutta2Integrator;
      // Symbol: drake::systems::RungeKutta3Integrator
      struct /* RungeKutta3Integrator */ {
        // Source: drake/systems/analysis/runge_kutta3_integrator.h:54
        const char* doc =
R"""(A third-order Runge Kutta integrator with a third order error
estimate.

For a discussion of this Runge-Kutta method, see [Butcher, 1987]. The
embedded error estimate was derived using the method mentioned in
[Hairer, 1993].

The Butcher tableau for this integrator follows:


::

    |
    0      |
    1/2    | 1/2
    1      | -1          2
    ---------------------------------------------------------------------------
             1/6         2/3       1/6
             0           1         0

where the second to last row is the 3rd-order propagated solution and
the last row is the 2nd-order midpoint used for the error estimate.

The following documentation is pulled from Simbody's implementation of
this integrator: "This is a 3-stage, first-same-as-last (FSAL) 3rd
order method which gives us an embedded 2nd order method as well, so
we can extract a 3rd-order error estimate for the 2nd-order result,
which error estimate can then be used for step size control, since it
will behave as h^3. We then propagate the 3rd order result (whose
error is unknown), which Hairer calls 'local extrapolation'. We call
the initial state (t0,y0) and want (t0+h,y1). We are given the initial
derivative f0=f(t0,y0), which most likely is left over from an
evaluation at the end of the last step."

- [Butcher, 1987] J. C. Butcher. The Numerical Analysis of Ordinary
  Differential Equations. John Wiley & Sons, 1987. p. 325.
- [Hairer, 1993] E. Hairer, S. Noersett, and G. Wanner. Solving ODEs I. 2nd
  rev. ed. Springer, 1993. p. 166.)""";
        // Symbol: drake::systems::RungeKutta3Integrator::RungeKutta3Integrator<T>
        struct /* ctor */ {
          // Source: drake/systems/analysis/runge_kutta3_integrator.h:56
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::systems::RungeKutta3Integrator::get_error_estimate_order
        struct /* get_error_estimate_order */ {
          // Source: drake/systems/analysis/runge_kutta3_integrator.h:75
          const char* doc =
R"""(This integrator provides third order error estimates.)""";
        } get_error_estimate_order;
        // Symbol: drake::systems::RungeKutta3Integrator::supports_error_estimation
        struct /* supports_error_estimation */ {
          // Source: drake/systems/analysis/runge_kutta3_integrator.h:72
          const char* doc =
R"""(The integrator supports error estimation.)""";
        } supports_error_estimation;
      } RungeKutta3Integrator;
      // Symbol: drake::systems::RungeKutta5Integrator
      struct /* RungeKutta5Integrator */ {
        // Source: drake/systems/analysis/runge_kutta5_integrator.h:46
        const char* doc =
R"""(A fifth-order, seven-stage, first-same-as-last (FSAL) Runge Kutta
integrator with a fourth order error estimate.

For a discussion of this Runge-Kutta method, see [Hairer, 1993]. The
embedded error estimate was derived using the method mentioned in
[Hairer, 1993]. The Butcher tableau for this integrator follows:


::

    0 |
    1/5 |        1/5
    3/10 |       3/40         9/40
    4/5 |      44/45       -56/15         32/9
    8/9 | 19372/6561   −25360/2187   64448/6561   −212/729
    1 |  9017/3168      −355/33   46732/5247     49/176     −5103/18656
    1 |     35/384            0     500/1113    125/192      −2187/6784      11/84         
    ---------------------------------------------------------------------------------         
    35/384            0     500/1113    125/192      −2187/6784      11/84      0  
    5179/57600            0   7571/16695    393/640   −92097/339200   187/2100   1/40

where the second to last row is the 5th-order (propagated) solution
and the last row gives a 2nd-order accurate solution used for error
control.

- [Dormand, 1980] J. Dormand and P. Prince. "A family of embedded
Runge-Kutta formulae", Journal of Computational and Applied Mathematics,
1980, 6(1): 19–26.
- [Hairer, 1993] E. Hairer, S. Noersett, and G. Wanner. Solving ODEs I. 2nd
rev. ed. Springer, 1993. p. 166.)""";
        // Symbol: drake::systems::RungeKutta5Integrator::RungeKutta5Integrator<T>
        struct /* ctor */ {
          // Source: drake/systems/analysis/runge_kutta5_integrator.h:48
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::systems::RungeKutta5Integrator::get_error_estimate_order
        struct /* get_error_estimate_order */ {
          // Source: drake/systems/analysis/runge_kutta5_integrator.h:71
          const char* doc =
R"""(The order of the asymptotic term in the error estimate.)""";
        } get_error_estimate_order;
        // Symbol: drake::systems::RungeKutta5Integrator::supports_error_estimation
        struct /* supports_error_estimation */ {
          // Source: drake/systems/analysis/runge_kutta5_integrator.h:68
          const char* doc =
R"""(The integrator supports error estimation.)""";
        } supports_error_estimation;
      } RungeKutta5Integrator;
      // Symbol: drake::systems::Saturation
      struct /* Saturation */ {
        // Source: drake/systems/primitives/saturation.h:38
        const char* doc =
R"""(An element-wise hard saturation block with inputs signal ``u``,
saturation values :math:`u_{min}` and/or :math:`u_{max}`, and output
``y`` respectively as in:

.. math:: y = u, u_{min} < u < u_{min}

.. math:: y = u_{min}, u \le u_{min}

.. math:: y = u_{max}, u \ge u_{max}

The input to this system directly feeds through to its output.

Note that :math:`u_{min}`, and :math:`u_{max}`, and :math:`u` are all
vectors of same dimension, and the following condition holds
elementwise in runtime.

.. math:: u_{min} <=  u_{max}

The quantities :math:`u_{min}`, and :math:`u_{max}` can be supplied as
inputs in separate ports or be initialised as constants using the
appropriate constructor by passing their default value. If these
quantities are not defined as constants but they are not connected to
appropriate sources, their values are taken by default to be
:math:`u_{min} = -\infty`, and :math:`u_{max} = \infty` respectively.
In this "variable" configuration, at least one of the input ports must
be connected.)""";
        // Symbol: drake::systems::Saturation::Saturation<T>
        struct /* ctor */ {
          // Source: drake/systems/primitives/saturation.h:50
          const char* doc_1args =
R"""(Constructs a variable Saturation system where the upper and lower
values are represented by vectors of identical size and can be
supplied via the max_value_port and min_value_port respectively.

Parameter ``input_size``:
    sets size of the input and output ports.

Please consult this class's description for the requirements of
``u_min`` and ``u_max`` to be supplied via the corresponding ports.)""";
          // Source: drake/systems/primitives/saturation.h:63
          const char* doc_2args =
R"""(Constructs a constant Saturation system where the upper and lower
values are represented by vectors of identical size supplied via this
constructor.

Parameter ``u_min``:
    the lower (vector) limit to the saturation.

Parameter ``u_max``:
    the upper (vector) limit to the saturation.

Please consult this class's description for the requirements of
``u_min`` and ``u_max``.)""";
        } ctor;
        // Symbol: drake::systems::Saturation::get_input_port
        struct /* get_input_port */ {
          // Source: drake/systems/primitives/saturation.h:66
          const char* doc = R"""(Returns the input port.)""";
        } get_input_port;
        // Symbol: drake::systems::Saturation::get_max_value_port
        struct /* get_max_value_port */ {
          // Source: drake/systems/primitives/saturation.h:77
          const char* doc = R"""(Returns the max value port.)""";
        } get_max_value_port;
        // Symbol: drake::systems::Saturation::get_min_value_port
        struct /* get_min_value_port */ {
          // Source: drake/systems/primitives/saturation.h:71
          const char* doc = R"""(Returns the min value port.)""";
        } get_min_value_port;
        // Symbol: drake::systems::Saturation::get_size
        struct /* get_size */ {
          // Source: drake/systems/primitives/saturation.h:83
          const char* doc = R"""(Returns the size.)""";
        } get_size;
      } Saturation;
      // Symbol: drake::systems::ScalarDenseOutput
      struct /* ScalarDenseOutput */ {
        // Source: drake/systems/analysis/scalar_dense_output.h:18
        const char* doc =
R"""(A DenseOutput class interface extension to deal with scalar ODE
solutions. A ScalarDenseOutput instance is also a DenseOutput instance
with single element vector values (i.e. size() == 1). As such, its
value can evaluated in both scalar and vectorial form (via
EvaluateScalar() and Evaluate(), respectively).)""";
        // Symbol: drake::systems::ScalarDenseOutput::DoEvaluate
        struct /* DoEvaluate */ {
          // Source: drake/systems/analysis/scalar_dense_output.h:40
          const char* doc = R"""()""";
        } DoEvaluate;
        // Symbol: drake::systems::ScalarDenseOutput::DoEvaluateScalar
        struct /* DoEvaluateScalar */ {
          // Source: drake/systems/analysis/scalar_dense_output.h:49
          const char* doc = R"""()""";
        } DoEvaluateScalar;
        // Symbol: drake::systems::ScalarDenseOutput::EvaluateScalar
        struct /* EvaluateScalar */ {
          // Source: drake/systems/analysis/scalar_dense_output.h:31
          const char* doc =
R"""(Evaluates output at the given time ``t``.

Parameter ``t``:
    Time at which to evaluate output.

Returns:
    Output scalar value.

Precondition:
    Output is not empty i.e. is_empty() is false.

Raises:
    RuntimeError if any of the preconditions is not met.

Raises:
    RuntimeError if given ``t`` is not within output's domain i.e.
    ``t`` ∉ [start_time(), end_time()].)""";
        } EvaluateScalar;
        // Symbol: drake::systems::ScalarDenseOutput::ScalarDenseOutput<T>
        struct /* ctor */ {
          // Source: drake/systems/analysis/scalar_dense_output.h:20
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::systems::ScalarDenseOutput::do_size
        struct /* do_size */ {
          // Source: drake/systems/analysis/scalar_dense_output.h:44
          const char* doc = R"""()""";
        } do_size;
      } ScalarDenseOutput;
      // Symbol: drake::systems::ScalarInitialValueProblem
      struct /* ScalarInitialValueProblem */ {
        // Source: drake/systems/analysis/scalar_initial_value_problem.h:51
        const char* doc =
R"""(A thin wrapper of the InitialValueProblem class to provide a simple
interface when solving scalar initial value problems i.e. when
evaluating the x(t; 𝐤) solution function to the given ODE dx/dt = f(t,
x; 𝐤), where f : t ⨯ x → ℝ , t ∈ ℝ, x ∈ ℝ, 𝐤 ∈ ℝᵐ, along with an
initial condition x(t₀; 𝐤) = x₀. The parameter vector 𝐤 allows for
generic IVP definitions, which can later be solved for any instance of
said vector.

Note the distinction from general initial value problems where f : t ⨯
𝐱 → ℝⁿ and 𝐱 ∈ ℝⁿ, addressed by the class being wrapped. While every
scalar initial value problem could be written in vector form, this
wrapper keeps both problem definition and solution in their scalar
form with almost zero overhead, leading to clearer code if applicable.
Moreover, this scalar form facilitates single-dimensional quadrature
using methods for solving initial value problems.

See InitialValueProblem class documentation for information on caching
support and dense output usage for improved efficiency in scalar IVP
solving.

For further insight into its use, consider the following examples of
scalar IVPs:

- The population growth of an hypothetical bacteria colony is described
  by dN/dt = r * N. The colony has N₀ subjects at time t₀. In this
  context, x ≜ N, x₀ ≜ N₀, 𝐤 ≜ [r], dx/dt = f(t, x; 𝐤) = 𝐤₁ * x.

- The charge Q stored in the capacitor of a (potentially equivalent) series
  RC circuit driven by a time varying voltage source E(t) can be described
  by dQ/dt = (E(t) - Q / Cs) / Rs, where Rs refers to the resistor's
  resistance and Cs refers to the capacitor's capacitance. In this context,
  and assuming an initial stored charge Q₀ at time t₀, x ≜ Q, 𝐤 ≜ [Rs, Cs],
  x₀ ≜ Q₀, dx/dt = f(t, x; 𝐤) = (E(t) - x / 𝐤₂) / 𝐤₁.)""";
        // Symbol: drake::systems::ScalarInitialValueProblem::DenseSolve
        struct /* DenseSolve */ {
          // Source: drake/systems/analysis/scalar_initial_value_problem.h:157
          const char* doc =
R"""(Solves and yields an approximation of the IVP solution x(t; 𝐤) for the
closed time interval between the initial time t₀ and the given final
time ``tf``, using initial state x₀ and parameter vector 𝐤 present in
``values`` (falling back to the ones given on construction if not
given).

To this end, the wrapped IntegratorBase instance solves this scalar
IVP, advancing time and state from t₀ and x₀ = x(t₀) to ``tf`` and
x(``tf)``, creating a scalar dense output over that [t₀, ``tf``]
interval along the way.

Parameter ``tf``:
    The IVP will be solved up to this time. Usually, t₀ < ``tf`` as an
    empty dense output would result if t₀ = ``tf``.

Parameter ``values``:
    IVP initial conditions and parameters.

Returns:
    A dense approximation to x(t; 𝐤) with x(t₀; 𝐤) = x₀, defined for
    t₀ ≤ t ≤ tf.

Note:
    The larger the given ``tf`` value is, the larger the approximated
    interval will be. See documentation of the specific dense output
    technique in use for reference on performance impact as this
    interval grows.

Precondition:
    Given ``tf`` must be larger than or equal to the specified initial
    time t₀ (either given or default).

Precondition:
    If given, the dimension of the initial state vector ``values``.x0
    must match that of the default initial state vector in the default
    specified values given on construction.

Precondition:
    If given, the dimension of the parameter vector ``values``.k must
    match that of the parameter vector in the default specified values
    given on construction.

Raises:
    RuntimeError if any of the preconditions is not met.)""";
        } DenseSolve;
        // Symbol: drake::systems::ScalarInitialValueProblem::ScalarInitialValueProblem<T>
        struct /* ctor */ {
          // Source: drake/systems/analysis/scalar_initial_value_problem.h:99
          const char* doc =
R"""(Constructs an scalar IVP described by the given
``scalar_ode_function``, using given ``default_values``.t0 and
``default_values``.x0 as initial conditions, and parameterized with
``default_values``.k by default.

Parameter ``scalar_ode_function``:
    The ODE function f(t, x; 𝐤) that describes the state evolution
    over time.

Parameter ``default_values``:
    The values specified by default for this IVP, i.e. default initial
    time t₀ ∈ ℝ and state x₀ ∈ ℝ, and default parameter vector 𝐤 ∈ ℝᵐ.

Precondition:
    An initial time ``default_values``.t0 is provided.

Precondition:
    An initial state ``default_values``.x0 is provided.

Precondition:
    An parameter vector ``default_values``.k is provided.

Raises:
    RuntimeError if preconditions are not met.)""";
        } ctor;
        // Symbol: drake::systems::ScalarInitialValueProblem::ScalarOdeContext
        struct /* ScalarOdeContext */ {
          // Source: drake/systems/analysis/scalar_initial_value_problem.h:67
          const char* doc =
R"""(A collection of values i.e. initial time t₀, initial state x₀ and
parameter vector 𝐤 to further specify the ODE system (in order to
become a scalar initial value problem).)""";
          // Symbol: drake::systems::ScalarInitialValueProblem::ScalarOdeContext::ScalarOdeContext
          struct /* ctor */ {
            // Source: drake/systems/analysis/scalar_initial_value_problem.h:69
            const char* doc_0args =
R"""(Default constructor, leaving all values unspecified.)""";
            // Source: drake/systems/analysis/scalar_initial_value_problem.h:76
            const char* doc_3args =
R"""(Constructor specifying all values.

Parameter ``t0_in``:
    Specified initial time t₀.

Parameter ``x0_in``:
    Specified initial state x₀.

Parameter ``k_in``:
    Specified parameter vector 𝐤.)""";
          } ctor;
          // Symbol: drake::systems::ScalarInitialValueProblem::ScalarOdeContext::k
          struct /* k */ {
            // Source: drake/systems/analysis/scalar_initial_value_problem.h:83
            const char* doc = R"""(The parameter vector 𝐤 for the IVP.)""";
          } k;
          // Symbol: drake::systems::ScalarInitialValueProblem::ScalarOdeContext::t0
          struct /* t0 */ {
            // Source: drake/systems/analysis/scalar_initial_value_problem.h:81
            const char* doc = R"""(The initial time t₀ for the IVP.)""";
          } t0;
          // Symbol: drake::systems::ScalarInitialValueProblem::ScalarOdeContext::x0
          struct /* x0 */ {
            // Source: drake/systems/analysis/scalar_initial_value_problem.h:82
            const char* doc = R"""(The initial state x₀ for the IVP.)""";
          } x0;
        } ScalarOdeContext;
        // Symbol: drake::systems::ScalarInitialValueProblem::ScalarOdeFunction
        struct /* ScalarOdeFunction */ {
          // Source: drake/systems/analysis/scalar_initial_value_problem.h:61
          const char* doc =
R"""(Scalar ODE dx/dt = f(t, x; 𝐤) function type.

Parameter ``t``:
    The independent variable t ∈ ℝ .

Parameter ``x``:
    The dependent variable x ∈ ℝ .

Parameter ``k``:
    The parameter vector 𝐤 ∈ ℝᵐ.

Returns:
    The derivative dx/dt ∈ ℝ.)""";
        } ScalarOdeFunction;
        // Symbol: drake::systems::ScalarInitialValueProblem::Solve
        struct /* Solve */ {
          // Source: drake/systems/analysis/scalar_initial_value_problem.h:125
          const char* doc =
R"""(Solves the IVP for time ``tf``, using the initial time t₀, initial
state x₀ and parameter vector 𝐤 present in ``values``, falling back to
the ones given on construction if not given.

Parameter ``tf``:
    The IVP will be solved for this time.

Parameter ``values``:
    IVP initial conditions and parameters.

Returns:
    The IVP solution x(``tf``; 𝐤) for x(t₀; 𝐤) = x₀.

Precondition:
    Given ``tf`` must be larger than or equal to the specified initial
    time t₀ (either given or default).

Precondition:
    If given, the dimension of the parameter vector ``values``.k must
    match that of the parameter vector in the default specified values
    given on construction.

Raises:
    RuntimeError if any of the preconditions is not met.)""";
        } Solve;
        // Symbol: drake::systems::ScalarInitialValueProblem::get_integrator
        struct /* get_integrator */ {
          // Source: drake/systems/analysis/scalar_initial_value_problem.h:192
          const char* doc =
R"""(Gets a reference to the internal integrator instance.)""";
        } get_integrator;
        // Symbol: drake::systems::ScalarInitialValueProblem::get_mutable_integrator
        struct /* get_mutable_integrator */ {
          // Source: drake/systems/analysis/scalar_initial_value_problem.h:197
          const char* doc =
R"""(Gets a mutable reference to the internal integrator instance.)""";
        } get_mutable_integrator;
        // Symbol: drake::systems::ScalarInitialValueProblem::reset_integrator
        struct /* reset_integrator */ {
          // Source: drake/systems/analysis/scalar_initial_value_problem.h:186
          const char* doc =
R"""(Resets the internal integrator instance by in-place construction of
the given integrator type.

A usage example is shown below.


::

    scalar_ivp.reset_integrator<RungeKutta2Integrator<T>>(max_step);

Parameter ``args``:
    The integrator type-specific arguments.

Returns:
    The new integrator instance.

Template parameter ``Integrator``:
    The integrator type, which must be an IntegratorBase subclass.

Template parameter ``Args``:
    The integrator specific argument types.

Warning:
    This operation invalidates pointers returned by
    ScalarInitialValueProblem::get_integrator() and
    ScalarInitialValueProblem::get_mutable_integrator().)""";
        } reset_integrator;
      } ScalarInitialValueProblem;
      // Symbol: drake::systems::ScalarViewDenseOutput
      struct /* ScalarViewDenseOutput */ {
        // Source: drake/systems/analysis/scalar_view_dense_output.h:22
        const char* doc =
R"""(A ScalarDenseOutput class implementation that wraps a DenseOutput
class instance and behaves as a view to one of its elements.)""";
        // Symbol: drake::systems::ScalarViewDenseOutput::DoEvaluateScalar
        struct /* DoEvaluateScalar */ {
          // Source: drake/systems/analysis/scalar_view_dense_output.h:54
          const char* doc = R"""()""";
        } DoEvaluateScalar;
        // Symbol: drake::systems::ScalarViewDenseOutput::ScalarViewDenseOutput<T>
        struct /* ctor */ {
          // Source: drake/systems/analysis/scalar_view_dense_output.h:34
          const char* doc =
R"""(Constructs a view of another DenseOutput instance.

Parameter ``base_output``:
    Base dense output to operate with.

Parameter ``n``:
    The nth scalar element (0-indexed) of the output value to view.

Raises:
    RuntimeError if ``base_output`` is nullptr.

Raises:
    RuntimeError if given ``n`` does not refer to a valid base output
    dimension i.e. ``n`` ∉ [0, ``base_output``->size()).)""";
        } ctor;
        // Symbol: drake::systems::ScalarViewDenseOutput::base_output_
        struct /* base_output_ */ {
          // Source: drake/systems/analysis/scalar_view_dense_output.h:71
          const char* doc = R"""()""";
        } base_output_;
        // Symbol: drake::systems::ScalarViewDenseOutput::do_end_time
        struct /* do_end_time */ {
          // Source: drake/systems/analysis/scalar_view_dense_output.h:66
          const char* doc = R"""()""";
        } do_end_time;
        // Symbol: drake::systems::ScalarViewDenseOutput::do_is_empty
        struct /* do_is_empty */ {
          // Source: drake/systems/analysis/scalar_view_dense_output.h:58
          const char* doc = R"""()""";
        } do_is_empty;
        // Symbol: drake::systems::ScalarViewDenseOutput::do_start_time
        struct /* do_start_time */ {
          // Source: drake/systems/analysis/scalar_view_dense_output.h:62
          const char* doc = R"""()""";
        } do_start_time;
        // Symbol: drake::systems::ScalarViewDenseOutput::get_base_output
        struct /* get_base_output */ {
          // Source: drake/systems/analysis/scalar_view_dense_output.h:49
          const char* doc =
R"""(Returns the base dense output upon which the view operates.)""";
        } get_base_output;
        // Symbol: drake::systems::ScalarViewDenseOutput::n_
        struct /* n_ */ {
          // Source: drake/systems/analysis/scalar_view_dense_output.h:74
          const char* doc = R"""()""";
        } n_;
      } ScalarViewDenseOutput;
      // Symbol: drake::systems::SemiExplicitEulerIntegrator
      struct /* SemiExplicitEulerIntegrator */ {
        // Source: drake/systems/analysis/semi_explicit_euler_integrator.h:69
        const char* doc =
R"""(A first-order, semi-explicit Euler integrator. State is updated in the
following manner:


::

    v(t₀+h) = v(t₀) + dv/dt(t₀) * h
          dq/dt = N(q(t₀)) * v(t₀+h)
        q(t₀+h) = q(t₀) + dq/dt * h

where ``v`` are the generalized velocity variables and ``q`` are
generalized coordinates. ``h`` is the integration step size, and ``N``
is a matrix (dependent upon ``q(t₀)``) that maps velocities to time
derivatives of generalized coordinates. For rigid body systems in 2D,
for example, ``N`` will generally be an identity matrix. For a single
rigid body in 3D, ``N`` and its pseudo-inverse (``N`` is generally
non-square but always left invertible) are frequently used to
transform between time derivatives of Euler parameters (unit
quaternions) and angular velocities (and vice versa), [Nikravesh
1988].

Note that these equations imply that the velocity variables are
updated first and that these new velocities are then used to update
the generalized coordinates (compare to ExplicitEulerIntegrator, where
the generalized coordinates are updated using the previous velocity
variables).

When a mechanical system is Hamiltonian (informally meaning that the
system is not subject to velocity-dependent forces), the semi-explicit
Euler integrator is a symplectic (energy conserving) integrator.
Symplectic integrators advertise energetically consistent behavior
with large step sizes compared to non-symplectic integrators.
Multi-body systems are not Hamiltonian, even in the absence of
externally applied velocity-dependent forces, due to the presence of
both Coriolis and gyroscopic forces. This integrator thus does not
generally conserve energy for such systems.

<h4>Association between time stepping and the semi-explicit Euler
integrator:</h4> Though many time stepping approaches use the
formulations above, these equations do not represent a "time stepping
scheme". The semi-explicit Euler integration equations can be applied
from one point in state space to another, assuming smoothness in
between, just like any other integrator using the following process:
(1) a simulator integrates to discontinuities, (2) the state of the
ODE/DAE is re-initialized, and (3) integration continues.

In contrast, time stepping schemes enforce all constraints at a single
time in the integration process: though a billiard break may consist
of tens of collisions occurring sequentially over a millisecond of
time, a time stepping method will treat all of these collisions as
occurring simultaneously.

- [Nikravesh 1988]  P. Nikravesh. Computer-Aided Analysis of Mechanical
                      Systems. Prentice Hall. New Jersey, 1988.
- [Stewart 2000]    D. Stewart. Rigid-body Dynamics with Friction and
                      Impact. SIAM Review, 42:1, 2000.)""";
        // Symbol: drake::systems::SemiExplicitEulerIntegrator::SemiExplicitEulerIntegrator<T>
        struct /* ctor */ {
          // Source: drake/systems/analysis/semi_explicit_euler_integrator.h:88
          const char* doc =
R"""(Constructs a fixed-step integrator for a given system using the given
context for initial conditions.

Parameter ``system``:
    A reference to the system to be simulated.

Parameter ``max_step_size``:
    The maximum (fixed) step size; the integrator will not take larger
    step sizes than this.

Parameter ``context``:
    Pointer to the context (nullptr is ok, but the caller must set a
    non-null context before Initialize()-ing the integrator).

See also:
    Initialize())""";
        } ctor;
        // Symbol: drake::systems::SemiExplicitEulerIntegrator::get_error_estimate_order
        struct /* get_error_estimate_order */ {
          // Source: drake/systems/analysis/semi_explicit_euler_integrator.h:99
          const char* doc =
R"""(Gets the error estimate order (returns zero, since error estimation is
not provided).)""";
        } get_error_estimate_order;
        // Symbol: drake::systems::SemiExplicitEulerIntegrator::supports_error_estimation
        struct /* supports_error_estimation */ {
          // Source: drake/systems/analysis/semi_explicit_euler_integrator.h:104
          const char* doc =
R"""(Integrator does not support accuracy estimation.)""";
        } supports_error_estimation;
      } SemiExplicitEulerIntegrator;
      // Symbol: drake::systems::SignalLog
      struct /* SignalLog */ {
        // Source: drake/systems/primitives/signal_log.h:18
        const char* doc =
R"""(This utility class serves as an in-memory cache of time-dependent
vector values. Note that this is a standalone class, not a Drake
System. It is primarily intended to support the Drake System primitive
SignalLogger, but can be used independently.)""";
        // Symbol: drake::systems::SignalLog::AddData
        struct /* AddData */ {
          // Source: drake/systems/primitives/signal_log.h:55
          const char* doc =
R"""(Adds a ``sample`` to the data set with the associated ``time`` value.

Parameter ``time``:
    The time value for this sample.

Parameter ``sample``:
    A vector of data of the declared size for this log.)""";
        } AddData;
        // Symbol: drake::systems::SignalLog::SignalLog<T>
        struct /* ctor */ {
          // Source: drake/systems/primitives/signal_log.h:27
          const char* doc =
R"""(Constructs the signal log.

Parameter ``input_size``:
    Dimension of the per-time step data set.

Parameter ``batch_allocation_size``:
    Storage is (re)allocated in blocks of size (input_size X
    batch_allocation_size).)""";
        } ctor;
        // Symbol: drake::systems::SignalLog::data
        struct /* data */ {
          // Source: drake/systems/primitives/signal_log.h:38
          const char* doc = R"""(Accesses the logged data.)""";
        } data;
        // Symbol: drake::systems::SignalLog::get_input_size
        struct /* get_input_size */ {
          // Source: drake/systems/primitives/signal_log.h:58
          const char* doc =
R"""(Reports the size of the log's input vector.)""";
        } get_input_size;
        // Symbol: drake::systems::SignalLog::num_samples
        struct /* num_samples */ {
          // Source: drake/systems/primitives/signal_log.h:30
          const char* doc =
R"""(Returns the number of samples taken since construction or last
reset().)""";
        } num_samples;
        // Symbol: drake::systems::SignalLog::reset
        struct /* reset */ {
          // Source: drake/systems/primitives/signal_log.h:44
          const char* doc = R"""(Clears the logged data.)""";
        } reset;
        // Symbol: drake::systems::SignalLog::sample_times
        struct /* sample_times */ {
          // Source: drake/systems/primitives/signal_log.h:33
          const char* doc = R"""(Accesses the logged time stamps.)""";
        } sample_times;
      } SignalLog;
      // Symbol: drake::systems::SignalLogger
      struct /* SignalLogger */ {
        // Source: drake/systems/primitives/signal_logger.h:56
        const char* doc =
R"""(A discrete sink block which logs its input to memory (not thread
safe). This data is then retrievable (e.g. after a simulation) via a
handful of accessor methods. This system holds a large, mutable Eigen
matrix for data storage, where each column corresponds to a data
point. It saves a data point and the context time whenever it samples
its input.

By default, sampling is performed every time the Simulator completes a
trajectory-advancing substep (that is, via a per-step Publish event),
with the first sample occurring during Simulator::Initialize(). That
means the samples will generally be unevenly spaced in time. If you
prefer regular sampling, you may optionally specify a "publish period"
in which case sampling occurs periodically, with the first sample
occurring at time 0. Alternatively (not common), you can specify that
logging should only occur at "forced publish" events, meaning at
explicit calls to System::Publish(). The Simulator's "publish every
time step" option also results in forced publish events, so should be
disabled if you want to control logging yourself.

Warning:
    SignalLogger is *not* thread-safe because it writes to a mutable
    buffer internally. If you have a Diagram that contains a
    SignalLogger, even with each thread having its own Context, the
    threads will conflict. You would have to have separate Diagrams in
    each thread to avoid trouble.

See also:
    LogOutput() for a convenient way to add logging to a Diagram.

See also:
    Simulator::set_publish_every_time_step()

See also:
    Simulator::set_publish_at_initialization()

.. pydrake_system::

    name: SignalLogger
    input_ports:
    - data)""";
        // Symbol: drake::systems::SignalLogger::SignalLogger<T>
        struct /* ctor */ {
          // Source: drake/systems/primitives/signal_logger.h:72
          const char* doc =
R"""(Constructs the signal logger system.

Warning:
    SignalLogger may become slower and slower as the number of log
    entries increases due to memory reallocations. You can avoid that
    by providing a ``batch_allocation_size`` comparable to the total
    expected number of log entries for your simulation.

Parameter ``input_size``:
    Dimension of the (single) input port. This corresponds to the
    number of rows of the data matrix.

Parameter ``batch_allocation_size``:
    Storage is (re)allocated in blocks of
    input_size-by-batch_allocation_size.

See also:
    LogOutput() helper function for a convenient way to add logging.)""";
          // Source: drake/systems/primitives/signal_logger.h:76
          const char* doc_copyconvert =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";
        } ctor;
        // Symbol: drake::systems::SignalLogger::data
        struct /* data */ {
          // Source: drake/systems/primitives/signal_logger.h:104
          const char* doc = R"""(Provides access to the logged data.)""";
        } data;
        // Symbol: drake::systems::SignalLogger::num_samples
        struct /* num_samples */ {
          // Source: drake/systems/primitives/signal_logger.h:94
          const char* doc =
R"""(Returns the number of samples taken since construction or last
reset().)""";
        } num_samples;
        // Symbol: drake::systems::SignalLogger::reset
        struct /* reset */ {
          // Source: drake/systems/primitives/signal_logger.h:109
          const char* doc = R"""(Clears the logged data.)""";
        } reset;
        // Symbol: drake::systems::SignalLogger::sample_times
        struct /* sample_times */ {
          // Source: drake/systems/primitives/signal_logger.h:98
          const char* doc =
R"""(Provides access to the sample times of the logged data. Time is taken
from the Context when the log entry is added.)""";
        } sample_times;
        // Symbol: drake::systems::SignalLogger::set_forced_publish_only
        struct /* set_forced_publish_only */ {
          // Source: drake/systems/primitives/signal_logger.h:91
          const char* doc =
R"""(Limits logging to forced publish calls only, that is, explicit calls
to System::Publish() issued directly or by the Simulator and disables
the default per-step sampling. This method cannot be called if
set_publish_period() has been called.

Raises:
    RuntimeError if set_publish_period() has been called.)""";
        } set_forced_publish_only;
        // Symbol: drake::systems::SignalLogger::set_publish_period
        struct /* set_publish_period */ {
          // Source: drake/systems/primitives/signal_logger.h:84
          const char* doc =
R"""(Sets the publishing period of this system to specify periodic sampling
and disables the default per-step sampling. This method can only be
called once and only if set_forced_publish_only() hasn't been called.

Raises:
    RuntimeError if called more than once, or if
    set_forced_publish_only() has been called.

Precondition:
    ``period`` must be greater than zero.)""";
        } set_publish_period;
      } SignalLogger;
      // Symbol: drake::systems::Simulator
      struct /* Simulator */ {
        // Source: drake/systems/analysis/simulator.h:215
        const char* doc =
R"""(A class for advancing the state of hybrid dynamic systems, represented
by ``System<T>`` objects, forward in time. Starting with an initial
Context for a given System, Simulator advances time and produces a
series of Context values that forms a trajectory satisfying the
system's dynamic equations to a specified accuracy. Only the Context
is modified by a Simulator; the System is const.

A Drake System is a continuous/discrete/hybrid dynamic system where
the continuous part is a DAE, that is, it is expected to consist of a
set of differential equations and bilateral algebraic constraints. The
set of active constraints may change as a result of particular events,
such as contact.

Given a current Context, we expect a System to provide us with -
derivatives for the continuous differential equations that already
satisfy the differentiated form of the constraints (typically,
acceleration constraints), - a projection method for least-squares
correction of violated higher-level constraints (position and velocity
level), - a time-of-next-update method that can be used to adjust the
integrator step size in preparation for a discrete update, - methods
that can update discrete variables when their update time is reached,
- witness (guard) functions for event isolation, - event handlers
(reset functions) for making appropriate changes to state and mode
variables when an event has been isolated.

The continuous parts of the trajectory are advanced using a numerical
integrator. Different integrators have different properties; you can
choose the one that is most appropriate for your application or use
the default which is adequate for most systems.

<h3>How the simulation is stepped: simulation mechanics for authors of
discrete and hybrid systems</h3>

This section is targeted toward users who have created a LeafSystem
implementing a discrete or hybrid system. For authors of such systems,
it can be useful to understand the simulation details in order to
attain the desired state behavior over time. This behavior is
dependent on the ordering in which discrete events and continuous
updates are processed. (By "discrete events" we mean to include any of
Drake's event handlers.) The basic issues and terminology are
introduced in the discrete_systems module; please look there first
before proceeding.

As pictured in discrete_systems, when a continuous-time system has
discrete events, the state x can have two significant values at the
event time t. These are - x⁻(t), the value of x *before* the discrete
update occurs (○ markers), and - x⁺(t), the value of x *after* the
discrete update occurs (● markers).

Thus the value of the Context, which contains both time and state,
advances from {t, x⁻(t)} to {t, x⁺(t)} as a result of the update.
While those Context values are user-visible, the details of stepping
here require an intermediate value which we'll denote {t, x*(t)}.

Recall that Drake's state x is partitioned into continuous, discrete,
and abstract partitions xc, xd, and xa, so ``x = { xc, xd, xa }``.
Within a single step, these are updated in three stages: -

Unrestricted update (can change x) -

Discrete update (can change only xd) -

Continuous update (changes t and xc)

Where needed, we extend the above notation to xc⁻, xa⁺, etc. to
indicate the value of an individual partition at a particular stage of
the stepping algorithm.

The following pseudocode uses the above notation to describe the
algorithm "Step()" that the Simulator uses to incrementally advance
the system trajectory (time t and state x). The Simulator's
AdvanceTo() method will be defined in terms of Step below. In general,
the length of a step is not known a priori and is determined by the
Step() algorithm. Each step consists of zero or more unrestricted
updates, followed by zero or more discrete updates, followed by
(possibly zero-length) continuous time and state advancement, followed
by zero or more publishes, and then a call to the monitor() function
if one has been defined. Updates, publishes, and the monitor can
report errors or detect a termination condition; that is not shown in
the pseudocode below.

The pseudocode will clarify the effects on time and state of each of
the update stages above. This algorithm is given a starting Context
value ``{tₛ, x⁻(tₛ)}`` and returns an end Context value ``{tₑ,
x⁻(tₑ)}``, where tₑ is *no later* than a given tₘₐₓ.


::

    // Advance the trajectory (time and state) from start value {tₛ, x⁻(tₛ)} to an
    // end value {tₑ, x⁻(tₑ)}, where tₛ ≤ tₑ ≤ tₘₐₓ.
    procedure Step(tₛ, x⁻(tₛ), tₘₐₓ)
    
    // Update any variables (no restrictions).
    x*(tₛ) ← DoAnyUnrestrictedUpdates(tₛ, x⁻(tₛ))
    
    // ----------------------------------
    // Time and state are at {tₛ, x*(tₛ)}
    // ----------------------------------
    
    // Update discrete variables.
    xd⁺(tₛ) ← DoAnyDiscreteUpdates(tₛ, x*(tₛ))
    
    xc⁺(tₛ) ← xc*(tₛ)  // These values carry over from x*(tₛ).
    xa⁺(tₛ) ← xa*(tₛ)
    
    // ----------------------------------
    // Time and state are at {tₛ, x⁺(tₛ)}
    // ----------------------------------
    
    // See how far it is safe to integrate without missing any events.
    tₑᵥₑₙₜ ← CalcNextEventTime(tₛ, x⁺(tₛ))
    
    // Integrate continuous variables forward in time. Integration may terminate
    // before reaching tₛₜₒₚ due to witnessed events.
    tₛₜₒₚ ← min(tₑᵥₑₙₜ, tₘₐₓ)
    tₑ, xc⁻(tₑ) ← Integrate(tₛ, x⁺(tₛ), tₛₜₒₚ)
    
    xd⁻(tₑ) ← xd⁺(tₛ)  // Discrete values are held from x⁺(tₛ).
    xa⁻(tₑ) ← xa⁺(tₛ)
    
    // ----------------------------------
    // Time and state are at {tₑ, x⁻(tₑ)}
    // ----------------------------------
    
    DoAnyPublishes(tₑ, x⁻(tₑ))
    CallMonitor(tₑ, x⁻(tₑ))
    
    return {tₑ, x⁻(tₑ)}

We can use the notation and pseudocode to flesh out the AdvanceTo(),
AdvancePendingEvents(), and Initialize() functions. Termination and
error conditions detected by event handlers or the monitor are
reported as status returns from these methods.


::

    // Advance the simulation until time tₘₐₓ.
    procedure AdvanceTo(tₘₐₓ) → status
    t ← current_time
    while t < tₘₐₓ
    {tₑ, x⁻(tₑ)} ← Step(t, x⁻(t), tₘₐₓ)
    {t, x⁻(t)} ← {tₑ, x⁻(tₑ)}
    endwhile
    
    // AdvancePendingEvents() is an advanced method, not commonly used.
    // Perform just the start-of-step update to advance from x⁻(t) to x⁺(t).
    procedure AdvancePendingEvents() → status
    t ≜ current_time, x⁻(t) ≜ current_state
    x⁺(t) ← DoAnyPendingUpdates(t, x⁻(t)) as in Step()
    x(t) ← x⁺(t)  // No continuous update needed.
    DoAnyPublishes(t, x(t))
    CallMonitor(t, x(t))
    
    // Update time and state to {t₀, x⁻(t₀)}, which is the starting value of the
    // trajectory, and thus the value the Context should contain at the start of the
    // first simulation step.
    procedure Initialize(t₀, x₀) → status
    // Initialization events can be optionally suppressed.
    x⁺(t₀) ← DoAnyInitializationUpdates as in Step()
    x⁻(t₀) ← x⁺(t₀)  // No continuous update needed.
    
    // ----------------------------------
    // Time and state are at {t₀, x⁻(t₀)}
    // ----------------------------------
    
    DoAnyPublishes(t₀, x⁻(t₀))
    CallMonitor(t₀, x⁻(t₀))

Initialize() can be viewed as a "0ᵗʰ step" that occurs before the
first Step() call as described above. Like Step(), Initialize() first
performs pending updates (in this case only initialization events can
be "pending", and even those may be optionally suppressed). Time
doesn't advance so there is no continuous update phase and witnesses
cannot trigger. Finally, again like Step(), the initial trajectory
point ``{t₀, x⁻(t₀)}`` is provided to the handlers for any triggered
publish events. That includes initialization publish events (if not
suppressed), per-step publish events, and periodic or timed publish
events that trigger at t₀, followed by a call to the monitor()
function if one has been defined (a monitor is semantically identical
to a per-step publish).

Optionally, initialization events can be suppressed. This can be
useful when reusing the simulator over the same system and time span.)""";
        // Symbol: drake::systems::Simulator::AdvancePendingEvents
        struct /* AdvancePendingEvents */ {
          // Source: drake/systems/analysis/simulator.h:349
          const char* doc =
R"""((Advanced) Handles discrete and abstract state update events that are
pending from the previous AdvanceTo() call, without advancing time.
See the Simulator class description for details about how Simulator
advances time and handles events. In the terminology used there, this
method advances the internal Context from ``{t, x⁻(t)}`` to ``{t,
x⁺(t)}``.

Normally, these update events would be handled at the start of the
next AdvanceTo() call, so this method is rarely needed. It can be
useful at the end of a simulation or to get intermediate results when
you are specifically interested in the ``x⁺(t)`` result.

This method is equivalent to ``AdvanceTo(current_time)``, where
``current_time=simulator.get_context().get_time())``. If there are no
pending events, nothing happens except possibly a final per-step
publish call (if enabled) followed by a call to the monitor() function
(if one has been provided).

Returns ``status``:
    A SimulatorStatus object indicating success, termination, or an
    error condition as reported by event handlers or the monitor
    function.

See also:
    AdvanceTo(), Initialize(), SimulatorStatus)""";
        } AdvancePendingEvents;
        // Symbol: drake::systems::Simulator::AdvanceTo
        struct /* AdvanceTo */ {
          // Source: drake/systems/analysis/simulator.h:326
          const char* doc =
R"""(Advances the System's trajectory until ``boundary_time`` is reached in
the context or some other termination condition occurs. A variety of
``RuntimeError`` conditions are possible here, as well as error
conditions that may be thrown by the System when it is asked to
perform computations. Be sure to enclose your simulation in a
``try-catch`` block and display the ``what()`` message.

We recommend that you call Initialize() prior to making the first call
to AdvanceTo(). However, if you don't it will be called for you the
first time that you attempt a step, possibly resulting in unexpected
error conditions. See documentation for ``Initialize()`` for the error
conditions it might produce.

Warning:
    You should consider calling Initialize() if you alter the the
    Context or Simulator options between successive AdvanceTo() calls.
    See Initialize() for more information.

Parameter ``boundary_time``:
    The maximum time to which the trajectory will be advanced by this
    call to AdvanceTo(). The method may return earlier if an event or
    the monitor function requests termination or reports an error
    condition.

Returns ``status``:
    A SimulatorStatus object indicating success, termination, or an
    error condition as reported by event handlers or the monitor
    function. The time in the context will be set either to the
    boundary_time or the time a termination or error was first
    detected.

Precondition:
    The internal Context satisfies all System constraints or will
    after pending Context updates are performed.

See also:
    Initialize(), AdvancePendingEvents(), SimulatorStatus)""";
        } AdvanceTo;
        // Symbol: drake::systems::Simulator::GetCurrentWitnessTimeIsolation
        struct /* GetCurrentWitnessTimeIsolation */ {
          // Source: drake/systems/analysis/simulator.h:679
          const char* doc =
R"""(Gets the length of the interval used for witness function time
isolation. The length of the interval is computed differently,
depending on context, to support multiple applications, as described
below:

* **Simulations using error controlled integrators**: the isolation time
  interval will be scaled by the product of the system's characteristic
  time and the accuracy stored in the Context.
* **Simulations using integrators taking fixed steps**: the isolation time
  interval will be determined differently depending on whether the
  accuracy is set in the Context or not. If the accuracy *is* set in the
  Context, the nominally fixed steps for integrating continuous state will
  be subdivided until events have been isolated to the requisite interval
  length, which is scaled by the step size times the accuracy in the
  Context. If accuracy is not set in the Context, event isolation will
  not be performed.

The isolation window length will never be smaller than the
integrator's working minimum tolerance (see
IntegratorBase::get_working_minimum_step_size());

Returns:
    the isolation window if the Simulator should be isolating
    witness-triggered events in time, or returns empty otherwise
    (indicating that any witness-triggered events should trigger at
    the end of a time interval over which continuous state is
    integrated).

Raises:
    RuntimeError if the accuracy is not set in the Context and the
    integrator is not operating in fixed step mode (see
    IntegratorBase::get_fixed_step_mode().)""";
        } GetCurrentWitnessTimeIsolation;
        // Symbol: drake::systems::Simulator::Initialize
        struct /* Initialize */ {
          // Source: drake/systems/analysis/simulator.h:295
          const char* doc =
R"""(See the class documentation for more information. We recommend calling
Initialize() explicitly prior to beginning a simulation so that error
conditions will be discovered early. However, Initialize() will be
called automatically by the first AdvanceTo() call if it hasn't
already been called.

Note:
    If you make a change to the Context or to Simulator options
    between AdvanceTo() calls you should consider whether to call
    Initialize() before resuming; AdvanceTo() will not do that
    automatically for you. Whether to do so depends on whether you
    want the above initialization operations performed.

Note:
    In particular, if you changed the time you must call Initialize().
    The time-triggered events must be recalculated in case one is due
    at the new starting time. The AdvanceTo() call will throw an
    exception if the Initialize() call is missing.

Note:
    The only way to suppress initialization events is by calling
    Initialize() explicitly. The most common scenario for this is when
    reusing a Simulator object. In this case, the caller is
    responsible for ensuring the correctness of the initial state.

Warning:
    Initialize() does not automatically attempt to satisfy System
    constraints -- it is up to you to make sure that constraints are
    satisfied by the initial conditions.

This method will throw ``RuntimeError`` if the combination of options
doesn't make sense. Other failures are possible from the System and
integrator in use.

Parameter ``params``:
    (optional) a parameter structure (

See also:
    InitializeParams).

Returns ``status``:
    A SimulatorStatus object indicating success, termination, or an
    error condition as reported by event handlers or the monitor
    function.

See also:
    AdvanceTo(), AdvancePendingEvents(), SimulatorStatus)""";
        } Initialize;
        // Symbol: drake::systems::Simulator::ResetStatistics
        struct /* ResetStatistics */ {
          // Source: drake/systems/analysis/simulator.h:575
          const char* doc =
R"""(Forget accumulated statistics. Statistics are reset to the values they
have post construction or immediately after ``Initialize()``.)""";
        } ResetStatistics;
        // Symbol: drake::systems::Simulator::Simulator<T>
        struct /* ctor */ {
          // Source: drake/systems/analysis/simulator.h:231
          const char* doc =
R"""(Create a Simulator that can advance a given System through time to
produce a trajectory consisting of a sequence of Context values. The
System must not have unresolved input ports if the values of those
ports are necessary for computations performed during simulation (see
class documentation).

The Simulator holds an internal, non-owned reference to the System
object so you must ensure that ``system`` has a longer lifetime than
the Simulator. It also owns a compatible Context internally that takes
on each of the trajectory values. You may optionally provide a Context
that will be used as the initial condition for the simulation;
otherwise the Simulator will obtain a default Context from ``system``.)""";
        } ctor;
        // Symbol: drake::systems::Simulator::clear_monitor
        struct /* clear_monitor */ {
          // Source: drake/systems/analysis/simulator.h:432
          const char* doc =
R"""(Removes the monitoring function if there is one.

See also:
    set_monitor())""";
        } clear_monitor;
        // Symbol: drake::systems::Simulator::get_actual_realtime_rate
        struct /* get_actual_realtime_rate */ {
          // Source: drake/systems/analysis/simulator.h:495
          const char* doc =
R"""(Return the rate that simulated time has progressed relative to real
time. A return of 1 means the simulation just matched real time, 2
means the simulation was twice as fast as real time, 0.5 means it was
running in 2X slow motion, etc.

The value returned here is calculated as follows:


::

    simulated_time_now - initial_simulated_time
      rate = -------------------------------------------
                   realtime_now - initial_realtime

The ``initial`` times are recorded when Initialize() or
ResetStatistics() is called. The returned rate is undefined if
Initialize() has not yet been called.

Returns:
    The rate achieved since the last Initialize() or ResetStatistics()
    call.

See also:
    set_target_realtime_rate())""";
        } get_actual_realtime_rate;
        // Symbol: drake::systems::Simulator::get_context
        struct /* get_context */ {
          // Source: drake/systems/analysis/simulator.h:531
          const char* doc =
R"""(Returns a const reference to the internally-maintained Context holding
the most recent step in the trajectory. This is suitable for
publishing or extracting information about this trajectory step. Do
not call this method if there is no Context.)""";
        } get_context;
        // Symbol: drake::systems::Simulator::get_integrator
        struct /* get_integrator */ {
          // Source: drake/systems/analysis/simulator.h:597
          const char* doc =
R"""(Gets a reference to the integrator used to advance the continuous
aspects of the system.)""";
        } get_integrator;
        // Symbol: drake::systems::Simulator::get_monitor
        struct /* get_monitor */ {
          // Source: drake/systems/analysis/simulator.h:436
          const char* doc =
R"""(Obtains a reference to the monitoring function, which may be empty.

See also:
    set_monitor())""";
        } get_monitor;
        // Symbol: drake::systems::Simulator::get_mutable_context
        struct /* get_mutable_context */ {
          // Source: drake/systems/analysis/simulator.h:541
          const char* doc =
R"""(Returns a mutable reference to the internally-maintained Context
holding the most recent step in the trajectory. This is suitable for
use in updates, sampling operations, event handlers, and constraint
projection. You can also modify this prior to calling Initialize() to
set initial conditions. Do not call this method if there is no
Context.)""";
        } get_mutable_context;
        // Symbol: drake::systems::Simulator::get_mutable_integrator
        struct /* get_mutable_integrator */ {
          // Source: drake/systems/analysis/simulator.h:601
          const char* doc =
R"""(Gets a reference to the mutable integrator used to advance the
continuous state of the system.)""";
        } get_mutable_integrator;
        // Symbol: drake::systems::Simulator::get_num_discrete_updates
        struct /* get_num_discrete_updates */ {
          // Source: drake/systems/analysis/simulator.h:588
          const char* doc =
R"""(Gets the number of discrete variable updates performed since the last
Initialize() call.)""";
        } get_num_discrete_updates;
        // Symbol: drake::systems::Simulator::get_num_publishes
        struct /* get_num_publishes */ {
          // Source: drake/systems/analysis/simulator.h:579
          const char* doc =
R"""(Gets the number of publishes made since the last Initialize() or
ResetStatistics() call.)""";
        } get_num_publishes;
        // Symbol: drake::systems::Simulator::get_num_steps_taken
        struct /* get_num_steps_taken */ {
          // Source: drake/systems/analysis/simulator.h:584
          const char* doc =
R"""(Gets the number of steps since the last Initialize() call. (We're not
counting the Initialize() 0-length "step".) Note that every
AdvanceTo() call can potentially take many steps.)""";
        } get_num_steps_taken;
        // Symbol: drake::systems::Simulator::get_num_unrestricted_updates
        struct /* get_num_unrestricted_updates */ {
          // Source: drake/systems/analysis/simulator.h:592
          const char* doc =
R"""(Gets the number of "unrestricted" updates performed since the last
Initialize() call.)""";
        } get_num_unrestricted_updates;
        // Symbol: drake::systems::Simulator::get_publish_every_time_step
        struct /* get_publish_every_time_step */ {
          // Source: drake/systems/analysis/simulator.h:525
          const char* doc =
R"""(Returns true if the set_publish_every_time_step() option has been
enabled. By default, returns false.)""";
        } get_publish_every_time_step;
        // Symbol: drake::systems::Simulator::get_system
        struct /* get_system */ {
          // Source: drake/systems/analysis/simulator.h:683
          const char* doc =
R"""(Gets a constant reference to the system.

Note:
    a mutable reference is not available.)""";
        } get_system;
        // Symbol: drake::systems::Simulator::get_target_realtime_rate
        struct /* get_target_realtime_rate */ {
          // Source: drake/systems/analysis/simulator.h:472
          const char* doc =
R"""(Return the real time rate target currently in effect. The default is
zero, meaning the Simulator runs as fast as possible. You can change
the target with set_target_realtime_rate().)""";
        } get_target_realtime_rate;
        // Symbol: drake::systems::Simulator::has_context
        struct /* has_context */ {
          // Source: drake/systems/analysis/simulator.h:548
          const char* doc =
R"""(Returns ``True`` if this Simulator has an internally-maintained
Context. This is always true unless ``reset_context()`` has been
called.)""";
        } has_context;
        // Symbol: drake::systems::Simulator::release_context
        struct /* release_context */ {
          // Source: drake/systems/analysis/simulator.h:567
          const char* doc =
R"""(Transfer ownership of this Simulator's internal Context to the caller.
The Simulator will no longer contain a Context. The caller must not
attempt to advance the simulator in time after that point.

See also:
    reset_context())""";
        } release_context;
        // Symbol: drake::systems::Simulator::reset_context
        struct /* reset_context */ {
          // Source: drake/systems/analysis/simulator.h:557
          const char* doc =
R"""(Replace the internally-maintained Context with a different one. The
current Context is deleted. This is useful for supplying a new set of
initial conditions. You should invoke Initialize() after replacing the
Context.

Parameter ``context``:
    The new context, which may be null. If the context is null, a new
    context must be set before attempting to step the system forward.)""";
        } reset_context;
        // Symbol: drake::systems::Simulator::reset_integrator
        struct /* reset_integrator */ {
          // Source: drake/systems/analysis/simulator.h:613
          const char* doc_0args =
R"""(Resets the integrator with a new one using factory construction.


::

    simulator.reset_integrator<RungeKutta3Integrator<double>>().

Resetting the integrator resets the Simulator such that it needs to be
initialized again -- see Initialize() for details.

Note:
    Integrator needs a constructor of the form Integrator(const
    System&, Context*); this constructor is usually associated with
    error-controlled integrators.)""";
          // Source: drake/systems/analysis/simulator.h:638
          const char* doc_1args =
R"""(Resets the integrator with a new one using factory construction and a
maximum step size argument (which is required for constructing
fixed-step integrators).


::

    simulator.reset_integrator<RungeKutta2Integrator<double>>(0.1).

See also:
    argument-less version of reset_integrator() for note about
    initialization.

Note:
    Integrator needs a constructor of the form Integrator(const
    System&, const T&, Context*); this constructor is usually
    associated with fixed-step integrators (i.e., integrators which do
    not support error estimation).)""";
        } reset_integrator;
        // Symbol: drake::systems::Simulator::set_monitor
        struct /* set_monitor */ {
          // Source: drake/systems/analysis/simulator.h:426
          const char* doc =
R"""(Provides a monitoring function that will be invoked at the end of
every step. (See the Simulator class documentation for a precise
definition of "step".) A monitor() function can be used to capture the
trajectory, to terminate the simulation, or to detect error
conditions. The monitor() function is invoked by the Simulator with a
Context whose value is a point along the simulated trajectory. The
monitor can be any functor and should capture any System references it
needs to operate correctly.

A monitor() function behaves the same as would a per-step Publish
event handler included in the top-level System or Diagram being
simulated. As in the case of Publish(), the monitor is called at the
end of every step taken internally by AdvanceTo(), and also at the end
of Initialize() and AdvancePendingEvents(). (See the Simulator class
documentation for more detail about what happens when in these
methods.) The monitor receives the top-level (root) Context, from
which any sub-Context can be obtained using
``subsystem.GetMyContextFromRoot()``, provided the necessary subsystem
reference has been captured for use in the monitor.

** Examples Output time and continuous states whenever the trajectory
is advanced:


::

    simulator.set_monitor([](const Context<T>& root_context) {
      std::cout << root_context.get_time() << " "
                << root_context.get_continuous_state_vector()
                << std::endl;
      return EventStatus::Succeeded();
    });

Terminate early but successfully on a condition in a subsystem of the
System diagram being simulated:


::

    simulator.set_monitor([&my_subsystem](const Context<T>& root_context) {
      const Context<T>& subcontext =
          my_subsystem.GetMyContextFromRoot(root_context);
      if (my_subsystem.GoalReached(subcontext)) {
        return EventStatus::ReachedTermination(my_subsystem,
            "Simulation achieved the desired goal.");
      }
      return EventStatus::Succeeded();
    });

In the above case, the Simulator's AdvanceTo() method will return
early when the subsystem reports that it has reached its goal. The
returned status will indicate the termination reason, and a
human-readable termination message containing the message provided by
the monitor can be obtained with status.FormatMessage().

Failure due to plant center of mass falling below a threshold:


::

    simulator.set_monitor([&plant](const Context<T>& root_context) {
      const Context<T>& plant_context =
          plant.GetMyContextFromRoot(root_context);
      const Vector3<T> com =
          plant.CalcCenterOfMassPositionInWorld(plant_context);
      if (com[2] < 0.1) {  // Check z height of com.
        return EventStatus::Failed(plant, "System fell over.");
      }
      return EventStatus::Succeeded();
    });

In the above case the Simulator's AdvanceTo() method will throw an
RuntimeError containing a human-readable message including the text
provided in the monitor.

Note:
    monitor() is called every time the trajectory is advanced by a
    step, which can mean it is called many times during a single
    AdvanceTo() call.

Note:
    The presence of a monitor has no effect on the step sizes taken,
    so a termination or error condition will be discovered only when
    first observed after a step is complete; it will not be further
    localized. Use witness-triggered events instead if you need
    precise isolation.)""";
        } set_monitor;
        // Symbol: drake::systems::Simulator::set_publish_at_initialization
        struct /* set_publish_at_initialization */ {
          // Source: drake/systems/analysis/simulator.h:519
          const char* doc =
R"""(Sets whether the simulation should trigger a forced-Publish at the end
of Initialize(). See set_publish_every_time_step() documentation for
more information.)""";
        } set_publish_at_initialization;
        // Symbol: drake::systems::Simulator::set_publish_every_time_step
        struct /* set_publish_every_time_step */ {
          // Source: drake/systems/analysis/simulator.h:512
          const char* doc =
R"""(Sets whether the simulation should trigger a forced-Publish event on
the System under simulation at the end of every trajectory-advancing
step. Specifically, that means the System::Publish() event dispatcher
will be invoked on each subsystem of the System and passed the current
Context and a forced-publish Event. If a subsystem has declared a
forced-publish event handler, that will be called. Otherwise, nothing
will happen unless the DoPublish() dispatcher has been overridden.

Enabling this option does not cause a forced-publish to be triggered
at initialization; if you want that you should also call
``set_publish_at_initialization(true)``. If you want a forced-publish
at the end of every step, you will usually also want one at the end of
initialization, requiring both options to be enabled.

See also:
    LeafSystem::DeclareForcedPublishEvent())""";
        } set_publish_every_time_step;
        // Symbol: drake::systems::Simulator::set_target_realtime_rate
        struct /* set_target_realtime_rate */ {
          // Source: drake/systems/analysis/simulator.h:465
          const char* doc =
R"""(Slow the simulation down to *approximately* synchronize with real time
when it would otherwise run too fast. Normally the Simulator takes
steps as quickly as it can. You can request that it slow down to
synchronize with real time by providing a realtime rate greater than
zero here.

Warning:
    No guarantees can be made about how accurately the simulation can
    be made to track real time, even if computation is fast enough.
    That's because the system utilities used to implement this do not
    themselves provide such guarantees. So this is likely to work
    nicely for visualization purposes where human perception is the
    only concern. For any other uses you should consider whether
    approximate real time is adequate for your purposes.

Note:
    If the full-speed simulation is already slower than real time you
    can't speed it up with this call! Instead consider requesting less
    integration accuracy, using a faster integration method or fixed
    time step, or using a simpler model.

Parameter ``realtime_rate``:
    Desired rate relative to real time. Set to 1 to track real time, 2
    to run twice as fast as real time, 0.5 for half speed, etc. Zero
    or negative restores the rate to its default of 0, meaning the
    simulation will proceed as fast as possible.)""";
        } set_target_realtime_rate;
      } Simulator;
      // Symbol: drake::systems::SimulatorConfig
      struct /* SimulatorConfig */ {
        // Source: drake/systems/analysis/simulator_config.h:14
        const char* doc =
R"""(The set of all configurable properties on a Simulator and
IntegratorBase.)""";
        // Symbol: drake::systems::SimulatorConfig::Serialize
        struct /* Serialize */ {
          // Source: drake/systems/analysis/simulator_config.h:16
          const char* doc = R"""()""";
        } Serialize;
        // Symbol: drake::systems::SimulatorConfig::accuracy
        struct /* accuracy */ {
          // Source: drake/systems/analysis/simulator_config.h:27
          const char* doc = R"""()""";
        } accuracy;
        // Symbol: drake::systems::SimulatorConfig::integration_scheme
        struct /* integration_scheme */ {
          // Source: drake/systems/analysis/simulator_config.h:25
          const char* doc = R"""()""";
        } integration_scheme;
        // Symbol: drake::systems::SimulatorConfig::max_step_size
        struct /* max_step_size */ {
          // Source: drake/systems/analysis/simulator_config.h:26
          const char* doc = R"""()""";
        } max_step_size;
        // Symbol: drake::systems::SimulatorConfig::publish_every_time_step
        struct /* publish_every_time_step */ {
          // Source: drake/systems/analysis/simulator_config.h:33
          const char* doc =
R"""(Sets Simulator::set_publish_at_initialization() in addition to
Simulator::set_publish_every_time_step() when applied by
ApplySimulatorConfig().)""";
        } publish_every_time_step;
        // Symbol: drake::systems::SimulatorConfig::target_realtime_rate
        struct /* target_realtime_rate */ {
          // Source: drake/systems/analysis/simulator_config.h:29
          const char* doc = R"""()""";
        } target_realtime_rate;
        // Symbol: drake::systems::SimulatorConfig::use_error_control
        struct /* use_error_control */ {
          // Source: drake/systems/analysis/simulator_config.h:28
          const char* doc = R"""()""";
        } use_error_control;
      } SimulatorConfig;
      // Symbol: drake::systems::SimulatorStatus
      struct /* SimulatorStatus */ {
        // Source: drake/systems/analysis/simulator_status.h:25
        const char* doc =
R"""(Holds the status return value from a call to Simulator::AdvanceTo()
and related methods. The argument t to AdvanceTo(t) is called the
boundary time, and represents the maximum time to which the simulation
trajectory will be advanced by a call to AdvanceTo(). (For methods
that don't advance time, the current time is considered to be the
boundary time.) A normal, successful return means that simulated time
advanced successfully to the boundary time, without encountering a
termination condition or error condition. AdvanceTo() may return
earlier than the boundary time if one of those conditions is
encountered. In that case the return object holds a reference to the
subsystem that detected the condition and a human-friendly message
from that subsystem that hopefully explains what happened.)""";
        // Symbol: drake::systems::SimulatorStatus::FormatMessage
        struct /* FormatMessage */ {
          // Source: drake/systems/analysis/simulator_status.h:70
          const char* doc =
R"""(Returns a human-readable message explaining the return result.)""";
        } FormatMessage;
        // Symbol: drake::systems::SimulatorStatus::IsIdenticalStatus
        struct /* IsIdenticalStatus */ {
          // Source: drake/systems/analysis/simulator_status.h:103
          const char* doc =
R"""(Returns true if the ``other`` status contains exactly the same
information as ``this`` status. This is likely only useful for unit
testing of SimulatorStatus.)""";
        } IsIdenticalStatus;
        // Symbol: drake::systems::SimulatorStatus::ReturnReason
        struct /* ReturnReason */ {
          // Source: drake/systems/analysis/simulator_status.h:29
          const char* doc = R"""()""";
          // Symbol: drake::systems::SimulatorStatus::ReturnReason::kEventHandlerFailed
          struct /* kEventHandlerFailed */ {
            // Source: drake/systems/analysis/simulator_status.h:41
            const char* doc =
R"""(An event handler or monitor function returned with a "failed"
EventStatus (has message with details). For AdvanceTo() the return
time may be earlier than the boundary time.)""";
          } kEventHandlerFailed;
          // Symbol: drake::systems::SimulatorStatus::ReturnReason::kReachedBoundaryTime
          struct /* kReachedBoundaryTime */ {
            // Source: drake/systems/analysis/simulator_status.h:33
            const char* doc =
R"""(This is the normal return: no termination or error condition was
encountered before reaching the boundary time. There is no message and
no saved System.)""";
          } kReachedBoundaryTime;
          // Symbol: drake::systems::SimulatorStatus::ReturnReason::kReachedTerminationCondition
          struct /* kReachedTerminationCondition */ {
            // Source: drake/systems/analysis/simulator_status.h:37
            const char* doc =
R"""(An event handler or monitor function returned with a "reached
termination condition" EventStatus (has message with details). For
AdvanceTo() the return time may be earlier than the boundary time.)""";
          } kReachedTerminationCondition;
        } ReturnReason;
        // Symbol: drake::systems::SimulatorStatus::SetEventHandlerFailed
        struct /* SetEventHandlerFailed */ {
          // Source: drake/systems/analysis/simulator_status.h:64
          const char* doc =
R"""(Sets this status to "event handler failed" with the early-termination
time and a message explaining why.)""";
        } SetEventHandlerFailed;
        // Symbol: drake::systems::SimulatorStatus::SetReachedBoundaryTime
        struct /* SetReachedBoundaryTime */ {
          // Source: drake/systems/analysis/simulator_status.h:47
          const char* doc =
R"""(Sets this status to "reached boundary time" with no message and with
the final time set to the boundary time (this is the same as the
post-construction default).)""";
        } SetReachedBoundaryTime;
        // Symbol: drake::systems::SimulatorStatus::SetReachedTermination
        struct /* SetReachedTermination */ {
          // Source: drake/systems/analysis/simulator_status.h:56
          const char* doc =
R"""(Sets this status to "reached termination" with the early-termination
time and a message explaining why.)""";
        } SetReachedTermination;
        // Symbol: drake::systems::SimulatorStatus::SimulatorStatus
        struct /* ctor */ {
          // Source: drake/systems/analysis/simulator_status.h:27
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::systems::SimulatorStatus::boundary_time
        struct /* boundary_time */ {
          // Source: drake/systems/analysis/simulator_status.h:79
          const char* doc =
R"""(Returns the maximum time we could have reached with this call; whether
we actually got there depends on the status. This is the time supplied
in an AdvanceTo() call or the current time for methods that don't
advance time, that is, Initialize() and AdvancePendingEvents().)""";
        } boundary_time;
        // Symbol: drake::systems::SimulatorStatus::message
        struct /* message */ {
          // Source: drake/systems/analysis/simulator_status.h:98
          const char* doc =
R"""(For termination or error conditions, returns a human-readable message
explaining what happened. This is the message from the subsystem that
detected the condition. FormatMessage() returns additional information
and also includes this message.)""";
        } message;
        // Symbol: drake::systems::SimulatorStatus::reason
        struct /* reason */ {
          // Source: drake/systems/analysis/simulator_status.h:87
          const char* doc =
R"""(Returns the reason that a Simulator call returned.)""";
        } reason;
        // Symbol: drake::systems::SimulatorStatus::return_time
        struct /* return_time */ {
          // Source: drake/systems/analysis/simulator_status.h:84
          const char* doc =
R"""(Returns the time that was actually reached. This will be
boundary_time() if succeeded() returns true. Otherwise it is the time
at which a termination or error condition was detected and may be
earlier than boundary_time().)""";
        } return_time;
        // Symbol: drake::systems::SimulatorStatus::succeeded
        struct /* succeeded */ {
          // Source: drake/systems/analysis/simulator_status.h:73
          const char* doc =
R"""(Returns true if we reached the boundary time with no surprises.)""";
        } succeeded;
        // Symbol: drake::systems::SimulatorStatus::system
        struct /* system */ {
          // Source: drake/systems/analysis/simulator_status.h:92
          const char* doc =
R"""(Optionally, returns the subsystem to which the status and contained
message should be attributed. May be nullptr in which case the status
should be attributed to the System as a whole.)""";
        } system;
      } SimulatorStatus;
      // Symbol: drake::systems::Sine
      struct /* Sine */ {
        // Source: drake/systems/primitives/sine.h:25
        const char* doc =
R"""(A sine system which outputs ``y = a * sin(f * t + p)`` and first and
second derivatives w.r.t. the time parameter ``t``. The block
parameters are: ``a`` the amplitude, ``f`` the frequency
(radians/second), and ``p`` the phase (radians), all of which are
constant vectors provided at construction time. This system has one or
zero input ports and three vector valued output ports (``y`` and its
first two derivatives). The user can specify whether to use simulation
time as the source of values for the time variable or an external
source. If an external time source is specified, the system is created
with an input port for the time source. Otherwise, the system is
created with zero input ports.)""";
        // Symbol: drake::systems::Sine::Sine<T>
        struct /* ctor */ {
          // Source: drake/systems/primitives/sine.h:39
          const char* doc_5args =
R"""(Constructs a Sine system where the amplitude, frequency, and phase is
applied to every input.

Parameter ``amplitude``:
    the sine wave amplitude

Parameter ``frequency``:
    the sine wave frequency (radians/second)

Parameter ``phase``:
    the sine wave phase (radians)

Parameter ``size``:
    number of elements in the output signal.

Parameter ``is_time_based``:
    indicates whether to use the simulation time as the source for the
    sine wave time variable, or use an external source, in which case
    an input port of size ``size`` is created.)""";
          // Source: drake/systems/primitives/sine.h:51
          const char* doc_4args =
R"""(Constructs a Sine system where different amplitudes, frequencies, and
phases can be applied to each sine wave.

Parameter ``amplitudes``:
    the sine wave amplitudes

Parameter ``frequencies``:
    the sine wave frequencies (radians/second)

Parameter ``phases``:
    the sine wave phases (radians)

Parameter ``is_time_based``:
    indicates whether to use the simulation time as the source for the
    sine wave time variable, or use an external source, in which case
    an input port is created.)""";
          // Source: drake/systems/primitives/sine.h:58
          const char* doc_copyconvert =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";
        } ctor;
        // Symbol: drake::systems::Sine::amplitude
        struct /* amplitude */ {
          // Source: drake/systems/primitives/sine.h:64
          const char* doc =
R"""(Returns the amplitude constant. This method should only be called if
the amplitude can be represented as a scalar value, i.e., every
element in the amplitude vector is the same. It will abort if the
amplitude cannot be represented as a single scalar value.)""";
        } amplitude;
        // Symbol: drake::systems::Sine::amplitude_vector
        struct /* amplitude_vector */ {
          // Source: drake/systems/primitives/sine.h:84
          const char* doc = R"""(Returns the amplitude vector constant.)""";
        } amplitude_vector;
        // Symbol: drake::systems::Sine::frequency
        struct /* frequency */ {
          // Source: drake/systems/primitives/sine.h:70
          const char* doc =
R"""(Returns the frequency constant. This method should only be called if
the frequency can be represented as a scalar value, i.e., every
element in the frequency vector is the same. It will abort if the
frequency cannot be represented as a single scalar value.)""";
        } frequency;
        // Symbol: drake::systems::Sine::frequency_vector
        struct /* frequency_vector */ {
          // Source: drake/systems/primitives/sine.h:87
          const char* doc = R"""(Returns the frequency vector constant.)""";
        } frequency_vector;
        // Symbol: drake::systems::Sine::is_time_based
        struct /* is_time_based */ {
          // Source: drake/systems/primitives/sine.h:81
          const char* doc =
R"""(Returns a boolean indicting whether to use simulation time as the
source of values for the time variable or an external source. Returns
true if the simulation time is used as the source, and returns false
otherwise.)""";
        } is_time_based;
        // Symbol: drake::systems::Sine::phase
        struct /* phase */ {
          // Source: drake/systems/primitives/sine.h:76
          const char* doc =
R"""(Returns the phase constant. This method should only be called if the
phase can be represented as a scalar value, i.e., every element in the
phase vector is the same. It will abort if the phase cannot be
represented as a single scalar value.)""";
        } phase;
        // Symbol: drake::systems::Sine::phase_vector
        struct /* phase_vector */ {
          // Source: drake/systems/primitives/sine.h:90
          const char* doc = R"""(Returns the phase vector constant.)""";
        } phase_vector;
      } Sine;
      // Symbol: drake::systems::SingleOutputVectorSource
      struct /* SingleOutputVectorSource */ {
        // Source: drake/systems/framework/single_output_vector_source.h:25
        const char* doc =
R"""(A base class that specializes LeafSystem for use with no input ports,
and only a single, vector output port. Subclasses should override the
protected method


::

    void DoCalcOutput(const Context<T>&, Eigen::VectorBlock<VectorX<T>>*) const;)""";
        // Symbol: drake::systems::SingleOutputVectorSource::DoCalcVectorOutput
        struct /* DoCalcVectorOutput */ {
          // Source: drake/systems/framework/single_output_vector_source.h:90
          const char* doc =
R"""(Provides a convenience method for SingleOutputVectorSource subclasses.
This method performs the same logical operation as
System::DoCalcOutput but provides the single output's VectorBlock
instead. Subclasses should override this method, and not the base
class method (which is ``final``).)""";
        } DoCalcVectorOutput;
        // Symbol: drake::systems::SingleOutputVectorSource::SingleOutputVectorSource<T>
        struct /* ctor */ {
          // Source: drake/systems/framework/single_output_vector_source.h:32
          const char* doc_0args =
R"""(Deleted default constructor. Child classes must either supply the
vector size to the single-argument constructor of ``int``, or supply a
model vector to the single-argument constructor of ``const
BasicVector<T>&``.)""";
          // Source: drake/systems/framework/single_output_vector_source.h:50
          const char* doc_1args_size =
R"""(Creates a source with the given sole output port configuration.

Note:
    Objects created using this constructor overload do not support
    system scalar conversion. See system_scalar_conversion. Use a
    different constructor overload if such conversion is desired.)""";
          // Source: drake/systems/framework/single_output_vector_source.h:58
          const char* doc_1args_model_vector =
R"""(Creates a source with output type and dimension of the
``model_vector``.

Note:
    Objects created using this constructor overload do not support
    system scalar conversion. See system_scalar_conversion. Use a
    different constructor overload if such conversion is desired.)""";
          // Source: drake/systems/framework/single_output_vector_source.h:68
          const char* doc_2args_converter_size =
R"""(Creates a source with the given sole output port configuration.

Note:
    objects created using this constructor may support system scalar
    conversion. See system_scalar_conversion.

Parameter ``converter``:
    is per LeafSystem::LeafSystem constructor documentation; see that
    function documentation for details.)""";
          // Source: drake/systems/framework/single_output_vector_source.h:78
          const char* doc_2args_converter_model_vector =
R"""(Creates a source with output type and dimension of the
``model_vector``.

Note:
    objects created using this constructor may support system scalar
    conversion. See system_scalar_conversion.

Parameter ``converter``:
    is per LeafSystem::LeafSystem constructor documentation; see that
    function documentation for details.)""";
        } ctor;
        // Symbol: drake::systems::SingleOutputVectorSource::get_output_port
        struct /* get_output_port */ {
          // Source: drake/systems/framework/single_output_vector_source.h:37
          const char* doc = R"""(Returns the sole output port.)""";
        } get_output_port;
      } SingleOutputVectorSource;
      // Symbol: drake::systems::State
      struct /* State */ {
        // Source: drake/systems/framework/state.h:29
        const char* doc =
R"""(%State is a container for all the data comprising the complete state
of a particular System at a particular moment. Any field in State may
be empty if it is not applicable to the System in question. A System
may not maintain state in any place other than a State object.

A State ``x`` contains three types of state variables:

- ContinuousState ``xc``
- DiscreteState   ``xd``
- AbstractState   ``xa``)""";
        // Symbol: drake::systems::State::SetFrom
        struct /* SetFrom */ {
          // Source: drake/systems/framework/state.h:110
          const char* doc = R"""(Initializes this state from a State<U>.)""";
        } SetFrom;
        // Symbol: drake::systems::State::State<T>
        struct /* ctor */ {
          // Source: drake/systems/framework/state.h:32
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::systems::State::get_abstract_state
        struct /* get_abstract_state */ {
          // Source: drake/systems/framework/state.h:95
          const char* doc =
R"""(Returns a const pointer to the abstract component of the state at
``index``. Asserts if ``index`` doesn't exist.)""";
        } get_abstract_state;
        // Symbol: drake::systems::State::get_continuous_state
        struct /* get_continuous_state */ {
          // Source: drake/systems/framework/state.h:42
          const char* doc = R"""()""";
        } get_continuous_state;
        // Symbol: drake::systems::State::get_discrete_state
        struct /* get_discrete_state */ {
          // Source: drake/systems/framework/state.h:57
          const char* doc = R"""()""";
        } get_discrete_state;
        // Symbol: drake::systems::State::get_mutable_abstract_state
        struct /* get_mutable_abstract_state */ {
          // Source: drake/systems/framework/state.h:103
          const char* doc =
R"""(Returns a mutable pointer to element ``index`` of the abstract state.
Asserts if ``index`` doesn't exist.)""";
        } get_mutable_abstract_state;
        // Symbol: drake::systems::State::get_mutable_continuous_state
        struct /* get_mutable_continuous_state */ {
          // Source: drake/systems/framework/state.h:47
          const char* doc = R"""()""";
        } get_mutable_continuous_state;
        // Symbol: drake::systems::State::get_mutable_discrete_state
        struct /* get_mutable_discrete_state */ {
          // Source: drake/systems/framework/state.h:62
          const char* doc = R"""()""";
        } get_mutable_discrete_state;
        // Symbol: drake::systems::State::set_abstract_state
        struct /* set_abstract_state */ {
          // Source: drake/systems/framework/state.h:77
          const char* doc = R"""()""";
        } set_abstract_state;
        // Symbol: drake::systems::State::set_continuous_state
        struct /* set_continuous_state */ {
          // Source: drake/systems/framework/state.h:37
          const char* doc = R"""()""";
        } set_continuous_state;
        // Symbol: drake::systems::State::set_discrete_state
        struct /* set_discrete_state */ {
          // Source: drake/systems/framework/state.h:52
          const char* doc = R"""()""";
        } set_discrete_state;
      } State;
      // Symbol: drake::systems::StateInterpolatorWithDiscreteDerivative
      struct /* StateInterpolatorWithDiscreteDerivative */ {
        // Source: drake/systems/primitives/discrete_derivative.h:146
        const char* doc =
R"""(Supports the common pattern of combining a (feed-through) position
with a velocity estimated with the DiscreteDerivative into a single
output vector with positions and velocities stacked. This assumes that
the number of positions == the number of velocities.


::

    ┌─────┐
    position ───┬───────────────────>│     │
                │                    │ Mux ├──> state
                │   ┌────────────┐   │     │
                └──>│  Discrete  ├──>│     │
                    │ Derivative │   └─────┘
                    └────────────┘

.. pydrake_system::

    name: StateInterpolatorWithDiscreteDerivative
    input_ports:
    - position
    output_ports:
    - state)""";
        // Symbol: drake::systems::StateInterpolatorWithDiscreteDerivative::StateInterpolatorWithDiscreteDerivative<T>
        struct /* ctor */ {
          // Source: drake/systems/primitives/discrete_derivative.h:152
          const char* doc =
R"""(Constructor taking ``num_positions``, the size of the position vector
to be differentiated, and ``time_step``, the sampling interval.)""";
        } ctor;
        // Symbol: drake::systems::StateInterpolatorWithDiscreteDerivative::set_initial_position
        struct /* set_initial_position */ {
          // Source: drake/systems/primitives/discrete_derivative.h:167
          const char* doc_2args_state_position =
R"""(Convenience method that sets the entire position history for the
discrete-time derivative to a constant vector value (resulting in
velocity estimate of zero). This is useful during initialization to
avoid large derivative outputs. ``position`` must be the same size as
the input/output ports. If suppress_initial_transient() is true, then
also disables the suppression for this ``state``.

Warning:
    This only changes the position history used for the velocity half
    of the output port; it has no effect on the feedthrough position.)""";
          // Source: drake/systems/primitives/discrete_derivative.h:190
          const char* doc_2args_context_position =
R"""(Convenience method that sets the entire position history for the
discrete-time derivative to a constant vector value (resulting in
velocity estimate of zero). This is useful during initialization to
avoid large derivative outputs. ``position`` must be the same size as
the input/output ports. If suppress_initial_transient() is true, then
also disables the suppression for this ``context``.

Warning:
    This only changes the position history used for the velocity half
    of the output port; it has no effect on the feedthrough position.)""";
        } set_initial_position;
        // Symbol: drake::systems::StateInterpolatorWithDiscreteDerivative::set_initial_state
        struct /* set_initial_state */ {
          // Source: drake/systems/primitives/discrete_derivative.h:178
          const char* doc_3args_state_position_velocity =
R"""(Convenience method that sets the entire position history for the
discrete-time derivative as if the most recent input was ``position``,
and the input before that was whatever was required to produce the
output velocity ``velocity``. ``position`` and ``velocity`` must be
the same size as the input/output ports. If
suppress_initial_transient() is true, then also disables the
suppression for this ``state``.

Warning:
    This only changes the position history used for the velocity half
    of the output port; it has no effect on the feedthrough position.)""";
          // Source: drake/systems/primitives/discrete_derivative.h:204
          const char* doc_3args_context_position_velocity =
R"""(Convenience method that sets the entire position history for the
discrete-time derivative as if the most recent input was ``position``,
and the input before that was whatever was required to produce the
output velocity ``velocity``. ``position`` and ``velocity`` must be
the same size as the input/output ports. If
suppress_initial_transient() is true, then also disables the
suppression for this ``context``.

Warning:
    This only changes the position history used for the velocity half
    of the output port; it has no effect on the feedthrough position.)""";
        } set_initial_state;
        // Symbol: drake::systems::StateInterpolatorWithDiscreteDerivative::suppress_initial_transient
        struct /* suppress_initial_transient */ {
          // Source: drake/systems/primitives/discrete_derivative.h:157
          const char* doc =
R"""(Returns the ``suppress_initial_transient`` passed to the constructor.)""";
        } suppress_initial_transient;
      } StateInterpolatorWithDiscreteDerivative;
      // Symbol: drake::systems::StepwiseDenseOutput
      struct /* StepwiseDenseOutput */ {
        // Source: drake/systems/analysis/stepwise_dense_output.h:26
        const char* doc =
R"""(A DenseOutput class interface extension, geared towards step-wise
construction procedures. Outputs of this kind are to be built
incrementally by means of discrete updates that extend its domain.
Nature of an update remains implementation specific.

To allow for update rectification (i.e. drop and replacement), in case
it fails to meet certain criteria (e.g. not within tolerances),
construction can be deferred to a consolidation step. In between
consolidations, updates can be rolled back (i.e. discarded) one by one
on a last-input-first-output basis. Implementations are thus
encouraged to keep recent updates in a light weight form, deferring
heavier computations and construction of a better suited
representation for evaluation. As such, evaluation is bound to succeed
only after consolidation.)""";
        // Symbol: drake::systems::StepwiseDenseOutput::Consolidate
        struct /* Consolidate */ {
          // Source: drake/systems/analysis/stepwise_dense_output.h:52
          const char* doc =
R"""(Consolidates latest updates.

All updates since last call or construction are put into a form that
is suitable for evaluation.

Remark:
    This process is irreversible.

Precondition:
    Updates have taken place since instantiation or last
    consolidation.

Postcondition:
    The extents covered by updates since instantiation or last
    consolidation can be evaluated (via Evaluate()).

Postcondition:
    Time extents covered by updates can be evaluated (via
    start_time()/end_time()).

Raises:
    RuntimeError if any of the preconditions is not met.)""";
        } Consolidate;
        // Symbol: drake::systems::StepwiseDenseOutput::Rollback
        struct /* Rollback */ {
          // Source: drake/systems/analysis/stepwise_dense_output.h:37
          const char* doc =
R"""(Rolls back (drops) the last update.

Remark:
    This process is irreversible.

Precondition:
    Updates have taken place since instantiation or last consolidation
    (via Consolidate()).

Raises:
    RuntimeError if any of the preconditions is not met.)""";
        } Rollback;
        // Symbol: drake::systems::StepwiseDenseOutput::StepwiseDenseOutput<T>
        struct /* ctor */ {
          // Source: drake/systems/analysis/stepwise_dense_output.h:28
          const char* doc = R"""()""";
        } ctor;
      } StepwiseDenseOutput;
      // Symbol: drake::systems::SubsystemIndex
      struct /* SubsystemIndex */ {
        // Source: drake/systems/framework/framework_common.h:42
        const char* doc =
R"""(Serves as a local index for a child subsystem within a parent Diagram,
or a child subcontext within a parent DiagramContext. A subsystem and
its matching subcontext have the same SubsystemIndex. Unique only
within a given subsystem or subcontext.)""";
      } SubsystemIndex;
      // Symbol: drake::systems::Subvector
      struct /* Subvector */ {
        // Source: drake/systems/framework/subvector.h:21
        const char* doc =
R"""(Subvector is a concrete class template that implements VectorBase by
providing a sliced view of a VectorBase.)""";
        // Symbol: drake::systems::Subvector::Subvector<T>
        struct /* ctor */ {
          // Source: drake/systems/framework/subvector.h:30
          const char* doc =
R"""(Constructs a subvector of vector that consists of num_elements
starting at first_element.

Parameter ``vector``:
    The vector to slice. Must not be nullptr. Must remain valid for
    the lifetime of this object.)""";
        } ctor;
        // Symbol: drake::systems::Subvector::size
        struct /* size */ {
          // Source: drake/systems/framework/subvector.h:45
          const char* doc = R"""()""";
        } size;
      } Subvector;
      // Symbol: drake::systems::Supervector
      struct /* Supervector */ {
        // Source: drake/systems/framework/supervector.h:20
        const char* doc =
R"""(Supervector is a concrete class template that implements VectorBase by
concatenating multiple VectorBases, which it does not own.)""";
        // Symbol: drake::systems::Supervector::Supervector<T>
        struct /* ctor */ {
          // Source: drake/systems/framework/supervector.h:27
          const char* doc =
R"""(Constructs a supervector consisting of all the vectors in subvectors,
which must live at least as long as this supervector.)""";
        } ctor;
        // Symbol: drake::systems::Supervector::size
        struct /* size */ {
          // Source: drake/systems/framework/supervector.h:36
          const char* doc = R"""()""";
        } size;
      } Supervector;
      // Symbol: drake::systems::SymbolicVectorSystem
      struct /* SymbolicVectorSystem */ {
        // Source: drake/systems/primitives/symbolic_vector_system.h:40
        const char* doc =
R"""(A LeafSystem that is defined by vectors of symbolic::Expression
representing the dynamics and output. The resulting system has only
zero or one vector input ports, zero or one vector of continuous or
discrete state (depending on the specified time_period), zero or one
vector of numeric parameters, and only zero or one vector output
ports.

See SymbolicVectorSystemBuilder to make the construction a little
nicer.

For example, to define the system: ẋ = -x + x³, y = x, we could write


::

    symbolic::Variable x("x");
      auto system = SymbolicVectorSystemBuilder().state(x)
                                                 .dynamics(-x + pow(x,3))
                                                 .output(x)
                                                 .Build();

Note: This will not be as performant as writing your own LeafSystem.
It is meant primarily for rapid prototyping.)""";
        // Symbol: drake::systems::SymbolicVectorSystem::SymbolicVectorSystem<T>
        struct /* ctor */ {
          // Source: drake/systems/primitives/symbolic_vector_system.h:75
          const char* doc_7args =
R"""(Construct the SymbolicVectorSystem.

Parameter ``time``:
    an (optional) Variable used to represent time in the dynamics.

Parameter ``state``:
    an (optional) vector of Variables representing the state. The
    order in this vector will determine the order of the elements in
    the state vector. Each element must be unique.

Parameter ``input``:
    an (optional) vector of Variables representing the input. The
    order in this vector will determine the order of the elements in
    the vector-valued input port. Each element must be unique.

Parameter ``parameter``:
    an (optional) vector of Variables representing the numeric
    parameter. The order in this vector will determine the order of
    the elements in the vector-valued parameter. Each element must be
    unique.

Parameter ``dynamics``:
    a vector of Expressions representing the dynamics of the system.
    If ``time_period`` == 0, then this describes the continuous time
    derivatives. If ``time_period`` > 0, then it defines the updates
    of the single discrete-valued state vector. The size of this
    vector must match the number of state variables.

Parameter ``output``:
    a vector of Expressions representing the output of the system. If
    empty, then no output port will be allocated.

Parameter ``time_period``:
    a scalar representing the period of a periodic update. time_period
    == 0.0 implies that the state variables will be declared as
    continuous state and the dynamics will be implemented as time
    derivatives. time_period > 0.0 implies the state variables will be
    declared as discrete state and the dynamics will be implemented as
    a dicraete variable update.)""";
          // Source: drake/systems/primitives/symbolic_vector_system.h:112
          const char* doc_6args =
R"""(Construct the SymbolicVectorSystem.

Parameter ``time``:
    an (optional) Variable used to represent time in the dynamics.

Parameter ``state``:
    an (optional) vector of Variables representing the state. The
    order in this vector will determine the order of the elements in
    the state vector. Each element must be unique.

Parameter ``input``:
    an (optional) vector of Variables representing the input. The
    order in this vector will determine the order of the elements in
    the vector-valued input port. Each element must be unique.

Parameter ``dynamics``:
    a vector of Expressions representing the dynamics of the system.
    If ``time_period`` == 0, then this describes the continuous time
    derivatives. If ``time_period`` > 0, then it defines the updates
    of the single discrete-valued state vector. The size of this
    vector must match the number of state variables.

Parameter ``output``:
    a vector of Expressions representing the output of the system. If
    empty, then no output port will be allocated.

Parameter ``time_period``:
    a scalar representing the period of a periodic update. time_period
    == 0.0 implies that the state variables will be declared as
    continuous state and the dynamics will be implemented as time
    derivatives. time_period > 0.0 implies the state variables will be
    declared as discrete state and the dynamics will be implemented as
    a dicraete variable update.)""";
          // Source: drake/systems/primitives/symbolic_vector_system.h:126
          const char* doc_copyconvert =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";
        } ctor;
        // Symbol: drake::systems::SymbolicVectorSystem::dynamics
        struct /* dynamics */ {
          // Source: drake/systems/primitives/symbolic_vector_system.h:144
          const char* doc = R"""()""";
        } dynamics;
        // Symbol: drake::systems::SymbolicVectorSystem::dynamics_for_variable
        struct /* dynamics_for_variable */ {
          // Source: drake/systems/primitives/symbolic_vector_system.h:152
          const char* doc =
R"""(Returns the dynamics for the variable ``var``. That is, it returns the
scalar expression corresponding to either ``\dot{var}`` (continuous
case) or ``var[n+1]`` (discrete case).

Raises:
    ValueError if this system has no corresponding dynamics for the
    variable ``var``.)""";
        } dynamics_for_variable;
        // Symbol: drake::systems::SymbolicVectorSystem::input_vars
        struct /* input_vars */ {
          // Source: drake/systems/primitives/symbolic_vector_system.h:140
          const char* doc = R"""()""";
        } input_vars;
        // Symbol: drake::systems::SymbolicVectorSystem::output
        struct /* output */ {
          // Source: drake/systems/primitives/symbolic_vector_system.h:165
          const char* doc = R"""()""";
        } output;
        // Symbol: drake::systems::SymbolicVectorSystem::parameter_vars
        struct /* parameter_vars */ {
          // Source: drake/systems/primitives/symbolic_vector_system.h:141
          const char* doc = R"""()""";
        } parameter_vars;
        // Symbol: drake::systems::SymbolicVectorSystem::state_vars
        struct /* state_vars */ {
          // Source: drake/systems/primitives/symbolic_vector_system.h:139
          const char* doc = R"""()""";
        } state_vars;
        // Symbol: drake::systems::SymbolicVectorSystem::time_var
        struct /* time_var */ {
          // Source: drake/systems/primitives/symbolic_vector_system.h:136
          const char* doc = R"""(@name Accessor methods.)""";
        } time_var;
      } SymbolicVectorSystem;
      // Symbol: drake::systems::SymbolicVectorSystemBuilder
      struct /* SymbolicVectorSystemBuilder */ {
        // Source: drake/systems/primitives/symbolic_vector_system.h:228
        const char* doc =
R"""(Builder design pattern to help with all of the optional arguments in
the constructor of SymbolicVectorSystem.

For example, to define the system: ẋ = -x + x³, y = x, we could write


::

    symbolic::Variable x("x");
      auto system = SymbolicVectorSystemBuilder().state(x)
                                                 .dynamics(-x + pow(x,3))
                                                 .output(x)
                                                 .Build();

See also:
    SymbolicVectorSystem)""";
        // Symbol: drake::systems::SymbolicVectorSystemBuilder::Build
        struct /* Build */ {
          // Source: drake/systems/primitives/symbolic_vector_system.h:361
          const char* doc =
R"""(Dispatches to the SymbolicVectorSystem constructor with our
accumulated arguments.)""";
        } Build;
        // Symbol: drake::systems::SymbolicVectorSystemBuilder::LinearizeDynamics
        struct /* LinearizeDynamics */ {
          // Source: drake/systems/primitives/symbolic_vector_system.h:347
          const char* doc =
R"""(Linearizes the system dynamics around ``(x0, u0)`` using the
first-order Taylor Series expansion.

Precondition:
    The length of ``x0`` should be the length of ``state()``.

Precondition:
    The length of ``u0`` should be the length of ``input()``.

Precondition:
    ``x0`` and ``u0`` should not include a state variable or an input
    variable.

Note:
    If ``x0`` or ``u0`` includes a variable new to this system
    builder, it will be added to this system builder as a parameter.)""";
        } LinearizeDynamics;
        // Symbol: drake::systems::SymbolicVectorSystemBuilder::SymbolicVectorSystemBuilder
        struct /* ctor */ {
          // Source: drake/systems/primitives/symbolic_vector_system.h:230
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::systems::SymbolicVectorSystemBuilder::dynamics
        struct /* dynamics */ {
          // Source: drake/systems/primitives/symbolic_vector_system.h:299
          const char* doc_was_unable_to_choose_unambiguous_names =
R"""(Sets the dynamics method (scalar version).)""";
        } dynamics;
        // Symbol: drake::systems::SymbolicVectorSystemBuilder::dynamics_for_variable
        struct /* dynamics_for_variable */ {
          // Source: drake/systems/primitives/symbolic_vector_system.h:387
          const char* doc =
R"""(Returns the dynamics for the variable ``var``. That is, it returns the
scalar expression corresponding to either ``\dot{var}`` (continuous
case) or ``var[n+1]`` (discrete case).

Raises:
    ValueError if this builder has no corresponding dynamics for the
    variable ``var``.)""";
        } dynamics_for_variable;
        // Symbol: drake::systems::SymbolicVectorSystemBuilder::input
        struct /* input */ {
          // Source: drake/systems/primitives/symbolic_vector_system.h:261
          const char* doc_was_unable_to_choose_unambiguous_names =
R"""(Sets the input variable (scalar version).)""";
        } input;
        // Symbol: drake::systems::SymbolicVectorSystemBuilder::output
        struct /* output */ {
          // Source: drake/systems/primitives/symbolic_vector_system.h:318
          const char* doc_was_unable_to_choose_unambiguous_names =
R"""(Sets the output method (scalar version).)""";
        } output;
        // Symbol: drake::systems::SymbolicVectorSystemBuilder::parameter
        struct /* parameter */ {
          // Source: drake/systems/primitives/symbolic_vector_system.h:280
          const char* doc_was_unable_to_choose_unambiguous_names =
R"""(Sets the parameter variable (scalar version).)""";
        } parameter;
        // Symbol: drake::systems::SymbolicVectorSystemBuilder::state
        struct /* state */ {
          // Source: drake/systems/primitives/symbolic_vector_system.h:241
          const char* doc_was_unable_to_choose_unambiguous_names =
R"""(Sets the state variable (scalar version).)""";
        } state;
        // Symbol: drake::systems::SymbolicVectorSystemBuilder::time
        struct /* time */ {
          // Source: drake/systems/primitives/symbolic_vector_system.h:235
          const char* doc_1args = R"""(Sets the time variable.)""";
          // Source: drake/systems/primitives/symbolic_vector_system.h:370
          const char* doc_0args =
R"""(@name Accessor methods. Returns the time variable if exists.)""";
        } time;
        // Symbol: drake::systems::SymbolicVectorSystemBuilder::time_period
        struct /* time_period */ {
          // Source: drake/systems/primitives/symbolic_vector_system.h:352
          const char* doc_1args =
R"""(Sets the time period (0 is continuous time).)""";
          // Source: drake/systems/primitives/symbolic_vector_system.h:402
          const char* doc_0args = R"""(Returns the time period.)""";
        } time_period;
      } SymbolicVectorSystemBuilder;
      // Symbol: drake::systems::System
      struct /* System */ {
        // Source: drake/systems/framework/system.h:69
        const char* doc =
R"""(Base class for all System functionality that is dependent on the
templatized scalar type T for input, state, parameters, and outputs.)""";
        // Symbol: drake::systems::System::Accept
        struct /* Accept */ {
          // Source: drake/systems/framework/system.h:77
          const char* doc =
R"""(Implements a visitor pattern.

See also:
    SystemVisitor<T>.)""";
        } Accept;
        // Symbol: drake::systems::System::AddConstraint
        struct /* AddConstraint */ {
          // Source: drake/systems/framework/system.h:1383
          const char* doc =
R"""(Adds an already-created constraint to the list of constraints for this
System. Ownership of the SystemConstraint is transferred to this
system.)""";
        } AddConstraint;
        // Symbol: drake::systems::System::AddExternalConstraint
        struct /* AddExternalConstraint */ {
          // Source: drake/systems/framework/system.h:449
          const char* doc =
R"""(Adds an "external" constraint to this System.

This method is intended for use by applications that are examining
this System to add additional constraints based on their particular
situation (e.g., that a velocity state element has an upper bound); it
is not intended for declaring intrinsic constraints that some
particular System subclass might always impose on itself (e.g., that a
mass parameter is non-negative). To that end, this method should not
be called by subclasses of ``this`` during their constructor.

The ``constraint`` will automatically persist across system scalar
conversion.)""";
        } AddExternalConstraint;
        // Symbol: drake::systems::System::AddTriggeredWitnessFunctionToCompositeEventCollection
        struct /* AddTriggeredWitnessFunctionToCompositeEventCollection */ {
          // Source: drake/systems/framework/system.h:1211
          const char* doc =
R"""(Add ``event`` to ``events`` due to a witness function triggering.
``events`` should be allocated with this system's
AllocateCompositeEventCollection. Neither ``event`` nor ``events`` can
be nullptr. Additionally, ``event`` must contain event data
(event->get_event_data() must not be nullptr) and the type of that
data must be WitnessTriggeredEventData.)""";
        } AddTriggeredWitnessFunctionToCompositeEventCollection;
        // Symbol: drake::systems::System::AllocateCompositeEventCollection
        struct /* AllocateCompositeEventCollection */ {
          // Source: drake/systems/framework/system.h:94
          const char* doc =
R"""(Allocates a CompositeEventCollection for this system. The allocated
instance is used for populating collections of triggered events; for
example, Simulator passes this object to System::CalcNextUpdateTime()
to allow the system to identify and handle upcoming events.)""";
        } AllocateCompositeEventCollection;
        // Symbol: drake::systems::System::AllocateContext
        struct /* AllocateContext */ {
          // Source: drake/systems/framework/system.h:87
          const char* doc =
R"""(Returns a Context<T> suitable for use with this System<T>.)""";
        } AllocateContext;
        // Symbol: drake::systems::System::AllocateDiscreteVariables
        struct /* AllocateDiscreteVariables */ {
          // Source: drake/systems/framework/system.h:130
          const char* doc =
R"""(Returns a DiscreteValues of the same dimensions as the discrete_state
allocated in CreateDefaultContext. The simulator will provide this
state as the output argument to Update.)""";
        } AllocateDiscreteVariables;
        // Symbol: drake::systems::System::AllocateFixedInputs
        struct /* AllocateFixedInputs */ {
          // Source: drake/systems/framework/system.h:187
          const char* doc =
R"""(For each input port, allocates a fixed input of the concrete type that
this System requires, and binds it to the port, disconnecting any
prior input. Does not assign any values to the fixed inputs.)""";
        } AllocateFixedInputs;
        // Symbol: drake::systems::System::AllocateForcedDiscreteUpdateEventCollection
        struct /* AllocateForcedDiscreteUpdateEventCollection */ {
          // Source: drake/systems/framework/system.h:908
          const char* doc = R"""()""";
        } AllocateForcedDiscreteUpdateEventCollection;
        // Symbol: drake::systems::System::AllocateForcedPublishEventCollection
        struct /* AllocateForcedPublishEventCollection */ {
          // Source: drake/systems/framework/system.h:905
          const char* doc = R"""()""";
        } AllocateForcedPublishEventCollection;
        // Symbol: drake::systems::System::AllocateForcedUnrestrictedUpdateEventCollection
        struct /* AllocateForcedUnrestrictedUpdateEventCollection */ {
          // Source: drake/systems/framework/system.h:911
          const char* doc = R"""()""";
        } AllocateForcedUnrestrictedUpdateEventCollection;
        // Symbol: drake::systems::System::AllocateImplicitTimeDerivativesResidual
        struct /* AllocateImplicitTimeDerivativesResidual */ {
          // Source: drake/systems/framework/system.h:123
          const char* doc =
R"""(Returns an Eigen VectorX suitable for use as the output argument to
the CalcImplicitTimeDerivativesResidual() method. The returned VectorX
will have size implicit_time_derivatives_residual_size() with the
elements uninitialized. This is just a convenience method -- you are
free to use any properly-sized mutable Eigen object as the residual
vector.)""";
        } AllocateImplicitTimeDerivativesResidual;
        // Symbol: drake::systems::System::AllocateInputAbstract
        struct /* AllocateInputAbstract */ {
          // Source: drake/systems/framework/system.h:103
          const char* doc =
R"""(Given an input port, allocates the abstract storage. The
``input_port`` must match a port declared via DeclareInputPort.)""";
        } AllocateInputAbstract;
        // Symbol: drake::systems::System::AllocateInputVector
        struct /* AllocateInputVector */ {
          // Source: drake/systems/framework/system.h:98
          const char* doc =
R"""(Given an input port, allocates the vector storage. The ``input_port``
must match a port declared via DeclareInputPort.)""";
        } AllocateInputVector;
        // Symbol: drake::systems::System::AllocateOutput
        struct /* AllocateOutput */ {
          // Source: drake/systems/framework/system.h:110
          const char* doc =
R"""(Returns a container that can hold the values of all of this System's
output ports. It is sized with the number of output ports and uses
each output port's allocation method to provide an object of the right
type for that port.)""";
        } AllocateOutput;
        // Symbol: drake::systems::System::AllocateTimeDerivatives
        struct /* AllocateTimeDerivatives */ {
          // Source: drake/systems/framework/system.h:115
          const char* doc =
R"""(Returns a ContinuousState of the same size as the continuous_state
allocated in CreateDefaultContext. The simulator will provide this
state as the output argument to EvalTimeDerivatives.)""";
        } AllocateTimeDerivatives;
        // Symbol: drake::systems::System::ApplyDiscreteVariableUpdate
        struct /* ApplyDiscreteVariableUpdate */ {
          // Source: drake/systems/framework/system.h:578
          const char* doc =
R"""(Given the ``discrete_state`` results of a previous call to
CalcDiscreteVariableUpdates() that dispatched the given collection of
events, modifies the ``context`` to reflect the updated
``discrete_state``.

Parameter ``events``:
    The Event collection that resulted in the given
    ``discrete_state``.

Parameter ``discrete_state``:
    The updated discrete state from a CalcDiscreteVariableUpdates()
    call. This is mutable to permit its contents to be swapped with
    the corresponding ``context`` contents (rather than copied).

Parameter ``context``:
    The Context whose discrete state is modified to match
    ``discrete_state``. Note that swapping contents with
    ``discrete_state`` may cause addresses of individual discrete
    state group vectors in ``context`` to be different on return than
    they were on entry.

Precondition:
    ``discrete_state`` is the result of a previous
    CalcDiscreteVariableUpdates() call that dispatched this ``events``
    collection.)""";
        } ApplyDiscreteVariableUpdate;
        // Symbol: drake::systems::System::ApplyUnrestrictedUpdate
        struct /* ApplyUnrestrictedUpdate */ {
          // Source: drake/systems/framework/system.h:619
          const char* doc =
R"""(Given the ``state`` results of a previous call to
CalcUnrestrictedUpdate() that dispatched the given collection of
events, modifies the ``context`` to reflect the updated ``state``.

Parameter ``events``:
    The Event collection that resulted in the given ``state``.

Parameter ``state``:
    The updated State from a CalcUnrestrictedUpdate() call. This is
    mutable to permit its contents to be swapped with the
    corresponding ``context`` contents (rather than copied).

Parameter ``context``:
    The Context whose State is modified to match ``state``. Note that
    swapping contents with the ``state`` may cause addresses of
    continuous, discrete, and abstract state containers in ``context``
    to be different on return than they were on entry.

Precondition:
    ``state`` is the result of a previous CalcUnrestrictedUpdate()
    call that dispatched this ``events`` collection.)""";
        } ApplyUnrestrictedUpdate;
        // Symbol: drake::systems::System::CalcConservativePower
        struct /* CalcConservativePower */ {
          // Source: drake/systems/framework/system.h:737
          const char* doc =
R"""(Calculates and returns the conservative power represented by the
current contents of the given ``context``. Prefer
EvalConservativePower() to avoid unnecessary recalculation.

See also:
    EvalConservativePower() for more information.)""";
        } CalcConservativePower;
        // Symbol: drake::systems::System::CalcDiscreteVariableUpdates
        struct /* CalcDiscreteVariableUpdates */ {
          // Source: drake/systems/framework/system.h:556
          const char* doc_3args =
R"""(This method is the public entry point for dispatching all discrete
variable update event handlers. Using all the discrete update handlers
in ``events``, the method calculates the update ``xd(n+1)`` to
discrete variables ``xd(n)`` in ``context`` and outputs the results to
``discrete_state``. See documentation for
DispatchDiscreteVariableUpdateHandler() for more details.)""";
          // Source: drake/systems/framework/system.h:586
          const char* doc_2args =
R"""(This method forces a discrete update on the system given a
``context``, and the updated discrete state is stored in
``discrete_state``. The discrete update event will have a trigger type
of kForced, with no attribute or custom callback.)""";
        } CalcDiscreteVariableUpdates;
        // Symbol: drake::systems::System::CalcImplicitTimeDerivativesResidual
        struct /* CalcImplicitTimeDerivativesResidual */ {
          // Source: drake/systems/framework/system.h:546
          const char* doc =
R"""(Evaluates the implicit form of the System equations and returns the
residual.

The explicit and implicit forms of the System equations are

(1) ẋ꜀ = fₑ(𝓒) explicit (2) 0 = fᵢ(𝓒; ẋ꜀) implicit

where ``𝓒 = {a, p, t, x, u}`` is the current value of the given
Context from which accuracy a, parameters p, time t, state x (``={x꜀
xd xₐ}``) and input values u are obtained. Substituting (1) into (2)
shows that the following condition must always hold:

(3) fᵢ(𝓒; fₑ(𝓒)) = 0 always true

When ``fᵢ(𝓒; ẋ꜀ₚ)`` is evaluated with a proposed time derivative ẋ꜀ₚ
that differs from ẋ꜀ the result will be non-zero; we call that the
*residual* of the implicit equation. Given a Context and proposed time
derivative ẋ꜀ₚ, this method returns the residual r such that

(4) r = fᵢ(𝓒; ẋ꜀ₚ).

The returned r will typically be the same length as x꜀ although that
is not required. And even if r and x꜀ are the same size, there will
not necessarily be any elementwise correspondence between them. (That
is, you should not assume that r[i] is the "residual" of ẋ꜀ₚ[i].) For
a Diagram, r is the concatenation of residuals from each of the
subsystems, in order of subsystem index within the Diagram.

A default implementation fᵢ⁽ᵈᵉᶠ⁾ for the implicit form is always
provided and makes use of the explicit form as follows:

(5) fᵢ⁽ᵈᵉᶠ⁾(𝓒; ẋ꜀ₚ) ≜ ẋ꜀ₚ − fₑ(𝓒)

which satisfies condition (3) by construction. (Note that the default
implementation requires the residual to have the same size as x꜀.)
Substantial efficiency gains can often be obtained by replacing the
default function with a customized implementation. Override
DoCalcImplicitTimeDerivativesResidual() to replace the default
implementation with a better one.

Parameter ``context``:
    The source for time, state, inputs, etc. to be used in calculating
    the residual.

Parameter ``proposed_derivatives``:
    The proposed value ẋ꜀ₚ for the time derivatives of x꜀.

Parameter ``residual``:
    The result r of evaluating the implicit function. Can be any
    mutable Eigen vector object of size
    implicit_time_derivatives_residual_size().

Precondition:
    ``proposed_derivatives`` is compatible with this System.

Precondition:
    ``residual`` is of size implicit_time_derivatives_residual_size().

See also:
    SystemBase::implicit_time_derivatives_residual_size()

See also:
    LeafSystem::DeclareImplicitTimeDerivativesResidualSize()

See also:
    DoCalcImplicitTimeDerivativesResidual()

See also:
    CalcTimeDerivatives())""";
        } CalcImplicitTimeDerivativesResidual;
        // Symbol: drake::systems::System::CalcKineticEnergy
        struct /* CalcKineticEnergy */ {
          // Source: drake/systems/framework/system.h:730
          const char* doc =
R"""(Calculates and returns the kinetic energy represented by the current
configuration and velocity provided in ``context``. Prefer
EvalKineticEnergy() to avoid unnecessary recalculation.

See also:
    EvalKineticEnergy() for more information.)""";
        } CalcKineticEnergy;
        // Symbol: drake::systems::System::CalcNextUpdateTime
        struct /* CalcNextUpdateTime */ {
          // Source: drake/systems/framework/system.h:648
          const char* doc =
R"""(This method is called by a Simulator during its calculation of the
size of the next continuous step to attempt. The System returns the
next time at which some discrete action must be taken, and records
what those actions ought to be in ``events``. Upon reaching that time,
the simulator will merge ``events`` with the other
CompositeEventCollection instances triggered through other mechanisms
(e.g. GetPerStepEvents()), and the merged CompositeEventCollection
will be passed to all event handling mechanisms.

If there is no timed event coming, the return value is Infinity. If a
finite update time is returned, there will be at least one Event
object in the returned event collection.

``events`` cannot be null. ``events`` will be cleared on entry.)""";
        } CalcNextUpdateTime;
        // Symbol: drake::systems::System::CalcNonConservativePower
        struct /* CalcNonConservativePower */ {
          // Source: drake/systems/framework/system.h:744
          const char* doc =
R"""(Calculates and returns the non-conservative power represented by the
current contents of the given ``context``. Prefer
EvalNonConservativePower() to avoid unnecessary recalculation.

See also:
    EvalNonConservativePower() for more information.)""";
        } CalcNonConservativePower;
        // Symbol: drake::systems::System::CalcOutput
        struct /* CalcOutput */ {
          // Source: drake/systems/framework/system.h:716
          const char* doc =
R"""(Utility method that computes for *every* output port i the value y(i)
that should result from the current contents of the given Context.
Note that individual output port values can be calculated using
``get_output_port(i).Calc()``; this method invokes that for each
output port in index order. The result may depend on time and the
current values of input ports, parameters, and state variables. The
result is written to ``outputs`` which must already have been
allocated to have the right number of entries of the right types.)""";
        } CalcOutput;
        // Symbol: drake::systems::System::CalcPotentialEnergy
        struct /* CalcPotentialEnergy */ {
          // Source: drake/systems/framework/system.h:723
          const char* doc =
R"""(Calculates and returns the potential energy represented by the current
configuration provided in ``context``. Prefer EvalPotentialEnergy() to
avoid unnecessary recalculation.

See also:
    EvalPotentialEnergy() for more information.)""";
        } CalcPotentialEnergy;
        // Symbol: drake::systems::System::CalcTimeDerivatives
        struct /* CalcTimeDerivatives */ {
          // Source: drake/systems/framework/system.h:488
          const char* doc =
R"""(Calculates the time derivatives ẋ꜀ of the continuous state x꜀ into a
given output argument. Prefer EvalTimeDerivatives() instead to avoid
unnecessary recomputation.

This method solves the System equations in explicit form:

ẋ꜀ = fₑ(𝓒)

where ``𝓒 = {a, p, t, x, u}`` is the current value of the given
Context from which accuracy a, parameters p, time t, state x (``={x꜀
xd xₐ}``) and input values u are obtained.

Parameter ``context``:
    The source for time, state, inputs, etc. defining the point at
    which the derivatives should be calculated.

Parameter ``derivatives``:
    The time derivatives ẋ꜀. Must be the same size as the continuous
    state vector in ``context``.

See also:
    EvalTimeDerivatives() for more information.

See also:
    CalcImplicitTimeDerivativesResidual() for the implicit form of
    these equations.)""";
        } CalcTimeDerivatives;
        // Symbol: drake::systems::System::CalcUnrestrictedUpdate
        struct /* CalcUnrestrictedUpdate */ {
          // Source: drake/systems/framework/system.h:598
          const char* doc_3args =
R"""(This method is the public entry point for dispatching all unrestricted
update event handlers. Using all the unrestricted update handers in
``events``, it updates *any* state variables in the ``context``, and
outputs the results to ``state``. It does not allow the dimensionality
of the state variables to change. See the documentation for
DispatchUnrestrictedUpdateHandler() for more details.

Raises:
    RuntimeError if the dimensionality of the state variables changes
    in the callback.)""";
          // Source: drake/systems/framework/system.h:631
          const char* doc_2args =
R"""(This method forces an unrestricted update on the system given a
``context``, and the updated state is stored in ``state``. The
unrestricted update event will have a trigger type of kForced, with no
additional data, attribute or custom callback.

See also:
    CalcUnrestrictedUpdate(const Context<T>&, const
    EventCollection<UnrestrictedUpdateEvent<T>>*, State<T>* state) for
    more information.)""";
        } CalcUnrestrictedUpdate;
        // Symbol: drake::systems::System::CalcWitnessValue
        struct /* CalcWitnessValue */ {
          // Source: drake/systems/framework/system.h:1203
          const char* doc =
R"""(Evaluates a witness function at the given context.)""";
        } CalcWitnessValue;
        // Symbol: drake::systems::System::CheckSystemConstraintsSatisfied
        struct /* CheckSystemConstraintsSatisfied */ {
          // Source: drake/systems/framework/system.h:1011
          const char* doc =
R"""(Returns true if ``context`` satisfies all of the registered
SystemConstraints with tolerance ``tol``.

See also:
    SystemConstraint::CheckSatisfied.)""";
        } CheckSystemConstraintsSatisfied;
        // Symbol: drake::systems::System::CheckValidOutput
        struct /* CheckValidOutput */ {
          // Source: drake/systems/framework/system.h:1018
          const char* doc =
R"""(Checks that ``output`` is consistent with the number and size of
output ports declared by the system.

Raises:
    RuntimeError unless ``output`` is non-null and valid for this
    system.)""";
        } CheckValidOutput;
        // Symbol: drake::systems::System::CopyContinuousStateVector
        struct /* CopyContinuousStateVector */ {
          // Source: drake/systems/framework/system.h:1022
          const char* doc =
R"""(Returns a copy of the continuous state vector x꜀ into an Eigen vector.)""";
        } CopyContinuousStateVector;
        // Symbol: drake::systems::System::CreateDefaultContext
        struct /* CreateDefaultContext */ {
          // Source: drake/systems/framework/system.h:135
          const char* doc =
R"""(This convenience method allocates a context using AllocateContext()
and sets its default values using SetDefaultContext().)""";
        } CreateDefaultContext;
        // Symbol: drake::systems::System::DeclareInputPort
        struct /* DeclareInputPort */ {
          // Source: drake/systems/framework/system.h:1359
          const char* doc_4args =
R"""(Adds a port with the specified ``type`` and ``size`` to the input
topology.

Input port names must be unique for this system (passing in a
duplicate ``name`` will throw RuntimeError). If ``name`` is given as
kUseDefaultName, then a default value of e.g. "u2", where 2 is the
input number will be provided. An empty ``name`` is not permitted.

If the port is intended to model a random noise or disturbance input,
``random_type`` can (optionally) be used to label it as such; doing so
enables algorithms for design and analysis (e.g. state estimation) to
reason explicitly about randomness at the system level. All random
input ports are assumed to be statistically independent.

Precondition:
    ``name`` must not be empty.

Raises:
    RuntimeError for a duplicate port name.

Returns:
    the declared port.)""";
          // Source: drake/systems/framework/system.h:1376
          const char* doc_3args =
R"""(See the nearly identical signature with an additional (first) argument
specifying the port name. This version will be deprecated as discussed
in #9447.)""";
        } DeclareInputPort;
        // Symbol: drake::systems::System::DispatchDiscreteVariableUpdateHandler
        struct /* DispatchDiscreteVariableUpdateHandler */ {
          // Source: drake/systems/framework/system.h:1309
          const char* doc =
R"""(This function dispatches all discrete update events to the appropriate
handlers. ``discrete_state`` cannot be null.)""";
        } DispatchDiscreteVariableUpdateHandler;
        // Symbol: drake::systems::System::DispatchPublishHandler
        struct /* DispatchPublishHandler */ {
          // Source: drake/systems/framework/system.h:1303
          const char* doc =
R"""(This function dispatches all publish events to the appropriate
handlers.)""";
        } DispatchPublishHandler;
        // Symbol: drake::systems::System::DispatchUnrestrictedUpdateHandler
        struct /* DispatchUnrestrictedUpdateHandler */ {
          // Source: drake/systems/framework/system.h:1320
          const char* doc =
R"""(This function dispatches all unrestricted update events to the
appropriate handlers. ``state`` cannot be null.)""";
        } DispatchUnrestrictedUpdateHandler;
        // Symbol: drake::systems::System::DoApplyDiscreteVariableUpdate
        struct /* DoApplyDiscreteVariableUpdate */ {
          // Source: drake/systems/framework/system.h:1314
          const char* doc = R"""()""";
        } DoApplyDiscreteVariableUpdate;
        // Symbol: drake::systems::System::DoApplyUnrestrictedUpdate
        struct /* DoApplyUnrestrictedUpdate */ {
          // Source: drake/systems/framework/system.h:1325
          const char* doc = R"""()""";
        } DoApplyUnrestrictedUpdate;
        // Symbol: drake::systems::System::DoCalcConservativePower
        struct /* DoCalcConservativePower */ {
          // Source: drake/systems/framework/system.h:1524
          const char* doc =
R"""(Override this method to return the rate Pc at which mechanical energy
is being converted *from* potential energy *to* kinetic energy by this
system in the given Context. By default, returns zero. Physical
systems should override. You may assume that ``context`` has already
been validated before it is passed to you here.

See EvalConservativePower() for details on what you must compute here.
In particular, this quantity must be *positive* when potential energy
is *decreasing*, and your conservative power method must *not* depend
explicitly on time or any input port values.)""";
        } DoCalcConservativePower;
        // Symbol: drake::systems::System::DoCalcImplicitTimeDerivativesResidual
        struct /* DoCalcImplicitTimeDerivativesResidual */ {
          // Source: drake/systems/framework/system.h:1434
          const char* doc =
R"""(Override this if you have an efficient way to evaluate the implicit
time derivatives residual for this System. Otherwise the default
implementation is ``residual = proposed_derivatives −
EvalTimeDerivatives(context)``. Note that you cannot use the default
implementation if you have changed the declared residual size.

Note:
    The public method has already verified that
    ``proposed_derivatives`` is compatible with this System and that
    ``residual`` is non-null and of the the declared size (as reported
    by SystemBase::implicit_time_derivatives_residual_size()). You do
    not have to check those two conditions in your implementation, but
    if you have additional restrictions you should validate that they
    are also met.)""";
        } DoCalcImplicitTimeDerivativesResidual;
        // Symbol: drake::systems::System::DoCalcKineticEnergy
        struct /* DoCalcKineticEnergy */ {
          // Source: drake/systems/framework/system.h:1512
          const char* doc =
R"""(Override this method for physical systems to calculate the kinetic
energy KE currently present in the motion provided in the given
Context. The default implementation returns 0 which is correct for
non-physical systems. You may assume that ``context`` has already been
validated before it is passed to you here.

See EvalKineticEnergy() for details on what you must compute here. In
particular, your kinetic energy method must *not* depend explicitly on
time or any input port values.)""";
        } DoCalcKineticEnergy;
        // Symbol: drake::systems::System::DoCalcNextUpdateTime
        struct /* DoCalcNextUpdateTime */ {
          // Source: drake/systems/framework/system.h:1455
          const char* doc =
R"""(Computes the next time at which this System must perform a discrete
action.

Override this method if your System has any discrete actions which
must interrupt the continuous simulation. This method is called only
from the public non-virtual CalcNextUpdateTime() which will already
have error-checked the parameters so you don't have to. You may assume
that ``context`` has already been validated and ``events`` pointer is
not null.

If you override this method, you *must* set the returned ``time``. Set
it to Infinity if there are no upcoming timed events. If you return a
finite update time, you *must* put at least one Event object in the
``events`` collection. These requirements are enforced by the public
CalcNextUpdateTime() method.

The default implementation returns with the next sample time being
Infinity and no events added to ``events``.)""";
        } DoCalcNextUpdateTime;
        // Symbol: drake::systems::System::DoCalcNonConservativePower
        struct /* DoCalcNonConservativePower */ {
          // Source: drake/systems/framework/system.h:1536
          const char* doc =
R"""(Override this method to return the rate Pnc at which work W is done on
the system by non-conservative forces. By default, returns zero.
Physical systems should override. You may assume that ``context`` has
already been validated before it is passed to you here.

See EvalNonConservativePower() for details on what you must compute
here. In particular, this quantity must be *negative* if the
non-conservative forces are *dissipative*, positive otherwise. Your
non-conservative power method can depend on anything you find in the
given Context, including time and input ports.)""";
        } DoCalcNonConservativePower;
        // Symbol: drake::systems::System::DoCalcPotentialEnergy
        struct /* DoCalcPotentialEnergy */ {
          // Source: drake/systems/framework/system.h:1501
          const char* doc =
R"""(Override this method for physical systems to calculate the potential
energy PE currently stored in the configuration provided in the given
Context. The default implementation returns 0 which is correct for
non-physical systems. You may assume that ``context`` has already been
validated before it is passed to you here.

See EvalPotentialEnergy() for details on what you must compute here.
In particular, your potential energy method must *not* depend
explicitly on time, velocities, or any input port values.)""";
        } DoCalcPotentialEnergy;
        // Symbol: drake::systems::System::DoCalcTimeDerivatives
        struct /* DoCalcTimeDerivatives */ {
          // Source: drake/systems/framework/system.h:1418
          const char* doc =
R"""(Override this if you have any continuous state variables x꜀ in your
concrete System to calculate their time derivatives. The
``derivatives`` vector will correspond elementwise with the state
vector ``Context.state.continuous_state.get_state()``. Thus, if the
state in the Context has second-order structure ``x꜀=[q v z]``, that
same structure applies to the derivatives.

This method is called only from the public non-virtual
CalcTimeDerivatives() which will already have error-checked the
parameters so you don't have to. In particular, implementations may
assume that the given Context is valid for this System; that the
``derivatives`` pointer is non-null, and that the referenced object
has the same constituent structure as was produced by
AllocateTimeDerivatives().

The default implementation does nothing if the ``derivatives`` vector
is size zero and aborts otherwise.)""";
        } DoCalcTimeDerivatives;
        // Symbol: drake::systems::System::DoCalcWitnessValue
        struct /* DoCalcWitnessValue */ {
          // Source: drake/systems/framework/system.h:1255
          const char* doc =
R"""(Derived classes will implement this method to evaluate a witness
function at the given context.)""";
        } DoCalcWitnessValue;
        // Symbol: drake::systems::System::DoGetInitializationEvents
        struct /* DoGetInitializationEvents */ {
          // Source: drake/systems/framework/system.h:1488
          const char* doc =
R"""(Implement this method to return any events to be handled at the
simulator's initialization step. ``events`` is cleared in the public
non-virtual GetInitializationEvents(). You may assume that ``context``
has already been validated and that ``events`` is not null. ``events``
can be changed freely by the overriding implementation.

The default implementation returns without changing ``events``.

See also:
    GetInitializationEvents())""";
        } DoGetInitializationEvents;
        // Symbol: drake::systems::System::DoGetMutableTargetSystemCompositeEventCollection
        struct /* DoGetMutableTargetSystemCompositeEventCollection */ {
          // Source: drake/systems/framework/system.h:880
          const char* doc = R"""()""";
        } DoGetMutableTargetSystemCompositeEventCollection;
        // Symbol: drake::systems::System::DoGetMutableTargetSystemState
        struct /* DoGetMutableTargetSystemState */ {
          // Source: drake/systems/framework/system.h:863
          const char* doc = R"""()""";
        } DoGetMutableTargetSystemState;
        // Symbol: drake::systems::System::DoGetPerStepEvents
        struct /* DoGetPerStepEvents */ {
          // Source: drake/systems/framework/system.h:1476
          const char* doc =
R"""(Implement this method to return any events to be handled before the
simulator integrates the system's continuous state at each time step.
``events`` is cleared in the public non-virtual GetPerStepEvents()
before that method calls this function. You may assume that
``context`` has already been validated and that ``events`` is not
null. ``events`` can be changed freely by the overriding
implementation.

The default implementation returns without changing ``events``.

See also:
    GetPerStepEvents())""";
        } DoGetPerStepEvents;
        // Symbol: drake::systems::System::DoGetPeriodicEvents
        struct /* DoGetPeriodicEvents */ {
          // Source: drake/systems/framework/system.h:1465
          const char* doc =
R"""(Implement this method to return all periodic triggered events.

See also:
    GetPeriodicEvents() for a detailed description of the returned
    variable.

Note:
    The default implementation returns an empty map.)""";
        } DoGetPeriodicEvents;
        // Symbol: drake::systems::System::DoGetTargetSystemCompositeEventCollection
        struct /* DoGetTargetSystemCompositeEventCollection */ {
          // Source: drake/systems/framework/system.h:887
          const char* doc = R"""()""";
        } DoGetTargetSystemCompositeEventCollection;
        // Symbol: drake::systems::System::DoGetTargetSystemContext
        struct /* DoGetTargetSystemContext */ {
          // Source: drake/systems/framework/system.h:858
          const char* doc = R"""()""";
        } DoGetTargetSystemContext;
        // Symbol: drake::systems::System::DoGetTargetSystemContinuousState
        struct /* DoGetTargetSystemContinuousState */ {
          // Source: drake/systems/framework/system.h:873
          const char* doc = R"""()""";
        } DoGetTargetSystemContinuousState;
        // Symbol: drake::systems::System::DoGetTargetSystemState
        struct /* DoGetTargetSystemState */ {
          // Source: drake/systems/framework/system.h:868
          const char* doc = R"""()""";
        } DoGetTargetSystemState;
        // Symbol: drake::systems::System::DoGetWitnessFunctions
        struct /* DoGetWitnessFunctions */ {
          // Source: drake/systems/framework/system.h:1264
          const char* doc =
R"""(Derived classes can override this method to provide witness functions
active for the given state. The default implementation does nothing.
On entry to this function, the context will have already been
validated and the vector of witness functions will have been validated
to be both empty and non-null.)""";
        } DoGetWitnessFunctions;
        // Symbol: drake::systems::System::DoMapQDotToVelocity
        struct /* DoMapQDotToVelocity */ {
          // Source: drake/systems/framework/system.h:1556
          const char* doc =
R"""(Provides the substantive implementation of MapQDotToVelocity().

The default implementation uses the identity mapping, and correctly
does nothing if the System does not have second-order state variables.
It throws RuntimeError if the ``generalized_velocity`` and ``qdot``
are not the same size, but that is not enough to guarantee that the
default implementation is adequate. Child classes must override this
function if qdot != v (even if they are the same size). This occurs,
for example, if a joint uses roll-pitch-yaw rotation angles for
orientation but angular velocity for rotational rate rather than
rotation angle derivatives.

If you implement this method you are required to use no more than
``O(nq)`` time where ``nq`` is the size of ``qdot``, so that the
System can meet the performance guarantee made for the public
interface, and you must also implement DoMapVelocityToQDot().
Implementations may assume that ``qdot`` has already been validated to
be the same size as ``q`` in the given Context, and that
``generalized_velocity`` is non-null.)""";
        } DoMapQDotToVelocity;
        // Symbol: drake::systems::System::DoMapVelocityToQDot
        struct /* DoMapVelocityToQDot */ {
          // Source: drake/systems/framework/system.h:1578
          const char* doc =
R"""(Provides the substantive implementation of MapVelocityToQDot().

The default implementation uses the identity mapping, and correctly
does nothing if the System does not have second-order state variables.
It throws RuntimeError if the ``generalized_velocity`` (`v`) and
``qdot`` are not the same size, but that is not enough to guarantee
that the default implementation is adequate. Child classes must
override this function if ``qdot != v`` (even if they are the same
size). This occurs, for example, if a joint uses roll-pitch-yaw
rotation angles for orientation but angular velocity for rotational
rate rather than rotation angle derivatives.

If you implement this method you are required to use no more than
``O(nq)`` time where ``nq`` is the size of ``qdot``, so that the
System can meet the performance guarantee made for the public
interface, and you must also implement DoMapQDotToVelocity().
Implementations may assume that ``generalized_velocity`` has already
been validated to be the same size as ``v`` in the given Context, and
that ``qdot`` is non-null.)""";
        } DoMapVelocityToQDot;
        // Symbol: drake::systems::System::EvalConservativePower
        struct /* EvalConservativePower */ {
          // Source: drake/systems/framework/system.h:350
          const char* doc =
R"""(Returns a reference to the cached value of the conservative power
(Pc), evaluating first if necessary using CalcConservativePower().

The returned Pc represents the rate at which mechanical energy is
being converted *from* potential energy (PE) *to* kinetic energy (KE)
by this system in the given Context. This quantity will be *positive*
when PE is *decreasing*. By definition here, conservative power may
depend only on quantities that explicitly contribute to PE and KE. See
EvalPotentialEnergy() and EvalKineticEnergy() for details.

Power due to non-conservative forces (e.g. dampers) can contribute to
the rate of change of KE. Therefore this method alone cannot be used
to determine whether KE is increasing or decreasing, only whether the
conservative power is adding or removing kinetic energy.
EvalNonConservativePower() can be used in conjunction with this method
to find the total rate of change of KE.

Non-physical systems where Pc is not meaningful will return Pc = 0.

Parameter ``context``:
    The Context whose contents may be used to evaluate conservative
    power.

Returns ``Pc``:
    The conservative power in watts (W or J/s) represented by the
    contents of the given ``context``.

See also:
    CalcConservativePower(), EvalNonConservativePower(),
    EvalPotentialEnergy(), EvalKineticEnergy())""";
        } EvalConservativePower;
        // Symbol: drake::systems::System::EvalEigenVectorInput
        struct /* EvalEigenVectorInput */ {
          // Source: drake/systems/framework/system.h:429
          const char* doc =
R"""(Returns the value of the vector-valued input port with the given
``port_index`` as an Eigen vector. Causes the value to become up to
date first if necessary. See EvalAbstractInput() for more information.

Precondition:
    ``port_index`` selects an existing input port of this System.

Precondition:
    the port must have been declared to be vector-valued.

Precondition:
    the port must be evaluable (connected or fixed).

See also:
    EvalVectorInput())""";
        } EvalEigenVectorInput;
        // Symbol: drake::systems::System::EvalKineticEnergy
        struct /* EvalKineticEnergy */ {
          // Source: drake/systems/framework/system.h:323
          const char* doc =
R"""(Returns a reference to the cached value of the kinetic energy (KE),
evaluating first if necessary using CalcKineticEnergy().

By definition here, kinetic energy depends only on "configuration" and
"velocity" (e.g. angular and translational velocity) of moving masses
which includes a subset of the state variables, and parameters that
affect configuration, velocities, or mass properties. The calculated
value may also be affected by the accuracy value supplied in the
Context. KE cannot depend explicitly on time (∂KE/∂t = 0) or input
port values (∂KE/∂u = 0).

Non-physical systems where KE is not meaningful will return KE = 0.

Parameter ``context``:
    The Context whose configuration and velocity variables may be used
    to evaluate kinetic energy.

Returns ``KE``:
    The kinetic energy in joules (J) represented by the configuration
    and velocity given in ``context``.

See also:
    CalcKineticEnergy())""";
        } EvalKineticEnergy;
        // Symbol: drake::systems::System::EvalNonConservativePower
        struct /* EvalNonConservativePower */ {
          // Source: drake/systems/framework/system.h:372
          const char* doc =
R"""(Returns a reference to the cached value of the non-conservative power
(Pnc), evaluating first if necessary using CalcNonConservativePower().

The returned Pnc represents the rate at which work W is done on the
system by non-conservative forces. Pnc is *negative* if the
non-conservative forces are *dissipative*, positive otherwise. Time
integration of Pnc yields work W, and the total mechanical energy ``E
= PE + KE − W`` should be conserved by any physically-correct model,
to within integration accuracy of W. Power is in watts (J/s). (Watts
are abbreviated W but not to be confused with work!) Any values in the
supplied Context (including time and input ports) may contribute to
the computation of non-conservative power.

Non-physical systems where Pnc is not meaningful will return Pnc = 0.

Parameter ``context``:
    The Context whose contents may be used to evaluate
    non-conservative power.

Returns ``Pnc``:
    The non-conservative power in watts (W or J/s) represented by the
    contents of the given ``context``.

See also:
    CalcNonConservativePower(), EvalConservativePower())""";
        } EvalNonConservativePower;
        // Symbol: drake::systems::System::EvalPotentialEnergy
        struct /* EvalPotentialEnergy */ {
          // Source: drake/systems/framework/system.h:304
          const char* doc =
R"""(Returns a reference to the cached value of the potential energy (PE),
evaluating first if necessary using CalcPotentialEnergy().

By definition here, potential energy depends only on "configuration"
(e.g. orientation and position), which includes a subset of the state
variables, and parameters that affect configuration or conservative
forces (such as lengths and masses). The calculated value may also be
affected by the accuracy value supplied in the Context. PE cannot
depend explicitly on time (∂PE/∂t = 0), velocities (∂PE/∂v = 0), or
input port values (∂PE/∂u = 0).

Non-physical systems where PE is not meaningful will return PE = 0.

Parameter ``context``:
    The Context whose configuration variables may be used to evaluate
    potential energy.

Returns ``PE``:
    The potential energy in joules (J) represented by the
    configuration given in ``context``.

See also:
    CalcPotentialEnergy())""";
        } EvalPotentialEnergy;
        // Symbol: drake::systems::System::EvalTimeDerivatives
        struct /* EvalTimeDerivatives */ {
          // Source: drake/systems/framework/system.h:274
          const char* doc =
R"""(Returns a reference to the cached value of the continuous state
variable time derivatives, evaluating first if necessary using
CalcTimeDerivatives().

This method returns the time derivatives ẋ꜀ of the continuous state
x꜀. The referenced return object will correspond elementwise with the
continuous state in the given Context. Thus, if the state in the
Context has second-order structure ``x꜀ = [q v z]``, that same
structure applies to the derivatives so we will have ``ẋ꜀ = [q̇ ̇v̇
ż]``.

Parameter ``context``:
    The Context whose time, input port, parameter, state, and accuracy
    values may be used to evaluate the derivatives.

Returns ``xcdot``:
    Time derivatives ẋ꜀ of x꜀ returned as a reference to an object of
    the same type and size as `context`'s continuous state.

See also:
    CalcTimeDerivatives(), CalcImplicitTimeDerivativesResidual(),
    get_time_derivatives_cache_entry())""";
        } EvalTimeDerivatives;
        // Symbol: drake::systems::System::EvalVectorInput
        struct /* EvalVectorInput */ {
          // Source: drake/systems/framework/system.h:390
          const char* doc =
R"""(Returns the value of the vector-valued input port with the given
``port_index`` as a BasicVector or a specific subclass ``Vec`` derived
from BasicVector. Causes the value to become up to date first if
necessary. See EvalAbstractInput() for more information.

The result is returned as a pointer to the input port's value of type
``Vec<T>`` or nullptr if the port is not connected.

Precondition:
    ``port_index`` selects an existing input port of this System.

Precondition:
    the port must have been declared to be vector-valued.

Precondition:
    the port's value must be of type Vec<T>.

Template parameter ``Vec``:
    The template type of the input vector, which must be a subclass of
    BasicVector.)""";
        } EvalVectorInput;
        // Symbol: drake::systems::System::FixInputPortsFrom
        struct /* FixInputPortsFrom */ {
          // Source: drake/systems/framework/system.h:1182
          const char* doc =
R"""(Fixes all of the input ports in ``target_context`` to their current
values in ``other_context``, as evaluated by ``other_system``.

Raises:
    RuntimeError unless ``other_context`` and ``target_context`` both
    have the same shape as this System, and the ``other_system``.
    Ignores disconnected inputs.)""";
        } FixInputPortsFrom;
        // Symbol: drake::systems::System::GetGraphvizFragment
        struct /* GetGraphvizFragment */ {
          // Source: drake/systems/framework/system.h:1046
          const char* doc =
R"""(Appends a Graphviz fragment to the ``dot`` stream. The fragment must
be valid Graphviz when wrapped in a ``digraph`` or ``subgraph``
stanza. Does nothing by default.

Parameter ``max_depth``:
    Sets a limit to the depth of nested diagrams to visualize. Set to
    zero to render a diagram as a single system block.)""";
        } GetGraphvizFragment;
        // Symbol: drake::systems::System::GetGraphvizId
        struct /* GetGraphvizId */ {
          // Source: drake/systems/framework/system.h:1063
          const char* doc =
R"""(Returns an opaque integer that uniquely identifies this system in the
Graphviz output.)""";
        } GetGraphvizId;
        // Symbol: drake::systems::System::GetGraphvizInputPortToken
        struct /* GetGraphvizInputPortToken */ {
          // Source: drake/systems/framework/system.h:1051
          const char* doc =
R"""(Appends a fragment to the ``dot`` stream identifying the graphviz node
representing ``port``. Does nothing by default.)""";
        } GetGraphvizInputPortToken;
        // Symbol: drake::systems::System::GetGraphvizOutputPortToken
        struct /* GetGraphvizOutputPortToken */ {
          // Source: drake/systems/framework/system.h:1057
          const char* doc =
R"""(Appends a fragment to the ``dot`` stream identifying the graphviz node
representing ``port``. Does nothing by default.)""";
        } GetGraphvizOutputPortToken;
        // Symbol: drake::systems::System::GetGraphvizString
        struct /* GetGraphvizString */ {
          // Source: drake/systems/framework/system.h:1037
          const char* doc =
R"""(Returns a Graphviz string describing this System. To render the
string, use the Graphviz tool, ``dot``. http://www.graphviz.org/

Parameter ``max_depth``:
    Sets a limit to the depth of nested diagrams to visualize. Set to
    zero to render a diagram as a single system block.

See also:
    GenerateHtml)""";
        } GetGraphvizString;
        // Symbol: drake::systems::System::GetInitializationEvents
        struct /* GetInitializationEvents */ {
          // Source: drake/systems/framework/system.h:671
          const char* doc =
R"""(This method is called by Simulator::Initialize() to gather all update
and publish events that need to be handled at initialization before
the simulator starts integration.

``events`` cannot be null. ``events`` will be cleared on entry.)""";
        } GetInitializationEvents;
        // Symbol: drake::systems::System::GetInputPort
        struct /* GetInputPort */ {
          // Source: drake/systems/framework/system.h:958
          const char* doc =
R"""(Returns the typed input port with the unique name ``port_name``. The
current implementation performs a linear search over strings; prefer
get_input_port() when performance is a concern.

Raises:
    RuntimeError if port_name is not found.)""";
        } GetInputPort;
        // Symbol: drake::systems::System::GetMemoryObjectName
        struct /* GetMemoryObjectName */ {
          // Source: drake/systems/framework/system.h:923
          const char* doc =
R"""(Returns a name for this System based on a stringification of its type
name and memory address. This is intended for use in diagnostic output
and should not be used for behavioral logic, because the
stringification of the type name may produce differing results across
platforms and because the address can vary from run to run.)""";
        } GetMemoryObjectName;
        // Symbol: drake::systems::System::GetMutableOutputVector
        struct /* GetMutableOutputVector */ {
          // Source: drake/systems/framework/system.h:1592
          const char* doc =
R"""(Returns a mutable Eigen expression for a vector valued output port
with index ``port_index`` in this system. All input ports that
directly depend on this output port will be notified that upstream
data has changed, and may invalidate cache entries as a result.)""";
        } GetMutableOutputVector;
        // Symbol: drake::systems::System::GetMutableSubsystemContext
        struct /* GetMutableSubsystemContext */ {
          // Source: drake/systems/framework/system.h:831
          const char* doc =
R"""(Returns a mutable reference to the subcontext that corresponds to the
contained System ``subsystem``.

Raises:
    RuntimeError if ``subsystem`` not contained in ``this`` System.

Precondition:
    The given ``context`` is valid for use with ``this`` System.)""";
        } GetMutableSubsystemContext;
        // Symbol: drake::systems::System::GetMyContextFromRoot
        struct /* GetMyContextFromRoot */ {
          // Source: drake/systems/framework/system.h:841
          const char* doc =
R"""(Returns the const Context for ``this`` subsystem, given a root
context. If ``this`` System is already the top level (root) System,
just returns ``root_context``. (A root Context is one that does not
have a parent Context.)

Raises:
    RuntimeError if the given ``root_context`` is not actually a root
    context.

See also:
    GetSubsystemContext())""";
        } GetMyContextFromRoot;
        // Symbol: drake::systems::System::GetMyMutableContextFromRoot
        struct /* GetMyMutableContextFromRoot */ {
          // Source: drake/systems/framework/system.h:846
          const char* doc =
R"""(Returns the mutable subsystem context for ``this`` system, given a
root context.

See also:
    GetMyContextFromRoot())""";
        } GetMyMutableContextFromRoot;
        // Symbol: drake::systems::System::GetOutputPort
        struct /* GetOutputPort */ {
          // Source: drake/systems/framework/system.h:993
          const char* doc =
R"""(Returns the typed output port with the unique name ``port_name``. The
current implementation performs a linear search over strings; prefer
get_output_port() when performance is a concern.

Raises:
    RuntimeError if port_name is not found.)""";
        } GetOutputPort;
        // Symbol: drake::systems::System::GetPerStepEvents
        struct /* GetPerStepEvents */ {
          // Source: drake/systems/framework/system.h:663
          const char* doc =
R"""(This method is called by Simulator::Initialize() to gather all update
and publish events that are to be handled in AdvanceTo() at the point
before Simulator integrates continuous state. It is assumed that these
events remain constant throughout the simulation. The "step" here
refers to the major time step taken by the Simulator. During every
simulation step, the simulator will merge ``events`` with the event
collections populated by other types of event triggering mechanism
(e.g., CalcNextUpdateTime()), and the merged CompositeEventCollection
objects will be passed to the appropriate handlers before Simulator
integrates the continuous state.

``events`` cannot be null. ``events`` will be cleared on entry.)""";
        } GetPerStepEvents;
        // Symbol: drake::systems::System::GetPeriodicEvents
        struct /* GetPeriodicEvents */ {
          // Source: drake/systems/framework/system.h:706
          const char* doc =
R"""(Gets all periodic triggered events for a system. Each periodic
attribute (offset and period, in seconds) is mapped to one or more
update events that are to be triggered at the proper times.)""";
        } GetPeriodicEvents;
        // Symbol: drake::systems::System::GetSubsystemContext
        struct /* GetSubsystemContext */ {
          // Source: drake/systems/framework/system.h:824
          const char* doc =
R"""(Returns a const reference to the subcontext that corresponds to the
contained System ``subsystem``.

Raises:
    RuntimeError if ``subsystem`` not contained in ``this`` System.

Precondition:
    The given ``context`` is valid for use with ``this`` System.)""";
        } GetSubsystemContext;
        // Symbol: drake::systems::System::GetUniquePeriodicDiscreteUpdateAttribute
        struct /* GetUniquePeriodicDiscreteUpdateAttribute */ {
          // Source: drake/systems/framework/system.h:683
          const char* doc =
R"""(Gets whether there exists a unique periodic attribute that triggers
one or more discrete update events (and, if so, returns that unique
periodic attribute). Thus, this method can be used (1) as a test to
determine whether a system's dynamics are at least partially governed
by difference equations and (2) to obtain the difference equation
update times.

Returns:
    optional<PeriodicEventData> Contains the periodic trigger
    attributes if the unique periodic attribute exists, otherwise
    ``nullopt``.)""";
        } GetUniquePeriodicDiscreteUpdateAttribute;
        // Symbol: drake::systems::System::GetWitnessFunctions
        struct /* GetWitnessFunctions */ {
          // Source: drake/systems/framework/system.h:1199
          const char* doc =
R"""(Gets the witness functions active for the given state.
DoGetWitnessFunctions() does the actual work. The vector of active
witness functions are expected to change only upon an unrestricted
update.

Parameter ``context``:
    a valid context for the System (aborts if not true).

Parameter ``w``:
    a valid pointer to an empty vector that will store pointers to the
    witness functions active for the current state. The method aborts
    if witnesses is null or non-empty.)""";
        } GetWitnessFunctions;
        // Symbol: drake::systems::System::HasAnyDirectFeedthrough
        struct /* HasAnyDirectFeedthrough */ {
          // Source: drake/systems/framework/system.h:191
          const char* doc =
R"""(Returns ``True`` if any of the inputs to the system might be directly
fed through to any of its outputs and ``False`` otherwise.)""";
        } HasAnyDirectFeedthrough;
        // Symbol: drake::systems::System::HasDirectFeedthrough
        struct /* HasDirectFeedthrough */ {
          // Source: drake/systems/framework/system.h:195
          const char* doc_1args =
R"""(Returns true if there might be direct-feedthrough from any input port
to the given ``output_port``, and false otherwise.)""";
          // Source: drake/systems/framework/system.h:199
          const char* doc_2args =
R"""(Returns true if there might be direct-feedthrough from the given
``input_port`` to the given ``output_port``, and false otherwise.)""";
        } HasDirectFeedthrough;
        // Symbol: drake::systems::System::HasInputPort
        struct /* HasInputPort */ {
          // Source: drake/systems/framework/system.h:962
          const char* doc =
R"""(Returns true iff the system has an InputPort of the given
``port_name``.)""";
        } HasInputPort;
        // Symbol: drake::systems::System::HasOutputPort
        struct /* HasOutputPort */ {
          // Source: drake/systems/framework/system.h:997
          const char* doc =
R"""(Returns true iff the system has an OutputPort of the given
``port_name``.)""";
        } HasOutputPort;
        // Symbol: drake::systems::System::IsDifferenceEquationSystem
        struct /* IsDifferenceEquationSystem */ {
          // Source: drake/systems/framework/system.h:700
          const char* doc =
R"""(Returns true iff the state dynamics of this system are governed
exclusively by a difference equation on a single discrete state group
and with a unique periodic update (having zero offset). E.g., it is
amenable to analysis of the form: x[n+1] = f(x[n], u[n]) Note that we
do NOT consider the number of input ports here, because in practice
many systems of interest (e.g. MultibodyPlant) have input ports that
are safely treated as constant during the analysis. Consider using
get_input_port_selection() to choose one.

Parameter ``time_period``:
    if non-null, then iff the function returns ``True``, then
    time_period is set to the period data returned from
    GetUniquePeriodicDiscreteUpdateAttribute(). If the function
    returns ``False`` (the system is not a difference equation
    system), then ``time_period`` does not receive a value.)""";
        } IsDifferenceEquationSystem;
        // Symbol: drake::systems::System::MapQDotToVelocity
        struct /* MapQDotToVelocity */ {
          // Source: drake/systems/framework/system.h:787
          const char* doc_was_unable_to_choose_unambiguous_names =
R"""(Transforms the time derivative ``qdot`` of the generalized
configuration ``q`` to generalized velocities ``v``. `v` and ``qdot``
are related linearly by ``qdot = N(q) * v``, where ``N`` is a block
diagonal matrix. For example, in a multibody system there will be one
block of ``N`` per tree joint. Although ``N`` is not necessarily
square, its left pseudo-inverse ``N+`` can be used to invert that
relationship without residual error, provided that ``qdot`` is in the
range space of ``N`` (that is, if it *could* have been produced as
``qdot=N*v`` for some ``v``). Using the configuration ``q`` from the
given Context this method calculates ``v = N+ * qdot`` (where
``N+=N+(q)``) for a given ``qdot``. This computation requires only
``O(nq)`` time where ``nq`` is the size of ``qdot``. Note that this
method does not take ``qdot`` from the Context.

See the alternate signature if you already have ``qdot`` in an Eigen
VectorX object; this signature will copy the VectorBase into an Eigen
object before performing the computation.

See also:
    MapVelocityToQDot())""";
        } MapQDotToVelocity;
        // Symbol: drake::systems::System::MapVelocityToQDot
        struct /* MapVelocityToQDot */ {
          // Source: drake/systems/framework/system.h:758
          const char* doc_was_unable_to_choose_unambiguous_names =
R"""(Transforms a given generalized velocity ``v`` to the time derivative
``qdot`` of the generalized configuration ``q`` taken from the
supplied Context. ``v`` and ``qdot`` are related linearly by ``qdot =
N(q) * v``, where ``N`` is a block diagonal matrix. For example, in a
multibody system there will be one block of ``N`` per tree joint. This
computation requires only ``O(nq)`` time where ``nq`` is the size of
``qdot``. Note that ``v`` is *not* taken from the Context; it is given
as an argument here.

See the alternate signature if you already have the generalized
velocity in an Eigen VectorX object; this signature will copy the
VectorBase into an Eigen object before performing the computation.

See also:
    MapQDotToVelocity())""";
        } MapVelocityToQDot;
        // Symbol: drake::systems::System::Publish
        struct /* Publish */ {
          // Source: drake/systems/framework/system.h:225
          const char* doc_2args =
R"""(This method is the public entry point for dispatching all publish
event handlers. It checks the validity of ``context``, and directly
calls DispatchPublishHandler. ``events`` is a homogeneous collection
of publish events.

Note:
    When publishing is triggered at particular times, those times
    likely will not coincide with integrator step times. A Simulator
    may interpolate to generate a suitable Context, or it may adjust
    the integrator step size so that a step begins exactly at the next
    publication time. In the latter case the change in step size may
    affect the numerical result somewhat since a smaller integrator
    step produces a more accurate solution.)""";
          // Source: drake/systems/framework/system.h:233
          const char* doc_1args =
R"""(Forces a publish on the system, given a ``context``. The publish event
will have a trigger type of kForced, with no additional data,
attribute or custom callback. The Simulator can be configured to call
this in Simulator::Initialize() and at the start of each continuous
integration step. See the Simulator API for more details.)""";
        } Publish;
        // Symbol: drake::systems::System::SetDefaultContext
        struct /* SetDefaultContext */ {
          // Source: drake/systems/framework/system.h:149
          const char* doc =
R"""(Sets Context fields to their default values. User code should not
override.)""";
        } SetDefaultContext;
        // Symbol: drake::systems::System::SetDefaultParameters
        struct /* SetDefaultParameters */ {
          // Source: drake/systems/framework/system.h:144
          const char* doc =
R"""(Assigns default values to all parameters. Overrides must not change
the number of parameters.)""";
        } SetDefaultParameters;
        // Symbol: drake::systems::System::SetDefaultState
        struct /* SetDefaultState */ {
          // Source: drake/systems/framework/system.h:139
          const char* doc =
R"""(Assigns default values to all elements of the state. Overrides must
not change the number of state variables.)""";
        } SetDefaultState;
        // Symbol: drake::systems::System::SetRandomContext
        struct /* SetRandomContext */ {
          // Source: drake/systems/framework/system.h:182
          const char* doc =
R"""(Sets Context fields to random values. User code should not override.)""";
        } SetRandomContext;
        // Symbol: drake::systems::System::SetRandomParameters
        struct /* SetRandomParameters */ {
          // Source: drake/systems/framework/system.h:176
          const char* doc =
R"""(Assigns random values to all parameters. This default implementation
calls SetDefaultParameters; override this method to provide random
parameters using the stdc++ random library, e.g.:


::

    std::uniform_real_distribution<T> uniform();
    parameters->get_mutable_numeric_parameter(0)
    ->SetAtIndex(0, uniform(*generator));

Overrides must not change the number of state variables.

See also:
    stochastic_systems)""";
        } SetRandomParameters;
        // Symbol: drake::systems::System::SetRandomState
        struct /* SetRandomState */ {
          // Source: drake/systems/framework/system.h:162
          const char* doc =
R"""(Assigns random values to all elements of the state. This default
implementation calls SetDefaultState; override this method to provide
random initial conditions using the stdc++ random library, e.g.:


::

    std::normal_distribution<T> gaussian();
    state->get_mutable_continuous_state()->get_mutable_vector()
    ->SetAtIndex(0, gaussian(*generator));

Overrides must not change the number of state variables.

See also:
    stochastic_systems)""";
        } SetRandomState;
        // Symbol: drake::systems::System::System<T>
        struct /* ctor */ {
          // Source: drake/systems/framework/system.h:1342
          const char* doc =
R"""(Constructs an empty System base class object and allocates base class
resources, possibly supporting scalar-type conversion support
(AutoDiff, etc.) using ``converter``.

See system_scalar_conversion for detailed background and examples
related to scalar-type conversion support.)""";
        } ctor;
        // Symbol: drake::systems::System::ToAutoDiffXd
        struct /* ToAutoDiffXd */ {
          // Source: drake/systems/framework/system.h:1085
          const char* doc_0args =
R"""(Creates a deep copy of this System, transmogrified to use the autodiff
scalar type, with a dynamic-sized vector of partial derivatives. The
result is never nullptr.

Raises:
    RuntimeError if this System does not support autodiff

See system_scalar_conversion for detailed background and examples
related to scalar-type conversion support.)""";
          // Source: drake/systems/framework/system.h:1103
          const char* doc_1args =
R"""(Creates a deep copy of ``from``, transmogrified to use the autodiff
scalar type, with a dynamic-sized vector of partial derivatives. The
result is never nullptr.

Raises:
    RuntimeError if ``from`` does not support autodiff

Usage:


::

    MySystem<double> plant;
    std::unique_ptr<MySystem<AutoDiffXd>> ad_plant =
    systems::System<double>::ToAutoDiffXd(plant);

Template parameter ``S``:
    The specific System type to accept and return.

See system_scalar_conversion for detailed background and examples
related to scalar-type conversion support.)""";
        } ToAutoDiffXd;
        // Symbol: drake::systems::System::ToAutoDiffXdMaybe
        struct /* ToAutoDiffXdMaybe */ {
          // Source: drake/systems/framework/system.h:1119
          const char* doc =
R"""(Creates a deep copy of this system exactly like ToAutoDiffXd(), but
returns nullptr if this System does not support autodiff, instead of
throwing an exception.)""";
        } ToAutoDiffXdMaybe;
        // Symbol: drake::systems::System::ToSymbolic
        struct /* ToSymbolic */ {
          // Source: drake/systems/framework/system.h:1137
          const char* doc_0args =
R"""(Creates a deep copy of this System, transmogrified to use the symbolic
scalar type. The result is never nullptr.

Raises:
    RuntimeError if this System does not support symbolic

See system_scalar_conversion for detailed background and examples
related to scalar-type conversion support.)""";
          // Source: drake/systems/framework/system.h:1154
          const char* doc_1args =
R"""(Creates a deep copy of ``from``, transmogrified to use the symbolic
scalar type. The result is never nullptr.

Raises:
    RuntimeError if this System does not support symbolic

Usage:


::

    MySystem<double> plant;
    std::unique_ptr<MySystem<symbolic::Expression>> sym_plant =
    systems::System<double>::ToSymbolic(plant);

Template parameter ``S``:
    The specific System pointer type to return.

See system_scalar_conversion for detailed background and examples
related to scalar-type conversion support.)""";
        } ToSymbolic;
        // Symbol: drake::systems::System::ToSymbolicMaybe
        struct /* ToSymbolicMaybe */ {
          // Source: drake/systems/framework/system.h:1170
          const char* doc =
R"""(Creates a deep copy of this system exactly like ToSymbolic(), but
returns nullptr if this System does not support symbolic, instead of
throwing an exception.)""";
        } ToSymbolicMaybe;
        // Symbol: drake::systems::System::ValidateChildOfContext
        struct /* ValidateChildOfContext */ {
          // Source: drake/systems/framework/system.h:1661
          const char* doc =
R"""(Checks whether the given object was created for this system.

Note:
    This method is sufficiently fast for performance sensitive code.)""";
        } ValidateChildOfContext;
        // Symbol: drake::systems::System::forced_discrete_update_events_exist
        struct /* forced_discrete_update_events_exist */ {
          // Source: drake/systems/framework/system.h:1600
          const char* doc = R"""()""";
        } forced_discrete_update_events_exist;
        // Symbol: drake::systems::System::forced_publish_events_exist
        struct /* forced_publish_events_exist */ {
          // Source: drake/systems/framework/system.h:1596
          const char* doc = R"""()""";
        } forced_publish_events_exist;
        // Symbol: drake::systems::System::forced_unrestricted_update_events_exist
        struct /* forced_unrestricted_update_events_exist */ {
          // Source: drake/systems/framework/system.h:1604
          const char* doc = R"""()""";
        } forced_unrestricted_update_events_exist;
        // Symbol: drake::systems::System::get_constraint
        struct /* get_constraint */ {
          // Source: drake/systems/framework/system.h:1005
          const char* doc =
R"""(Returns the constraint at index ``constraint_index``.

Raises:
    ValueError for an invalid constraint_index.)""";
        } get_constraint;
        // Symbol: drake::systems::System::get_forced_discrete_update_events
        struct /* get_forced_discrete_update_events */ {
          // Source: drake/systems/framework/system.h:1632
          const char* doc = R"""()""";
        } get_forced_discrete_update_events;
        // Symbol: drake::systems::System::get_forced_publish_events
        struct /* get_forced_publish_events */ {
          // Source: drake/systems/framework/system.h:1626
          const char* doc = R"""()""";
        } get_forced_publish_events;
        // Symbol: drake::systems::System::get_forced_unrestricted_update_events
        struct /* get_forced_unrestricted_update_events */ {
          // Source: drake/systems/framework/system.h:1638
          const char* doc = R"""()""";
        } get_forced_unrestricted_update_events;
        // Symbol: drake::systems::System::get_input_port
        struct /* get_input_port */ {
          // Source: drake/systems/framework/system.h:931
          const char* doc_1args =
R"""(Returns the typed input port at index ``port_index``.)""";
          // Source: drake/systems/framework/system.h:937
          const char* doc_0args =
R"""(Convenience method for the case of exactly one input port.)""";
        } get_input_port;
        // Symbol: drake::systems::System::get_input_port_selection
        struct /* get_input_port_selection */ {
          // Source: drake/systems/framework/system.h:951
          const char* doc =
R"""(Returns the typed input port specified by the InputPortSelection or by
the InputPortIndex. Returns nullptr if no port is selected. This is
provided as a convenience method since many algorithms provide the
same common default or optional port semantics.)""";
        } get_input_port_selection;
        // Symbol: drake::systems::System::get_mutable_forced_discrete_update_events
        struct /* get_mutable_forced_discrete_update_events */ {
          // Source: drake/systems/framework/system.h:1614
          const char* doc = R"""()""";
        } get_mutable_forced_discrete_update_events;
        // Symbol: drake::systems::System::get_mutable_forced_publish_events
        struct /* get_mutable_forced_publish_events */ {
          // Source: drake/systems/framework/system.h:1608
          const char* doc = R"""()""";
        } get_mutable_forced_publish_events;
        // Symbol: drake::systems::System::get_mutable_forced_unrestricted_update_events
        struct /* get_mutable_forced_unrestricted_update_events */ {
          // Source: drake/systems/framework/system.h:1620
          const char* doc = R"""()""";
        } get_mutable_forced_unrestricted_update_events;
        // Symbol: drake::systems::System::get_output_port
        struct /* get_output_port */ {
          // Source: drake/systems/framework/system.h:966
          const char* doc_1args =
R"""(Returns the typed output port at index ``port_index``.)""";
          // Source: drake/systems/framework/system.h:972
          const char* doc_0args =
R"""(Convenience method for the case of exactly one output port.)""";
        } get_output_port;
        // Symbol: drake::systems::System::get_output_port_selection
        struct /* get_output_port_selection */ {
          // Source: drake/systems/framework/system.h:986
          const char* doc =
R"""(Returns the typed output port specified by the OutputPortSelection or
by the OutputPortIndex. Returns nullptr if no port is selected. This
is provided as a convenience method since many algorithms provide the
same common default or optional port semantics.)""";
        } get_output_port_selection;
        // Symbol: drake::systems::System::get_system_scalar_converter
        struct /* get_system_scalar_converter */ {
          // Source: drake/systems/framework/system.h:1189
          const char* doc =
R"""((Advanced) Returns the SystemScalarConverter for this object. This is
an expert-level API intended for framework authors. Most users should
prefer the convenience helpers such as System::ToAutoDiffXd.)""";
        } get_system_scalar_converter;
        // Symbol: drake::systems::System::get_time_derivatives_cache_entry
        struct /* get_time_derivatives_cache_entry */ {
          // Source: drake/systems/framework/system.h:282
          const char* doc =
R"""((Advanced) Returns the CacheEntry used to cache time derivatives for
EvalTimeDerivatives().)""";
        } get_time_derivatives_cache_entry;
        // Symbol: drake::systems::System::num_constraints
        struct /* num_constraints */ {
          // Source: drake/systems/framework/system.h:1001
          const char* doc =
R"""(Returns the number of constraints specified for the system.)""";
        } num_constraints;
        // Symbol: drake::systems::System::set_forced_discrete_update_events
        struct /* set_forced_discrete_update_events */ {
          // Source: drake/systems/framework/system.h:1648
          const char* doc = R"""()""";
        } set_forced_discrete_update_events;
        // Symbol: drake::systems::System::set_forced_publish_events
        struct /* set_forced_publish_events */ {
          // Source: drake/systems/framework/system.h:1643
          const char* doc = R"""()""";
        } set_forced_publish_events;
        // Symbol: drake::systems::System::set_forced_unrestricted_update_events
        struct /* set_forced_unrestricted_update_events */ {
          // Source: drake/systems/framework/system.h:1653
          const char* doc = R"""()""";
        } set_forced_unrestricted_update_events;
      } System;
      // Symbol: drake::systems::SystemBase
      struct /* SystemBase */ {
        // Source: drake/systems/framework/system_base.h:33
        const char* doc =
R"""(Provides non-templatized functionality shared by the templatized
System classes.

Terminology: in general a Drake System is a tree structure composed of
"subsystems", which are themselves System objects. The corresponding
Context is a parallel tree structure composed of "subcontexts", which
are themselves Context objects. There is a one-to-one correspondence
between subsystems and subcontexts. Within a given System (Context),
its child subsystems (subcontexts) are indexed using a SubsystemIndex;
there is no separate SubcontextIndex since the numbering must be
identical.)""";
        // Symbol: drake::systems::SystemBase::AddAbstractParameter
        struct /* AddAbstractParameter */ {
          // Source: drake/systems/framework/system_base.h:943
          const char* doc =
R"""((Internal use only) Assigns a ticket to a new abstract parameter with
the given ``index``.

Precondition:
    The supplied index must be the next available one; that is,
    indexes must be assigned sequentially.)""";
        } AddAbstractParameter;
        // Symbol: drake::systems::SystemBase::AddAbstractState
        struct /* AddAbstractState */ {
          // Source: drake/systems/framework/system_base.h:917
          const char* doc =
R"""((Internal use only) Assigns a ticket to a new abstract state variable
with the given ``index``.

Precondition:
    The supplied index must be the next available one; that is,
    indexes must be assigned sequentially.)""";
        } AddAbstractState;
        // Symbol: drake::systems::SystemBase::AddDiscreteStateGroup
        struct /* AddDiscreteStateGroup */ {
          // Source: drake/systems/framework/system_base.h:904
          const char* doc =
R"""((Internal use only) Assigns a ticket to a new discrete variable group
with the given ``index``.

Precondition:
    The supplied index must be the next available one; that is,
    indexes must be assigned sequentially.)""";
        } AddDiscreteStateGroup;
        // Symbol: drake::systems::SystemBase::AddInputPort
        struct /* AddInputPort */ {
          // Source: drake/systems/framework/system_base.h:829
          const char* doc =
R"""((Internal use only) Adds an already-constructed input port to this
System. Insists that the port already contains a reference to this
System, and that the port's index is already set to the next available
input port index for this System, that the port name is unique (just
within this System), and that the port name is non-empty.)""";
        } AddInputPort;
        // Symbol: drake::systems::SystemBase::AddNumericParameter
        struct /* AddNumericParameter */ {
          // Source: drake/systems/framework/system_base.h:930
          const char* doc =
R"""((Internal use only) Assigns a ticket to a new numeric parameter with
the given ``index``.

Precondition:
    The supplied index must be the next available one; that is,
    indexes must be assigned sequentially.)""";
        } AddNumericParameter;
        // Symbol: drake::systems::SystemBase::AddOutputPort
        struct /* AddOutputPort */ {
          // Source: drake/systems/framework/system_base.h:854
          const char* doc =
R"""((Internal use only) Adds an already-constructed output port to this
System. Insists that the port already contains a reference to this
System, and that the port's index is already set to the next available
output port index for this System, and that the name of the port is
unique.

Raises:
    RuntimeError if the name of the output port is not unique.)""";
        } AddOutputPort;
        // Symbol: drake::systems::SystemBase::AllocateContext
        struct /* AllocateContext */ {
          // Source: drake/systems/framework/system_base.h:80
          const char* doc =
R"""(Returns a Context suitable for use with this System. Context resources
are allocated based on resource requests that were made during System
construction.)""";
        } AllocateContext;
        // Symbol: drake::systems::SystemBase::ContextSizes
        struct /* ContextSizes */ {
          // Source: drake/systems/framework/system_base.h:1097
          const char* doc =
R"""(Return type for get_context_sizes(). Initialized to zero and equipped
with a += operator for Diagram use in aggregation.)""";
          // Symbol: drake::systems::SystemBase::ContextSizes::num_abstract_parameters
          struct /* num_abstract_parameters */ {
            // Source: drake/systems/framework/system_base.h:1104
            const char* doc = R"""()""";
          } num_abstract_parameters;
          // Symbol: drake::systems::SystemBase::ContextSizes::num_abstract_states
          struct /* num_abstract_states */ {
            // Source: drake/systems/framework/system_base.h:1102
            const char* doc = R"""()""";
          } num_abstract_states;
          // Symbol: drake::systems::SystemBase::ContextSizes::num_discrete_state_groups
          struct /* num_discrete_state_groups */ {
            // Source: drake/systems/framework/system_base.h:1101
            const char* doc = R"""()""";
          } num_discrete_state_groups;
          // Symbol: drake::systems::SystemBase::ContextSizes::num_generalized_positions
          struct /* num_generalized_positions */ {
            // Source: drake/systems/framework/system_base.h:1098
            const char* doc = R"""()""";
          } num_generalized_positions;
          // Symbol: drake::systems::SystemBase::ContextSizes::num_generalized_velocities
          struct /* num_generalized_velocities */ {
            // Source: drake/systems/framework/system_base.h:1099
            const char* doc = R"""()""";
          } num_generalized_velocities;
          // Symbol: drake::systems::SystemBase::ContextSizes::num_misc_continuous_states
          struct /* num_misc_continuous_states */ {
            // Source: drake/systems/framework/system_base.h:1100
            const char* doc = R"""()""";
          } num_misc_continuous_states;
          // Symbol: drake::systems::SystemBase::ContextSizes::num_numeric_parameter_groups
          struct /* num_numeric_parameter_groups */ {
            // Source: drake/systems/framework/system_base.h:1103
            const char* doc = R"""()""";
          } num_numeric_parameter_groups;
          // Symbol: drake::systems::SystemBase::ContextSizes::operator+=
          struct /* operator_iadd */ {
            // Source: drake/systems/framework/system_base.h:1106
            const char* doc = R"""()""";
          } operator_iadd;
        } ContextSizes;
        // Symbol: drake::systems::SystemBase::DeclareCacheEntry
        struct /* DeclareCacheEntry */ {
          // Source: drake/systems/framework/system_base.h:362
          const char* doc_4args_description_alloc_function_calc_function_prerequisites_of_calc =
R"""(Declares a new CacheEntry in this System using the least-restrictive
definitions for the associated functions. Prefer one of the
more-convenient signatures below if you can. The new cache entry is
assigned a unique CacheIndex and DependencyTicket, which can be
obtained from the returned CacheEntry. The function signatures here
are:


::

    std::unique_ptr<AbstractValue> Alloc();
    void Calc(const ContextBase&, AbstractValue*);

where the AbstractValue objects must resolve to the same concrete
type.

Parameter ``description``:
    A human-readable description of this cache entry, most useful for
    debugging and documentation. Not interpreted in any way by Drake;
    it is retained by the cache entry and used to generate the
    description for the corresponding CacheEntryValue in the Context.

Parameter ``alloc_function``:
    Given a Context, returns a heap-allocated AbstractValue object
    suitable for holding a value for this cache entry.

Parameter ``calc_function``:
    Provides the computation that maps from a given Context to the
    current value that this cache entry should have, and writes that
    value to a given object of the type returned by
    ``alloc_function``.

Parameter ``prerequisites_of_calc``:
    Provides the DependencyTicket list containing a ticket for *every*
    Context value on which ``calc_function`` may depend when it
    computes its result. Defaults to ``{all_sources_ticket()}`` if
    unspecified. If the cache value is truly independent of the
    Context (rare!) say so explicitly by providing the list
    ``{nothing_ticket()}``; an explicitly empty list ``{}`` is
    forbidden.

Returns:
    a reference to the newly-created CacheEntry.

Raises:
    RuntimeError if given an explicitly empty prerequisite list.)""";
          // Source: drake/systems/framework/system_base.h:381
          const char* doc_4args_stdstring_ValueTypeMySystemconst_voidMySystemconstMyContextValueTypeconst_stdset =
R"""(Declares a cache entry by specifying member functions to use both for
the allocator and calculator. The signatures are:


::

    ValueType MySystem::MakeValueType() const;
    void MySystem::CalcCacheValue(const MyContext&, ValueType*) const;

where ``MySystem`` is a class derived from ``SystemBase``, `MyContext`
is a class derived from ``ContextBase``, and ``ValueType`` is any
concrete type such that ``Value<ValueType>`` is permitted. (The method
names are arbitrary.) Template arguments will be deduced and do not
need to be specified. See the DeclareCacheEntry_primary "primary
DeclareCacheEntry() signature" for more information about the
parameters and behavior.

See also:
    drake::Value)""";
          // Source: drake/systems/framework/system_base.h:402
          const char* doc_4args_stdstring_constValueType_voidMySystemconstMyContextValueTypeconst_stdset =
R"""(Declares a cache entry by specifying a model value of concrete type
``ValueType`` and a calculator function that is a class member
function (method) with signature:


::

    void MySystem::CalcCacheValue(const MyContext&, ValueType*) const;

where ``MySystem`` is a class derived from ``SystemBase``, `MyContext`
is a class derived from ``ContextBase``, and ``ValueType`` is any
concrete type such that ``Value<ValueType>`` is permitted. (The method
names are arbitrary.) Template arguments will be deduced and do not
need to be specified. See the DeclareCacheEntry_primary "primary
DeclareCacheEntry() signature" above for more information about the
parameters and behavior.

See also:
    drake::Value)""";
          // Source: drake/systems/framework/system_base.h:417
          const char* doc_4args_stdstring_constValueType_ValueTypeMySystemconstMyContextconst_stdset =
R"""(Declares a cache entry by specifying a model value of concrete type
``ValueType`` and a calculator function that is a class member
function (method) with signature:


::

    ValueType MySystem::CalcCacheValue(const MyContext&) const;

Other than the calculator signature, this is identical to the other
DeclareCacheEntry_model_and_calc "model and calculator signature",
please look there for more information.)""";
          // Source: drake/systems/framework/system_base.h:446
          const char* doc_3args_stdstring_voidMySystemconstMyContextValueTypeconst_stdset =
R"""(Declares a cache entry by specifying only a calculator function that
is a class member function (method) with signature:


::

    void MySystem::CalcCacheValue(const MyContext&, ValueType*) const;

where ``MySystem`` is a class derived from ``SystemBase`` and
``MyContext`` is a class derived from ``ContextBase``. `ValueType` is
a concrete type such that (a) ``Value<ValueType>`` is permitted, and
(b) ``ValueType`` is default constructible. That allows us to create a
model value using ``Value<ValueType>{}`` (value initialized so
numerical types will be zeroed in the model). (The method name is
arbitrary.) Template arguments will be deduced and do not need to be
specified. See the first DeclareCacheEntry() signature above for more
information about the parameters and behavior.

Note:
    The default constructor will be called once immediately to create
    a model value, and subsequent allocations will just copy the model
    value without invoking the constructor again. If you want the
    constructor invoked again at each allocation (not common), use one
    of the other signatures to explicitly provide a method for the
    allocator to call; that method can then invoke the ``ValueType``
    default constructor each time it is called.

See also:
    drake::Value)""";
          // Source: drake/systems/framework/system_base.h:461
          const char* doc_3args_stdstring_ValueTypeMySystemconstMyContextconst_stdset =
R"""(Declares a cache entry by specifying only a calculator function that
is a class member function (method) with signature:


::

    ValueType MySystem::CalcCacheValue(const MyContext&) const;

Other than the calculator method's signature, this is identical to the
other DeclareCacheEntry_calc_only "calculator-only signature"; please
look there for more information.)""";
        } DeclareCacheEntry;
        // Symbol: drake::systems::SystemBase::DeclareCacheEntryWithKnownTicket
        struct /* DeclareCacheEntryWithKnownTicket */ {
          // Source: drake/systems/framework/system_base.h:956
          const char* doc =
R"""((Internal use only) This is for cache entries associated with
pre-defined tickets, for example the cache entry for time derivatives.
See the public API for the most-general DeclareCacheEntry() signature
for the meanings of the other parameters here.)""";
        } DeclareCacheEntryWithKnownTicket;
        // Symbol: drake::systems::SystemBase::DoAllocateContext
        struct /* DoAllocateContext */ {
          // Source: drake/systems/framework/system_base.h:1093
          const char* doc =
R"""(Derived class implementations should allocate a suitable concrete
Context type, then invoke the above InitializeContextBase() method. A
Diagram must then invoke AllocateContext() to obtain each of the
subcontexts for its DiagramContext, and must set up inter-subcontext
dependencies among its children and between itself and its children.
Then context resources such as parameters and state should be
allocated.)""";
        } DoAllocateContext;
        // Symbol: drake::systems::SystemBase::EvalAbstractInput
        struct /* EvalAbstractInput */ {
          // Source: drake/systems/framework/system_base.h:124
          const char* doc =
R"""(Returns the value of the input port with the given ``port_index`` as
an AbstractValue, which is permitted for ports of any type. Causes the
value to become up to date first if necessary, delegating to our
parent Diagram. Returns a pointer to the port's value, or nullptr if
the port is not connected. If you know the actual type, use one of the
more-specific signatures.

Precondition:
    ``port_index`` selects an existing input port of this System.

See also:
    EvalInputValue(), System::EvalVectorInput(),
    System::EvalEigenVectorInput())""";
        } EvalAbstractInput;
        // Symbol: drake::systems::SystemBase::EvalAbstractInputImpl
        struct /* EvalAbstractInputImpl */ {
          // Source: drake/systems/framework/system_base.h:1001
          const char* doc =
R"""((Internal use only) Shared code for updating an input port and
returning a pointer to its abstract value, or nullptr if the port is
not connected. ``func`` should be the user-visible API function name
obtained with **func**.)""";
        } EvalAbstractInputImpl;
        // Symbol: drake::systems::SystemBase::EvalInputValue
        struct /* EvalInputValue */ {
          // Source: drake/systems/framework/system_base.h:148
          const char* doc =
R"""(Returns the value of an abstract-valued input port with the given
``port_index`` as a value of known type ``V``. Causes the value to
become up to date first if necessary. See EvalAbstractInput() for more
information.

The result is returned as a pointer to the input port's value of type
``V``, or nullptr if the port is not connected.

Precondition:
    ``port_index`` selects an existing input port of this System.

Precondition:
    the port's value must be retrievable from the stored abstract
    value using ``AbstractValue::get_value<V>``.

Template parameter ``V``:
    The type of data expected.)""";
        } EvalInputValue;
        // Symbol: drake::systems::SystemBase::GetDirectFeedthroughs
        struct /* GetDirectFeedthroughs */ {
          // Source: drake/systems/framework/system_base.h:221
          const char* doc =
R"""(Reports all direct feedthroughs from input ports to output ports. For
a system with m input ports: ``I = i₀, i₁, ..., iₘ₋₁``, and n output
ports, ``O = o₀, o₁, ..., oₙ₋₁``, the return map will contain pairs
(u, v) such that

- 0 ≤ u < m,
- 0 ≤ v < n,
- and there *might* be a direct feedthrough from input iᵤ to each output oᵥ.

See DeclareLeafOutputPort_feedthrough "DeclareLeafOutputPort"
documentation for how leaf systems can report their feedthrough.)""";
        } GetDirectFeedthroughs;
        // Symbol: drake::systems::SystemBase::GetInputPortBaseOrThrow
        struct /* GetInputPortBaseOrThrow */ {
          // Source: drake/systems/framework/system_base.h:1054
          const char* doc =
R"""((Internal use only) Returns the InputPortBase at index ``port_index``,
throwing ValueError we don't like the port index. The name of the
public API method that received the bad index is provided in ``func``
and is included in the error message.)""";
        } GetInputPortBaseOrThrow;
        // Symbol: drake::systems::SystemBase::GetOutputPortBaseOrThrow
        struct /* GetOutputPortBaseOrThrow */ {
          // Source: drake/systems/framework/system_base.h:1068
          const char* doc =
R"""((Internal use only) Returns the OutputPortBase at index
``port_index``, throwing ValueError if we don't like the port index.
The name of the public API method that received the bad index is
provided in ``func`` and is included in the error message.)""";
        } GetOutputPortBaseOrThrow;
        // Symbol: drake::systems::SystemBase::GetSystemName
        struct /* GetSystemName */ {
          // Source: drake/systems/framework/system_base.h:60
          const char* doc =
R"""(Returns a human-readable name for this system, for use in messages and
logging. This will be the same as returned by get_name(), unless that
would be an empty string. In that case we return a non-unique
placeholder name, currently just "_" (a lone underscore).)""";
        } GetSystemName;
        // Symbol: drake::systems::SystemBase::GetSystemPathname
        struct /* GetSystemPathname */ {
          // Source: drake/systems/framework/system_base.h:68
          const char* doc =
R"""(Generates and returns a human-readable full path name of this
subsystem, for use in messages and logging. The name starts from the
root System, with "::" delimiters between parent and child subsystems,
with the individual subsystems represented by their names as returned
by GetSystemName().)""";
        } GetSystemPathname;
        // Symbol: drake::systems::SystemBase::GetSystemType
        struct /* GetSystemType */ {
          // Source: drake/systems/framework/system_base.h:75
          const char* doc =
R"""(Returns the most-derived type of this concrete System object as a
human-readable string suitable for use in error messages. The format
is as generated by NiceTypeName and will include namespace
qualification if present.

See also:
    NiceTypeName for more specifics.)""";
        } GetSystemType;
        // Symbol: drake::systems::SystemBase::InitializeContextBase
        struct /* InitializeContextBase */ {
          // Source: drake/systems/framework/system_base.h:1085
          const char* doc =
R"""(This method must be invoked from within derived class
DoAllocateContext() implementations right after the concrete Context
object has been allocated. It allocates cache entries, sets up all
intra-Context dependencies, and marks the ContextBase as initialized
so that we can verify proper derived-class behavior.

Precondition:
    The supplied context must not be null and must not already have
    been initialized.)""";
        } InitializeContextBase;
        // Symbol: drake::systems::SystemBase::MakeFixInputPortTypeChecker
        struct /* MakeFixInputPortTypeChecker */ {
          // Source: drake/systems/framework/system_base.h:995
          const char* doc =
R"""((Internal use only) Given a ``port_index``, returns a function to be
called when validating Context::FixInputPort requests. The function
should attempt to throw an exception if the input AbstractValue is
invalid, so that errors can be reported at Fix-time instead of
EvalInput-time.)""";
        } MakeFixInputPortTypeChecker;
        // Symbol: drake::systems::SystemBase::NextInputPortName
        struct /* NextInputPortName */ {
          // Source: drake/systems/framework/system_base.h:876
          const char* doc =
R"""((Internal use only) Returns a name for the next input port, using the
given name if it isn't kUseDefaultName, otherwise making up a name
like "u3" from the next available input port index.

Precondition:
    ``given_name`` must not be empty.)""";
        } NextInputPortName;
        // Symbol: drake::systems::SystemBase::NextOutputPortName
        struct /* NextOutputPortName */ {
          // Source: drake/systems/framework/system_base.h:890
          const char* doc =
R"""((Internal use only) Returns a name for the next output port, using the
given name if it isn't kUseDefaultName, otherwise making up a name
like "y3" from the next available output port index.

Precondition:
    ``given_name`` must not be empty.)""";
        } NextOutputPortName;
        // Symbol: drake::systems::SystemBase::SystemBase
        struct /* ctor */ {
          // Source: drake/systems/framework/system_base.h:820
          const char* doc = R"""((Internal use only).)""";
        } ctor;
        // Symbol: drake::systems::SystemBase::ThrowCantEvaluateInputPort
        struct /* ThrowCantEvaluateInputPort */ {
          // Source: drake/systems/framework/system_base.h:1047
          const char* doc =
R"""(Throws RuntimeError because someone called API method ``func``, that
requires this input port to be evaluatable, but the port was neither
fixed nor connected.)""";
        } ThrowCantEvaluateInputPort;
        // Symbol: drake::systems::SystemBase::ThrowInputPortHasWrongType
        struct /* ThrowInputPortHasWrongType */ {
          // Source: drake/systems/framework/system_base.h:1031
          const char* doc =
R"""(Throws RuntimeError because someone called API method ``func``
claiming the input port had some value type that was wrong.)""";
        } ThrowInputPortHasWrongType;
        // Symbol: drake::systems::SystemBase::ThrowInputPortIndexOutOfRange
        struct /* ThrowInputPortIndexOutOfRange */ {
          // Source: drake/systems/framework/system_base.h:1015
          const char* doc =
R"""(Throws ValueError to report bad input ``port_index`` that was passed
to API method ``func``.)""";
        } ThrowInputPortIndexOutOfRange;
        // Symbol: drake::systems::SystemBase::ThrowNegativePortIndex
        struct /* ThrowNegativePortIndex */ {
          // Source: drake/systems/framework/system_base.h:1010
          const char* doc = R"""()""";
        } ThrowNegativePortIndex;
        // Symbol: drake::systems::SystemBase::ThrowNotAVectorInputPort
        struct /* ThrowNotAVectorInputPort */ {
          // Source: drake/systems/framework/system_base.h:1026
          const char* doc =
R"""(Throws RuntimeError because someone misused API method ``func``, that
is only allowed for declared-vector input ports, on an abstract port
whose index is given here.)""";
        } ThrowNotAVectorInputPort;
        // Symbol: drake::systems::SystemBase::ThrowOutputPortIndexOutOfRange
        struct /* ThrowOutputPortIndexOutOfRange */ {
          // Source: drake/systems/framework/system_base.h:1020
          const char* doc =
R"""(Throws ValueError to report bad output ``port_index`` that was passed
to API method ``func``.)""";
        } ThrowOutputPortIndexOutOfRange;
        // Symbol: drake::systems::SystemBase::ValidateContext
        struct /* ValidateContext */ {
          // Source: drake/systems/framework/system_base.h:801
          const char* doc =
R"""(Checks whether the given context was created for this system.

Note:
    This method is sufficiently fast for performance sensitive code.)""";
        } ValidateContext;
        // Symbol: drake::systems::SystemBase::abstract_parameter_ticket
        struct /* abstract_parameter_ticket */ {
          // Source: drake/systems/framework/system_base.h:605
          const char* doc =
R"""(Returns a ticket indicating dependence on a particular abstract
parameter paᵢ.

See also:
    pa_ticket() to obtain a ticket for *all* abstract parameters.)""";
        } abstract_parameter_ticket;
        // Symbol: drake::systems::SystemBase::abstract_state_ticket
        struct /* abstract_state_ticket */ {
          // Source: drake/systems/framework/system_base.h:565
          const char* doc =
R"""(Returns a ticket indicating dependence on a particular abstract state
variable xaᵢ.

See also:
    xa_ticket() to obtain a ticket for *all* abstract variables.)""";
        } abstract_state_ticket;
        // Symbol: drake::systems::SystemBase::accuracy_ticket
        struct /* accuracy_ticket */ {
          // Source: drake/systems/framework/system_base.h:514
          const char* doc =
R"""(Returns a ticket indicating dependence on the accuracy setting in the
Context. This is the same ticket for all systems and refers to the
same accuracy value.)""";
        } accuracy_ticket;
        // Symbol: drake::systems::SystemBase::all_input_ports_ticket
        struct /* all_input_ports_ticket */ {
          // Source: drake/systems/framework/system_base.h:635
          const char* doc =
R"""(Returns a ticket indicating dependence on *all* input ports u of this
system.

See also:
    input_port_ticket() to obtain a ticket for just one input port.)""";
        } all_input_ports_ticket;
        // Symbol: drake::systems::SystemBase::all_parameters_ticket
        struct /* all_parameters_ticket */ {
          // Source: drake/systems/framework/system_base.h:620
          const char* doc =
R"""(Returns a ticket indicating dependence on *all* parameters p in this
system, including numeric parameters pn, and abstract parameters pa.)""";
        } all_parameters_ticket;
        // Symbol: drake::systems::SystemBase::all_sources_except_input_ports_ticket
        struct /* all_sources_except_input_ports_ticket */ {
          // Source: drake/systems/framework/system_base.h:656
          const char* doc =
R"""(Returns a ticket indicating dependence on every possible independent
source value *except* input ports. This can be helpful in avoiding the
incorrect appearance of algebraic loops in a Diagram (those always
involve apparent input port dependencies). For an output port, use
this ticket plus tickets for just the input ports on which the output
computation *actually* depends. The sources included in this ticket
are: time, accuracy, state, and parameters. Note that dependencies on
cache entries are *not* included here. Usually that won't matter since
cache entries typically depend on at least one of time, accuracy,
state, or parameters so will be invalidated for the same reason the
current computation is. However, for a computation that depends on a
cache entry that depends only on input ports, be sure that you have
included those input ports in the dependency list, or include a direct
dependency on the cache entry.

See also:
    input_port_ticket() to obtain a ticket for an input port.

See also:
    cache_entry_ticket() to obtain a ticket for a cache entry.

See also:
    all_sources_ticket() to also include all input ports as
    dependencies.)""";
        } all_sources_except_input_ports_ticket;
        // Symbol: drake::systems::SystemBase::all_sources_ticket
        struct /* all_sources_ticket */ {
          // Source: drake/systems/framework/system_base.h:666
          const char* doc =
R"""(Returns a ticket indicating dependence on every possible independent
source value, including time, accuracy, state, input ports, and
parameters (but not cache entries). This is the default dependency for
computations that have not specified anything more refined. It is
equivalent to the set ``{all_sources_except_input_ports_ticket(),
all_input_ports_ticket()}``.

See also:
    cache_entry_ticket() to obtain a ticket for a cache entry.)""";
        } all_sources_ticket;
        // Symbol: drake::systems::SystemBase::all_state_ticket
        struct /* all_state_ticket */ {
          // Source: drake/systems/framework/system_base.h:583
          const char* doc =
R"""(Returns a ticket indicating dependence on *all* state variables x in
this system, including continuous variables xc, discrete (numeric)
variables xd, and abstract state variables xa. This does not imply
dependence on time, accuracy, parameters, or inputs; those must be
specified separately. If you mean to express dependence on all
possible value sources, use all_sources_ticket() instead.)""";
        } all_state_ticket;
        // Symbol: drake::systems::SystemBase::assign_next_dependency_ticket
        struct /* assign_next_dependency_ticket */ {
          // Source: drake/systems/framework/system_base.h:972
          const char* doc =
R"""((Internal use only) Assigns the next unused dependency ticket number,
unique only within a particular system. Each call to this method
increments the ticket number.)""";
        } assign_next_dependency_ticket;
        // Symbol: drake::systems::SystemBase::cache_entry_ticket
        struct /* cache_entry_ticket */ {
          // Source: drake/systems/framework/system_base.h:674
          const char* doc =
R"""(Returns a ticket indicating dependence on the cache entry indicated by
``index``. Note that cache entries are *not* included in the
``all_sources`` ticket so must be listed separately.

Precondition:
    ``index`` selects an existing cache entry in this System.)""";
        } cache_entry_ticket;
        // Symbol: drake::systems::SystemBase::configuration_ticket
        struct /* configuration_ticket */ {
          // Source: drake/systems/framework/system_base.h:697
          const char* doc = R"""()""";
        } configuration_ticket;
        // Symbol: drake::systems::SystemBase::discrete_state_ticket
        struct /* discrete_state_ticket */ {
          // Source: drake/systems/framework/system_base.h:550
          const char* doc =
R"""(Returns a ticket indicating dependence on a particular discrete state
variable xdᵢ (may be a vector). (We sometimes refer to this as a
"discrete variable group".)

See also:
    xd_ticket() to obtain a ticket for *all* discrete variables.)""";
        } discrete_state_ticket;
        // Symbol: drake::systems::SystemBase::get_cache_entry
        struct /* get_cache_entry */ {
          // Source: drake/systems/framework/system_base.h:230
          const char* doc =
R"""(Returns a reference to a CacheEntry given its ``index``.)""";
        } get_cache_entry;
        // Symbol: drake::systems::SystemBase::get_context_sizes
        struct /* get_context_sizes */ {
          // Source: drake/systems/framework/system_base.h:1120
          const char* doc_0args =
R"""(Obtains access to the declared Context partition sizes as accumulated
during LeafSystem or Diagram construction .)""";
          // Source: drake/systems/framework/system_base.h:1128
          const char* doc_1args =
R"""(Allows Diagram to access protected get_context_sizes() recursively on
its subsystems.)""";
        } get_context_sizes;
        // Symbol: drake::systems::SystemBase::get_input_port_base
        struct /* get_input_port_base */ {
          // Source: drake/systems/framework/system_base.h:184
          const char* doc =
R"""(Returns a reference to an InputPort given its ``port_index``.

Precondition:
    ``port_index`` selects an existing input port of this System.)""";
        } get_input_port_base;
        // Symbol: drake::systems::SystemBase::get_mutable_cache_entry
        struct /* get_mutable_cache_entry */ {
          // Source: drake/systems/framework/system_base.h:238
          const char* doc =
R"""((Advanced) Returns a mutable reference to a CacheEntry given its
``index``. Note that you do not need mutable access to a CacheEntry to
modify its value in a Context, so most users should not use this
method.)""";
        } get_mutable_cache_entry;
        // Symbol: drake::systems::SystemBase::get_mutable_context_sizes
        struct /* get_mutable_context_sizes */ {
          // Source: drake/systems/framework/system_base.h:1124
          const char* doc =
R"""(Obtains mutable access to the Context sizes struct. Should be used
only during LeafSystem or Diagram construction.)""";
        } get_mutable_context_sizes;
        // Symbol: drake::systems::SystemBase::get_name
        struct /* get_name */ {
          // Source: drake/systems/framework/system_base.h:54
          const char* doc =
R"""(Returns the name last supplied to set_name(), if any. Diagrams built
with DiagramBuilder will always have a default name for every
contained subsystem for which no user-provided name is available.
Systems created by copying with a scalar type change have the same
name as the source system. An empty string is returned if no name has
been set.)""";
        } get_name;
        // Symbol: drake::systems::SystemBase::get_output_port_base
        struct /* get_output_port_base */ {
          // Source: drake/systems/framework/system_base.h:190
          const char* doc =
R"""(Returns a reference to an OutputPort given its ``port_index``.

Precondition:
    ``port_index`` selects an existing output port of this System.)""";
        } get_output_port_base;
        // Symbol: drake::systems::SystemBase::get_parent_service
        struct /* get_parent_service */ {
          // Source: drake/systems/framework/system_base.h:965
          const char* doc =
R"""(Returns a pointer to the service interface of the immediately
enclosing Diagram if one has been set, otherwise nullptr.)""";
        } get_parent_service;
        // Symbol: drake::systems::SystemBase::get_system_id
        struct /* get_system_id */ {
          // Source: drake/systems/framework/system_base.h:1151
          const char* doc =
R"""((Internal) Gets the id used to tag context data as being created by
this system.)""";
        } get_system_id;
        // Symbol: drake::systems::SystemBase::implicit_time_derivatives_residual_size
        struct /* implicit_time_derivatives_residual_size */ {
          // Source: drake/systems/framework/system_base.h:793
          const char* doc =
R"""(Returns the size of the implicit time derivatives residual vector. By
default this is the same as num_continuous_states() but a LeafSystem
can change it during construction via
LeafSystem::DeclareImplicitTimeDerivativesResidualSize().)""";
        } implicit_time_derivatives_residual_size;
        // Symbol: drake::systems::SystemBase::input_port_ticket
        struct /* input_port_ticket */ {
          // Source: drake/systems/framework/system_base.h:627
          const char* doc =
R"""(Returns a ticket indicating dependence on input port uᵢ indicated by
``index``.

Precondition:
    ``index`` selects an existing input port of this System.)""";
        } input_port_ticket;
        // Symbol: drake::systems::SystemBase::ke_ticket
        struct /* ke_ticket */ {
          // Source: drake/systems/framework/system_base.h:732
          const char* doc =
R"""(Returns a ticket for the cache entry that holds the kinetic energy
calculation.

See also:
    System::EvalKineticEnergy())""";
        } ke_ticket;
        // Symbol: drake::systems::SystemBase::kinematics_ticket
        struct /* kinematics_ticket */ {
          // Source: drake/systems/framework/system_base.h:711
          const char* doc = R"""()""";
        } kinematics_ticket;
        // Symbol: drake::systems::SystemBase::nothing_ticket
        struct /* nothing_ticket */ {
          // Source: drake/systems/framework/system_base.h:501
          const char* doc =
R"""(Returns a ticket indicating that a computation does not depend on
*any* source value; that is, it is a constant. If this appears in a
prerequisite list, it must be the only entry.)""";
        } nothing_ticket;
        // Symbol: drake::systems::SystemBase::num_abstract_parameters
        struct /* num_abstract_parameters */ {
          // Source: drake/systems/framework/system_base.h:785
          const char* doc =
R"""(Returns the number of declared abstract parameters.)""";
        } num_abstract_parameters;
        // Symbol: drake::systems::SystemBase::num_abstract_states
        struct /* num_abstract_states */ {
          // Source: drake/systems/framework/system_base.h:774
          const char* doc =
R"""(Returns the number of declared abstract state variables.)""";
        } num_abstract_states;
        // Symbol: drake::systems::SystemBase::num_cache_entries
        struct /* num_cache_entries */ {
          // Source: drake/systems/framework/system_base.h:225
          const char* doc =
R"""(Returns the number nc of cache entries currently allocated in this
System. These are indexed from 0 to nc-1.)""";
        } num_cache_entries;
        // Symbol: drake::systems::SystemBase::num_continuous_states
        struct /* num_continuous_states */ {
          // Source: drake/systems/framework/system_base.h:761
          const char* doc =
R"""(Returns the number of declared continuous state variables.)""";
        } num_continuous_states;
        // Symbol: drake::systems::SystemBase::num_discrete_state_groups
        struct /* num_discrete_state_groups */ {
          // Source: drake/systems/framework/system_base.h:769
          const char* doc =
R"""(Returns the number of declared discrete state groups (each group is a
vector-valued discrete state variable).)""";
        } num_discrete_state_groups;
        // Symbol: drake::systems::SystemBase::num_input_ports
        struct /* num_input_ports */ {
          // Source: drake/systems/framework/system_base.h:172
          const char* doc =
R"""(Returns the number of input ports currently allocated in this System.
These are indexed from 0 to num_input_ports()-1.)""";
        } num_input_ports;
        // Symbol: drake::systems::SystemBase::num_numeric_parameter_groups
        struct /* num_numeric_parameter_groups */ {
          // Source: drake/systems/framework/system_base.h:780
          const char* doc =
R"""(Returns the number of declared numeric parameters (each of these is a
vector-valued parameter).)""";
        } num_numeric_parameter_groups;
        // Symbol: drake::systems::SystemBase::num_output_ports
        struct /* num_output_ports */ {
          // Source: drake/systems/framework/system_base.h:178
          const char* doc =
R"""(Returns the number of output ports currently allocated in this System.
These are indexed from 0 to num_output_ports()-1.)""";
        } num_output_ports;
        // Symbol: drake::systems::SystemBase::num_total_inputs
        struct /* num_total_inputs */ {
          // Source: drake/systems/framework/system_base.h:196
          const char* doc =
R"""(Returns the total dimension of all of the vector-valued input ports
(as if they were muxed).)""";
        } num_total_inputs;
        // Symbol: drake::systems::SystemBase::num_total_outputs
        struct /* num_total_outputs */ {
          // Source: drake/systems/framework/system_base.h:204
          const char* doc =
R"""(Returns the total dimension of all of the vector-valued output ports
(as if they were muxed).)""";
        } num_total_outputs;
        // Symbol: drake::systems::SystemBase::numeric_parameter_ticket
        struct /* numeric_parameter_ticket */ {
          // Source: drake/systems/framework/system_base.h:590
          const char* doc =
R"""(Returns a ticket indicating dependence on a particular numeric
parameter pnᵢ (may be a vector).

See also:
    pn_ticket() to obtain a ticket for *all* numeric parameters.)""";
        } numeric_parameter_ticket;
        // Symbol: drake::systems::SystemBase::output_port_ticket
        struct /* output_port_ticket */ {
          // Source: drake/systems/framework/system_base.h:754
          const char* doc =
R"""((Internal use only) Returns a ticket indicating dependence on the
output port indicated by ``index``. No user-definable quantities in a
system can meaningfully depend on that system's own output ports.

Precondition:
    ``index`` selects an existing output port of this System.)""";
        } output_port_ticket;
        // Symbol: drake::systems::SystemBase::pa_ticket
        struct /* pa_ticket */ {
          // Source: drake/systems/framework/system_base.h:614
          const char* doc =
R"""(Returns a ticket indicating dependence on all of the abstract
parameters pa in the current Context.

See also:
    abstract_parameter_ticket() to obtain a ticket for just one
    abstract parameter.)""";
        } pa_ticket;
        // Symbol: drake::systems::SystemBase::pc_ticket
        struct /* pc_ticket */ {
          // Source: drake/systems/framework/system_base.h:739
          const char* doc =
R"""(Returns a ticket for the cache entry that holds the conservative power
calculation.

See also:
    System::EvalConservativePower())""";
        } pc_ticket;
        // Symbol: drake::systems::SystemBase::pe_ticket
        struct /* pe_ticket */ {
          // Source: drake/systems/framework/system_base.h:725
          const char* doc =
R"""(Returns a ticket for the cache entry that holds the potential energy
calculation.

See also:
    System::EvalPotentialEnergy())""";
        } pe_ticket;
        // Symbol: drake::systems::SystemBase::pn_ticket
        struct /* pn_ticket */ {
          // Source: drake/systems/framework/system_base.h:598
          const char* doc =
R"""(Returns a ticket indicating dependence on all of the numerical
parameters in the current Context.

See also:
    numeric_parameter_ticket() to obtain a ticket for just one numeric
    parameter.)""";
        } pn_ticket;
        // Symbol: drake::systems::SystemBase::pnc_ticket
        struct /* pnc_ticket */ {
          // Source: drake/systems/framework/system_base.h:746
          const char* doc =
R"""(Returns a ticket for the cache entry that holds the non-conservative
power calculation.

See also:
    System::EvalNonConservativePower())""";
        } pnc_ticket;
        // Symbol: drake::systems::SystemBase::q_ticket
        struct /* q_ticket */ {
          // Source: drake/systems/framework/system_base.h:521
          const char* doc =
R"""(Returns a ticket indicating that a computation depends on
configuration state variables q. There is no ticket representing just
one of the state variables qᵢ.)""";
        } q_ticket;
        // Symbol: drake::systems::SystemBase::set_implicit_time_derivatives_residual_size
        struct /* set_implicit_time_derivatives_residual_size */ {
          // Source: drake/systems/framework/system_base.h:1143
          const char* doc =
R"""(Allows a LeafSystem to override the default size for the implicit time
derivatives residual and a Diagram to sum up the total size. If no
value is set, the default size is n=num_continuous_states().

Parameter ``n``:
    The size of the residual vector output argument of
    System::CalcImplicitTimeDerivativesResidual(). If n <= 0 restore
    to the default, num_continuous_states().

See also:
    implicit_time_derivatives_residual_size()

See also:
    LeafSystem::DeclareImplicitTimeDerivativesResidualSize()

See also:
    System::CalcImplicitTimeDerivativesResidual())""";
        } set_implicit_time_derivatives_residual_size;
        // Symbol: drake::systems::SystemBase::set_name
        struct /* set_name */ {
          // Source: drake/systems/framework/system_base.h:44
          const char* doc =
R"""(Sets the name of the system. Do not use the path delimiter character
':' in the name. When creating a Diagram, names of sibling subsystems
should be unique. DiagramBuilder uses this method to assign a unique
default name if none is provided.)""";
        } set_name;
        // Symbol: drake::systems::SystemBase::set_parent_service
        struct /* set_parent_service */ {
          // Source: drake/systems/framework/system_base.h:982
          const char* doc =
R"""((Internal use only) Declares that ``parent_service`` is the service
interface of the Diagram that owns this subsystem. Aborts if the
parent service has already been set to something else.)""";
        } set_parent_service;
        // Symbol: drake::systems::SystemBase::time_ticket
        struct /* time_ticket */ {
          // Source: drake/systems/framework/system_base.h:507
          const char* doc =
R"""(Returns a ticket indicating dependence on time. This is the same
ticket for all systems and refers to the same time value.)""";
        } time_ticket;
        // Symbol: drake::systems::SystemBase::v_ticket
        struct /* v_ticket */ {
          // Source: drake/systems/framework/system_base.h:529
          const char* doc =
R"""(Returns a ticket indicating dependence on velocity state variables v.
This does *not* also indicate a dependence on configuration variables
q -- you must list that explicitly or use kinematics_ticket() instead.
There is no ticket representing just one of the state variables vᵢ.)""";
        } v_ticket;
        // Symbol: drake::systems::SystemBase::xa_ticket
        struct /* xa_ticket */ {
          // Source: drake/systems/framework/system_base.h:573
          const char* doc =
R"""(Returns a ticket indicating dependence on all of the abstract state
variables in the current Context.

See also:
    abstract_state_ticket() to obtain a ticket for just one abstract
    state variable.)""";
        } xa_ticket;
        // Symbol: drake::systems::SystemBase::xc_ticket
        struct /* xc_ticket */ {
          // Source: drake/systems/framework/system_base.h:542
          const char* doc =
R"""(Returns a ticket indicating dependence on *all* of the continuous
state variables q, v, or z.)""";
        } xc_ticket;
        // Symbol: drake::systems::SystemBase::xcdot_ticket
        struct /* xcdot_ticket */ {
          // Source: drake/systems/framework/system_base.h:718
          const char* doc =
R"""(Returns a ticket for the cache entry that holds time derivatives of
the continuous variables.

See also:
    EvalTimeDerivatives())""";
        } xcdot_ticket;
        // Symbol: drake::systems::SystemBase::xd_ticket
        struct /* xd_ticket */ {
          // Source: drake/systems/framework/system_base.h:558
          const char* doc =
R"""(Returns a ticket indicating dependence on all of the numerical
discrete state variables, in any discrete variable group.

See also:
    discrete_state_ticket() to obtain a ticket for just one discrete
    state variable.)""";
        } xd_ticket;
        // Symbol: drake::systems::SystemBase::z_ticket
        struct /* z_ticket */ {
          // Source: drake/systems/framework/system_base.h:536
          const char* doc =
R"""(Returns a ticket indicating dependence on any or all of the
miscellaneous continuous state variables z. There is no ticket
representing just one of the state variables zᵢ.)""";
        } z_ticket;
      } SystemBase;
      // Symbol: drake::systems::SystemConstraint
      struct /* SystemConstraint */ {
        // Source: drake/systems/framework/system_constraint.h:144
        const char* doc =
R"""(A SystemConstraint is a generic base-class for constraints on Systems.

A SystemConstraint is a means to inform our algorithms *about* the
implemented system behavior -- declaring the constraint does not
*cause* the system behavior to change. It is meant to improve analysis
by telling our algorithms that "all valid solutions of this dynamical
system will satisfy the following (in)equalities". Examples could
include conserved quantities or joint limits on a mechanism.

This class is intentionally similar to, but (so far) independent from
solvers::Constraint. This is primarily because there is no notion of
decision variables in the system classes (yet); rather each individual
algorithm (e.g. trajectory optimization, or system identification)
constructs decision variables for the particular mathematical program
that is being formulated, and must bind the system constraint to those
variables (e.g. by populating the Context with the decision variables
and calling Calc).

We can convert a SystemConstraint to a solvers::Constraint by using
SystemConstraintWrapper or SystemConstraintAdapter.

See also:
    LeafSystem<T>::DeclareEqualityConstraint and
    LeafSystem<T>::DeclareInequalityConstraint for use cases.)""";
        // Symbol: drake::systems::SystemConstraint::Calc
        struct /* Calc */ {
          // Source: drake/systems/framework/system_constraint.h:203
          const char* doc =
R"""(Evaluates the function pointer passed in through the constructor,
writing the output to ``value``. ``value`` will be
(non-conservatively) resized to match the constraint function output.)""";
        } Calc;
        // Symbol: drake::systems::SystemConstraint::CheckSatisfied
        struct /* CheckSatisfied */ {
          // Source: drake/systems/framework/system_constraint.h:215
          const char* doc =
R"""(Evaluates the function pointer, and check if all of the outputs are
within the desired bounds.)""";
        } CheckSatisfied;
        // Symbol: drake::systems::SystemConstraint::SystemConstraint<T>
        struct /* ctor */ {
          // Source: drake/systems/framework/system_constraint.h:154
          const char* doc_2args =
R"""((Advanced) Constructs a default (zero-sized) SystemConstraint.

Most users should call a LeafSystem method like
DeclareEqualityConstraint to create (and add) constraints, not call
this constructor directly.

Parameter ``description``:
    a human-readable description useful for debugging.)""";
          // Source: drake/systems/framework/system_constraint.h:168
          const char* doc_4args =
R"""((Advanced) Constructs a SystemConstraint. Depending on the ``bounds``
it could be an equality constraint f(x) = 0, or an inequality
constraint lower_bound <= f(x) <= upper_bound.

Most users should call a LeafSystem method like
DeclareEqualityConstraint to create (and add) constraints, not call
this constructor directly.

Parameter ``description``:
    a human-readable description useful for debugging.)""";
        } ctor;
        // Symbol: drake::systems::SystemConstraint::bounds
        struct /* bounds */ {
          // Source: drake/systems/framework/system_constraint.h:248
          const char* doc = R"""()""";
        } bounds;
        // Symbol: drake::systems::SystemConstraint::description
        struct /* description */ {
          // Source: drake/systems/framework/system_constraint.h:256
          const char* doc = R"""()""";
        } description;
        // Symbol: drake::systems::SystemConstraint::get_system
        struct /* get_system */ {
          // Source: drake/systems/framework/system_constraint.h:243
          const char* doc =
R"""(Returns a reference to the System that owns this constraint. Note that
for a constraint on a diagram this will be the diagram itself, never a
leaf system whose constraint was re-expressed.)""";
        } get_system;
        // Symbol: drake::systems::SystemConstraint::is_equality_constraint
        struct /* is_equality_constraint */ {
          // Source: drake/systems/framework/system_constraint.h:251
          const char* doc = R"""()""";
        } is_equality_constraint;
        // Symbol: drake::systems::SystemConstraint::lower_bound
        struct /* lower_bound */ {
          // Source: drake/systems/framework/system_constraint.h:254
          const char* doc = R"""()""";
        } lower_bound;
        // Symbol: drake::systems::SystemConstraint::size
        struct /* size */ {
          // Source: drake/systems/framework/system_constraint.h:249
          const char* doc = R"""()""";
        } size;
        // Symbol: drake::systems::SystemConstraint::type
        struct /* type */ {
          // Source: drake/systems/framework/system_constraint.h:250
          const char* doc = R"""()""";
        } type;
        // Symbol: drake::systems::SystemConstraint::upper_bound
        struct /* upper_bound */ {
          // Source: drake/systems/framework/system_constraint.h:255
          const char* doc = R"""()""";
        } upper_bound;
      } SystemConstraint;
      // Symbol: drake::systems::SystemConstraintAdapter
      struct /* SystemConstraintAdapter */ {
        // Source: drake/systems/optimization/system_constraint_adapter.h:20
        const char* doc =
R"""(This class is a factory class to generate SystemConstraintWrapper.
Namely this class helps to convert a SystemConstraint to a
solvers::Constraint. Internally this class will convert a
System<double> to System<AutoDiffXd> (and System<symbolic::Expression>
if possible), and store these systems (of different scalar types)
inside this class. Using this class with a system that cannot be
converted to System<AutoDiffXd> will cause a runtime error.)""";
        // Symbol: drake::systems::SystemConstraintAdapter::Create
        struct /* Create */ {
          // Source: drake/systems/optimization/system_constraint_adapter.h:43
          const char* doc =
R"""(This method creates a solvers::Constraint from a SystemConstraint. The
newly created constraint represents lower <=
system_constraint.Calc(UpdateContextFromDecisionVariablesGeneric(x))
<= upper, where lower and upper are obtained from
SystemConstraint::lower_bound() and SystemConstraint::upper_bound().

Parameter ``index``:
    The index of the constraint stored inside ``system`` in the class
    constructor.

Parameter ``context``:
    SystemConstraint::Calc function requires a context as the input.
    On the other hand, the generated constraint might be imposed on a
    partial subset of variables (state, time, input and parameters)
    inside the context. Hence we use
    ``UpdateContextFromDecisionVariablesGeneric`` to select the
    decision variables inside ``context``. The unselected variables
    will remain to its values stored in ``context``.)""";
        } Create;
        // Symbol: drake::systems::SystemConstraintAdapter::MaybeCreateConstraintSymbolically
        struct /* MaybeCreateConstraintSymbolically */ {
          // Source: drake/systems/optimization/system_constraint_adapter.h:79
          const char* doc =
R"""(Given a SystemConstraint and the Context to evaluate this
SystemConstraint, parse the constraint in the symbolic forms.
Currently we support parsing the following forms:

1. bounding box ( lower <= x <= upper ) 2. linear equality ( aᵀx = b )
3. linear inequality ( lower <= aᵀx <= upper )

If the SystemConstraint cannot be parsed to the forms above, then
returns nullopt; otherwise returns a vector containing the parsed
constraint.

Parameter ``index``:
    The index of the constraint in the System object.

Parameter ``context``:
    The context used to evaluate the SystemConstraint.

Returns ``constraints``:
    If the SystemConstraint can be parsed to the constraint in the
    above forms, then constraints.value()[i] is the i'th row of the
    SystemConstraint evaluation result; if the SystemConstraint cannot
    be parsed in the above forms (either due to the System is not
    instantiated with symbolic::Expression, or the constraint is not
    linear), then constraints.has_value() = false.)""";
        } MaybeCreateConstraintSymbolically;
        // Symbol: drake::systems::SystemConstraintAdapter::MaybeCreateGenericConstraintSymbolically
        struct /* MaybeCreateGenericConstraintSymbolically */ {
          // Source: drake/systems/optimization/system_constraint_adapter.h:105
          const char* doc =
R"""(Given a SystemConstraint and the Context to evaluate this
SystemConstraint, parses the constraint to a generic nonlinear
constraint lower <= SystemConstraint.Calc(context) <= upper. If the
SystemConstraint cannot be parsed to the form above, then returns
empty; otherwise returns a parsed constraint, together with the bound
variables. We currently only support systems without abstract state or
abstract parameters.

Parameter ``index``:
    The index of the constraint in the System object.

Parameter ``context``:
    The context used to evaluate the SystemConstraint.

Note:
    each expression in ``context`` (like state, parameter, etc) should
    be either a single symbolic variable, or a constant. Currently we
    do not support complicated symbolic expressions.

Returns ``constraint``:
    A generic nonlinear constraint parsed from SystemConstraint. If
    the SystemConstraint cannot be parsed to the generic constraint
    using ``context`` instantiated with symbolic::Expression, then
    constraint.has_value() = false.

Raises:
    invalid_argument if the system contains abstract state or abstract
    parameters.)""";
        } MaybeCreateGenericConstraintSymbolically;
        // Symbol: drake::systems::SystemConstraintAdapter::SystemConstraintAdapter
        struct /* ctor */ {
          // Source: drake/systems/optimization/system_constraint_adapter.h:22
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::systems::SystemConstraintAdapter::system_autodiff
        struct /* system_autodiff */ {
          // Source: drake/systems/optimization/system_constraint_adapter.h:112
          const char* doc =
R"""(Getters for the system instantiated with AutoDiffXd.)""";
        } system_autodiff;
        // Symbol: drake::systems::SystemConstraintAdapter::system_symbolic
        struct /* system_symbolic */ {
          // Source: drake/systems/optimization/system_constraint_adapter.h:120
          const char* doc =
R"""(Returns the symbolic system. Throws a runtime error if the system
cannot be instantiated with symbolic::Expression.)""";
        } system_symbolic;
      } SystemConstraintAdapter;
      // Symbol: drake::systems::SystemConstraintBounds
      struct /* SystemConstraintBounds */ {
        // Source: drake/systems/framework/system_constraint.h:38
        const char* doc =
R"""(The bounds of a SystemConstraint. This also encompasses the form of
the constraint: equality constraints occur when both the lower and
upper bounds are all zeros.)""";
        // Symbol: drake::systems::SystemConstraintBounds::Equality
        struct /* Equality */ {
          // Source: drake/systems/framework/system_constraint.h:47
          const char* doc =
R"""(Creates constraint of type SystemConstraintType::kEquality, with the
given size for ``f(x)``.)""";
        } Equality;
        // Symbol: drake::systems::SystemConstraintBounds::SystemConstraintBounds
        struct /* ctor */ {
          // Source: drake/systems/framework/system_constraint.h:43
          const char* doc_0args =
R"""(Creates constraint bounds with zero size.)""";
          // Source: drake/systems/framework/system_constraint.h:58
          const char* doc_2args_lower_upper =
R"""(Creates a constraint with the given upper and lower bounds for
``f(x)``. The type() of this constraint will be kInequality, except in
the unusual case where both lower and upper are all zeros (in which
case it is kEquality). It is not currently allowed to set lower ==
upper (creating an equality constraint in the form f(x) = b), except
when b == 0. Using a non-zero b might be allowed in the future.)""";
          // Source: drake/systems/framework/system_constraint.h:64
          const char* doc_2args_lower_stdnulloptt =
R"""(Creates an inequality constraint with the given lower bounds for
``f(x)``. The upper bounds are all positive infinity.)""";
          // Source: drake/systems/framework/system_constraint.h:70
          const char* doc_2args_stdnulloptt_upper =
R"""(Creates an inequality constraint with the given upper bounds for
``f(x)``. The lower bounds are all negative infinity.)""";
        } ctor;
        // Symbol: drake::systems::SystemConstraintBounds::lower
        struct /* lower */ {
          // Source: drake/systems/framework/system_constraint.h:76
          const char* doc = R"""()""";
        } lower;
        // Symbol: drake::systems::SystemConstraintBounds::size
        struct /* size */ {
          // Source: drake/systems/framework/system_constraint.h:74
          const char* doc = R"""()""";
        } size;
        // Symbol: drake::systems::SystemConstraintBounds::type
        struct /* type */ {
          // Source: drake/systems/framework/system_constraint.h:75
          const char* doc = R"""()""";
        } type;
        // Symbol: drake::systems::SystemConstraintBounds::upper
        struct /* upper */ {
          // Source: drake/systems/framework/system_constraint.h:77
          const char* doc = R"""()""";
        } upper;
      } SystemConstraintBounds;
      // Symbol: drake::systems::SystemConstraintIndex
      struct /* SystemConstraintIndex */ {
        // Source: drake/systems/framework/framework_common.h:69
        const char* doc =
R"""(Serves as the local index for constraints declared on a given System.)""";
      } SystemConstraintIndex;
      // Symbol: drake::systems::SystemConstraintType
      struct /* SystemConstraintType */ {
        // Source: drake/systems/framework/system_constraint.h:29
        const char* doc = R"""(The form of a SystemConstraint.)""";
        // Symbol: drake::systems::SystemConstraintType::kEquality
        struct /* kEquality */ {
          // Source: drake/systems/framework/system_constraint.h:30
          const char* doc = R"""(The constraint is of the form f(x)=0.)""";
        } kEquality;
        // Symbol: drake::systems::SystemConstraintType::kInequality
        struct /* kInequality */ {
          // Source: drake/systems/framework/system_constraint.h:31
          const char* doc = R"""()""";
        } kInequality;
      } SystemConstraintType;
      // Symbol: drake::systems::SystemConstraintWrapper
      struct /* SystemConstraintWrapper */ {
        // Source: drake/systems/optimization/system_constraint_wrapper.h:45
        const char* doc =
R"""(This wrapper class wraps a SystemConstraint object to the format of
solvers::Constraint. The constraint is lower <=
SystemConstraint.Calc(UpdateContextFromDecisionVaraibles(x)) <= upper
where lower/upper are the lower and upper bounds of the
SystemConstraint object. When the lower and upper are equal, this
represents an equality constraint.)""";
        // Symbol: drake::systems::SystemConstraintWrapper::SystemConstraintWrapper
        struct /* ctor */ {
          // Source: drake/systems/optimization/system_constraint_wrapper.h:75
          const char* doc =
R"""(Wraps a single SystemConstraint of the given system into a
solvers::Constraint. Note that this constraint doesn't require the
System to support symbolic expressions. The wrapped
solvers::Constraint is a generic nonlinear constraint.

Parameter ``system_double``:
    The System whose SystemConstraint is converted to
    solvers::Constraint.

Parameter ``system_autodiff``:
    This system should be converted from system_double by converting
    the scalar type. If this is pointer is null, then the AutoDiffXd
    version of the system will be created internally inside this
    wrapper class.

Parameter ``index``:
    The index of the SystemConstraint in ``system_double`` (and also
    ``system_autodiff)``.

Parameter ``context``:
    The value stored in this context will be used in
    SystemConstraintWrapper::Eval. If ``updater_double`` (and
    ``updater_autodiff)`` doesn't update everything in the context
    (such as state, input, params, etc), then the un-updated part in
    the context will keep its value to those stored in ``context``.

Parameter ``updater_double``:
    Maps x in SystemConstraintWrapper::Eval(x, &y) to a context. The
    context is then used in SystemConstraint.Calc(context).

Parameter ``updater_autodiff``:
    Same as ``updater_double``, but works for autodiff type.

Parameter ``x_size``:
    The number of variables bound with this constraint. Namely, the
    size of x in SystemConstraintWrapper.Eval(x, &y).)""";
        } ctor;
        // Symbol: drake::systems::SystemConstraintWrapper::constraint_index
        struct /* constraint_index */ {
          // Source: drake/systems/optimization/system_constraint_wrapper.h:89
          const char* doc =
R"""(Getter for the index of the constraint in the system.)""";
        } constraint_index;
        // Symbol: drake::systems::SystemConstraintWrapper::system_autodiff
        struct /* system_autodiff */ {
          // Source: drake/systems/optimization/system_constraint_wrapper.h:86
          const char* doc =
R"""(Gets the AutoDiffXd type System stored in this constraint.)""";
        } system_autodiff;
      } SystemConstraintWrapper;
      // Symbol: drake::systems::SystemImpl
      struct /* SystemImpl */ {
        // Source: drake/systems/framework/system.h:41
        const char* doc = R"""()""";
        // Symbol: drake::systems::SystemImpl::SystemImpl
        struct /* ctor */ {
          // Source: drake/systems/framework/system.h:43
          const char* doc = R"""()""";
        } ctor;
      } SystemImpl;
      // Symbol: drake::systems::SystemOutput
      struct /* SystemOutput */ {
        // Source: drake/systems/framework/system_output.h:32
        const char* doc =
R"""(Conveniently stores a snapshot of the values of every output port of a
System. There is framework support for allocating the right types and
filling them in but otherwise this is not used internally. Note that
there is never any live connection between a SystemOutput object and
the System whose output values it has captured.

A ``SystemOutput<T>`` object can only be obtained using
``System<T>::AllocateOutput()`` or by copying an existing SystemOutput
object.)""";
        // Symbol: drake::systems::SystemOutput::GetMutableData
        struct /* GetMutableData */ {
          // Source: drake/systems/framework/system_output.h:65
          const char* doc =
R"""((Advanced) Returns mutable access to an AbstractValue object that is
suitable for holding the value of output port ``index`` of the
allocating System. This works for any output port regardless of it
actual type. Most users should just call ``System<T>::CalcOutputs()``
to get all the output port values at once.)""";
        } GetMutableData;
        // Symbol: drake::systems::SystemOutput::GetMutableVectorData
        struct /* GetMutableVectorData */ {
          // Source: drake/systems/framework/system_output.h:76
          const char* doc =
R"""((Advanced) Returns mutable access to a ``BasicVector<T>`` object that
is suitable for holding the value of output port ``index`` of the
allocating System. The object's concrete type is preserved from the
output port. Most users should just call ``System<T>::CalcOutputs()``
to get all the output port values at once.

Raises:
    RuntimeError if the port is not vector-valued.)""";
        } GetMutableVectorData;
        // Symbol: drake::systems::SystemOutput::SystemOutput<T>
        struct /* ctor */ {
          // Source: drake/systems/framework/system_output.h:34
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::systems::SystemOutput::get_data
        struct /* get_data */ {
          // Source: drake/systems/framework/system_output.h:47
          const char* doc =
R"""(Returns the last-saved value of output port ``index`` as an
AbstractValue. This works for any output port regardless of it actual
type.)""";
        } get_data;
        // Symbol: drake::systems::SystemOutput::get_vector_data
        struct /* get_vector_data */ {
          // Source: drake/systems/framework/system_output.h:55
          const char* doc =
R"""(Returns the last-saved value of output port ``index`` as a
``BasicVector<T>``, although the actual concrete type is preserved
from the actual output port.

Raises:
    RuntimeError if the port is not vector-valued.)""";
        } get_vector_data;
        // Symbol: drake::systems::SystemOutput::num_ports
        struct /* num_ports */ {
          // Source: drake/systems/framework/system_output.h:40
          const char* doc =
R"""(Returns the number of output ports specified for this SystemOutput
during allocation.)""";
        } num_ports;
      } SystemOutput;
      // Symbol: drake::systems::SystemScalarConverter
      struct /* SystemScalarConverter */ {
        // Source: drake/systems/framework/system_scalar_converter.h:35
        const char* doc =
R"""(Helper class to convert a System<U> into a System<T>, intended for
internal use by the System framework, not directly by users.

For user-facing documentation see system_scalar_conversion.

Because it is not templated on a System subclass, this class can be
used by LeafSystem without any direct knowledge of the subtypes being
converted. In other words, it enables a runtime flavor of the CRTP.

Throughout this class, the template type ``S`` must be the
most-derived concrete System subclass. This object may only be used to
convert System<U> objects of runtime type S<U>, not subclasses of
S<U>.)""";
        // Symbol: drake::systems::SystemScalarConverter::Add
        struct /* Add */ {
          // Source: drake/systems/framework/system_scalar_converter.h:125
          const char* doc =
R"""(Registers the std::function to be used to convert a System<U> into a
System<T>. A pair of types can be registered (added) at most once.)""";
        } Add;
        // Symbol: drake::systems::SystemScalarConverter::AddIfSupported
        struct /* AddIfSupported */ {
          // Source: drake/systems/framework/system_scalar_converter.h:131
          const char* doc =
R"""(Adds converter for an S<U> into an S<T>, iff scalar_conversion::Traits
says its supported. The converter uses S's scalar-type converting copy
constructor.)""";
        } AddIfSupported;
        // Symbol: drake::systems::SystemScalarConverter::Convert
        struct /* Convert */ {
          // Source: drake/systems/framework/system_scalar_converter.h:153
          const char* doc =
R"""(Converts a System<U> into a System<T>. This is the API that LeafSystem
uses to provide a default implementation of DoToAutoDiffXd, etc.

Template parameter ``U``:
    the donor scalar type (to convert from)

Template parameter ``T``:
    the resulting scalar type (to convert into))""";
        } Convert;
        // Symbol: drake::systems::SystemScalarConverter::GuaranteedSubtypePreservation
        struct /* GuaranteedSubtypePreservation */ {
          // Source: drake/systems/framework/system_scalar_converter.h:79
          const char* doc =
R"""(A configuration option for our constructor, controlling whether or not
the Convert implementation requires that the System subclass type is
preserved.)""";
          // Symbol: drake::systems::SystemScalarConverter::GuaranteedSubtypePreservation::kDisabled
          struct /* kDisabled */ {
            // Source: drake/systems/framework/system_scalar_converter.h:87
            const char* doc =
R"""(The argument to Convert need not be the exact type S that was used to
populate the SystemScalarConverter -- it can be either exactly that S,
or a subtype of that S. This permits subtype information to be lost
across conversion.)""";
          } kDisabled;
          // Symbol: drake::systems::SystemScalarConverter::GuaranteedSubtypePreservation::kEnabled
          struct /* kEnabled */ {
            // Source: drake/systems/framework/system_scalar_converter.h:82
            const char* doc =
R"""(The argument to Convert must be of the exact type S that was used to
populate the SystemScalarConverter.)""";
          } kEnabled;
        } GuaranteedSubtypePreservation;
        // Symbol: drake::systems::SystemScalarConverter::IsConvertible
        struct /* IsConvertible */ {
          // Source: drake/systems/framework/system_scalar_converter.h:145
          const char* doc =
R"""(Returns true iff this object can convert a System<U> into a System<T>,
i.e., whether Convert() will return non-null.

Template parameter ``U``:
    the donor scalar type (to convert from)

Template parameter ``T``:
    the resulting scalar type (to convert into))""";
        } IsConvertible;
        // Symbol: drake::systems::SystemScalarConverter::RemoveUnlessAlsoSupportedBy
        struct /* RemoveUnlessAlsoSupportedBy */ {
          // Source: drake/systems/framework/system_scalar_converter.h:137
          const char* doc =
R"""(Removes from this converter all pairs where ``other.IsConvertible<T,
U>`` is false. The subtype ``S`` need not be the same between this and
``other``.)""";
        } RemoveUnlessAlsoSupportedBy;
        // Symbol: drake::systems::SystemScalarConverter::SystemScalarConverter
        struct /* ctor */ {
          // Source: drake/systems/framework/system_scalar_converter.h:42
          const char* doc_0args =
R"""(Creates an object that returns nullptr for all Convert() requests. The
single-argument constructor below is the typical way to create a
useful instance of this type.)""";
          // Source: drake/systems/framework/system_scalar_converter.h:73
          const char* doc_1args =
R"""(Creates an object that uses S's scalar-type converting copy
constructor. That constructor takes the form of, e.g.:


::

    template <typename T>
    class Foo {
      template <typename U>
      explicit Foo(const Foo<U>& other);
    };

This constructor only creates a converter between a limited set of
types, specifically the default_scalars "default scalars".

By default, all non-identity pairs (pairs where T and U differ) drawn
from the above list can be used for T and U. Systems may specialize
scalar_conversion::Traits to disable support for some or all of these
conversions, or after construction may call Add<T, U>() on the
returned object to enable support for additional custom types.

Template parameter ``S``:
    is the System type to convert

This an implicit conversion constructor (not marked ``explicit``), in
order to make calling code substantially more readable, with
relatively little risk of an unwanted accidental conversion happening.

See system_scalar_conversion for additional overview documentation.)""";
          // Source: drake/systems/framework/system_scalar_converter.h:96
          const char* doc_2args =
R"""((Advanced) Creates using S's scalar-type converting copy constructor.
Behaves exactly like SystemScalarConverter(SystemTypeTag<S>), but with
the additional option to turn off guaranteed subtype preservation of
the System being converted. In general, subtype preservation is an
important invariant during scalar conversion, so be cautious about
disabling it.)""";
        } ctor;
        // Symbol: drake::systems::SystemScalarConverter::empty
        struct /* empty */ {
          // Source: drake/systems/framework/system_scalar_converter.h:115
          const char* doc =
R"""(Returns true iff no conversions are supported. (In other words,
whether this is a default-constructed object.))""";
        } empty;
      } SystemScalarConverter;
      // Symbol: drake::systems::SystemSymbolicInspector
      struct /* SystemSymbolicInspector */ {
        // Source: drake/systems/framework/system_symbolic_inspector.h:38
        const char* doc =
R"""(The SystemSymbolicInspector uses symbolic::Expressions to analyze
various properties of the System, such as time invariance and
input-to-output sparsity, along with many others.

A SystemSymbolicInspector is only interesting if the Context contains
purely vector-valued elements. If any abstract-valued elements are
present, the SystemSymbolicInspector will not be able to parse the
governing equations reliably.

It would be possible to report system properties for a specific
configuration of the abstract inputs, state, or parameters. We
intentionally do not provide such an analysis, because it would invite
developers to shoot themselves in the foot by accidentally overstating
sparsity, for instance if a given input affects a given output in some
modes, but not the mode tested.

Even with that limitation on scope, SystemSymbolicInspector has risks,
if the System contains C++ native conditionals like "if" or "switch".
symbolic::Expression does not provide an implicit conversion to
``bool``, so it is unlikely that anyone will accidentally write a
System that both uses native conditionals and compiles with a
symbolic::Expression scalar type. However, it is possible, for
instance using an explicit cast, or ``std::equal_to``.)""";
        // Symbol: drake::systems::SystemSymbolicInspector::HasAffineDynamics
        struct /* HasAffineDynamics */ {
          // Source: drake/systems/framework/system_symbolic_inspector.h:61
          const char* doc =
R"""(Returns true iff all of the derivatives and discrete updates have at
most an affine dependence on state and input. Note that the return
value does NOT depend on the output methods (they may be affine or
not).)""";
        } HasAffineDynamics;
        // Symbol: drake::systems::SystemSymbolicInspector::IsAbstract
        struct /* IsAbstract */ {
          // Source: drake/systems/framework/system_symbolic_inspector.h:64
          const char* doc =
R"""(Returns true if any field in the ``context`` is abstract-valued.)""";
        } IsAbstract;
        // Symbol: drake::systems::SystemSymbolicInspector::IsConnectedInputToOutput
        struct /* IsConnectedInputToOutput */ {
          // Source: drake/systems/framework/system_symbolic_inspector.h:51
          const char* doc =
R"""(Returns true if the input port at the given ``input_port_index`` is or
might possibly be a term in the output at the given
``output_port_index``.)""";
        } IsConnectedInputToOutput;
        // Symbol: drake::systems::SystemSymbolicInspector::IsTimeInvariant
        struct /* IsTimeInvariant */ {
          // Source: drake/systems/framework/system_symbolic_inspector.h:56
          const char* doc =
R"""(Returns true if there is no dependence on time in the dynamics
(continuous nor discrete) nor the outputs.)""";
        } IsTimeInvariant;
        // Symbol: drake::systems::SystemSymbolicInspector::SystemSymbolicInspector
        struct /* ctor */ {
          // Source: drake/systems/framework/system_symbolic_inspector.h:43
          const char* doc =
R"""(Constructs a SystemSymbolicInspector for the given ``system`` by
initializing every vector-valued element in the Context with symbolic
variables.)""";
        } ctor;
        // Symbol: drake::systems::SystemSymbolicInspector::constraints
        struct /* constraints */ {
          // Source: drake/systems/framework/system_symbolic_inspector.h:132
          const char* doc =
R"""(Returns a reference to the symbolic representation of the constraints.)""";
        } constraints;
        // Symbol: drake::systems::SystemSymbolicInspector::continuous_state
        struct /* continuous_state */ {
          // Source: drake/systems/framework/system_symbolic_inspector.h:85
          const char* doc =
R"""(Returns a reference to the symbolic representation of the continuous
state.)""";
        } continuous_state;
        // Symbol: drake::systems::SystemSymbolicInspector::derivatives
        struct /* derivatives */ {
          // Source: drake/systems/framework/system_symbolic_inspector.h:111
          const char* doc =
R"""(Returns a copy of the symbolic representation of the continuous-time
dynamics.)""";
        } derivatives;
        // Symbol: drake::systems::SystemSymbolicInspector::discrete_state
        struct /* discrete_state */ {
          // Source: drake/systems/framework/system_symbolic_inspector.h:92
          const char* doc =
R"""(Returns a reference to the symbolic representation of the discrete
state.

Parameter ``i``:
    The discrete state group number.)""";
        } discrete_state;
        // Symbol: drake::systems::SystemSymbolicInspector::discrete_update
        struct /* discrete_update */ {
          // Source: drake/systems/framework/system_symbolic_inspector.h:118
          const char* doc =
R"""(Returns a reference to the symbolic representation of the
discrete-time dynamics.

Parameter ``i``:
    The discrete state group number.)""";
        } discrete_update;
        // Symbol: drake::systems::SystemSymbolicInspector::input
        struct /* input */ {
          // Source: drake/systems/framework/system_symbolic_inspector.h:78
          const char* doc =
R"""(Returns a reference to the symbolic representation of the input.

Parameter ``i``:
    The input port number.)""";
        } input;
        // Symbol: drake::systems::SystemSymbolicInspector::numeric_parameters
        struct /* numeric_parameters */ {
          // Source: drake/systems/framework/system_symbolic_inspector.h:103
          const char* doc =
R"""(Returns a reference to the symbolic representation of the numeric
parameters.

Parameter ``i``:
    The numeric parameter group number.)""";
        } numeric_parameters;
        // Symbol: drake::systems::SystemSymbolicInspector::output
        struct /* output */ {
          // Source: drake/systems/framework/system_symbolic_inspector.h:126
          const char* doc =
R"""(Returns a reference to the symbolic representation of the output.

Parameter ``i``:
    The output port number.)""";
        } output;
        // Symbol: drake::systems::SystemSymbolicInspector::time
        struct /* time */ {
          // Source: drake/systems/framework/system_symbolic_inspector.h:74
          const char* doc =
R"""(@name Reference symbolic components A set of accessor methods that
provide direct access to the symbolic forms of the System. This class
carefully sets up and names all of the symbolic elements of the
Context, and other methods should be able to reap the benefits.
Returns a reference to the symbolic representation of time.)""";
        } time;
      } SystemSymbolicInspector;
      // Symbol: drake::systems::SystemTypeTag
      struct /* SystemTypeTag */ {
        // Source: drake/systems/framework/system_type_tag.h:29
        const char* doc =
R"""(A tag object that denotes a System subclass ``S`` in function
signatures.

For example, ``SystemTypeTag<MySystem>{}`` will create a dummy object
that can be used to call functions that look like:


::

    template <template <typename> class S>
    const char* get_foo(SystemTypeTag<S>) { return S<double>::get_foo(); }
    
    int main() {
       std::cout << get_foo(SystemTypeTag<MySystem>{});
    }

In this case, we could directly call get_foo<MySystem>() by specifying
the template argument, but that is not always possible. In particular,
tag objects are acutely useful when calling templated constructors,
because there is no other mechanism for the caller to specify the
template type.)""";
        // Symbol: drake::systems::SystemTypeTag::SystemTypeTag<S>
        struct /* ctor */ {
          // Source: drake/systems/framework/system_type_tag.h:30
          const char* doc = R"""()""";
        } ctor;
      } SystemTypeTag;
      // Symbol: drake::systems::SystemVisitor
      struct /* SystemVisitor */ {
        // Source: drake/systems/framework/system_visitor.h:38
        const char* doc =
R"""(Provides a "Visitor Pattern" for System and Diagram. Rather than
adding more virtual methods to the System base class, or performing a
dynamic_cast to test if a System is a Diagram, you may use the visitor
pattern enabled by this class, e.g.:


::

    template <typename T>
    class MySystemVisitor : public SystemVisitor {
    ...
    }
    
    MySystemVisitor<T> visitor;
    system.Accept(visitor);

will call the correct ``Visit`` overload.

Note:
    This method does *not* recurse through the subsystems of a
    Diagram, but that is easy to do: just call Diagram::GetSystems()
    in your visitor and then call Accept on the subsystems.)""";
        // Symbol: drake::systems::SystemVisitor::SystemVisitor<T>
        struct /* ctor */ {
          // Source: drake/systems/framework/system_visitor.h:40
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::systems::SystemVisitor::VisitDiagram
        struct /* VisitDiagram */ {
          // Source: drake/systems/framework/system_visitor.h:49
          const char* doc =
R"""(This method will be called by System<T>::accept() if the System *is* a
Diagram<T>.)""";
        } VisitDiagram;
        // Symbol: drake::systems::SystemVisitor::VisitSystem
        struct /* VisitSystem */ {
          // Source: drake/systems/framework/system_visitor.h:45
          const char* doc =
R"""(This method will be called by System<T>::accept() if the System *is
not* a Diagram<T>.)""";
        } VisitSystem;
      } SystemVisitor;
      // Symbol: drake::systems::TimeVaryingAffineSystem
      struct /* TimeVaryingAffineSystem */ {
        // Source: drake/systems/primitives/affine_system.h:43
        const char* doc =
R"""(Base class for a discrete- or continuous-time, time-varying affine
system, with potentially time-varying coefficients.

.. pydrake_system::

    name: TimeVaryingAffineSystem
    input_ports:
    - u(t)
    output_ports:
    - y(t)

If ``time_period > 0.0``, then the affine system will have the state
update:

.. math:: x(t+h) = A(t) x(t) + B(t) u(t) + f_0(t),

where ``h`` is the time_period. If ``time_period == 0.0``, then the
system will have the time derivatives:

.. math:: \dot{x}(t) = A(t) x(t) + B(t) u(t) + f_0(t),

where ``u`` denotes the input vector, ``x`` denotes the state vector.

In both cases, the system will have the output:

.. math:: y(t) = C(t) x(t) + D(t) u(t) + y_0(t),

where ``y`` denotes the output vector.

*

See also:
    AffineSystem)""";
        // Symbol: drake::systems::TimeVaryingAffineSystem::A
        struct /* A */ {
          // Source: drake/systems/primitives/affine_system.h:59
          const char* doc =
R"""(@name Methods To Be Implemented by Subclasses

Implementations must define these, and the returned matrices must be
sized to match the ``num_states``, `num_inputs`, and ``num_outputs``
specified in the constructor.)""";
        } A;
        // Symbol: drake::systems::TimeVaryingAffineSystem::B
        struct /* B */ {
          // Source: drake/systems/primitives/affine_system.h:60
          const char* doc = R"""()""";
        } B;
        // Symbol: drake::systems::TimeVaryingAffineSystem::C
        struct /* C */ {
          // Source: drake/systems/primitives/affine_system.h:62
          const char* doc = R"""()""";
        } C;
        // Symbol: drake::systems::TimeVaryingAffineSystem::CalcOutputY
        struct /* CalcOutputY */ {
          // Source: drake/systems/primitives/affine_system.h:125
          const char* doc =
R"""(Computes

.. math:: y(t) = C(t) x(t) + D(t) u(t) + y_0(t),

with by calling ``C(t)``, `D(t)``, and `y0(t)`` with runtime size
checks. Derived classes may override this for performance reasons.)""";
        } CalcOutputY;
        // Symbol: drake::systems::TimeVaryingAffineSystem::ConfigureDefaultAndRandomStateFrom
        struct /* ConfigureDefaultAndRandomStateFrom */ {
          // Source: drake/systems/primitives/affine_system.h:110
          const char* doc =
R"""(Helper method. Derived classes should call this from the)""";
        } ConfigureDefaultAndRandomStateFrom;
        // Symbol: drake::systems::TimeVaryingAffineSystem::D
        struct /* D */ {
          // Source: drake/systems/primitives/affine_system.h:63
          const char* doc = R"""()""";
        } D;
        // Symbol: drake::systems::TimeVaryingAffineSystem::DoCalcDiscreteVariableUpdates
        struct /* DoCalcDiscreteVariableUpdates */ {
          // Source: drake/systems/primitives/affine_system.h:137
          const char* doc =
R"""(Computes

.. math:: x(t+h) = A(t) x(t) + B(t) u(t) + f_0(t),

with by calling ``A(t)``, `B(t)``, and `f0(t)`` with runtime size
checks. Derived classes may override this for performance reasons.)""";
        } DoCalcDiscreteVariableUpdates;
        // Symbol: drake::systems::TimeVaryingAffineSystem::DoCalcTimeDerivatives
        struct /* DoCalcTimeDerivatives */ {
          // Source: drake/systems/primitives/affine_system.h:131
          const char* doc =
R"""(Computes

.. math:: \dot{x}(t) = A(t) x(t) + B(t) u(t) + f_0(t),

with by calling ``A(t)``, `B(t)``, and `f0(t)`` with runtime size
checks. Derived classes may override this for performance reasons.)""";
        } DoCalcTimeDerivatives;
        // Symbol: drake::systems::TimeVaryingAffineSystem::SetDefaultState
        struct /* SetDefaultState */ {
          // Source: drake/systems/primitives/affine_system.h:143
          const char* doc = R"""(Sets the initial conditions.)""";
        } SetDefaultState;
        // Symbol: drake::systems::TimeVaryingAffineSystem::SetRandomState
        struct /* SetRandomState */ {
          // Source: drake/systems/primitives/affine_system.h:147
          const char* doc = R"""(Sets the random initial conditions.)""";
        } SetRandomState;
        // Symbol: drake::systems::TimeVaryingAffineSystem::TimeVaryingAffineSystem<T>
        struct /* ctor */ {
          // Source: drake/systems/primitives/affine_system.h:103
          const char* doc =
R"""(Constructor.

Parameter ``converter``:
    scalar-type conversion support helper (i.e., AutoDiff, etc.); pass
    a default-constructed object if such support is not desired. See
    system_scalar_conversion for detailed background and examples
    related to scalar-type conversion support.

Parameter ``num_states``:
    size of the system's state vector

Parameter ``num_inputs``:
    size of the system's input vector

Parameter ``num_outputs``:
    size of the system's output vector

Parameter ``time_period``:
    discrete update period, or 0.0 to use continuous time)""";
        } ctor;
        // Symbol: drake::systems::TimeVaryingAffineSystem::configure_default_state
        struct /* configure_default_state */ {
          // Source: drake/systems/primitives/affine_system.h:69
          const char* doc =
R"""(Configures the value that will be assigned to the state vector in
``SetDefaultContext``. `x0` must be a vector of length ``num_states``.)""";
        } configure_default_state;
        // Symbol: drake::systems::TimeVaryingAffineSystem::configure_random_state
        struct /* configure_random_state */ {
          // Source: drake/systems/primitives/affine_system.h:76
          const char* doc =
R"""(Configures the Gaussian distribution over state vectors used in the
``SetRandomContext`` methods. The mean of the distribution will be the
default state (

See also:
    configure_default_state()). ``covariance`` must have size
    ``num_states`` by ``num_states`` and must be symmetric and
    positive semi-definite.)""";
        } configure_random_state;
        // Symbol: drake::systems::TimeVaryingAffineSystem::f0
        struct /* f0 */ {
          // Source: drake/systems/primitives/affine_system.h:61
          const char* doc = R"""()""";
        } f0;
        // Symbol: drake::systems::TimeVaryingAffineSystem::get_default_state
        struct /* get_default_state */ {
          // Source: drake/systems/primitives/affine_system.h:80
          const char* doc =
R"""(Returns the configured default state.

See also:
    configure_default_state().)""";
        } get_default_state;
        // Symbol: drake::systems::TimeVaryingAffineSystem::get_input_port
        struct /* get_input_port */ {
          // Source: drake/systems/primitives/affine_system.h:48
          const char* doc =
R"""(Returns the input port containing the externally applied input.)""";
        } get_input_port;
        // Symbol: drake::systems::TimeVaryingAffineSystem::get_output_port
        struct /* get_output_port */ {
          // Source: drake/systems/primitives/affine_system.h:51
          const char* doc =
R"""(Returns the output port containing the output state.)""";
        } get_output_port;
        // Symbol: drake::systems::TimeVaryingAffineSystem::get_random_state_covariance
        struct /* get_random_state_covariance */ {
          // Source: drake/systems/primitives/affine_system.h:83
          const char* doc =
R"""(Returns the configured random state covariance.)""";
        } get_random_state_covariance;
        // Symbol: drake::systems::TimeVaryingAffineSystem::num_inputs
        struct /* num_inputs */ {
          // Source: drake/systems/primitives/affine_system.h:89
          const char* doc = R"""()""";
        } num_inputs;
        // Symbol: drake::systems::TimeVaryingAffineSystem::num_outputs
        struct /* num_outputs */ {
          // Source: drake/systems/primitives/affine_system.h:90
          const char* doc = R"""()""";
        } num_outputs;
        // Symbol: drake::systems::TimeVaryingAffineSystem::num_states
        struct /* num_states */ {
          // Source: drake/systems/primitives/affine_system.h:88
          const char* doc = R"""()""";
        } num_states;
        // Symbol: drake::systems::TimeVaryingAffineSystem::time_period
        struct /* time_period */ {
          // Source: drake/systems/primitives/affine_system.h:87
          const char* doc = R"""()""";
        } time_period;
        // Symbol: drake::systems::TimeVaryingAffineSystem::y0
        struct /* y0 */ {
          // Source: drake/systems/primitives/affine_system.h:64
          const char* doc = R"""()""";
        } y0;
      } TimeVaryingAffineSystem;
      // Symbol: drake::systems::TimeVaryingLinearSystem
      struct /* TimeVaryingLinearSystem */ {
        // Source: drake/systems/primitives/linear_system.h:101
        const char* doc =
R"""(Base class for a discrete or continuous linear time-varying (LTV)
system.

If ``time_period > 0.0``, the system will have the following
discrete-time state update:

.. math:: x(t+h) = A(t) x(t) + B(t) u(t),

where ``h`` is the time_period. If ``time_period == 0.0``, the system
will have the following continuous-time state update:

.. math:: \dot{x}(t) = A(t) x(t) + B(t) u(t),

both with the output:

.. math:: y(t) = C(t) x(t) + D(t) u(t).)""";
        // Symbol: drake::systems::TimeVaryingLinearSystem::TimeVaryingLinearSystem<T>
        struct /* ctor */ {
          // Source: drake/systems/primitives/linear_system.h:116
          const char* doc =
R"""(Constructor.

Parameter ``converter``:
    scalar-type conversion support helper (i.e., AutoDiff, etc.); pass
    a default-constructed object if such support is not desired. See
    system_scalar_conversion for detailed background and examples
    related to scalar-type conversion support.

Parameter ``num_states``:
    size of the system's state vector

Parameter ``num_inputs``:
    size of the system's input vector

Parameter ``num_outputs``:
    size of the system's output vector

Parameter ``time_period``:
    discrete update period, or 0.0 to use continuous time)""";
        } ctor;
      } TimeVaryingLinearSystem;
      // Symbol: drake::systems::TrajectoryAffineSystem
      struct /* TrajectoryAffineSystem */ {
        // Source: drake/systems/primitives/trajectory_affine_system.h:20
        const char* doc =
R"""(A continuous- or discrete-time Affine Time-Varying system with system
matrices described by trajectories.)""";
        // Symbol: drake::systems::TrajectoryAffineSystem::A
        struct /* A */ {
          // Source: drake/systems/primitives/trajectory_affine_system.h:43
          const char* doc =
R"""(@name Implementations of TimeVaryingAffineSystem<T>'s pure virtual
methods.)""";
        } A;
        // Symbol: drake::systems::TrajectoryAffineSystem::B
        struct /* B */ {
          // Source: drake/systems/primitives/trajectory_affine_system.h:46
          const char* doc = R"""()""";
        } B;
        // Symbol: drake::systems::TrajectoryAffineSystem::C
        struct /* C */ {
          // Source: drake/systems/primitives/trajectory_affine_system.h:52
          const char* doc = R"""()""";
        } C;
        // Symbol: drake::systems::TrajectoryAffineSystem::D
        struct /* D */ {
          // Source: drake/systems/primitives/trajectory_affine_system.h:55
          const char* doc = R"""()""";
        } D;
        // Symbol: drake::systems::TrajectoryAffineSystem::TrajectoryAffineSystem<T>
        struct /* ctor */ {
          // Source: drake/systems/primitives/trajectory_affine_system.h:28
          const char* doc =
R"""(Constructs a TrajectoryAffineSystem from trajectories of matrices.

Parameter ``time_period``:
    Defines the period of the discrete time system; use
    time_period=0.0 to denote a continuous time system. $*Default:*
    0.0)""";
          // Source: drake/systems/primitives/trajectory_affine_system.h:38
          const char* doc_copyconvert =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";
        } ctor;
        // Symbol: drake::systems::TrajectoryAffineSystem::f0
        struct /* f0 */ {
          // Source: drake/systems/primitives/trajectory_affine_system.h:49
          const char* doc = R"""()""";
        } f0;
        // Symbol: drake::systems::TrajectoryAffineSystem::y0
        struct /* y0 */ {
          // Source: drake/systems/primitives/trajectory_affine_system.h:58
          const char* doc = R"""()""";
        } y0;
      } TrajectoryAffineSystem;
      // Symbol: drake::systems::TrajectoryLinearSystem
      struct /* TrajectoryLinearSystem */ {
        // Source: drake/systems/primitives/trajectory_linear_system.h:20
        const char* doc =
R"""(A continuous- or discrete-time Linear Time-Varying system with system
matrices described by trajectories.)""";
        // Symbol: drake::systems::TrajectoryLinearSystem::A
        struct /* A */ {
          // Source: drake/systems/primitives/trajectory_linear_system.h:42
          const char* doc =
R"""(@name Implementations of PiecewisePolynomialLinearSystem<T>'s pure
virtual methods.)""";
        } A;
        // Symbol: drake::systems::TrajectoryLinearSystem::B
        struct /* B */ {
          // Source: drake/systems/primitives/trajectory_linear_system.h:45
          const char* doc = R"""()""";
        } B;
        // Symbol: drake::systems::TrajectoryLinearSystem::C
        struct /* C */ {
          // Source: drake/systems/primitives/trajectory_linear_system.h:48
          const char* doc = R"""()""";
        } C;
        // Symbol: drake::systems::TrajectoryLinearSystem::D
        struct /* D */ {
          // Source: drake/systems/primitives/trajectory_linear_system.h:51
          const char* doc = R"""()""";
        } D;
        // Symbol: drake::systems::TrajectoryLinearSystem::TrajectoryLinearSystem<T>
        struct /* ctor */ {
          // Source: drake/systems/primitives/trajectory_linear_system.h:29
          const char* doc =
R"""(Constructs a PiecewisePolynomialLinearSystem from a
LinearTimeVaryingData structure.

Parameter ``time_period``:
    Defines the period of the discrete time system; use
    time_period=0.0 to denote a continuous time system. $*Default:*
    0.0)""";
          // Source: drake/systems/primitives/trajectory_linear_system.h:37
          const char* doc_copyconvert =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";
        } ctor;
      } TrajectoryLinearSystem;
      // Symbol: drake::systems::TrajectorySource
      struct /* TrajectorySource */ {
        // Source: drake/systems/primitives/trajectory_source.h:22
        const char* doc =
R"""(A source block that generates the value of a Trajectory for a given
time. The output is vector values, and may vary with the time (as
reflected in the context) at which the output is evaluated.)""";
        // Symbol: drake::systems::TrajectorySource::TrajectorySource<T>
        struct /* ctor */ {
          // Source: drake/systems/primitives/trajectory_source.h:31
          const char* doc =
R"""(Parameter ``trajectory``:
    Trajectory used by the system.

Parameter ``output_derivative_order``:
    The number of times to take the derivative. Must be greater than
    or equal to zero.

Parameter ``zero_derivatives_beyond_limits``:
    All derivatives will be zero before the start time or after the
    end time of ``trajectory``.)""";
        } ctor;
      } TrajectorySource;
      // Symbol: drake::systems::TriggerType
      struct /* TriggerType */ {
        // Source: drake/systems/framework/event.h:359
        const char* doc =
R"""(Predefined types of triggers for events. Used at run time to determine
why the associated event has occurred.)""";
        // Symbol: drake::systems::TriggerType::kForced
        struct /* kForced */ {
          // Source: drake/systems/framework/event.h:373
          const char* doc =
R"""(This trigger indicates that an associated event is triggered by
directly calling the corresponding public system API for event
handling (e.g. Publish(context)).)""";
        } kForced;
        // Symbol: drake::systems::TriggerType::kInitialization
        struct /* kInitialization */ {
          // Source: drake/systems/framework/event.h:366
          const char* doc =
R"""(This trigger indicates that an associated event is triggered at system
initialization.)""";
        } kInitialization;
        // Symbol: drake::systems::TriggerType::kPerStep
        struct /* kPerStep */ {
          // Source: drake/systems/framework/event.h:410
          const char* doc =
R"""(This trigger indicates that an associated event is triggered whenever
a ``solver`` takes a ``step``. A ``solver`` is an abstract construct
that controls or tracks the time and state evolution of a System. A
simulator is a ``solver``- it advances time a finite duration by
integrating a system, modifying its state accordingly- as is a process
that receives some numeric state from IPC that is then used to, e.g.,
update abstract state. Steps may occur at irregular time intervals: a
step typically coincides with a point in time where it is advantageous
to poll for events, like immediately after an integrator has advanced
time and state.

Per-step events are most commonly created in
System::GetPerStepEvents(). A very common use of such per-step events
is to update a discrete or abstract state variable that changes
whenever the continuous state advances; examples are computing the
"min" or "max" of some state variable, recording a signal in a delay
buffer, or publishing. Per-step events are also useful to implement
feedback controllers interfaced with physical devices; the controller
can be implemented in the event handler, and the "step" would
correspond to receiving sensory data from the hardware.)""";
        } kPerStep;
        // Symbol: drake::systems::TriggerType::kPeriodic
        struct /* kPeriodic */ {
          // Source: drake/systems/framework/event.h:388
          const char* doc =
R"""(This type indicates that an associated event is triggered by the
system proceeding to a time t ∈ {tᵢ = t₀ + p * i} for some period p,
time offset t₀, and i is a non-negative integer.

See also:
    PeriodicEventData. Periodic events are commonly created in
    System::CalcNextUpdateTime().)""";
        } kPeriodic;
        // Symbol: drake::systems::TriggerType::kTimed
        struct /* kTimed */ {
          // Source: drake/systems/framework/event.h:380
          const char* doc =
R"""(This trigger indicates that an associated event is triggered by the
system proceeding to a single, arbitrary time. Timed events are
commonly created in System::CalcNextUpdateTime().)""";
        } kTimed;
        // Symbol: drake::systems::TriggerType::kUnknown
        struct /* kUnknown */ {
          // Source: drake/systems/framework/event.h:360
          const char* doc = R"""()""";
        } kUnknown;
        // Symbol: drake::systems::TriggerType::kWitness
        struct /* kWitness */ {
          // Source: drake/systems/framework/event.h:416
          const char* doc =
R"""(This trigger indicates that an associated event is triggered by the
zero crossing of a witness function.)""";
        } kWitness;
      } TriggerType;
      // Symbol: drake::systems::UnrestrictedUpdateEvent
      struct /* UnrestrictedUpdateEvent */ {
        // Source: drake/systems/framework/event.h:719
        const char* doc =
R"""(This class represents an unrestricted update event. It has an optional
callback function to do custom handling of this event given const
Context and const UnrestrictedUpdateEvent object references, and
writes the updates to a mutable, non-null State object.)""";
        // Symbol: drake::systems::UnrestrictedUpdateEvent::UnrestrictedUpdateCallback
        struct /* UnrestrictedUpdateCallback */ {
          // Source: drake/systems/framework/event.h:731
          const char* doc =
R"""(Callback function that processes an unrestricted update event.)""";
        } UnrestrictedUpdateCallback;
        // Symbol: drake::systems::UnrestrictedUpdateEvent::UnrestrictedUpdateEvent<T>
        struct /* ctor */ {
          // Source: drake/systems/framework/event.h:735
          const char* doc_0args =
R"""(Makes an UnrestrictedUpdateEvent with no trigger type, no event data,
and no specified callback function.)""";
          // Source: drake/systems/framework/event.h:739
          const char* doc_1args =
R"""(Makes a UnrestrictedUpdateEvent with no trigger type, no event data,
and the specified callback function.)""";
        } ctor;
        // Symbol: drake::systems::UnrestrictedUpdateEvent::handle
        struct /* handle */ {
          // Source: drake/systems/framework/event.h:761
          const char* doc =
R"""(Calls the optional callback function, if one exists, with ``context``,
``this`` and ``discrete_state``.)""";
        } handle;
        // Symbol: drake::systems::UnrestrictedUpdateEvent::is_discrete_update
        struct /* is_discrete_update */ {
          // Source: drake/systems/framework/event.h:724
          const char* doc = R"""()""";
        } is_discrete_update;
      } UnrestrictedUpdateEvent;
      // Symbol: drake::systems::UseDefaultName
      struct /* UseDefaultName */ {
        // Source: drake/systems/framework/framework_common.h:81
        const char* doc =
R"""((Advanced.) Tag type that indicates a system or port should use a
default name, instead of a user-provided name. Most users will use the
kUseDefaultName constant, without ever having to mention this type.)""";
      } UseDefaultName;
      // Symbol: drake::systems::VectorBase
      struct /* VectorBase */ {
        // Source: drake/systems/framework/vector_base.h:32
        const char* doc =
R"""(VectorBase is an abstract base class that real-valued signals between
Systems and real-valued System state vectors must implement. Classes
that inherit from VectorBase will typically provide names for the
elements of the vector, and may also provide other computations for
the convenience of Systems handling the signal. The vector is always a
column vector. It may or may not be contiguous in memory. Contiguous
subclasses should typically inherit from BasicVector, not from
VectorBase directly.)""";
        // Symbol: drake::systems::VectorBase::CopyToPreSizedVector
        struct /* CopyToPreSizedVector */ {
          // Source: drake/systems/framework/vector_base.h:135
          const char* doc =
R"""(Copies this entire VectorBase into a pre-sized Eigen Vector.

Implementations should ensure this operation is O(N) in the size of
the value.

Raises:
    RuntimeError if ``vec`` is the wrong size.)""";
        } CopyToPreSizedVector;
        // Symbol: drake::systems::VectorBase::CopyToVector
        struct /* CopyToVector */ {
          // Source: drake/systems/framework/vector_base.h:122
          const char* doc =
R"""(Copies this entire VectorBase into a contiguous Eigen Vector.

Implementations should ensure this operation is O(N) in the size of
the value and allocates only the O(N) memory that it returns.)""";
        } CopyToVector;
        // Symbol: drake::systems::VectorBase::DoGetAtIndexChecked
        struct /* DoGetAtIndexChecked */ {
          // Source: drake/systems/framework/vector_base.h:215
          const char* doc =
R"""(Implementations should ensure this operation is O(1) and allocates no
memory. The index has already been checked for negative, but not size.
Implementations must throw an exception when index >= size().)""";
        } DoGetAtIndexChecked;
        // Symbol: drake::systems::VectorBase::DoGetAtIndexUnchecked
        struct /* DoGetAtIndexUnchecked */ {
          // Source: drake/systems/framework/vector_base.h:206
          const char* doc =
R"""(Implementations should ensure this operation is O(1) and allocates no
memory. The index need not be validated when in release mode.)""";
        } DoGetAtIndexUnchecked;
        // Symbol: drake::systems::VectorBase::DoPlusEqScaled
        struct /* DoPlusEqScaled */ {
          // Source: drake/systems/framework/vector_base.h:233
          const char* doc =
R"""(Adds in multiple scaled vectors to this vector. All vectors are
guaranteed to be the same size.

You should override this method if possible with a more efficient
approach that leverages structure; the default implementation performs
element-by-element computations that are likely inefficient, but even
this implementation minimizes memory accesses for efficiency. If the
vector is contiguous, for example, implementations that leverage SIMD
operations should be far more efficient. Overriding implementations
should ensure that this operation remains O(N) in the size of the
value and allocates no memory.)""";
        } DoPlusEqScaled;
        // Symbol: drake::systems::VectorBase::GetAtIndex
        struct /* GetAtIndex */ {
          // Source: drake/systems/framework/vector_base.h:62
          const char* doc =
R"""(Returns the element at the given index in the vector.

Raises:
    RuntimeError if the index is >= size() or negative. Consider
    operator[]() instead if bounds-checking is unwanted.)""";
        } GetAtIndex;
        // Symbol: drake::systems::VectorBase::GetElementBounds
        struct /* GetElementBounds */ {
          // Source: drake/systems/framework/vector_base.h:195
          const char* doc =
R"""(Get the bounds for the elements. If lower and upper are both empty
size vectors, then there are no bounds. Otherwise, the bounds are
(*lower)(i) <= GetAtIndex(i) <= (*upper)(i) The default output is no
bounds.)""";
        } GetElementBounds;
        // Symbol: drake::systems::VectorBase::PlusEqScaled
        struct /* PlusEqScaled */ {
          // Source: drake/systems/framework/vector_base.h:161
          const char* doc_2args =
R"""(Add in scaled vector ``rhs`` to this vector.

Raises:
    RuntimeError if ``rhs`` is a different size than this.)""";
          // Source: drake/systems/framework/vector_base.h:167
          const char* doc_1args =
R"""(Add in multiple scaled vectors to this vector.

Raises:
    RuntimeError if any rhs are a different size than this.)""";
        } PlusEqScaled;
        // Symbol: drake::systems::VectorBase::ScaleAndAddToVector
        struct /* ScaleAndAddToVector */ {
          // Source: drake/systems/framework/vector_base.h:149
          const char* doc =
R"""(Adds a scaled version of this vector to Eigen vector ``vec``.

Raises:
    RuntimeError if ``vec`` is the wrong size.

Implementations should ensure this operation remains O(N) in the size
of the value and allocates no memory.)""";
        } ScaleAndAddToVector;
        // Symbol: drake::systems::VectorBase::SetAtIndex
        struct /* SetAtIndex */ {
          // Source: drake/systems/framework/vector_base.h:78
          const char* doc =
R"""(Replaces the state at the given index with the value.

Raises:
    RuntimeError if the index is >= size(). Consider operator[]()
    instead if bounds-checking is unwanted.)""";
        } SetAtIndex;
        // Symbol: drake::systems::VectorBase::SetFrom
        struct /* SetFrom */ {
          // Source: drake/systems/framework/vector_base.h:88
          const char* doc =
R"""(Replaces the entire vector with the contents of ``value``.

Raises:
    RuntimeError if ``value`` is not a column vector with size() rows.

Implementations should ensure this operation is O(N) in the size of
the value and allocates no memory.)""";
        } SetFrom;
        // Symbol: drake::systems::VectorBase::SetFromVector
        struct /* SetFromVector */ {
          // Source: drake/systems/framework/vector_base.h:102
          const char* doc =
R"""(Replaces the entire vector with the contents of ``value``.

Raises:
    RuntimeError if ``value`` is not a column vector with size() rows.

Implementations should ensure this operation is O(N) in the size of
the value and allocates no memory.)""";
        } SetFromVector;
        // Symbol: drake::systems::VectorBase::SetZero
        struct /* SetZero */ {
          // Source: drake/systems/framework/vector_base.h:111
          const char* doc =
R"""(Sets all elements of this vector to zero.)""";
        } SetZero;
        // Symbol: drake::systems::VectorBase::ThrowMismatchedSize
        struct /* ThrowMismatchedSize */ {
          // Source: drake/systems/framework/vector_base.h:251
          const char* doc = R"""()""";
        } ThrowMismatchedSize;
        // Symbol: drake::systems::VectorBase::ThrowOutOfRange
        struct /* ThrowOutOfRange */ {
          // Source: drake/systems/framework/vector_base.h:245
          const char* doc = R"""()""";
        } ThrowOutOfRange;
        // Symbol: drake::systems::VectorBase::VectorBase<T>
        struct /* ctor */ {
          // Source: drake/systems/framework/vector_base.h:35
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::systems::VectorBase::operator+=
        struct /* operator_iadd */ {
          // Source: drake/systems/framework/vector_base.h:181
          const char* doc =
R"""(Add in vector ``rhs`` to this vector.

Raises:
    RuntimeError if ``rhs`` is a different size than this.)""";
        } operator_iadd;
        // Symbol: drake::systems::VectorBase::operator-=
        struct /* operator_isub */ {
          // Source: drake/systems/framework/vector_base.h:187
          const char* doc =
R"""(Subtract in vector ``rhs`` to this vector.

Raises:
    RuntimeError if ``rhs`` is a different size than this.)""";
        } operator_isub;
        // Symbol: drake::systems::VectorBase::operator[]
        struct /* operator_array */ {
          // Source: drake/systems/framework/vector_base.h:47
          const char* doc =
R"""(Returns the element at the given index in the vector.

Precondition:
    0 <= ``index`` < size())""";
        } operator_array;
        // Symbol: drake::systems::VectorBase::size
        struct /* size */ {
          // Source: drake/systems/framework/vector_base.h:43
          const char* doc =
R"""(Returns the number of elements in the vector.

Implementations should ensure this operation is O(1) and allocates no
memory.)""";
        } size;
      } VectorBase;
      // Symbol: drake::systems::VectorSystem
      struct /* VectorSystem */ {
        // Source: drake/systems/framework/vector_system.h:32
        const char* doc =
R"""(A base class that specializes LeafSystem for use with only zero or one
vector input ports, and only zero or one vector output ports.

By default, this base class does not declare any state; subclasses may
optionally declare continuous or discrete state, but not both;
subclasses may not declare abstract state.)""";
        // Symbol: drake::systems::VectorSystem::CalcVectorOutput
        struct /* CalcVectorOutput */ {
          // Source: drake/systems/framework/vector_system.h:196
          const char* doc =
R"""(Converts the parameters to Eigen::VectorBlock form, then delegates to
DoCalcVectorOutput().)""";
        } CalcVectorOutput;
        // Symbol: drake::systems::VectorSystem::DoCalcDiscreteVariableUpdates
        struct /* DoCalcDiscreteVariableUpdates */ {
          // Source: drake/systems/framework/vector_system.h:164
          const char* doc =
R"""(Converts the parameters to Eigen::VectorBlock form, then delegates to
DoCalcVectorDiscreteVariableUpdates().)""";
        } DoCalcDiscreteVariableUpdates;
        // Symbol: drake::systems::VectorSystem::DoCalcTimeDerivatives
        struct /* DoCalcTimeDerivatives */ {
          // Source: drake/systems/framework/vector_system.h:136
          const char* doc =
R"""(Converts the parameters to Eigen::VectorBlock form, then delegates to
DoCalcVectorTimeDerivatives().)""";
        } DoCalcTimeDerivatives;
        // Symbol: drake::systems::VectorSystem::DoCalcVectorDiscreteVariableUpdates
        struct /* DoCalcVectorDiscreteVariableUpdates */ {
          // Source: drake/systems/framework/vector_system.h:313
          const char* doc =
R"""(Provides a convenience method for VectorSystem subclasses. This method
performs the same logical operation as
System::DoCalcDiscreteVariableUpdates but provides VectorBlocks to
represent the input, discrete state, and discrete updates. Subclasses
should override this method, and not the base class method (which is
``final``).

The ``state`` will be either empty or the discrete state, depending on
whether discrete state was declared at context-creation time.

By default, this function does nothing if the ``next_state`` is empty,
and throws an exception otherwise.)""";
        } DoCalcVectorDiscreteVariableUpdates;
        // Symbol: drake::systems::VectorSystem::DoCalcVectorOutput
        struct /* DoCalcVectorOutput */ {
          // Source: drake/systems/framework/vector_system.h:273
          const char* doc =
R"""(Provides a convenience method for VectorSystem subclasses. This method
performs the same logical operation as System::DoCalcOutput but
provides VectorBlocks to represent the input, state, and output.
Subclasses with outputs should override this method, and not the base
class method (which is ``final``).

The ``state`` will be either empty, the continuous state, or the
discrete state, depending on which (or none) was declared at
context-creation time.

The ``input`` will be empty (zero-sized) when this System is declared
to be non-direct-feedthrough.

By default, this function does nothing if the ``output`` is empty, and
throws an exception otherwise.)""";
        } DoCalcVectorOutput;
        // Symbol: drake::systems::VectorSystem::DoCalcVectorTimeDerivatives
        struct /* DoCalcVectorTimeDerivatives */ {
          // Source: drake/systems/framework/vector_system.h:292
          const char* doc =
R"""(Provides a convenience method for VectorSystem subclasses. This method
performs the same logical operation as System::DoCalcTimeDerivatives
but provides VectorBlocks to represent the input, continuous state,
and derivatives. Subclasses should override this method, and not the
base class method (which is ``final``). The ``state`` will be either
empty or the continuous state, depending on whether continuous state
was declared at context-creation time.

By default, this function does nothing if the ``derivatives`` are
empty, and throws an exception otherwise.)""";
        } DoCalcVectorTimeDerivatives;
        // Symbol: drake::systems::VectorSystem::EvalVectorInput
        struct /* EvalVectorInput */ {
          // Source: drake/systems/framework/vector_system.h:106
          const char* doc =
R"""(Causes the vector-valued input port to become up-to-date, and returns
the port's value as an Eigen vector. If the system has zero inputs,
then returns an empty vector.)""";
        } EvalVectorInput;
        // Symbol: drake::systems::VectorSystem::GetVectorState
        struct /* GetVectorState */ {
          // Source: drake/systems/framework/vector_system.h:118
          const char* doc =
R"""(Returns a reference to an Eigen vector version of the state from
within the Context.)""";
        } GetVectorState;
        // Symbol: drake::systems::VectorSystem::VectorSystem<T>
        struct /* ctor */ {
          // Source: drake/systems/framework/vector_system.h:52
          const char* doc_3args =
R"""(Creates a system with one input port and one output port of the given
sizes, when the sizes are non-zero. Either size can be zero, in which
case no input (or output) port is created.

The ``direct_feedthrough`` specifies whether the input port direct
feeds through to the output port. (See
SystemBase::GetDirectFeedthroughs().) When not provided, assumes true
(the output is direct feedthrough). When false, the DoCalcVectorOutput
``input`` will be empty (zero-sized).

Does *not* declare scalar-type conversion support (AutoDiff, etc.). To
enable AutoDiff support, use the SystemScalarConverter-based
constructor. (For that, see system_scalar_conversion at the example
titled "Example using drake::systems::VectorSystem as the base
class".))""";
          // Source: drake/systems/framework/vector_system.h:75
          const char* doc_4args =
R"""(Creates a system with one input port and one output port of the given
sizes, when the sizes are non-zero. Either size can be zero, in which
case no input (or output) port is created. This constructor allows
subclasses to declare scalar-type conversion support (AutoDiff, etc.).

The ``direct_feedthrough`` specifies whether the input port direct
feeds through to the output port. (See
SystemBase::GetDirectFeedthroughs().) When not provided, infers
feedthrough from the symbolic form if available, or else assumes true
(the output is direct feedthrough). When false, the DoCalcVectorOutput
``input`` will be empty (zero-sized).

The scalar-type conversion support will use ``converter``. To enable
scalar-type conversion support, pass a ``SystemTypeTag<S>{}`` where
``S`` must be the exact class of ``this`` being constructed.

See system_scalar_conversion for detailed background and examples
related to scalar-type conversion support, especially the example
titled "Example using drake::systems::VectorSystem as the base class".)""";
        } ctor;
      } VectorSystem;
      // Symbol: drake::systems::VelocityImplicitEulerIntegrator
      struct /* VelocityImplicitEulerIntegrator */ {
        // Source: drake/systems/analysis/velocity_implicit_euler_integrator.h:134
        const char* doc =
R"""(A first-order, fully implicit integrator optimized for second-order
systems, with a second-order error estimate.

The velocity-implicit Euler integrator is a variant of the first-order
implicit Euler that takes advantage of the simple mapping q̇ = N(q) v
of second order systems to formulate a smaller problem in velocities
(and miscellaneous states if any) only. For systems with second-order
dynamics, VelocityImplicitEulerIntegrator formulates a problem that is
half as large as that formulated by Drake's ImplicitEulerIntegrator,
resulting in improved run-time performance. Upon convergence of the
resulting system of equations, this method provides the same
discretization as ImplicitEulerIntegrator, but at a fraction of the
computational cost.

This integrator requires a system of ordinary differential equations
(ODEs) in state ``x = (q,v,z)`` to be expressible in the following
form:

q̇ = N(q) v; (1) ẏ = f_y(t,q,y), (2) where ``q̇`` and ``v`` are
linearly related via the kinematic mapping ``N(q)``, `y = (v,z)``, and
`f_y`` is a function that can depend on the time and state.

Implicit Euler uses the following update rule at time step n:

qⁿ⁺¹ = qⁿ + h N(qⁿ⁺¹) vⁿ⁺¹; (3) yⁿ⁺¹ = yⁿ + h f_y(tⁿ⁺¹,qⁿ⁺¹,yⁿ⁺¹). (4)

To solve the nonlinear system for ``(qⁿ⁺¹,yⁿ⁺¹)``, the
velocity-implicit Euler integrator iterates with a modified Newton's
method: At iteration ``k``, it finds a ``(qₖ₊₁,yₖ₊₁)`` that attempts
to satisfy

qₖ₊₁ = qⁿ + h N(qₖ) vₖ₊₁. (5) yₖ₊₁ = yⁿ + h f_y(tⁿ⁺¹,qₖ₊₁,yₖ₊₁); (6)

In this notation, the ``n`'s index timesteps, while the `k`'s index
the specific Newton-Raphson iterations within each time step.

Notice that we've intentionally lagged N(qₖ) one iteration behind in
Eq (5). This allows it to substitute (5) into (6) to obtain a
non-linear system in `y`` only. Contrast this strategy with the one
implemented by ImplicitEulerIntegrator, which solves a larger
non-linear system in the full state x.

To find a ``(qₖ₊₁,yₖ₊₁)`` that approximately satisfies (5-6), we
linearize the system (5-6) to compute a Newton step. Define

ℓ(y) = f_y(tⁿ⁺¹,qⁿ + h N(qₖ) v,y), (7) Jₗ(y) = ∂ℓ(y) / ∂y. (8)

To advance the Newton step, the velocity-implicit Euler integrator
solves the following linear equation for ``Δy``:

(I - h Jₗ) Δy = - R(yₖ), (9) where ``R(y) = y - yⁿ - h ℓ(y)`` and ``Δy
= yₖ₊₁ - yₖ``. The ``Δy`` solution directly gives us ``yₖ₊₁``. It then
substitutes the ``vₖ₊₁`` component of ``yₖ₊₁`` in (5) to get ``qₖ₊₁``.

This implementation uses a Newton method and relies upon the
convergence to a solution for ``y`` in ``R(y) = 0`` where ``R(y) = y -
yⁿ - h ℓ(y)`` as ``h`` becomes sufficiently small. General
implementational details for the Newton method were gleaned from
Section IV.8 in [Hairer, 1996].

**** Error Estimation

In this integrator, we simultaneously take a large step at the
requested step size of h as well as two half-sized steps each with
step size ``h/2``. The result from two half-sized steps is propagated
as the solution, while the difference between the two results is used
as the error estimate for the propagated solution. This error estimate
is accurate to the second order.

To be precise, let ``x̅ⁿ⁺¹`` be the computed solution from a large
step, ``x̃ⁿ⁺¹`` be the computed solution from two small steps, and
``xⁿ⁺¹`` be the true solution. Since the integrator propagates
``x̃ⁿ⁺¹`` as its solution, we denote the true error vector as ``ε =
x̃ⁿ⁺¹ - xⁿ⁺¹``. VelocityImplicitEulerIntegrator uses ``ε* = x̅ⁿ⁺¹ -
x̃ⁿ⁺¹``, the difference between the two solutions, as the second-order
error estimate, because for a smooth system, ``‖ε*‖ = O(h²)``, and
``‖ε - ε*‖ = O(h³)``. See the notes in
VelocityImplicitEulerIntegrator<T>::get_error_estimate_order() for a
detailed derivation of the error estimate's truncation error.

In this implementation, VelocityImplicitEulerIntegrator<T> attempts
the large full-sized step before attempting the two small half-sized
steps, because the large step is more likely to fail to converge, and
if it is performed first, convergence failures are detected early,
avoiding the unnecessary effort of computing potentially-successful
small steps.

- [Hairer, 1996]   E. Hairer and G. Wanner. Solving Ordinary Differential
                   Equations II (Stiff and Differential-Algebraic Problems).
                   Springer, 1996, Section IV.8, p. 118–130.

Note:
    In the statistics reported by IntegratorBase, all statistics that
    deal with the number of steps or the step sizes will track the
    large full-sized steps. This is because the large full-sized ``h``
    is the smallest irrevocable time-increment advanced by this
    integrator: if, for example, the second small half-sized step
    fails, this integrator revokes to the state before the first small
    step. This behavior is similar to other integrators with
    multi-stage evaluation: the step-counting statistics treat a
    "step" as the combination of all the stages.

Note:
    Furthermore, because the small half-sized steps are propagated as
    the solution, the large full-sized step is the error estimator,
    and the error estimation statistics track the effort during the
    large full-sized step. If the integrator is not in full-Newton
    mode (see ImplicitIntegrator<T>::set_use_full_newton()), most of
    the work incurred by constructing and factorizing matrices and by
    failing Newton-Raphson iterations will be counted toward the error
    estimation statistics, because the large step is performed first.

Note:
    This integrator uses the integrator accuracy setting, even when
    run in fixed-step mode, to limit the error in the underlying
    Newton-Raphson process. See IntegratorBase::set_target_accuracy()
    for more info.

See also:
    ImplicitIntegrator class documentation for information about
    implicit integration methods in general.

See also:
    ImplicitEulerIntegrator class documentation for information about
    the "implicit Euler" integration method.)""";
        // Symbol: drake::systems::VelocityImplicitEulerIntegrator::VelocityImplicitEulerIntegrator<T>
        struct /* ctor */ {
          // Source: drake/systems/analysis/velocity_implicit_euler_integrator.h:136
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::systems::VelocityImplicitEulerIntegrator::get_error_estimate_order
        struct /* get_error_estimate_order */ {
          // Source: drake/systems/analysis/velocity_implicit_euler_integrator.h:292
          const char* doc =
R"""(Returns the asymptotic order of the difference between the large and
small steps (from which the error estimate is computed), which is 2.
That is, the error estimate, ``ε* = x̅ⁿ⁺¹ - x̃ⁿ⁺¹`` has the property
that ``‖ε*‖ = O(h²)``, and it deviates from the true error, ``ε``, by
``‖ε - ε*‖ = O(h³)``.

**** Derivation of the asymptotic order

To derive the second-order error estimate, let us first define the
vector- valued function ``e(tⁿ, h, xⁿ) = x̅ⁿ⁺¹ - xⁿ⁺¹``, the local
truncation error for a single, full-sized velocity-implicit Euler
integration step, with initial conditions ``(tⁿ, xⁿ)``, and a step
size of ``h``. Furthermore, use ``ẍ`` to denote ``df/dt``, and ``∇f``
and ``∇ẍ`` to denote the Jacobians ``df/dx`` and ``dẍ/dx`` of the
ODE system ``ẋ = f(t, x)``. Note that ``ẍ`` uses a total time
derivative, i.e., ``ẍ = ∂f/∂t + ∇f f``.

Let us use ``x*`` to denote the true solution after a half-step,
``x(tⁿ+½h)``, and ``x̃*`` to denote the velocity-implicit Euler
solution after a single half-sized step. Furthermore, let us use
``xⁿ*¹`` to denote the true solution of the system at time ``t =
tⁿ+h`` if the system were at ``x̃*`` when ``t = tⁿ+½h``. See the
following diagram for an illustration.

Legend: ───── propagation along the true system :···· propagation
using implicit Euler with a half step :---- propagation using implicit
Euler with a full step

Time tⁿ tⁿ+½h tⁿ+h

State :----------------------- x̅ⁿ⁺¹ <─── used for error estimation :
: : : :·········· x̃ⁿ⁺¹ <─── propagated result : : :········· x̃*
─────── xⁿ*¹ : xⁿ ─────── x* ─────── xⁿ⁺¹ <─── true solution

We will use superscripts to denote evaluating an expression with ``x``
at that subscript and ``t`` at the corresponding time, e.g. ``ẍⁿ``
denotes ``ẍ(tⁿ, xⁿ)``, and ``f*`` denotes ``f(tⁿ+½h, x*)``. We first
present a shortened derivation, followed by the longer, detailed
version.

We know the local truncation error for the implicit Euler method is:

e(tⁿ, h, xⁿ) = x̅ⁿ⁺¹ - xⁿ⁺¹ = ½ h²ẍⁿ + O(h³). (10)

The local truncation error ε from taking two half steps is composed of
these two terms:

e₁ = xⁿ*¹ - xⁿ⁺¹ = (1/8) h²ẍⁿ + O(h³), (15) e₂ = x̃ⁿ⁺¹ - xⁿ*¹ = (1/8)
h²ẍⁿ + O(h³). (20)

Taking the sum,

ε = x̃ⁿ⁺¹ - xⁿ⁺¹ = e₁ + e₂ = (1/4) h²ẍⁿ + O(h³). (21)

These two estimations allow us to obtain an estimation of the local
error from the difference between the available quantities x̅ⁿ⁺¹ and
x̃ⁿ⁺¹:

ε* = x̅ⁿ⁺¹ - x̃ⁿ⁺¹ = e(tⁿ, h, xⁿ) - ε, = (1/4) h²ẍⁿ + O(h³), (22)

and therefore our error estimate is second order.

Below we will show this derivation in detail along with the proof that
``‖ε - ε*‖ = O(h³)``:

Let us look at a single velocity-implicit Euler step. Upon
Newton-Raphson convergence, the truncation error for velocity-implicit
Euler, which is the same as the truncation error for implicit Euler
(because both methods solve Eqs. (3-4)), is

e(tⁿ, h, xⁿ) = ½ h²ẍⁿ⁺¹ + O(h³) = ½ h²ẍⁿ + O(h³). (10)

To see why the two are equivalent, we can Taylor expand about ``(tⁿ,
xⁿ)``,

ẍⁿ⁺¹ = ẍⁿ + h dẍ/dtⁿ + O(h²) = ẍⁿ + O(h). e(tⁿ, h, xⁿ) = ½ h²ẍⁿ⁺¹
+ O(h³) = ½ h²(ẍⁿ + O(h)) + O(h³) = ½ h²ẍⁿ + O(h³).

Moving on with our derivation, after one small half-sized implicit
Euler step, the solution ``x̃*`` is

x̃* = x* + e(tⁿ, ½h, xⁿ) = x* + (1/8) h²ẍⁿ + O(h³), x̃* - x* = (1/8)
h²ẍⁿ + O(h³). (11)

Taylor expanding about ``t = tⁿ+½h`` in this ``x = x̃*`` alternate
reality,

xⁿ*¹ = x̃* + ½h f(tⁿ+½h, x̃*) + O(h²). (12)

Similarly, Taylor expansions about ``t = tⁿ+½h`` and the true solution
``x = x*`` also give us

xⁿ⁺¹ = x* + ½h f* + O(h²), (13) f(tⁿ+½h, x̃*) = f* + (∇f*) (x̃* - x*)
+ O(‖x̃* - x*‖²) = f* + O(h²), (14) where in the last line we
substituted Eq. (11).

Eq. (12) minus Eq. (13) gives us,

xⁿ*¹ - xⁿ⁺¹ = x̃* - x* + ½h(f(tⁿ+½h, x̃*) - f*) + O(h³), = x̃* - x* +
O(h³), where we just substituted in Eq. (14). Finally, substituting in
Eq. (11),

e₁ = xⁿ*¹ - xⁿ⁺¹ = (1/8) h²ẍⁿ + O(h³). (15)

After the second small step, the solution ``x̃ⁿ⁺¹`` is

x̃ⁿ⁺¹ = xⁿ*¹ + e(tⁿ+½h, ½h, x̃*), = xⁿ*¹ + (1/8)h² ẍ(tⁿ+½h, x̃*) +
O(h³). (16)

Taking Taylor expansions about ``(tⁿ, xⁿ)``,

x* = xⁿ + ½h fⁿ + O(h²) = xⁿ + O(h). (17) x̃* - xⁿ = (x̃* - x*) + (x*
- xⁿ) = O(h), (18) where we substituted in Eqs. (11) and (17), and

ẍ(tⁿ+½h, x̃*) = ẍⁿ + ½h ∂ẍ/∂tⁿ + ∇ẍⁿ (x̃* - xⁿ) + O(h ‖x̃* - xⁿ‖)
= ẍⁿ + O(h), (19) where we substituted in Eq. (18).

Substituting Eqs. (19) and (15) into Eq. (16),

x̃ⁿ⁺¹ = xⁿ*¹ + (1/8) h²ẍⁿ + O(h³) (20) = xⁿ⁺¹ + (1/4) h²ẍⁿ + O(h³),
therefore

ε = x̃ⁿ⁺¹ - xⁿ⁺¹ = (1/4) h² ẍⁿ + O(h³). (21)

Subtracting Eq. (21) from Eq. (10),

e(tⁿ, h, xⁿ) - ε = (½ - 1/4) h²ẍⁿ + O(h³); ⇒ ε* = x̅ⁿ⁺¹ - x̃ⁿ⁺¹ =
(1/4) h²ẍⁿ + O(h³). (22)

Eq. (22) shows that our error estimate is second-order. Since the
first term on the RHS matches ``ε`` (Eq. (21)),

ε* = ε + O(h³). (23))""";
        } get_error_estimate_order;
        // Symbol: drake::systems::VelocityImplicitEulerIntegrator::supports_error_estimation
        struct /* supports_error_estimation */ {
          // Source: drake/systems/analysis/velocity_implicit_euler_integrator.h:147
          const char* doc =
R"""(Returns true, because this integrator supports error estimation.)""";
        } supports_error_estimation;
      } VelocityImplicitEulerIntegrator;
      // Symbol: drake::systems::WitnessFunction
      struct /* WitnessFunction */ {
        // Source: drake/systems/framework/witness_function.h:94
        const char* doc =
R"""(Class that stores a function that is able to help determine the time
and state at which a step of the initial value problem integration of
a System should end, which may be done for any number of purposes,
including publishing or state reinitialization (i.e., event handling).
System authors declare witness functions through
LeafSystem::MakeWitnessFunction().

For the ensuing discussion, consider two times (``t₀`` and ``t₁ >
t₀``) and states corresponding to those times (``x(t₀)`` and
``x(t₁)``). A witness function, ``w(t, x)``, "triggers" only when it
crosses zero at a time ``t*`` where ``t₀ < t* ≤ t₁``. Note the
half-open interval. For an example of a witness function, consider the
"signed distance" (i.e., Euclidean distance when bodies are disjoint
and minimum translational distance when bodies intersect) between two
rigid bodies; this witness function can be used to determine both the
time of impact for rigid bodies and their states at that time of
impact.

Precision in the definition of the witness function is necessary,
because we want the witness function to trigger only once if, for
example, ``w(t₀, x(t₀)) ≠ 0``, `w(t₁, x(t₁)) = 0`, and ``w(t₂, x(t₂))
≠ 0``, for some t₂ > t₁. In other words, if the witness function is
evaluated over the intervals [t₀, t₁] and [t₁, t₂], meaning that the
zero occurs precisely at an interval endpoint, the witness function
should trigger once. Similarly, the witness function should trigger
exactly once if ``w(t₀, x(t₀)) ≠ 0``, `w(t*, x(t*)) = 0`, and ``w(t₁,
x(t₁)) = 0``, for ``t* ∈ (t₀, t₁)``. We can define the trigger
condition formally over interval ``[t₀, t₁]`` using the function:


::

    T(w, t₀, x(t₀), t₁) =   1   if w(t₀, x(t₀)) ≠ 0 and
                                   w(t₀, x(t₀))⋅w(t₁, x(t₁)) ≤ 0
                            0   if w(t₀, x(t₀)) = 0 or
                                   w(t₀, x(t₀))⋅w(t₁, x(t₁)) > 0

We wish for the witness function to trigger if the trigger function
evaluates to one. The trigger function can be further modified, if
desired, to incorporate the constraint that the witness function
should trigger only when crossing from positive values to negative
values, or vice versa.

A good witness function should not cross zero repeatedly over a small
interval of time (relative to the maximum designated integration step
size) or over small changes in state; when a witness function has been
"bracketed" over an interval of time (i.e., it changes sign), that
witness function will ideally cross zero only once in that interval.

A witness function trigger time is isolated only to a small interval
of time (as described in Simulator). The disadvantage of this scheme
is that it always requires the length of the interval to be reduced to
the requisite length *and that each function evaluation (which
requires numerical integration) is extraordinarily expensive*. If, for
example, the (slow) bisection algorithm were used to isolate the time
interval, the number of integrations necessary to cut the interval
from a length of ℓ to a length of ε will be log₂(ℓ / ε). Bisection is
just one of several possible algorithms for isolating the time
interval, though it's a reliable choice and always converges linearly.)""";
        // Symbol: drake::systems::WitnessFunction::CalcCallback
        struct /* CalcCallback */ {
          // Source: drake/systems/framework/witness_function.h:100
          const char* doc =
R"""(Signature of a function suitable for calculating a value of a
particular witness function.)""";
        } CalcCallback;
        // Symbol: drake::systems::WitnessFunction::CalcWitnessValue
        struct /* CalcWitnessValue */ {
          // Source: drake/systems/framework/witness_function.h:173
          const char* doc =
R"""(Evaluates the witness function at the given context.)""";
        } CalcWitnessValue;
        // Symbol: drake::systems::WitnessFunction::WitnessFunction<T>
        struct /* ctor */ {
          // Source: drake/systems/framework/witness_function.h:96
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::systems::WitnessFunction::description
        struct /* description */ {
          // Source: drake/systems/framework/witness_function.h:167
          const char* doc =
R"""(Gets the description of this witness function (used primarily for
logging and debugging).)""";
        } description;
        // Symbol: drake::systems::WitnessFunction::direction_type
        struct /* direction_type */ {
          // Source: drake/systems/framework/witness_function.h:170
          const char* doc =
R"""(Gets the direction(s) under which this witness function triggers.)""";
        } direction_type;
        // Symbol: drake::systems::WitnessFunction::get_event
        struct /* get_event */ {
          // Source: drake/systems/framework/witness_function.h:207
          const char* doc =
R"""(Gets the event that will be dispatched when the witness function
triggers. A null pointer indicates that no event will be dispatched.)""";
        } get_event;
        // Symbol: drake::systems::WitnessFunction::get_mutable_event
        struct /* get_mutable_event */ {
          // Source: drake/systems/framework/witness_function.h:211
          const char* doc =
R"""(Gets a mutable pointer to the event that will occur when the witness
function triggers.)""";
        } get_mutable_event;
        // Symbol: drake::systems::WitnessFunction::get_system
        struct /* get_system */ {
          // Source: drake/systems/framework/witness_function.h:179
          const char* doc =
R"""(Gets a reference to the System used by this witness function.)""";
        } get_system;
        // Symbol: drake::systems::WitnessFunction::should_trigger
        struct /* should_trigger */ {
          // Source: drake/systems/framework/witness_function.h:184
          const char* doc =
R"""(Checks whether the witness function should trigger using given values
at w0 and wf. Note that this function is not specific to a particular
witness function.)""";
        } should_trigger;
      } WitnessFunction;
      // Symbol: drake::systems::WitnessFunctionDirection
      struct /* WitnessFunctionDirection */ {
        // Source: drake/systems/framework/witness_function.h:21
        const char* doc = R"""()""";
        // Symbol: drake::systems::WitnessFunctionDirection::kCrossesZero
        struct /* kCrossesZero */ {
          // Source: drake/systems/framework/witness_function.h:37
          const char* doc =
R"""(Witness function triggers *any time* the function crosses/touches
zero, *except* when the witness function evaluates to zero at the
beginning of the interval. Conceptually equivalent to
kPositiveThenNonNegative OR kNegativeThenNonNegative.)""";
        } kCrossesZero;
        // Symbol: drake::systems::WitnessFunctionDirection::kNegativeThenNonNegative
        struct /* kNegativeThenNonNegative */ {
          // Source: drake/systems/framework/witness_function.h:31
          const char* doc =
R"""(Witness function triggers when the function crosses or touches zero
after an initial negative evaluation.)""";
        } kNegativeThenNonNegative;
        // Symbol: drake::systems::WitnessFunctionDirection::kNone
        struct /* kNone */ {
          // Source: drake/systems/framework/witness_function.h:23
          const char* doc =
R"""(This witness function will never be triggered.)""";
        } kNone;
        // Symbol: drake::systems::WitnessFunctionDirection::kPositiveThenNonPositive
        struct /* kPositiveThenNonPositive */ {
          // Source: drake/systems/framework/witness_function.h:27
          const char* doc =
R"""(Witness function triggers when the function crosses or touches zero
after an initial positive evaluation.)""";
        } kPositiveThenNonPositive;
      } WitnessFunctionDirection;
      // Symbol: drake::systems::WitnessTriggeredEventData
      struct /* WitnessTriggeredEventData */ {
        // Source: drake/systems/framework/event.h:290
        const char* doc =
R"""(Class for storing data from a witness function triggering to be passed
to event handlers. A witness function isolates the time to a
(typically small) window during which the witness function crosses
zero. The time and state at both sides of this window are passed to
the event handler so that the system can precisely determine the
reason that the witness function triggered.)""";
        // Symbol: drake::systems::WitnessTriggeredEventData::WitnessTriggeredEventData<T>
        struct /* ctor */ {
          // Source: drake/systems/framework/event.h:292
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::systems::WitnessTriggeredEventData::set_t0
        struct /* set_t0 */ {
          // Source: drake/systems/framework/event.h:311
          const char* doc =
R"""(Sets the time at the left end of the window. Note that ``t0`` should
be smaller than ``tf`` after both values are set.)""";
        } set_t0;
        // Symbol: drake::systems::WitnessTriggeredEventData::set_tf
        struct /* set_tf */ {
          // Source: drake/systems/framework/event.h:319
          const char* doc =
R"""(Sets the time at the right end of the window. Note that ``tf`` should
be larger than ``t0`` after both values are set.)""";
        } set_tf;
        // Symbol: drake::systems::WitnessTriggeredEventData::set_triggered_witness
        struct /* set_triggered_witness */ {
          // Source: drake/systems/framework/event.h:301
          const char* doc =
R"""(Sets the witness function that triggered the event handler.)""";
        } set_triggered_witness;
        // Symbol: drake::systems::WitnessTriggeredEventData::set_xc0
        struct /* set_xc0 */ {
          // Source: drake/systems/framework/event.h:327
          const char* doc =
R"""(Sets a pointer to the continuous state at the left end of the
isolation window.)""";
        } set_xc0;
        // Symbol: drake::systems::WitnessTriggeredEventData::set_xcf
        struct /* set_xcf */ {
          // Source: drake/systems/framework/event.h:335
          const char* doc =
R"""(Sets a pointer to the continuous state at the right end of the
isolation window.)""";
        } set_xcf;
        // Symbol: drake::systems::WitnessTriggeredEventData::t0
        struct /* t0 */ {
          // Source: drake/systems/framework/event.h:307
          const char* doc =
R"""(Gets the time at the left end of the window. Default is NaN (which
indicates that the value is invalid).)""";
        } t0;
        // Symbol: drake::systems::WitnessTriggeredEventData::tf
        struct /* tf */ {
          // Source: drake/systems/framework/event.h:315
          const char* doc =
R"""(Gets the time at the right end of the window. Default is NaN (which
indicates that the value is invalid).)""";
        } tf;
        // Symbol: drake::systems::WitnessTriggeredEventData::triggered_witness
        struct /* triggered_witness */ {
          // Source: drake/systems/framework/event.h:296
          const char* doc =
R"""(Gets the witness function that triggered the event handler.)""";
        } triggered_witness;
        // Symbol: drake::systems::WitnessTriggeredEventData::xc0
        struct /* xc0 */ {
          // Source: drake/systems/framework/event.h:323
          const char* doc =
R"""(Gets a pointer to the continuous state at the left end of the
isolation window.)""";
        } xc0;
        // Symbol: drake::systems::WitnessTriggeredEventData::xcf
        struct /* xcf */ {
          // Source: drake/systems/framework/event.h:331
          const char* doc =
R"""(Gets a pointer to the continuous state at the right end of the
isolation window.)""";
        } xcf;
      } WitnessTriggeredEventData;
      // Symbol: drake::systems::WrapToSystem
      struct /* WrapToSystem */ {
        // Source: drake/systems/primitives/wrap_to_system.h:23
        const char* doc =
R"""(An element-wise wrapping block that transforms the specified indices
of the input signal ``u`` into the interval ``[low, high)``.
Precisely, the output element ``i`` is given the value:


::

    outputᵢ = inputᵢ + kᵢ*(highᵢ-lowᵢ)

for the unique integer value ``kᵢ`` that lands the output in the
desired interval.)""";
        // Symbol: drake::systems::WrapToSystem::WrapToSystem<T>
        struct /* ctor */ {
          // Source: drake/systems/primitives/wrap_to_system.h:30
          const char* doc =
R"""(Constructs a system to pass through a fixed-size input vector to the
output. Additional calls to set_interval() are required to produce any
wrapping behavior.)""";
        } ctor;
        // Symbol: drake::systems::WrapToSystem::get_size
        struct /* get_size */ {
          // Source: drake/systems/primitives/wrap_to_system.h:39
          const char* doc = R"""(Returns the size.)""";
        } get_size;
        // Symbol: drake::systems::WrapToSystem::set_interval
        struct /* set_interval */ {
          // Source: drake/systems/primitives/wrap_to_system.h:36
          const char* doc =
R"""(Sets the system to wrap the ``index`` element of the input vector to
the interval ``[low, high)``. If this method is called multiple times
for the same index, then only the last interval will be used. ``low``
and ``high`` should be finite, and low < high.)""";
        } set_interval;
      } WrapToSystem;
      // Symbol: drake::systems::ZeroOrderHold
      struct /* ZeroOrderHold */ {
        // Source: drake/systems/primitives/zero_order_hold.h:49
        const char* doc =
R"""(A zero order hold block with input u, which may be vector-valued
(discrete or continuous) or abstract, and discrete output y, where the
y is sampled from u with a fixed period.

.. pydrake_system::

    name: ZeroOrderHold
    input_ports:
    - u
    output_ports:
    - y

The discrete state space dynamics of ZeroOrderHold is:


::

    xₙ₊₁ = uₙ     // update
      yₙ   = xₙ     // output
      x₀   = xᵢₙᵢₜ  // initialize

where xᵢₙᵢₜ = 0 for vector-valued ZeroOrderHold, and xᵢₙᵢₜ is a given
value for abstract-valued ZeroOrderHold.

See discrete_systems "Discrete Systems" for general information about
discrete systems in Drake, including how they interact with continuous
systems.

Note:
    This system uses a periodic update with zero offset, so the first
    update occurs at t=0. When used with a Simulator, the output port
    is equal to xᵢₙᵢₜ after simulator.Initialize(), but is immediately
    updated to u₀ at the start of the first step. If you want to force
    that initial update, use simulator.AdvanceTo(0.).

Note:
    For an abstract-valued ZeroOrderHold, scalar-type conversion is
    not supported since AbstractValue does not support it.)""";
        // Symbol: drake::systems::ZeroOrderHold::LatchInputPortToState
        struct /* LatchInputPortToState */ {
          // Source: drake/systems/primitives/zero_order_hold.h:80
          const char* doc =
R"""((Advanced) Manually sample the input port and copy ("latch") the value
into the state. This emulates an update event and is mostly useful for
testing.)""";
        } LatchInputPortToState;
        // Symbol: drake::systems::ZeroOrderHold::ZeroOrderHold<T>
        struct /* ctor */ {
          // Source: drake/systems/primitives/zero_order_hold.h:57
          const char* doc_2args_period_sec_vector_size =
R"""(Constructs a ZeroOrderHold system with the given ``period_sec``, over
a vector-valued input of size ``vector_size``. The default initial
value for this system will be zero. The offset is always zero, meaning
that the first update occurs at t=0.)""";
          // Source: drake/systems/primitives/zero_order_hold.h:64
          const char* doc_2args_period_sec_abstract_model_value =
R"""(Constructs a ZeroOrderHold system with the given ``period_sec``, over
a abstract-valued input ``abstract_model_value``. The default initial
value for this system will be ``abstract_model_value``. The offset is
always zero, meaning that the first update occurs at t=0.)""";
          // Source: drake/systems/primitives/zero_order_hold.h:70
          const char* doc_copyconvert =
R"""(Scalar-type converting copy constructor. See system_scalar_conversion.)""";
        } ctor;
        // Symbol: drake::systems::ZeroOrderHold::period
        struct /* period */ {
          // Source: drake/systems/primitives/zero_order_hold.h:75
          const char* doc =
R"""(Reports the period of this hold (in seconds).)""";
        } period;
      } ZeroOrderHold;
      // Symbol: drake::systems::analysis
      struct /* analysis */ {
        // Symbol: drake::systems::analysis::MonteCarloSimulation
        struct /* MonteCarloSimulation */ {
          // Source: drake/systems/analysis/monte_carlo.h:148
          const char* doc =
R"""(Generate samples of a scalar random variable output by running many
random simulations drawn from independent samples of the distributions
governing the stochastic simulation.

In pseudo-code, this algorithm implements:


::

    for i=1:num_samples
        const generator_snapshot = deepcopy(generator)
        output = RandomSimulation(..., generator)
        data(i) = std::pair(generator_snapshot, output)
      return data

See also:
    RandomSimulation() for details about ``make_simulator``,
    ``output``, and ``final_time``.

Parameter ``num_samples``:
    Number of independent samples to draw from the distribution (and
    equivalently, the number of simulations to run).

Parameter ``generator``:
    Random number generator to be used to generate the random samples.
    If null, then a new RandomGenerator will be allocated and used
    internally (and repeated calls to this method will return
    identical results). To produce statistically "independent" samples
    on a future call to MonteCarloSimulation, you should make repeated
    uses of the same RandomGenerator object.

Returns:
    a list of RandomSimulationResult's.)""";
        } MonteCarloSimulation;
        // Symbol: drake::systems::analysis::RandomSimulation
        struct /* RandomSimulation */ {
          // Source: drake/systems/analysis/monte_carlo.h:85
          const char* doc =
R"""(Run a deterministic simulation of a (stochastic) System using the
``generator`` to instantiate all "random" quantities.

In pseudo-code, this algorithm implements:


::

    simulator = make_simulator(generator)
      simulator.get_system().SetRandomContext(generator)
      simulator.AdvanceTo(final_time)
      return output(simulator.get_context())

Parameter ``make_simulator``:
    Callers to this method define a stochastic simulation by providing
    the ``make_simulator`` factory method to return a Simulator using
    the supplied RandomGenerator as the only source of randomness.
    This interface was designed to support cases where the
    System/Diagram is random (not only the Context), e.g. in the case
    where are variable number of objects are added to a multibody
    simulation.

Parameter ``output``:
    The scalar random variable output, denoted ``output``, is defined
    as a function of the Simulator's System's Context, evaluated at
    the ``final_time``. Monte-Carlo investigations that studying the
    details of an entire trajectory can still use this interface, e.g.
    by including a "runtime monitor" System that latches the
    worst-case deviation of a specification into it's Context to be
    queried at the final time.

Parameter ``final_time``:
    The time that each instance of the Simulator is stepped to. In
    many cases, this will be equivalent to the duration of the
    simulation, but it need not be because SetRandomContext() could
    initialize the time to a non-zero value, or an event could trigger
    premature termination of the simulation (see #4447).

Parameter ``generator``:
    Random number generator to be used to generate the random samples.

Returns:
    the ``output`` evaluated from the Context at ``final_time``.)""";
        } RandomSimulation;
        // Symbol: drake::systems::analysis::RandomSimulationResult
        struct /* RandomSimulationResult */ {
          // Source: drake/systems/analysis/monte_carlo.h:105
          const char* doc =
R"""(A snapshot of the generator used to produce the random simulation.
Use, e.g.,


::

    RandomGenerator generator(result.generator_snapshot)
      RandomSimulation(make_simulator, output, final_time, &generator)

for a deterministic playback of the sampled simulation. Use the
operator<<() operator>>() methods provided for the generator, which
implements the Standard Template Library <a href=
"https://en.cppreference.com/w/cpp/named_req/RandomNumberEngine">
RandomNumberEngine concept</a>, if you wish to serialize the results.
Note that the generator "snapshots" are returned as const, because any
non-const operations on that object may advance the state of the
generator (making it no-longer valuable in reproducing the
simulation).)""";
          // Symbol: drake::systems::analysis::RandomSimulationResult::RandomSimulationResult
          struct /* ctor */ {
            // Source: drake/systems/analysis/monte_carlo.h:106
            const char* doc = R"""()""";
          } ctor;
          // Symbol: drake::systems::analysis::RandomSimulationResult::generator_snapshot
          struct /* generator_snapshot */ {
            // Source: drake/systems/analysis/monte_carlo.h:110
            const char* doc = R"""()""";
          } generator_snapshot;
          // Symbol: drake::systems::analysis::RandomSimulationResult::output
          struct /* output */ {
            // Source: drake/systems/analysis/monte_carlo.h:111
            const char* doc = R"""()""";
          } output;
        } RandomSimulationResult;
        // Symbol: drake::systems::analysis::RegionOfAttraction
        struct /* RegionOfAttraction */ {
          // Source: drake/systems/analysis/region_of_attraction.h:63
          const char* doc =
R"""(Estimates the region of attraction of the time-invariant ``system`` at
the fixed point defined by ``context``.

This implementation only searches for the largest level set of the
``lyapunov_candidate`` function from ``options`` (or a candidate
obtained from solving the Lyapunov equation on the linearization).

Parameter ``system``:
    a time-invariant continuous-time System that supports scalar-type
    conversion to symbolic::Expression. The dynamics of the system
    must be polynomial.

Parameter ``context``:
    a Context that defines the parameters of the system and the
    fixed-point about which we are analyzing the regional stability.

Parameter ``options``:
    provides a variety of configuration options.

See also:
    RegionOfAttractionOptions.

Returns:
    a symbolic::Expression representing a Lyapunov function using the
    symbolic Variables named x0, x1..., where the order matches the
    continuous state vector in the ``context``, or the vector
    state_variables passed in through the options structure (if it is
    non-empty). The level set {x | V(x)<=1} containing the fixed-point
    in ``context`` represents the region of attraction.

Note: There are more numerical techniques that we know how to apply
here. Do report an issue if you discover a system for which this code
does not perform well.)""";
        } RegionOfAttraction;
        // Symbol: drake::systems::analysis::RegionOfAttractionOptions
        struct /* RegionOfAttractionOptions */ {
          // Source: drake/systems/analysis/region_of_attraction.h:15
          const char* doc =
R"""(Consolidates the many possible options to be passed to the region of
attraction algorithm.)""";
          // Symbol: drake::systems::analysis::RegionOfAttractionOptions::RegionOfAttractionOptions
          struct /* ctor */ {
            // Source: drake/systems/analysis/region_of_attraction.h:16
            const char* doc = R"""()""";
          } ctor;
          // Symbol: drake::systems::analysis::RegionOfAttractionOptions::lyapunov_candidate
          struct /* lyapunov_candidate */ {
            // Source: drake/systems/analysis/region_of_attraction.h:22
            const char* doc =
R"""(A candidate Lyapunov function using the symbolic Variables named x0,
x1, ..., where the order matches the continuous state vector of the
system being evaluated (or the vector state_variables).)""";
          } lyapunov_candidate;
          // Symbol: drake::systems::analysis::RegionOfAttractionOptions::state_variables
          struct /* state_variables */ {
            // Source: drake/systems/analysis/region_of_attraction.h:29
            const char* doc =
R"""(If non-empty, a list of Variable that associates the variable name
with the elements of the System's continuous state vector. Must be
empty or have size equal to the number of continuous state variables
in the system.)""";
          } state_variables;
        } RegionOfAttractionOptions;
        // Symbol: drake::systems::analysis::SampleBasedLyapunovAnalysis
        struct /* SampleBasedLyapunovAnalysis */ {
          // Source: drake/systems/analysis/lyapunov.h:57
          const char* doc =
R"""(Sets up a linear program to search for the coefficients of a Lyapunov
function that satisfies the Lyapunov conditions at a set of sample
points. ∀xᵢ, V(xᵢ) ≥ 0, ∀xᵢ, V̇(xᵢ) = ∂V/∂x f(xᵢ) ≤ 0. In order to
provide boundary conditions to the problem, and improve numerical
conditioning, we additionally impose the constraint V(x₀) = 0, and add
an objective that pushes V̇(xᵢ) towards -1 (time-to-go): min ∑ |V̇(xᵢ)
+ 1|.

For background, and a description of this algorithm, see
http://underactuated.csail.mit.edu/underactuated.html?chapter=lyapunov
. It currently requires that the system to be optimized has only
continuous state and it is assumed to be time invariant.

Parameter ``system``:
    to be verified. We currently require that the system has only
    continuous state, and it is assumed to be time invariant. Unlike
    many analysis algorithms, the system does *not* need to support
    conversion to other ScalarTypes (double is sufficient).

Parameter ``context``:
    is used only to specify any parameters of the system, and to fix
    any input ports. The system/context must have all inputs assigned.

Parameter ``basis_functions``:
    must define an AutoDiffXd function that takes the state vector as
    an input argument and returns the vector of values of the basis
    functions at that state. The Lyapunov function will then have the
    form V(x) = ∑ pᵢ φᵢ(x), where ``p`` is the vector to be solved for
    and ``φ(x)`` is the vector of basis function evaluations returned
    by this function.

Parameter ``state_samples``:
    is a list of sample states (one per column) at which to apply the
    optimization constraints and the objective.

Parameter ``V_zero_state``:
    is a particular state, x₀, where we impose the condition: V(x₀) =
    0.

Returns:
    params the VectorXd of parameters, p, that satisfies the Lyapunov
    conditions described above. The resulting Lyapunov function is
    V(x) = ∑ pᵢ φᵢ(x),)""";
        } SampleBasedLyapunovAnalysis;
        // Symbol: drake::systems::analysis::ScalarSystemFunction
        struct /* ScalarSystemFunction */ {
          // Source: drake/systems/analysis/monte_carlo.h:44
          const char* doc =
R"""(Defines an arbitrary scalar function of the Context. This is used in
the RandomSimulation and MonteCarloSimulation tools below as a way of
defining the output random variable of interest -- the
ScalarSystemFunction is evaluated with the final conditions of the
simulation and the double that is returned is the value of the random
variable. (Although there is no randomness in the ScalarSystemFunction
itself, in the RandomSimulation case the final Context will be random,
so functions of that context will also be random).)""";
        } ScalarSystemFunction;
        // Symbol: drake::systems::analysis::SimulatorFactory
        struct /* SimulatorFactory */ {
          // Source: drake/systems/analysis/monte_carlo.h:30
          const char* doc =
R"""(Defines a factory method that constructs a Simulator (with an owned
System) using the supplied RandomGenerator as the only source of
randomness.

Note that in many interesting cases, the SimulatorFactory may simply
ignore the RandomGenerator argument and return the Simulator object
deterministically, because randomness may also be introduced *inside*
the simulation (by SetRandomContext and/or random input ports).

Also consider that the System referenced by the Simulator returned by
this method must have a lifetime that lasts beyond any calls this
Simulator. Having the Simulator own the System (by calling the
unique_ptr version of the constructor) is one convenient solution.)""";
        } SimulatorFactory;
      } analysis;
      // Symbol: drake::systems::controllers
      struct /* controllers */ {
        // Symbol: drake::systems::controllers::CartesianSetpoint
        struct /* CartesianSetpoint */ {
          // Source: drake/systems/controllers/setpoint.h:33
          const char* doc =
R"""(This is used to compute target spatial acceleration, which is the
input to the inverse dynamics controller. The target acceleration is
computed by: acceleration_d = Kp*(x* - x) + Kd*(xd* - xd) + xdd*,
where x is pose, xd is velocity, and xdd is acceleration. Variables
with superscript * are the set points, and Kp and Kd are the position
and velocity gains.

Pose "difference" is computed as: H^w_d = E * H^w_m, E = H^w_d *
H^w_m.inverse(), where H^w_d = desired orientation in the world frame,
H^w_m = measured orientation in the world frame, E = a small rotation
in the world frame from measured to desired.

The first terms 3 are angular accelerations, and the last 3 are linear
accelerations.)""";
          // Symbol: drake::systems::controllers::CartesianSetpoint::CartesianSetpoint<Scalar>
          struct /* ctor */ {
            // Source: drake/systems/controllers/setpoint.h:52
            const char* doc =
R"""(Parameter ``pose_d``:
    Desired pose

Parameter ``vel_d``:
    Desired velocity

Parameter ``acc_d``:
    Desired feedforward acceleration

Parameter ``Kp``:
    Position gain

Parameter ``Kd``:
    Velocity gain)""";
          } ctor;
          // Symbol: drake::systems::controllers::CartesianSetpoint::ComputeTargetAcceleration
          struct /* ComputeTargetAcceleration */ {
            // Source: drake/systems/controllers/setpoint.h:68
            const char* doc =
R"""(Computes target acceleration using PD feedback + feedfoward
acceleration.

Parameter ``pose``:
    Measured pose

Parameter ``vel``:
    Measured velocity

Returns:
    Computed spatial acceleration.)""";
          } ComputeTargetAcceleration;
          // Symbol: drake::systems::controllers::CartesianSetpoint::Kd
          struct /* Kd */ {
            // Source: drake/systems/controllers/setpoint.h:124
            const char* doc = R"""()""";
          } Kd;
          // Symbol: drake::systems::controllers::CartesianSetpoint::Kp
          struct /* Kp */ {
            // Source: drake/systems/controllers/setpoint.h:123
            const char* doc = R"""()""";
          } Kp;
          // Symbol: drake::systems::controllers::CartesianSetpoint::desired_acceleration
          struct /* desired_acceleration */ {
            // Source: drake/systems/controllers/setpoint.h:122
            const char* doc = R"""()""";
          } desired_acceleration;
          // Symbol: drake::systems::controllers::CartesianSetpoint::desired_pose
          struct /* desired_pose */ {
            // Source: drake/systems/controllers/setpoint.h:118
            const char* doc = R"""()""";
          } desired_pose;
          // Symbol: drake::systems::controllers::CartesianSetpoint::desired_velocity
          struct /* desired_velocity */ {
            // Source: drake/systems/controllers/setpoint.h:121
            const char* doc = R"""()""";
          } desired_velocity;
          // Symbol: drake::systems::controllers::CartesianSetpoint::eigen_aligned_operator_new_marker_type
          struct /* eigen_aligned_operator_new_marker_type */ {
            // Source: drake/systems/controllers/setpoint.h:135
            const char* doc = R"""()""";
          } eigen_aligned_operator_new_marker_type;
          // Symbol: drake::systems::controllers::CartesianSetpoint::is_valid
          struct /* is_valid */ {
            // Source: drake/systems/controllers/setpoint.h:105
            const char* doc = R"""()""";
          } is_valid;
          // Symbol: drake::systems::controllers::CartesianSetpoint::mutable_Kd
          struct /* mutable_Kd */ {
            // Source: drake/systems/controllers/setpoint.h:133
            const char* doc = R"""()""";
          } mutable_Kd;
          // Symbol: drake::systems::controllers::CartesianSetpoint::mutable_Kp
          struct /* mutable_Kp */ {
            // Source: drake/systems/controllers/setpoint.h:132
            const char* doc = R"""()""";
          } mutable_Kp;
          // Symbol: drake::systems::controllers::CartesianSetpoint::mutable_desired_acceleration
          struct /* mutable_desired_acceleration */ {
            // Source: drake/systems/controllers/setpoint.h:131
            const char* doc = R"""()""";
          } mutable_desired_acceleration;
          // Symbol: drake::systems::controllers::CartesianSetpoint::mutable_desired_pose
          struct /* mutable_desired_pose */ {
            // Source: drake/systems/controllers/setpoint.h:127
            const char* doc = R"""()""";
          } mutable_desired_pose;
          // Symbol: drake::systems::controllers::CartesianSetpoint::mutable_desired_velocity
          struct /* mutable_desired_velocity */ {
            // Source: drake/systems/controllers/setpoint.h:130
            const char* doc = R"""()""";
          } mutable_desired_velocity;
        } CartesianSetpoint;
        // Symbol: drake::systems::controllers::DiscreteTimeLinearQuadraticRegulator
        struct /* DiscreteTimeLinearQuadraticRegulator */ {
          // Source: drake/systems/controllers/linear_quadratic_regulator.h:63
          const char* doc =
R"""(Computes the optimal feedback controller, u=-Kx, and the optimal
cost-to-go J = x'Sx for the problem:

.. math:: x[n+1] = Ax[n] + Bu[n]

.. math:: \min_u \sum_0^\infty x'Qx + u'Ru

Parameter ``A``:
    The state-space dynamics matrix of size num_states x num_states.

Parameter ``B``:
    The state-space input matrix of size num_states x num_inputs.

Parameter ``Q``:
    A symmetric positive semi-definite cost matrix of size num_states
    x num_states.

Parameter ``R``:
    A symmetric positive definite cost matrix of size num_inputs x
    num_inputs.

Returns:
    A structure that contains the optimal feedback gain K and the
    quadratic cost term S. The optimal feedback control is u = -Kx;

Raises:
    RuntimeError if R is not positive definite.)""";
        } DiscreteTimeLinearQuadraticRegulator;
        // Symbol: drake::systems::controllers::DynamicProgrammingOptions
        struct /* DynamicProgrammingOptions */ {
          // Source: drake/systems/controllers/dynamic_programming.h:21
          const char* doc =
R"""(Consolidates the many possible options to be passed to the dynamic
programming algorithms.)""";
          // Symbol: drake::systems::controllers::DynamicProgrammingOptions::DynamicProgrammingOptions
          struct /* ctor */ {
            // Source: drake/systems/controllers/dynamic_programming.h:22
            const char* doc = R"""()""";
          } ctor;
          // Symbol: drake::systems::controllers::DynamicProgrammingOptions::PeriodicBoundaryCondition
          struct /* PeriodicBoundaryCondition */ {
            // Source: drake/systems/controllers/dynamic_programming.h:33
            const char* doc =
R"""(For algorithms that rely on approximations of the state-dynamics (as
in FittedValueIteration), this is a list of state dimensions for which
the state space maximum value should be "wrapped around" to ensure
that all values are in the range [low, high). The classic example is
for angles that are wrapped around at 2π.)""";
            // Symbol: drake::systems::controllers::DynamicProgrammingOptions::PeriodicBoundaryCondition::PeriodicBoundaryCondition
            struct /* ctor */ {
              // Source: drake/systems/controllers/dynamic_programming.h:34
              const char* doc = R"""()""";
            } ctor;
            // Symbol: drake::systems::controllers::DynamicProgrammingOptions::PeriodicBoundaryCondition::high
            struct /* high */ {
              // Source: drake/systems/controllers/dynamic_programming.h:37
              const char* doc = R"""()""";
            } high;
            // Symbol: drake::systems::controllers::DynamicProgrammingOptions::PeriodicBoundaryCondition::low
            struct /* low */ {
              // Source: drake/systems/controllers/dynamic_programming.h:36
              const char* doc = R"""()""";
            } low;
            // Symbol: drake::systems::controllers::DynamicProgrammingOptions::PeriodicBoundaryCondition::state_index
            struct /* state_index */ {
              // Source: drake/systems/controllers/dynamic_programming.h:35
              const char* doc = R"""()""";
            } state_index;
          } PeriodicBoundaryCondition;
          // Symbol: drake::systems::controllers::DynamicProgrammingOptions::assume_non_continuous_states_are_fixed
          struct /* assume_non_continuous_states_are_fixed */ {
            // Source: drake/systems/controllers/dynamic_programming.h:68
            const char* doc =
R"""((Advanced) Boolean which, if true, allows this algorithm to optimize
without considering the dynamics of any non-continuous states. This is
helpful for optimizing systems that might have some additional
book-keeping variables in their state. Only use this if you are sure
that the dynamics of the additional state variables cannot impact the
dynamics of the continuous states. $*Default:* false.)""";
          } assume_non_continuous_states_are_fixed;
          // Symbol: drake::systems::controllers::DynamicProgrammingOptions::convergence_tol
          struct /* convergence_tol */ {
            // Source: drake/systems/controllers/dynamic_programming.h:44
            const char* doc =
R"""(Value iteration methods converge when the value function stops
changing (typically evaluated with the l∞ norm). This value sets that
threshold.)""";
          } convergence_tol;
          // Symbol: drake::systems::controllers::DynamicProgrammingOptions::discount_factor
          struct /* discount_factor */ {
            // Source: drake/systems/controllers/dynamic_programming.h:26
            const char* doc =
R"""(A value between (0,1] that discounts future rewards.

See also:
    FittedValueIteration.)""";
          } discount_factor;
          // Symbol: drake::systems::controllers::DynamicProgrammingOptions::input_port_index
          struct /* input_port_index */ {
            // Source: drake/systems/controllers/dynamic_programming.h:59
            const char* doc =
R"""(For systems with multiple input ports, we must specify which input
port is being used in the control design.

See also:
    systems::InputPortSelection.)""";
          } input_port_index;
          // Symbol: drake::systems::controllers::DynamicProgrammingOptions::periodic_boundary_conditions
          struct /* periodic_boundary_conditions */ {
            // Source: drake/systems/controllers/dynamic_programming.h:39
            const char* doc = R"""()""";
          } periodic_boundary_conditions;
          // Symbol: drake::systems::controllers::DynamicProgrammingOptions::visualization_callback
          struct /* visualization_callback */ {
            // Source: drake/systems/controllers/dynamic_programming.h:55
            const char* doc =
R"""(If callable, this method is invoked during each major iteration of the
dynamic programming algorithm, in order to facilitate e.g. graphical
inspection/debugging of the results.

Note:
    The first call happens at iteration 1 (after the value iteration
    has run once), not zero.)""";
          } visualization_callback;
        } DynamicProgrammingOptions;
        // Symbol: drake::systems::controllers::FiniteHorizonLinearQuadraticRegulator
        struct /* FiniteHorizonLinearQuadraticRegulator */ {
          // Source: drake/systems/controllers/finite_horizon_linear_quadratic_regulator.h:140
          const char* doc =
R"""(Solves the differential Riccati equation to compute the optimal
controller and optimal cost-to-go for the finite-horizon linear
quadratic regulator:

.. math:: \min_u (x(t_f)-x_d(t_f))'Q_f(x(t_f)-x_d(t_f)) + \int_{t_0}^{t_f}
(x(t)-x_d(t))'Q(x(t)-x_d(t)) dt + \int_{t_0}^{t_f}
(u(t)-u_d(t))'R(u(t)-u_d(t)) dt + \int_{t_0}^{t_f}
2(x(t)-x_d(t))'N(u(t)-u_d(t)) dt \
\text{s.t. } \dot{x} - \dot{x}_0(t) = A(t)(x(t) - x_0(t)) + B(t)(u(t) -
u_0(t)) + c(t)

where A(t), B(t), and c(t) are taken from the gradients of the
continuous-time dynamics ẋ = f(t,x,u), as A(t) = dfdx(t, x0(t),
u0(t)), B(t) = dfdu(t, x0(t), u0(t)), and c(t) = f(t, x0(t), u0(t)) -
ẋ0(t). x0(t) and u0(t) can be specified in ``options``, otherwise are
taken to be constant trajectories with values given by ``context``.

Parameter ``system``:
    a System<double> representing the plant.

Parameter ``context``:
    a Context<double> used to pass the default input, state, and
    parameters. Note: Use ``options`` to specify time-varying nominal
    state and/or input trajectories.

Parameter ``t0``:
    is the initial time.

Parameter ``tf``:
    is the final time (with tf > t0).

Parameter ``Q``:
    is nxn positive semi-definite.

Parameter ``R``:
    is mxm positive definite.

Parameter ``options``:
    is the optional FiniteHorizonLinearQuadraticRegulatorOptions.

Precondition:
    ``system`` must be a System<double> with (only) n continuous state
    variables and m inputs. It must be convertable to
    System<AutoDiffXd>.

Note:
    Support for difference-equation systems (

See also:
    System<T>::IsDifferenceEquationSystem()) by solving the
    differential Riccati equation and richer specification of the
    objective are anticipated (they are listed in the code as TODOs).)""";
        } FiniteHorizonLinearQuadraticRegulator;
        // Symbol: drake::systems::controllers::FiniteHorizonLinearQuadraticRegulatorOptions
        struct /* FiniteHorizonLinearQuadraticRegulatorOptions */ {
          // Source: drake/systems/controllers/finite_horizon_linear_quadratic_regulator.h:19
          const char* doc =
R"""(A structure to facilitate passing the myriad of optional arguments to
the FiniteHorizonLinearQuadraticRegulator algorithms.)""";
          // Symbol: drake::systems::controllers::FiniteHorizonLinearQuadraticRegulatorOptions::FiniteHorizonLinearQuadraticRegulatorOptions
          struct /* ctor */ {
            // Source: drake/systems/controllers/finite_horizon_linear_quadratic_regulator.h:20
            const char* doc = R"""()""";
          } ctor;
          // Symbol: drake::systems::controllers::FiniteHorizonLinearQuadraticRegulatorOptions::N
          struct /* N */ {
            // Source: drake/systems/controllers/finite_horizon_linear_quadratic_regulator.h:32
            const char* doc =
R"""(A num_states x num_inputs matrix that describes the running cost
2(x-xd(t))'N(u-ud(t)). If unset, then N will be set to the zero
matrix.)""";
          } N;
          // Symbol: drake::systems::controllers::FiniteHorizonLinearQuadraticRegulatorOptions::Qf
          struct /* Qf */ {
            // Source: drake/systems/controllers/finite_horizon_linear_quadratic_regulator.h:26
            const char* doc =
R"""(A num_states x num_states positive semi-definite matrix which
specified the cost at the final time. If unset, then Qf will be set to
the zero matrix.)""";
          } Qf;
          // Symbol: drake::systems::controllers::FiniteHorizonLinearQuadraticRegulatorOptions::input_port_index
          struct /* input_port_index */ {
            // Source: drake/systems/controllers/finite_horizon_linear_quadratic_regulator.h:68
            const char* doc =
R"""(For systems with multiple input ports, we must specify which input
port is being used in the control design.

See also:
    systems::InputPortSelection.)""";
          } input_port_index;
          // Symbol: drake::systems::controllers::FiniteHorizonLinearQuadraticRegulatorOptions::u0
          struct /* u0 */ {
            // Source: drake/systems/controllers/finite_horizon_linear_quadratic_regulator.h:48
            const char* doc =
R"""(A nominal input trajectory. The system is linearized about this
trajectory. u0 must be defined over the entire interval, [t0, tf]. If
null, then u0 is taken to be a constant trajectory (whose value is
specified by the context passed into the LQR method).)""";
          } u0;
          // Symbol: drake::systems::controllers::FiniteHorizonLinearQuadraticRegulatorOptions::ud
          struct /* ud */ {
            // Source: drake/systems/controllers/finite_horizon_linear_quadratic_regulator.h:62
            const char* doc =
R"""(A desired input trajectory. The objective is to regulate to this
trajectory -- the input component of the quadratic running cost is
(u-ud(t))'*R*(u-ud(t)). If null, then ud(t) = u0(t).)""";
          } ud;
          // Symbol: drake::systems::controllers::FiniteHorizonLinearQuadraticRegulatorOptions::x0
          struct /* x0 */ {
            // Source: drake/systems/controllers/finite_horizon_linear_quadratic_regulator.h:40
            const char* doc =
R"""(A nominal state trajectory. The system is linearized about this
trajectory. x0 must be defined over the entire interval [t0, tf]. If
null, then x0 is taken to be a constant trajectory (whose value is
specified by the context passed into the LQR method).)""";
          } x0;
          // Symbol: drake::systems::controllers::FiniteHorizonLinearQuadraticRegulatorOptions::xd
          struct /* xd */ {
            // Source: drake/systems/controllers/finite_horizon_linear_quadratic_regulator.h:55
            const char* doc =
R"""(A desired state trajectory. The objective is to regulate to this
trajectory -- the state component of the quadratic running cost is
(x-xd(t))'*Q*(x-xd(t)) and the final cost is (x-xd(t))'Qf(x-xd(t)). If
null, then xd(t) = x0(t).)""";
          } xd;
        } FiniteHorizonLinearQuadraticRegulatorOptions;
        // Symbol: drake::systems::controllers::FiniteHorizonLinearQuadraticRegulatorResult
        struct /* FiniteHorizonLinearQuadraticRegulatorResult */ {
          // Source: drake/systems/controllers/finite_horizon_linear_quadratic_regulator.h:79
          const char* doc =
R"""(A structure that contains the basic
FiniteHorizonLinearQuadraticRegulator results. The finite-horizon
cost-to-go is given by (x-x0(t))'*S(t)*(x-x0(t)) + 2*(x-x₀(t))'sₓ(t) +
s₀(t) and the optimal controller is given by u-u0(t) = -K(t)*(x-x₀(t))
- k₀(t). Please don't overlook the factor of 2 in front of the sₓ(t)
term.)""";
          // Symbol: drake::systems::controllers::FiniteHorizonLinearQuadraticRegulatorResult::K
          struct /* K */ {
            // Source: drake/systems/controllers/finite_horizon_linear_quadratic_regulator.h:84
            const char* doc =
R"""(Note: This K is the K_x term in the derivation notes.)""";
          } K;
          // Symbol: drake::systems::controllers::FiniteHorizonLinearQuadraticRegulatorResult::S
          struct /* S */ {
            // Source: drake/systems/controllers/finite_horizon_linear_quadratic_regulator.h:87
            const char* doc = R"""()""";
          } S;
          // Symbol: drake::systems::controllers::FiniteHorizonLinearQuadraticRegulatorResult::k0
          struct /* k0 */ {
            // Source: drake/systems/controllers/finite_horizon_linear_quadratic_regulator.h:89
            const char* doc = R"""()""";
          } k0;
          // Symbol: drake::systems::controllers::FiniteHorizonLinearQuadraticRegulatorResult::s0
          struct /* s0 */ {
            // Source: drake/systems/controllers/finite_horizon_linear_quadratic_regulator.h:91
            const char* doc = R"""()""";
          } s0;
          // Symbol: drake::systems::controllers::FiniteHorizonLinearQuadraticRegulatorResult::sx
          struct /* sx */ {
            // Source: drake/systems/controllers/finite_horizon_linear_quadratic_regulator.h:90
            const char* doc = R"""()""";
          } sx;
          // Symbol: drake::systems::controllers::FiniteHorizonLinearQuadraticRegulatorResult::u0
          struct /* u0 */ {
            // Source: drake/systems/controllers/finite_horizon_linear_quadratic_regulator.h:81
            const char* doc = R"""()""";
          } u0;
          // Symbol: drake::systems::controllers::FiniteHorizonLinearQuadraticRegulatorResult::x0
          struct /* x0 */ {
            // Source: drake/systems/controllers/finite_horizon_linear_quadratic_regulator.h:80
            const char* doc = R"""()""";
          } x0;
        } FiniteHorizonLinearQuadraticRegulatorResult;
        // Symbol: drake::systems::controllers::FittedValueIteration
        struct /* FittedValueIteration */ {
          // Source: drake/systems/controllers/dynamic_programming.h:107
          const char* doc =
R"""(Implements Fitted Value Iteration on a (triangulated) Barycentric
Mesh, which designs a state-feedback policy to minimize the
infinite-horizon cost ∑ γⁿ g(x[n],u[n]), where γ is the discount
factor in ``options``.

For background, and a description of this algorithm, see
http://underactuated.csail.mit.edu/underactuated.html?chapter=dp . It
currently requires that the system to be optimized has only continuous
state and it is assumed to be time invariant. This code makes a
discrete-time approximation (using ``timestep)`` for the value
iteration update.

Parameter ``simulator``:
    contains the reference to the System being optimized and to a
    Context for that system, which may contain non-default Parameters,
    etc. The ``simulator`` is run for ``timestep`` seconds from every
    point on the mesh in order to approximate the dynamics; all of the
    simulation parameters (integrator, etc) are relevant during that
    evaluation.

Parameter ``cost_function``:
    is the continuous-time instantaneous cost. This implementation of
    the discrete-time formulation above uses the approximation g(x,u)
    = timestep*cost_function(x,u).

Parameter ``state_grid``:
    defines the mesh on the state space used to represent the
    cost-to-go function and the resulting policy.

Parameter ``input_grid``:
    defines the discrete action space used in the value iteration
    update.

Parameter ``timestep``:
    a time in seconds used for the discrete-time approximation.

Parameter ``options``:
    optional DynamicProgrammingOptions structure.

Returns:
    a std::pair containing the resulting policy, implemented as a
    BarycentricMeshSystem, and the RowVectorXd J that defines the
    expected cost-to-go on a BarycentricMesh using ``state_grid``. The
    policy has a single vector input (which is the continuous state of
    the system passed in through ``simulator)`` and a single vector
    output (which is the input of the system passed in through
    ``simulator)``.)""";
        } FittedValueIteration;
        // Symbol: drake::systems::controllers::InverseDynamics
        struct /* InverseDynamics */ {
          // Source: drake/systems/controllers/inverse_dynamics.h:33
          const char* doc =
R"""(Solves inverse dynamics with no consideration for joint actuator force
limits. The system also provides a pure gravity compensation mode.
This system provides a BasicVector input port for the state ``(q,
v)``, where ``q`` is the generalized position and ``v`` is the
generalized velocity, and a BasicVector output port for the computed
generalized forces. There is an additional BasicVector input port for
desired acceleration when configured to be **not** in pure gravity
compensation mode.

InverseDynamicsController uses a PID controller to generate desired
acceleration and uses this class to compute generalized forces. This
class should be used directly if desired acceleration is computed
differently.

See also:
    Constructors for descriptions of how (and which) forces are
    incorporated into the inverse dynamics computation.)""";
          // Symbol: drake::systems::controllers::InverseDynamics::InverseDynamics<T>
          struct /* ctor */ {
            // Source: drake/systems/controllers/inverse_dynamics.h:71
            const char* doc =
R"""(Computes the generalized force ``tau_id`` that needs to be applied so
that the multibody system undergoes a desired acceleration ``vd_d``.
That is, ``tau_id`` is the result of an inverse dynamics computation
according to:


::

    tau_id = M(q)vd_d + C(q, v)v - tau_g(q) - tau_app

where ``M(q)`` is the mass matrix, ``C(q, v)v`` is the bias term
containing Coriolis and gyroscopic effects, ``tau_g(q)`` is the vector
of generalized forces due to gravity and ``tau_app`` contains applied
forces from force elements added to the multibody model (this can
include damping, springs, etc. See
MultibodyPlant::CalcForceElementsContribution()).

Parameter ``plant``:
    Pointer to the multibody plant model. The life span of ``plant``
    must be longer than that of this instance.

Parameter ``mode``:
    If set to kGravityCompensation, this instance will only consider
    the gravity term. It also will NOT have the desired acceleration
    input port.

Precondition:
    The plant must be finalized (i.e., plant.is_finalized() must
    return ``True``).)""";
          } ctor;
          // Symbol: drake::systems::controllers::InverseDynamics::InverseDynamicsMode
          struct /* InverseDynamicsMode */ {
            // Source: drake/systems/controllers/inverse_dynamics.h:35
            const char* doc = R"""()""";
            // Symbol: drake::systems::controllers::InverseDynamics::InverseDynamicsMode::kGravityCompensation
            struct /* kGravityCompensation */ {
              // Source: drake/systems/controllers/inverse_dynamics.h:40
              const char* doc = R"""(Purely gravity compensation mode.)""";
            } kGravityCompensation;
            // Symbol: drake::systems::controllers::InverseDynamics::InverseDynamicsMode::kInverseDynamics
            struct /* kInverseDynamics */ {
              // Source: drake/systems/controllers/inverse_dynamics.h:37
              const char* doc = R"""(Full inverse computation mode.)""";
            } kInverseDynamics;
          } InverseDynamicsMode;
          // Symbol: drake::systems::controllers::InverseDynamics::get_input_port_desired_acceleration
          struct /* get_input_port_desired_acceleration */ {
            // Source: drake/systems/controllers/inverse_dynamics.h:86
            const char* doc =
R"""(Returns the input port for the desired acceleration.)""";
          } get_input_port_desired_acceleration;
          // Symbol: drake::systems::controllers::InverseDynamics::get_input_port_estimated_state
          struct /* get_input_port_estimated_state */ {
            // Source: drake/systems/controllers/inverse_dynamics.h:79
            const char* doc =
R"""(Returns the input port for the estimated state.)""";
          } get_input_port_estimated_state;
          // Symbol: drake::systems::controllers::InverseDynamics::get_output_port_force
          struct /* get_output_port_force */ {
            // Source: drake/systems/controllers/inverse_dynamics.h:96
            const char* doc =
R"""(Returns the output port for the generalized forces that realize the
desired acceleration. The dimension of that force vector will be
identical to the dimensionality of the generalized velocities.)""";
          } get_output_port_force;
          // Symbol: drake::systems::controllers::InverseDynamics::is_pure_gravity_compensation
          struct /* is_pure_gravity_compensation */ {
            // Source: drake/systems/controllers/inverse_dynamics.h:100
            const char* doc = R"""()""";
          } is_pure_gravity_compensation;
        } InverseDynamics;
        // Symbol: drake::systems::controllers::InverseDynamicsController
        struct /* InverseDynamicsController */ {
          // Source: drake/systems/controllers/inverse_dynamics_controller.h:60
          const char* doc =
R"""(A state feedback controller that uses a PidController to generate
desired accelerations, which are then converted into torques using
InverseDynamics. More specifically, the output of this controller is:
``torque = inverse_dynamics(q, v, vd_d)``, where ``vd_d = kp(q* - q) +
kd(v* - v) + ki int(q* - q) + vd*``. `q` and ``v`` stand for the
generalized position and velocity, and ``vd`` is the generalized
acceleration. ``*`` indicates reference values.

.. pydrake_system::

    name: InverseDynamicsController
    input_ports:
    - estimated_state
    - desired_state
    - desired_acceleration*
    output_ports:
    - force

This controller always has a BasicVector input port for estimated
robot state ``(q, v)``, a BasicVector input port for reference robot
state ``(q*, v*)`` and a BasicVector output port for computed torque
``torque``. A constructor flag can be set to track reference
acceleration ``vd*`` as well. When set, a BasicVector input port is
also declared, and it's content is used as ``vd*``. When unset,
``vd*`` is be treated as zero.

Note that this class assumes the robot is fully actuated, its position
and velocity have the same dimension, and it does not have a floating
base. If violated, the program will abort. This controller was not
designed for closed-loop systems: the controller accounts for neither
constraint forces nor actuator forces applied at loop constraints. Use
on such systems is not recommended.

See also:
    InverseDynamics for an accounting of all forces incorporated into
    the inverse dynamics computation.)""";
          // Symbol: drake::systems::controllers::InverseDynamicsController::InverseDynamicsController<T>
          struct /* ctor */ {
            // Source: drake/systems/controllers/inverse_dynamics_controller.h:88
            const char* doc_5args_referenced_plant =
R"""(Constructs an inverse dynamics controller for the given ``plant``
model. The InverseDynamicsController holds an internal, non-owned
reference to the MultibodyPlant object so you must ensure that
``plant`` has a longer lifetime than ``this``
InverseDynamicsController.

Parameter ``plant``:
    The model of the plant for control.

Parameter ``kp``:
    Position gain.

Parameter ``ki``:
    Integral gain.

Parameter ``kd``:
    Velocity gain.

Parameter ``has_reference_acceleration``:
    If true, there is an extra BasicVector input port for ``vd*``. If
    false, ``vd*`` is treated as zero, and no extra input port is
    declared.

Precondition:
    ``plant`` has been finalized (plant.is_finalized() returns
    ``True``).

Raises:
    RuntimeError if - The plant is not finalized (see
    MultibodyPlant::Finalize()). - The number of generalized
    velocities is not equal to the number of generalized positions. -
    The model is not fully actuated. - Vector kp, ki and kd do not all
    have the same size equal to the number of generalized positions.)""";
            // Source: drake/systems/controllers/inverse_dynamics_controller.h:101
            const char* doc_5args_owned_plant =
R"""(Constructs an inverse dynamics controller and takes the ownership of
the input ``plant``.)""";
          } ctor;
          // Symbol: drake::systems::controllers::InverseDynamicsController::get_input_port_desired_acceleration
          struct /* get_input_port_desired_acceleration */ {
            // Source: drake/systems/controllers/inverse_dynamics_controller.h:119
            const char* doc =
R"""(Returns the input port for the reference acceleration.)""";
          } get_input_port_desired_acceleration;
          // Symbol: drake::systems::controllers::InverseDynamicsController::get_input_port_desired_state
          struct /* get_input_port_desired_state */ {
            // Source: drake/systems/controllers/inverse_dynamics_controller.h:135
            const char* doc =
R"""(Returns the input port for the desired state.)""";
          } get_input_port_desired_state;
          // Symbol: drake::systems::controllers::InverseDynamicsController::get_input_port_estimated_state
          struct /* get_input_port_estimated_state */ {
            // Source: drake/systems/controllers/inverse_dynamics_controller.h:128
            const char* doc =
R"""(Returns the input port for the estimated state.)""";
          } get_input_port_estimated_state;
          // Symbol: drake::systems::controllers::InverseDynamicsController::get_multibody_plant_for_control
          struct /* get_multibody_plant_for_control */ {
            // Source: drake/systems/controllers/inverse_dynamics_controller.h:149
            const char* doc =
R"""(Returns a constant pointer to the MultibodyPlant used for control.)""";
          } get_multibody_plant_for_control;
          // Symbol: drake::systems::controllers::InverseDynamicsController::get_output_port_control
          struct /* get_output_port_control */ {
            // Source: drake/systems/controllers/inverse_dynamics_controller.h:142
            const char* doc =
R"""(Returns the output port for computed control.)""";
          } get_output_port_control;
          // Symbol: drake::systems::controllers::InverseDynamicsController::set_integral_value
          struct /* set_integral_value */ {
            // Source: drake/systems/controllers/inverse_dynamics_controller.h:113
            const char* doc =
R"""(Sets the integral part of the PidController to ``value``. ``value``
must be a column vector of the appropriate size.)""";
          } set_integral_value;
        } InverseDynamicsController;
        // Symbol: drake::systems::controllers::LinearModelPredictiveController
        struct /* LinearModelPredictiveController */ {
          // Source: drake/systems/controllers/linear_model_predictive_controller.h:33
          const char* doc =
R"""(Implements a basic Model Predictive Controller that linearizes the
system about an equilibrium condition and regulates to the same point
by solving an optimal control problem over a finite time horizon. In
particular, MPC solves, at each time step k, the following problem to
find an optimal u(k) as a function of x(k):

.. math:: \min_{u(k),\ldots,u(k+N),x(k+1),\ldots,x(k+N)}
         \sum_{i=k}^{k+N} ((x(i) - xd(i))ᵀQ(x(i) - xd(i)) +
                           (u(i) - ud(i))ᵀR(u(i) - ud(i)))

.. math:: \mathrm{s.t. } x(k+1) = A(k)x(k) + B(k)u(k)

and subject to linear inequality constraints on the inputs and states,
where N is the horizon length, Q and R are cost matrices, and xd and
ud are the desired states and inputs, respectively. Note that the
present implementation solves the QP in whole at every time step,
discarding any information between steps.)""";
          // Symbol: drake::systems::controllers::LinearModelPredictiveController::LinearModelPredictiveController<T>
          struct /* ctor */ {
            // Source: drake/systems/controllers/linear_model_predictive_controller.h:62
            const char* doc =
R"""(Constructor for an unconstrained MPC formulation with linearization
occurring about the provided base_context. Since this formulation is
devoid of any externally-imposed input/state constraints, the
controller essentially behaves the same as a finite-time LQR.

Parameter ``model``:
    The plant model of the System to be controlled.

Parameter ``base_context``:
    The fixed base point about which to linearize of the system and
    regulate the system. To be valid, ``base_context`` must correspond
    to an equilibrium point of the system.

Parameter ``Q``:
    A symmetric positive semi-definite state cost matrix of size
    (num_states x num_states).

Parameter ``R``:
    A symmetric positive definite control effort cost matrix of size
    (num_inputs x num_inputs).

Parameter ``time_period``:
    The discrete time period (in seconds) at which controller updates
    occur.

Parameter ``time_horizon``:
    The prediction time horizon (seconds).

Precondition:
    model must have discrete states of dimension num_states and inputs
    of dimension num_inputs.

Precondition:
    base_context must have discrete states set as appropriate for the
    given ``model``. The input must also be initialized via
    ``input_port.FixValue(base_context, u0)``, or otherwise
    initialized via Diagram.)""";
          } ctor;
          // Symbol: drake::systems::controllers::LinearModelPredictiveController::get_control_port
          struct /* get_control_port */ {
            // Source: drake/systems/controllers/linear_model_predictive_controller.h:72
            const char* doc = R"""()""";
          } get_control_port;
          // Symbol: drake::systems::controllers::LinearModelPredictiveController::get_state_port
          struct /* get_state_port */ {
            // Source: drake/systems/controllers/linear_model_predictive_controller.h:69
            const char* doc = R"""()""";
          } get_state_port;
        } LinearModelPredictiveController;
        // Symbol: drake::systems::controllers::LinearProgrammingApproximateDynamicProgramming
        struct /* LinearProgrammingApproximateDynamicProgramming */ {
          // Source: drake/systems/controllers/dynamic_programming.h:171
          const char* doc =
R"""(Implements the Linear Programming approach to approximate dynamic
programming. It optimizes the linear program

maximize ∑ Jₚ(x). subject to ∀x, ∀u, Jₚ(x) ≤ g(x,u) + γJₚ(f(x,u)),

where g(x,u) is the one-step cost, Jₚ(x) is a (linearly) parameterized
cost-to-go function with parameter vector p, and γ is the discount
factor in ``options``.

For background, and a description of this algorithm, see
http://underactuated.csail.mit.edu/underactuated.html?chapter=dp . It
currently requires that the system to be optimized has only continuous
state and it is assumed to be time invariant. This code makes a
discrete-time approximation (using ``timestep)`` for the value
iteration update.

Parameter ``simulator``:
    contains the reference to the System being optimized and to a
    Context for that system, which may contain non-default Parameters,
    etc. The ``simulator`` is run for ``timestep`` seconds from every
    pair of input/state sample points in order to approximate the
    dynamics; all of the simulation parameters (integrator, etc) are
    relevant during that evaluation.

Parameter ``cost_function``:
    is the continuous-time instantaneous cost. This implementation of
    the discrete-time formulation above uses the approximation g(x,u)
    = timestep*cost_function(x,u).

Parameter ``linearly_parameterized_cost_to_go_function``:
    must define a function to approximate the cost-to-go, which takes
    the state vector as the first input and the parameter vector as
    the second input. This can be any function of the form Jₚ(x) = ∑
    pᵢ φᵢ(x). This algorithm will pass in a VectorX of
    symbolic::Variable in order to set up the linear program.

Parameter ``state_samples``:
    is a list of sample states (one per column) at which to apply the
    optimization constraints and the objective.

Parameter ``input_samples``:
    is a list of inputs (one per column) which are evaluated *at every
    sample point*.

Parameter ``timestep``:
    a time in seconds used for the discrete-time approximation.

Parameter ``options``:
    optional DynamicProgrammingOptions structure.

Returns:
    params the VectorXd of parameters that optimizes the supplied
    cost-to-go function.)""";
        } LinearProgrammingApproximateDynamicProgramming;
        // Symbol: drake::systems::controllers::LinearQuadraticRegulator
        struct /* LinearQuadraticRegulator */ {
          // Source: drake/systems/controllers/linear_quadratic_regulator.h:36
          const char* doc_5args =
R"""(Computes the optimal feedback controller, u=-Kx, and the optimal
cost-to-go J = x'Sx for the problem:

.. math:: \dot{x} = Ax + Bu

.. math:: \min_u \int_0^\infty x'Qx + u'Ru + 2x'Nu dt

Parameter ``A``:
    The state-space dynamics matrix of size num_states x num_states.

Parameter ``B``:
    The state-space input matrix of size num_states x num_inputs.

Parameter ``Q``:
    A symmetric positive semi-definite cost matrix of size num_states
    x num_states.

Parameter ``R``:
    A symmetric positive definite cost matrix of size num_inputs x
    num_inputs.

Parameter ``N``:
    A cost matrix of size num_states x num_inputs. If the matrix is
    zero-sized, N will be treated as a num_states x num_inputs zero
    matrix.

Returns:
    A structure that contains the optimal feedback gain K and the
    quadratic cost term S. The optimal feedback control is u = -Kx;

Raises:
    RuntimeError if R is not positive definite.)""";
          // Source: drake/systems/controllers/linear_quadratic_regulator.h:92
          const char* doc_4args =
R"""(Creates a system that implements the optimal time-invariant linear
quadratic regulator (LQR). If ``system`` is a continuous-time system,
then solves the continuous-time LQR problem:

.. math:: \min_u \int_0^\infty x^T(t)Qx(t) + u^T(t)Ru(t) dt.

If ``system`` is a discrete-time system, then solves the discrete-time
LQR problem:

.. math:: \min_u \sum_0^\infty x^T[n]Qx[n] + u^T[n]Ru[n].

Parameter ``system``:
    The System to be controlled.

Parameter ``Q``:
    A symmetric positive semi-definite cost matrix of size num_states
    x num_states.

Parameter ``R``:
    A symmetric positive definite cost matrix of size num_inputs x
    num_inputs.

Parameter ``N``:
    A cost matrix of size num_states x num_inputs.

Returns:
    A system implementing the optimal controller in the original
    system coordinates.

Raises:
    RuntimeError if R is not positive definite.)""";
          // Source: drake/systems/controllers/linear_quadratic_regulator.h:134
          const char* doc_6args =
R"""(Linearizes the System around the specified Context, computes the
optimal time-invariant linear quadratic regulator (LQR), and returns a
System which implements that regulator in the original System's
coordinates. If ``system`` is a continuous-time system, then solves
the continuous-time LQR problem:

.. math:: \min_u \int_0^\infty (x-x_0)^TQ(x-x_0) + (u-u_0)^TR(u-u_0) dt.

If ``system`` is a discrete-time system, then solves the discrete-time
LQR problem:

.. math:: \min_u \sum_0^\infty (x-x_0)^TQ(x-x_0) + (u-u_0)^TR(u-u_0),

where :math:`x_0` is the nominal state and :math:`u_0` is the nominal
input. The system is considered discrete if it has a single discrete
state vector and a single unique periodic update event declared.

Parameter ``system``:
    The System to be controlled.

Parameter ``context``:
    Defines the desired state and control input to regulate the system
    to. Note that this state/input must be an equilibrium point of the
    system. See drake::systems::Linearize for more details.

Parameter ``Q``:
    A symmetric positive semi-definite cost matrix of size num_states
    x num_states.

Parameter ``R``:
    A symmetric positive definite cost matrix of size num_inputs x
    num_inputs.

Parameter ``N``:
    A cost matrix of size num_states x num_inputs. If the matrix is
    zero-sized, N will be treated as a num_states x num_inputs zero
    matrix.

Parameter ``int_port_index``:
    The index of the input port to linearize around.

Returns:
    A system implementing the optimal controller in the original
    system coordinates.

Raises:
    RuntimeError if R is not positive definite. $See also:

drake::systems::Linearize())""";
        } LinearQuadraticRegulator;
        // Symbol: drake::systems::controllers::LinearQuadraticRegulatorResult
        struct /* LinearQuadraticRegulatorResult */ {
          // Source: drake/systems/controllers/linear_quadratic_regulator.h:11
          const char* doc = R"""()""";
          // Symbol: drake::systems::controllers::LinearQuadraticRegulatorResult::K
          struct /* K */ {
            // Source: drake/systems/controllers/linear_quadratic_regulator.h:12
            const char* doc = R"""()""";
          } K;
          // Symbol: drake::systems::controllers::LinearQuadraticRegulatorResult::S
          struct /* S */ {
            // Source: drake/systems/controllers/linear_quadratic_regulator.h:13
            const char* doc = R"""()""";
          } S;
        } LinearQuadraticRegulatorResult;
        // Symbol: drake::systems::controllers::MakeFiniteHorizonLinearQuadraticRegulator
        struct /* MakeFiniteHorizonLinearQuadraticRegulator */ {
          // Source: drake/systems/controllers/finite_horizon_linear_quadratic_regulator.h:155
          const char* doc =
R"""(Variant of FiniteHorizonLinearQuadraticRegulator that returns a System
implementing the regulator (controller) as a System, with a single
"plant_state" input for the estimated plant state, and a single
"control" output for the regulator control output.

See also:
    FiniteHorizonLinearQuadraticRegulator for details on the
    arguments.)""";
        } MakeFiniteHorizonLinearQuadraticRegulator;
        // Symbol: drake::systems::controllers::PidControlledSystem
        struct /* PidControlledSystem */ {
          // Source: drake/systems/controllers/pid_controlled_system.h:59
          const char* doc =
R"""(A system that encapsulates a PidController and a controlled System
(a.k.a the "plant").

The passed in plant must meet the following properties:

* Input port ``plant_input_port_index`` must be all of the control inputs
  (size U). When the plant is a dynamics model, this is typically the
  generalized effort (e.g., force or torque) command.

* The output port passed to the PidControlledSystem constructor must be
  of size 2 * Q, where the first Q elements are the position states of
  the plant, and the second Q elements are the velocity states of the
  plant. Q >= U.

The resulting PidControlledSystem has two input ports with the
following properties:

* Input port zero is the feed forward control (size U), which will be added
  onto the output of the PID controller. The sum is sent to the plant's
  input.

* Input port one is the desired *controlled* states (2 * U) of the plant,
  where the first half are the *controlled* positions, and the second half
  are the *controlled* velocities.

All output ports of the plant are exposed as output ports of the
PidControlledSystem in the same order (and therefore with the same
index) as they appear in the plant.

Some of the constructors include a parameter called
``feedback_selector``. It is used to select the *controlled* states
from the plant's state output port. Let ``S`` be the gain matrix in
parameter ``feedback_selector``. `S` must have dimensions of ``(2 * U,
2 * Q)``. Typically, ``S`` contains one ``1`` in each row, and zeros
everywhere else. ``S`` does not affect the desired state input. Let
'x' be the full state of the plant (size 2 * Q), and 'x_d' be the
desired state (size 2 * U), ``S`` is used to compute the state error
as ``x_err = S * x - x_d``.)""";
          // Symbol: drake::systems::controllers::PidControlledSystem::ConnectController
          struct /* ConnectController */ {
            // Source: drake/systems/controllers/pid_controlled_system.h:174
            const char* doc_7args =
R"""(Creates a PidController and uses ``builder`` to connect
``plant_input`` and ``plant_output`` from an existing plant. The
controlled states are selected by ``feedback_selector``.)""";
            // Source: drake/systems/controllers/pid_controlled_system.h:184
            const char* doc_6args =
R"""(Creates a PidController and uses ``builder`` to connect
``plant_input`` and ``plant_output`` from an existing plant. The
plant's full state is used for feedback.)""";
          } ConnectController;
          // Symbol: drake::systems::controllers::PidControlledSystem::ConnectControllerWithInputSaturation
          struct /* ConnectControllerWithInputSaturation */ {
            // Source: drake/systems/controllers/pid_controlled_system.h:196
            const char* doc_9args =
R"""(Creates a PidController with input saturation and uses ``builder`` to
connect ``plant_input`` and ``plant_output`` from an existing plant.
The controlled states are selected by ``feedback_selector``. The
output of the PidController is clipped to be within the specified
bounds. Note that using input limits along with integral gain constant
may cause the integrator to windup.)""";
            // Source: drake/systems/controllers/pid_controlled_system.h:210
            const char* doc_8args =
R"""(Creates a PidController with input saturation and uses ``builder`` to
connect ``plant_input`` and ``plant_output`` from an existing plant.
The plant's full state is used for feedback. The output of the
PidController is clipped to be within the specified bounds. Note that
using input limits along with integral gain constant may cause the
integrator to windup.)""";
          } ConnectControllerWithInputSaturation;
          // Symbol: drake::systems::controllers::PidControlledSystem::ConnectResult
          struct /* ConnectResult */ {
            // Source: drake/systems/controllers/pid_controlled_system.h:164
            const char* doc = R"""(The return type of ConnectController.)""";
            // Symbol: drake::systems::controllers::PidControlledSystem::ConnectResult::control_input_port
            struct /* control_input_port */ {
              // Source: drake/systems/controllers/pid_controlled_system.h:166
              const char* doc = R"""(The feed forward control input.)""";
            } control_input_port;
            // Symbol: drake::systems::controllers::PidControlledSystem::ConnectResult::state_input_port
            struct /* state_input_port */ {
              // Source: drake/systems/controllers/pid_controlled_system.h:168
              const char* doc = R"""(The feedback state input.)""";
            } state_input_port;
          } ConnectResult;
          // Symbol: drake::systems::controllers::PidControlledSystem::PidControlledSystem<T>
          struct /* ctor */ {
            // Source: drake/systems/controllers/pid_controlled_system.h:76
            const char* doc_6args_double_gains =
R"""(``plant`` full state is used for feedback control, and all the
dimensions have homogeneous gains specified by ``Kp``, ``Kd`` and
``Ki``.

Parameter ``plant``:
    The system to be controlled. This must not be ``nullptr``.

Parameter ``Kp``:
    the proportional constant.

Parameter ``Ki``:
    the integral constant.

Parameter ``Kd``:
    the derivative constant.

Parameter ``state_output_port_index``:
    identifies the output port on the plant that contains the (full)
    state information.

Parameter ``plant_input_port_index``:
    identifies the input port on the plant that takes in the input
    (computed as the output of the PID controller).)""";
            // Source: drake/systems/controllers/pid_controlled_system.h:93
            const char* doc_6args_vector_gains =
R"""(``plant`` full state is used for feedback control, and the vectorized
gains are specified by ``Kp``, ``Kd`` and ``Ki``.

Parameter ``plant``:
    The system to be controlled. This must not be ``nullptr``.

Parameter ``Kp``:
    the proportional vector constant.

Parameter ``Ki``:
    the integral vector constant.

Parameter ``Kd``:
    the derivative vector constant.

Parameter ``state_output_port_index``:
    identifies the output port on the plant that contains the (full)
    state information.

Parameter ``plant_input_port_index``:
    identifies the input port on the plant that takes in the input
    (computed as the output of the PID controller).)""";
            // Source: drake/systems/controllers/pid_controlled_system.h:116
            const char* doc_7args_double_gains =
R"""(A constructor where the gains are scalar values and some of the
plant's output is part of the feedback signal as specified by
``feedback_selector``.

Parameter ``plant``:
    The system to be controlled. This must not be ``nullptr``.

Parameter ``feedback_selector``:
    The matrix that selects which part of the plant's full state is
    fed back to the PID controller. For semantic details of this
    parameter, see this class's description.

Parameter ``Kp``:
    the proportional constant.

Parameter ``Ki``:
    the integral constant.

Parameter ``Kd``:
    the derivative constant.

Parameter ``state_output_port_index``:
    identifies the output port on the plant that contains the (full)
    state information.

Parameter ``plant_input_port_index``:
    identifies the input port on the plant that takes in the input
    (computed as the output of the PID controller).)""";
            // Source: drake/systems/controllers/pid_controlled_system.h:138
            const char* doc_7args_vector_gains =
R"""(A constructor where the gains are vector values and some of the
plant's output is part of the feedback signal as specified by
``feedback_selector``.

Parameter ``plant``:
    The system to be controlled. This must not be ``nullptr``.

Parameter ``feedback_selector``:
    The matrix that selects which part of the plant's full state is
    fed back to the PID controller. For semantic details of this
    parameter, see this class's description.

Parameter ``Kp``:
    the proportional vector constant.

Parameter ``Ki``:
    the integral vector constant.

Parameter ``Kd``:
    the derivative vector constant.

Parameter ``state_output_port_index``:
    identifies the output port on the plant that contains the (full)
    state information.

Parameter ``plant_input_port_index``:
    identifies the input port on the plant that takes in the input
    (computed as the output of the PID controller).)""";
          } ctor;
          // Symbol: drake::systems::controllers::PidControlledSystem::get_control_input_port
          struct /* get_control_input_port */ {
            // Source: drake/systems/controllers/pid_controlled_system.h:150
            const char* doc =
R"""(Returns:
    the input port for the feed forward control input.)""";
          } get_control_input_port;
          // Symbol: drake::systems::controllers::PidControlledSystem::get_state_input_port
          struct /* get_state_input_port */ {
            // Source: drake/systems/controllers/pid_controlled_system.h:155
            const char* doc =
R"""(Returns:
    the input port for the desired position/velocity state.)""";
          } get_state_input_port;
          // Symbol: drake::systems::controllers::PidControlledSystem::get_state_output_port
          struct /* get_state_output_port */ {
            // Source: drake/systems/controllers/pid_controlled_system.h:159
            const char* doc = R"""()""";
          } get_state_output_port;
          // Symbol: drake::systems::controllers::PidControlledSystem::plant
          struct /* plant */ {
            // Source: drake/systems/controllers/pid_controlled_system.h:147
            const char* doc = R"""()""";
          } plant;
        } PidControlledSystem;
        // Symbol: drake::systems::controllers::PidController
        struct /* PidController */ {
          // Source: drake/systems/controllers/pid_controller.h:49
          const char* doc =
R"""(Implements the PID controller. Given estimated state ``x_in = (q_in,
v_in)``, the controlled state ``x_c = (q_c, v_c)`` is computed by
``x_c = P_x * x_in``, where ``P_x`` is a state projection matrix. The
desired state ``x_d = (q_d, v_d)``, is in the same space as ``x_c``.
The output of this controller is:


::

    y = P_y * (kp * (q_d - q_c) + kd * (v_d - v_c) + ki * integral(q_d - q_c)),

where ``P_y`` is the output projection matrix.

.. pydrake_system::

    name: PidController
    input_ports:
    - estimated_state
    - desired_state
    output_ports:
    - control

This system has one continuous state, which is the integral of
position error, two input ports: estimated state ``x_in`` and desired
state ``x_d``, and one output port ``y``. Note that this class assumes
``|q_c| = |v_c|`` and ``|q_d| = |v_d|``. However, ``|q_c|`` does not
have to equal to ``|q_d|``. One typical use case for non-identity
``P_x`` and ``P_y`` is to select a subset of state for feedback.)""";
          // Symbol: drake::systems::controllers::PidController::DoCalcTimeDerivatives
          struct /* DoCalcTimeDerivatives */ {
            // Source: drake/systems/controllers/pid_controller.h:193
            const char* doc = R"""()""";
          } DoCalcTimeDerivatives;
          // Symbol: drake::systems::controllers::PidController::GetGraphvizFragment
          struct /* GetGraphvizFragment */ {
            // Source: drake/systems/controllers/pid_controller.h:190
            const char* doc =
R"""(Appends to ``dot`` a simplified Graphviz representation of the PID
controller, since the internal wiring is unimportant and hard for
human viewers to parse.)""";
          } GetGraphvizFragment;
          // Symbol: drake::systems::controllers::PidController::PidController<T>
          struct /* ctor */ {
            // Source: drake/systems/controllers/pid_controller.h:65
            const char* doc_3args =
R"""(Constructs a PID controller. ``P_x`` and ``P_y`` are identity matrices
of proper sizes. The estimated and desired state inputs are 2 *
``kp``'s size, and the control output has ``kp``'s size.

Parameter ``kp``:
    P gain.

Parameter ``ki``:
    I gain.

Parameter ``kd``:
    D gain.

Raises:
    RuntimeError if ``kp``, ``ki`` and ``kd`` have different
    dimensions.)""";
            // Source: drake/systems/controllers/pid_controller.h:79
            const char* doc_4args =
R"""(Constructs a PID controller. Calls the full constructor, with the
output projection matrix ``P_y`` being the identity matrix.

Parameter ``state_projection``:
    The state projection matrix ``P_x``.

Parameter ``kp``:
    P gain.

Parameter ``ki``:
    I gain.

Parameter ``kd``:
    D gain.

Raises:
    RuntimeError if ``kp``, ``ki`` and ``kd`` have different
    dimensions or `P_x.row() != 2 * |kp|'.)""";
            // Source: drake/systems/controllers/pid_controller.h:101
            const char* doc_5args =
R"""(Constructs a PID controller. This assumes that


::

    1. |kp| = |kd| = |ki| = |q_d| = |v_d|
      2. 2 * |q_d| = P_x.rows
      3. |x_in| = P_x.cols
      4. |y| = P_y.rows
      4. |q_d| = P_y.cols

Parameter ``state_projection``:
    The state projection matrix ``P_x``.

Parameter ``output_projection``:
    The output projection matrix ``P_y``.

Parameter ``kp``:
    P gain.

Parameter ``ki``:
    I gain.

Parameter ``kd``:
    V gain.

Raises:
    RuntimeError if any assumption is violated.)""";
            // Source: drake/systems/controllers/pid_controller.h:108
            const char* doc_copyconvert =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";
          } ctor;
          // Symbol: drake::systems::controllers::PidController::get_Kd_singleton
          struct /* get_Kd_singleton */ {
            // Source: drake/systems/controllers/pid_controller.h:135
            const char* doc =
R"""(Returns the derivative gain constant. This method should only be
called if the derivative gain can be represented as a scalar value,
i.e., every element in the derivative gain vector is the same. It will
throw a ``RuntimeError`` if the derivative gain cannot be represented
as a scalar value.)""";
          } get_Kd_singleton;
          // Symbol: drake::systems::controllers::PidController::get_Kd_vector
          struct /* get_Kd_vector */ {
            // Source: drake/systems/controllers/pid_controller.h:150
            const char* doc = R"""(Returns the derivative gain vector.)""";
          } get_Kd_vector;
          // Symbol: drake::systems::controllers::PidController::get_Ki_singleton
          struct /* get_Ki_singleton */ {
            // Source: drake/systems/controllers/pid_controller.h:126
            const char* doc =
R"""(Returns the integral gain constant. This method should only be called
if the integral gain can be represented as a scalar value, i.e., every
element in the integral gain vector is the same. It will throw a
``RuntimeError`` if the integral gain cannot be represented as a
scalar value.)""";
          } get_Ki_singleton;
          // Symbol: drake::systems::controllers::PidController::get_Ki_vector
          struct /* get_Ki_vector */ {
            // Source: drake/systems/controllers/pid_controller.h:145
            const char* doc = R"""(Returns the integral gain vector.)""";
          } get_Ki_vector;
          // Symbol: drake::systems::controllers::PidController::get_Kp_singleton
          struct /* get_Kp_singleton */ {
            // Source: drake/systems/controllers/pid_controller.h:117
            const char* doc =
R"""(Returns the proportional gain constant. This method should only be
called if the proportional gain can be represented as a scalar value,
i.e., every element in the proportional gain vector is the same. It
will throw a ``RuntimeError`` if the proportional gain cannot be
represented as a scalar value.)""";
          } get_Kp_singleton;
          // Symbol: drake::systems::controllers::PidController::get_Kp_vector
          struct /* get_Kp_vector */ {
            // Source: drake/systems/controllers/pid_controller.h:140
            const char* doc = R"""(Returns the proportional gain vector.)""";
          } get_Kp_vector;
          // Symbol: drake::systems::controllers::PidController::get_input_port_desired_state
          struct /* get_input_port_desired_state */ {
            // Source: drake/systems/controllers/pid_controller.h:173
            const char* doc =
R"""(Returns the input port for the desired state.)""";
          } get_input_port_desired_state;
          // Symbol: drake::systems::controllers::PidController::get_input_port_estimated_state
          struct /* get_input_port_estimated_state */ {
            // Source: drake/systems/controllers/pid_controller.h:166
            const char* doc =
R"""(Returns the input port for the estimated state.)""";
          } get_input_port_estimated_state;
          // Symbol: drake::systems::controllers::PidController::get_output_port_control
          struct /* get_output_port_control */ {
            // Source: drake/systems/controllers/pid_controller.h:180
            const char* doc =
R"""(Returns the output port for computed control.)""";
          } get_output_port_control;
          // Symbol: drake::systems::controllers::PidController::set_integral_value
          struct /* set_integral_value */ {
            // Source: drake/systems/controllers/pid_controller.h:156
            const char* doc =
R"""(Sets the integral part of the PidController to ``value``. ``value``
must be a column vector of the appropriate size.)""";
          } set_integral_value;
        } PidController;
        // Symbol: drake::systems::controllers::StateFeedbackControllerInterface
        struct /* StateFeedbackControllerInterface */ {
          // Source: drake/systems/controllers/state_feedback_controller_interface.h:17
          const char* doc =
R"""(Interface for state feedback controllers. This class needs to be
extended by concrete implementations. It provides named accessors to
actual and desired state input ports and control output port.)""";
          // Symbol: drake::systems::controllers::StateFeedbackControllerInterface::StateFeedbackControllerInterface<T>
          struct /* ctor */ {
            // Source: drake/systems/controllers/state_feedback_controller_interface.h:19
            const char* doc = R"""()""";
          } ctor;
          // Symbol: drake::systems::controllers::StateFeedbackControllerInterface::get_input_port_desired_state
          struct /* get_input_port_desired_state */ {
            // Source: drake/systems/controllers/state_feedback_controller_interface.h:30
            const char* doc =
R"""(Returns the input port for the desired state.)""";
          } get_input_port_desired_state;
          // Symbol: drake::systems::controllers::StateFeedbackControllerInterface::get_input_port_estimated_state
          struct /* get_input_port_estimated_state */ {
            // Source: drake/systems/controllers/state_feedback_controller_interface.h:24
            const char* doc =
R"""(Returns the input port for the estimated state.)""";
          } get_input_port_estimated_state;
          // Symbol: drake::systems::controllers::StateFeedbackControllerInterface::get_output_port_control
          struct /* get_output_port_control */ {
            // Source: drake/systems/controllers/state_feedback_controller_interface.h:36
            const char* doc =
R"""(Returns the output port for computed control.)""";
          } get_output_port_control;
        } StateFeedbackControllerInterface;
        // Symbol: drake::systems::controllers::VectorSetpoint
        struct /* VectorSetpoint */ {
          // Source: drake/systems/controllers/setpoint.h:168
          const char* doc = R"""()""";
          // Symbol: drake::systems::controllers::VectorSetpoint::ComputeTargetAcceleration
          struct /* ComputeTargetAcceleration */ {
            // Source: drake/systems/controllers/setpoint.h:211
            const char* doc =
R"""(Computes target acceleration using PD feedback + feedforward
acceleration

Parameter ``idx``:
    Index

Parameter ``pos``:
    Measured position

Parameter ``vel``:
    Measured velocity

Returns:
    Computed acceleration)""";
          } ComputeTargetAcceleration;
          // Symbol: drake::systems::controllers::VectorSetpoint::Kd
          struct /* Kd */ {
            // Source: drake/systems/controllers/setpoint.h:256
            const char* doc = R"""()""";
          } Kd;
          // Symbol: drake::systems::controllers::VectorSetpoint::Kp
          struct /* Kp */ {
            // Source: drake/systems/controllers/setpoint.h:255
            const char* doc = R"""()""";
          } Kp;
          // Symbol: drake::systems::controllers::VectorSetpoint::VectorSetpoint<Scalar>
          struct /* ctor */ {
            // Source: drake/systems/controllers/setpoint.h:189
            const char* doc =
R"""(Parameter ``pos_d``:
    Desired position

Parameter ``vel_d``:
    Desired velocity

Parameter ``acc_d``:
    Desired feedforward acceleration

Parameter ``Kp``:
    Position gain

Parameter ``Kd``:
    Velocity gain)""";
          } ctor;
          // Symbol: drake::systems::controllers::VectorSetpoint::desired_acceleration
          struct /* desired_acceleration */ {
            // Source: drake/systems/controllers/setpoint.h:254
            const char* doc = R"""()""";
          } desired_acceleration;
          // Symbol: drake::systems::controllers::VectorSetpoint::desired_position
          struct /* desired_position */ {
            // Source: drake/systems/controllers/setpoint.h:252
            const char* doc = R"""()""";
          } desired_position;
          // Symbol: drake::systems::controllers::VectorSetpoint::desired_velocity
          struct /* desired_velocity */ {
            // Source: drake/systems/controllers/setpoint.h:253
            const char* doc = R"""()""";
          } desired_velocity;
          // Symbol: drake::systems::controllers::VectorSetpoint::is_valid
          struct /* is_valid */ {
            // Source: drake/systems/controllers/setpoint.h:239
            const char* doc = R"""()""";
          } is_valid;
          // Symbol: drake::systems::controllers::VectorSetpoint::mutable_Kd
          struct /* mutable_Kd */ {
            // Source: drake/systems/controllers/setpoint.h:264
            const char* doc = R"""()""";
          } mutable_Kd;
          // Symbol: drake::systems::controllers::VectorSetpoint::mutable_Kp
          struct /* mutable_Kp */ {
            // Source: drake/systems/controllers/setpoint.h:263
            const char* doc = R"""()""";
          } mutable_Kp;
          // Symbol: drake::systems::controllers::VectorSetpoint::mutable_desired_acceleration
          struct /* mutable_desired_acceleration */ {
            // Source: drake/systems/controllers/setpoint.h:262
            const char* doc = R"""()""";
          } mutable_desired_acceleration;
          // Symbol: drake::systems::controllers::VectorSetpoint::mutable_desired_position
          struct /* mutable_desired_position */ {
            // Source: drake/systems/controllers/setpoint.h:260
            const char* doc = R"""()""";
          } mutable_desired_position;
          // Symbol: drake::systems::controllers::VectorSetpoint::mutable_desired_velocity
          struct /* mutable_desired_velocity */ {
            // Source: drake/systems/controllers/setpoint.h:261
            const char* doc = R"""()""";
          } mutable_desired_velocity;
          // Symbol: drake::systems::controllers::VectorSetpoint::size
          struct /* size */ {
            // Source: drake/systems/controllers/setpoint.h:257
            const char* doc = R"""()""";
          } size;
        } VectorSetpoint;
        // Symbol: drake::systems::controllers::ZMPPlanner
        struct /* ZMPPlanner */ {
          // Source: drake/systems/controllers/zmp_planner.h:70
          const char* doc =
R"""(Given a desired two dimensional (X and Y) zero-moment point (ZMP)
trajectory parameterized as a piecewise polynomial, an optimal center
of mass (CoM) trajectory is planned using a linear inverted pendulum
model (LIPM). A second order value function (optimal cost-to-go) and a
linear policy are also computed along the optimal trajectory. The
system dynamics for the X and Y directions are decoupled, however, we
plan the XY motion together for convenience.

Let :math:`c` be the CoM position, the The state of the system,
:math:`x`, is :math:`[c; \dot{c}]`, the control, :math:`u = \ddot{c}`,
and :math:`y` represents the center of pressure (CoP). For the X
direction, the LIPM dynamics is:

.. math:: y = c - \frac{z}{g} * u,

where :math:`g` is the gravity constant and :math:`z` is the CoM
height. :math:`z` is assumed to be constant in LIPM. The full dynamics
can also be written in the matrix form as:

.. math:: \dot{x} = A x + B u \
        y = C x + D u

The one step cost function :math:`L` is defined as:

.. math:: L(y, u, t) = (y - y_d(t))^T Q_y (y - y_d(t)) + u^T R u,

where :math:`Q_y` and :math:`R` are weighting matrices, and
:math:`y_d(t)` is the desired ZMP trajectory at time :math:`t`.

The value function is defined as

.. math:: V(x, t) = \min_{u[t:t_f]} \bar{x}(t_f)^T S \bar{x}(t_f)
          + \int_{t}^{t_f} L(y, u, \tau) d\tau,

subject to the dynamics, and :math:`t_f` is the last time in the
desired ZMP trajectory, :math:`\bar{x} = [c - y_d(t_f); \dot{c}]`,
:math:`S` is the quadratic term from the infinite horizon continuous
time LQR solution solved with the same dynamics and one step cost
function.

For this problem, :math:`V` is known to have a quadratic form of:

.. math:: V(x, t) = \bar{x}^T V_{xx} \bar{x} + \bar{x}^T V_x(t) + V_0(t),

and the corresponding optimal control policy, :math:`u^*`, is linear
w.r.t. to :math:`x`:

.. math:: u^*(x, t) = K \bar{x} + u_0(t).

See the following reference for more details about the algorithm:

[1] R. Tedrake, S. Kuindersma, R. Deits and K. Miura, "A closed-form
solution for real-time ZMP gait generation and feedback
stabilization," 2015 IEEE-RAS 15th International Conference on
Humanoid Robots (Humanoids), Seoul, 2015, pp. 936-940.)""";
          // Symbol: drake::systems::controllers::ZMPPlanner::ComputeOptimalCoMdd
          struct /* ComputeOptimalCoMdd */ {
            // Source: drake/systems/controllers/zmp_planner.h:111
            const char* doc =
R"""(Computes the optimal control (CoM acceleration) at ``time`` given CoM
state ``x`` using the linear policy. Should only be called after Plan
is called.

Parameter ``time``:
    , Current time.

Parameter ``x``:
    , Current state.

Returns:
    Optimal CoMdd.)""";
          } ComputeOptimalCoMdd;
          // Symbol: drake::systems::controllers::ZMPPlanner::Plan
          struct /* Plan */ {
            // Source: drake/systems/controllers/zmp_planner.h:93
            const char* doc =
R"""(Implements the algorithm in [1] that computes a nominal CoM
trajectory, and the corresponding second order value function and
linear policy.

None of the other public methods should be called until Plan is
called.

It is allowed to pass in a ``zmp_d`` with a non-stationary end point,
but the user should treat the result with caution, since the resulting
nominal CoM trajectory diverges exponentially fast past the end point.

Parameter ``zmp_d``:
    , Desired two dimensional ZMP trajectory.

Parameter ``x0``:
    , Initial CoM state.

Parameter ``height``:
    , CoM height from the ground.

Parameter ``gravity``:
    , Gravity constant, defaults to 9.81

Parameter ``Qy``:
    , Quadratic cost term on ZMP deviation from the desired, defaults
    to identity.

Parameter ``R``:
    , Quadratic cost term on CoM acceleration, defaults to zero.)""";
          } Plan;
          // Symbol: drake::systems::controllers::ZMPPlanner::ZMPPlanner
          struct /* ctor */ {
            // Source: drake/systems/controllers/zmp_planner.h:72
            const char* doc = R"""()""";
          } ctor;
          // Symbol: drake::systems::controllers::ZMPPlanner::comdd_to_cop
          struct /* comdd_to_cop */ {
            // Source: drake/systems/controllers/zmp_planner.h:123
            const char* doc =
R"""(Converts CoM acceleration to center of pressure (CoP) using cop = C *
x + D * u, which is equivalent to cop = com - z / g * comdd Should
only be called after Plan is called.

Parameter ``x``:
    , CoM position and velocity

Parameter ``u``:
    , CoM acceleration

Returns:
    center of pressure (CoP))""";
          } comdd_to_cop;
          // Symbol: drake::systems::controllers::ZMPPlanner::eigen_aligned_operator_new_marker_type
          struct /* eigen_aligned_operator_new_marker_type */ {
            // Source: drake/systems/controllers/zmp_planner.h:277
            const char* doc = R"""()""";
          } eigen_aligned_operator_new_marker_type;
          // Symbol: drake::systems::controllers::ZMPPlanner::get_A
          struct /* get_A */ {
            // Source: drake/systems/controllers/zmp_planner.h:132
            const char* doc = R"""(Getter for A matrix.)""";
          } get_A;
          // Symbol: drake::systems::controllers::ZMPPlanner::get_B
          struct /* get_B */ {
            // Source: drake/systems/controllers/zmp_planner.h:140
            const char* doc = R"""(Getter for B matrix.)""";
          } get_B;
          // Symbol: drake::systems::controllers::ZMPPlanner::get_C
          struct /* get_C */ {
            // Source: drake/systems/controllers/zmp_planner.h:148
            const char* doc = R"""(Getter for C matrix.)""";
          } get_C;
          // Symbol: drake::systems::controllers::ZMPPlanner::get_D
          struct /* get_D */ {
            // Source: drake/systems/controllers/zmp_planner.h:156
            const char* doc = R"""(Getter for D matrix.)""";
          } get_D;
          // Symbol: drake::systems::controllers::ZMPPlanner::get_Qy
          struct /* get_Qy */ {
            // Source: drake/systems/controllers/zmp_planner.h:164
            const char* doc = R"""(Getter for Qy matrix.)""";
          } get_Qy;
          // Symbol: drake::systems::controllers::ZMPPlanner::get_R
          struct /* get_R */ {
            // Source: drake/systems/controllers/zmp_planner.h:172
            const char* doc = R"""(Getter for R matrix.)""";
          } get_R;
          // Symbol: drake::systems::controllers::ZMPPlanner::get_Vx
          struct /* get_Vx */ {
            // Source: drake/systems/controllers/zmp_planner.h:262
            const char* doc =
R"""(Returns the time varying first order term (s2 in [1]) of the value
function.)""";
          } get_Vx;
          // Symbol: drake::systems::controllers::ZMPPlanner::get_Vxx
          struct /* get_Vxx */ {
            // Source: drake/systems/controllers/zmp_planner.h:253
            const char* doc =
R"""(Returns the time invariant second order term (S1 in [1]) of the value
function.)""";
          } get_Vxx;
          // Symbol: drake::systems::controllers::ZMPPlanner::get_desired_zmp
          struct /* get_desired_zmp */ {
            // Source: drake/systems/controllers/zmp_planner.h:180
            const char* doc_1args =
R"""(Returns the desired ZMP evaluated at ``time``.)""";
            // Source: drake/systems/controllers/zmp_planner.h:217
            const char* doc_0args = R"""(Returns the desired ZMP trajectory.)""";
          } get_desired_zmp;
          // Symbol: drake::systems::controllers::ZMPPlanner::get_final_desired_zmp
          struct /* get_final_desired_zmp */ {
            // Source: drake/systems/controllers/zmp_planner.h:209
            const char* doc = R"""()""";
          } get_final_desired_zmp;
          // Symbol: drake::systems::controllers::ZMPPlanner::get_nominal_com
          struct /* get_nominal_com */ {
            // Source: drake/systems/controllers/zmp_planner.h:188
            const char* doc_1args =
R"""(Returns the nominal CoM evaluated at ``time``.)""";
            // Source: drake/systems/controllers/zmp_planner.h:226
            const char* doc_0args = R"""(Returns the nominal CoM trajectory.)""";
          } get_nominal_com;
          // Symbol: drake::systems::controllers::ZMPPlanner::get_nominal_comd
          struct /* get_nominal_comd */ {
            // Source: drake/systems/controllers/zmp_planner.h:196
            const char* doc_1args =
R"""(Returns the nominal CoM velocity evaluated at ``time``.)""";
            // Source: drake/systems/controllers/zmp_planner.h:235
            const char* doc_0args =
R"""(Returns the nominal CoM velocity trajectory.)""";
          } get_nominal_comd;
          // Symbol: drake::systems::controllers::ZMPPlanner::get_nominal_comdd
          struct /* get_nominal_comdd */ {
            // Source: drake/systems/controllers/zmp_planner.h:204
            const char* doc_1args =
R"""(Returns the nominal CoM acceleration evaluated at ``time``.)""";
            // Source: drake/systems/controllers/zmp_planner.h:244
            const char* doc_0args =
R"""(Returns the nominal CoM acceleration trajectory.)""";
          } get_nominal_comdd;
          // Symbol: drake::systems::controllers::ZMPPlanner::has_planned
          struct /* has_planned */ {
            // Source: drake/systems/controllers/zmp_planner.h:101
            const char* doc = R"""(Returns true if Plan has been called.)""";
          } has_planned;
        } ZMPPlanner;
      } controllers;
      // Symbol: drake::systems::estimators
      struct /* estimators */ {
        // Symbol: drake::systems::estimators::LuenbergerObserver
        struct /* LuenbergerObserver */ {
          // Source: drake/systems/estimators/luenberger_observer.h:37
          const char* doc =
R"""(A simple state observer for a dynamical system of the form:

.. math:: \dot{x} = f(x,u)

.. math:: y = g(x,u)

the observer dynamics takes the form

.. math:: \dot{\hat{x}} = f(\hat{x},u) + L(y - g(\hat{x},u))

where :math:`\hat{x}` is the estimated state of the original system.

The output of the observer system is :math:`\hat{x}`.

.. pydrake_system::

    name: LuenbergerObserver
    input_ports:
    - observed system input
    - observed_system_output
    output_ports:
    - estimated_state

@tparam_default_scalars)""";
          // Symbol: drake::systems::estimators::LuenbergerObserver::L
          struct /* L */ {
            // Source: drake/systems/estimators/luenberger_observer.h:87
            const char* doc =
R"""(Provides access via the short-hand name, L, too.)""";
          } L;
          // Symbol: drake::systems::estimators::LuenbergerObserver::LuenbergerObserver<T>
          struct /* ctor */ {
            // Source: drake/systems/estimators/luenberger_observer.h:39
            const char* doc_was_unable_to_choose_unambiguous_names = R"""()""";
          } ctor;
          // Symbol: drake::systems::estimators::LuenbergerObserver::get_estimated_state_output_port
          struct /* get_estimated_state_output_port */ {
            // Source: drake/systems/estimators/luenberger_observer.h:79
            const char* doc = R"""()""";
          } get_estimated_state_output_port;
          // Symbol: drake::systems::estimators::LuenbergerObserver::get_observed_system_input_input_port
          struct /* get_observed_system_input_input_port */ {
            // Source: drake/systems/estimators/luenberger_observer.h:69
            const char* doc = R"""()""";
          } get_observed_system_input_input_port;
          // Symbol: drake::systems::estimators::LuenbergerObserver::get_observed_system_output_input_port
          struct /* get_observed_system_output_input_port */ {
            // Source: drake/systems/estimators/luenberger_observer.h:74
            const char* doc = R"""()""";
          } get_observed_system_output_input_port;
          // Symbol: drake::systems::estimators::LuenbergerObserver::observer_gain
          struct /* observer_gain */ {
            // Source: drake/systems/estimators/luenberger_observer.h:84
            const char* doc = R"""(Provides access to the observer gain.)""";
          } observer_gain;
        } LuenbergerObserver;
        // Symbol: drake::systems::estimators::SteadyStateKalmanFilter
        struct /* SteadyStateKalmanFilter */ {
          // Source: drake/systems/estimators/kalman_filter.h:37
          const char* doc_4args_A_C_W_V =
R"""(Computes the optimal observer gain, L, for the linear system defined
by

.. math:: \dot{x} = Ax + Bu + w,

.. math:: y = Cx + Du + v.

The resulting observer is of the form

.. math:: \dot{\hat{x}} = A\hat{x} + Bu + L(y - C\hat{x} - Du).

The process noise, w, and the measurement noise, v, are assumed to be
iid mean-zero Gaussian.

This is a simplified form of the full Kalman filter obtained by
assuming that the state-covariance matrix has already converged to its
steady-state solution.

Parameter ``A``:
    The state-space dynamics matrix of size num_states x num_states.

Parameter ``C``:
    The state-space output matrix of size num_outputs x num_states.

Parameter ``W``:
    The process noise covariance matrix, E[ww'], of size num_states x
    num_states.

Parameter ``V``:
    The measurement noise covariance matrix, E[vv'], of size num_.

Returns:
    The steady-state observer gain matrix of size num_states x
    num_outputs.

Raises:
    RuntimeError if V is not positive definite.)""";
          // Source: drake/systems/estimators/kalman_filter.h:56
          const char* doc_3args_system_W_V =
R"""(Creates a Luenberger observer system using the optimal steady-state
Kalman filter gain matrix, L, as described above.

Parameter ``system``:
    A unique_ptr to a LinearSystem describing the system to be
    observed. The new observer will take and maintain ownership of
    this pointer.

Parameter ``W``:
    The process noise covariance matrix, E[ww'], of size num_states x
    num_states.

Parameter ``V``:
    The measurement noise covariance matrix, E[vv'], of size num_.

Returns:
    A unique_ptr to the constructed observer system.

Raises:
    RuntimeError if V is not positive definite.)""";
          // Source: drake/systems/estimators/kalman_filter.h:88
          const char* doc_4args_system_context_W_V =
R"""(Creates a Luenberger observer system using the steady-state Kalman
filter observer gain.

Assuming ``system`` has the (continuous-time) dynamics: dx/dt =
f(x,u), and the output: y = g(x,u), then the resulting observer will
have the form dx̂/dt = f(x̂,u) + L(y - g(x̂,u)), where x̂ is the
estimated state and the gain matrix, L, is designed as a steady-state
Kalman filter using a linearization of f(x,u) at ``context`` as
described above.

Parameter ``system``:
    A unique_ptr to a System describing the system to be observed. The
    new observer will take and maintain ownership of this pointer.

Parameter ``context``:
    A unique_ptr to the context describing a fixed-point of the system
    (plus any additional parameters). The new observer will take and
    maintain ownership of this pointer for use in its internal forward
    simulation.

Parameter ``W``:
    The process noise covariance matrix, E[ww'], of size num_states x
    num_states.

Parameter ``V``:
    The measurement noise covariance matrix, E[vv'], of size num_.

Returns:
    A unique_ptr to the constructed observer system.

Raises:
    RuntimeError if V is not positive definite.)""";
        } SteadyStateKalmanFilter;
      } estimators;
      // Symbol: drake::systems::kAbstractValued
      struct /* kAbstractValued */ {
        // Source: drake/systems/framework/framework_common.h:75
        const char* doc = R"""()""";
      } kAbstractValued;
      // Symbol: drake::systems::kVectorValued
      struct /* kVectorValued */ {
        // Source: drake/systems/framework/framework_common.h:74
        const char* doc = R"""()""";
      } kVectorValued;
      // Symbol: drake::systems::lcm
      struct /* lcm */ {
        // Symbol: drake::systems::lcm::ConnectLcmScope
        struct /* ConnectLcmScope */ {
          // Source: drake/systems/lcm/connect_lcm_scope.h:37
          const char* doc =
R"""((To be deprecated.) Prefer to use LcmScopeSystem::AddToBuilder instead
of this function; the LcmScopeSystem provides more detailed
timestamps.

Provides the ability to publish any vector-valued output port to the
LCM ``channel``, using the drake::lcmt_drake_signal LCM message type,
by adding an appropriate LcmPublisherSystem to the ``builder``. If
``lcm`` is null, then an LCM instance will be created automatically
(but this is expensive, and creating multiple LCM instances in a
single process should be avoided).

The intention is to enable logging and debugging in complex diagrams
using external tools like ``lcm-spy``.

The optional ``publish_period`` specifies how often messages will be
published. If the period is zero (the default), then the underlying
LcmPublisherSystem will publish every step.

Precondition:
    ``src`` must be an OutputPort of a system that has already been
    added to the ``builder``.)""";
        } ConnectLcmScope;
        // Symbol: drake::systems::lcm::LcmInterfaceSystem
        struct /* LcmInterfaceSystem */ {
          // Source: drake/systems/lcm/lcm_interface_system.h:39
          const char* doc =
R"""(LcmInterfaceSystem acts within a Diagram to allow LcmSubscriberSystem
instances to receive data from the network during a simulation. When
its parent Diagram is run via the Simulator, the LcmSubscriberSystem
sources will output new values based on new data received over LCM.

This System has no inputs nor outputs nor state nor parameters; it
declares only an update event that pumps LCM messages into their
subscribers iff the LCM stack has message(s) waiting. The subscribers
will then update their outputs using their own declared events.

Note that because this class implements DrakeLcmInterface, any
subscriber registered on that interface will be serviced during
simulation, not just `LcmSubscriberSystem`s.


::

    {cpp}
    DiagramBuilder<double> builder;
    auto lcm = builder.AddSystem<LcmInterfaceSystem>();
    auto subscriber = builder.AddSystem(
        LcmSubscriberSystem::Make<lcmt_drake_signal>("channel", lcm));)""";
          // Symbol: drake::systems::lcm::LcmInterfaceSystem::HandleSubscriptions
          struct /* HandleSubscriptions */ {
            // Source: drake/systems/lcm/lcm_interface_system.h:64
            const char* doc = R"""()""";
          } HandleSubscriptions;
          // Symbol: drake::systems::lcm::LcmInterfaceSystem::LcmInterfaceSystem
          struct /* ctor */ {
            // Source: drake/systems/lcm/lcm_interface_system.h:48
            const char* doc_1args_lcm_url =
R"""(Constructs using the given URL. With no URL, uses the LCM_DEFAULT_URL
environment variable iff it is set or else the default hard-coded URL.)""";
            // Source: drake/systems/lcm/lcm_interface_system.h:55
            const char* doc_1args_lcm =
R"""(Constructs using the given LCM service. The pointer is aliased by this
class and must remain valid for the lifetime of this object. Users
MUST NOT start the receive thread on this object.)""";
          } ctor;
          // Symbol: drake::systems::lcm::LcmInterfaceSystem::Publish
          struct /* Publish */ {
            // Source: drake/systems/lcm/lcm_interface_system.h:60
            const char* doc = R"""()""";
          } Publish;
          // Symbol: drake::systems::lcm::LcmInterfaceSystem::Subscribe
          struct /* Subscribe */ {
            // Source: drake/systems/lcm/lcm_interface_system.h:63
            const char* doc = R"""()""";
          } Subscribe;
        } LcmInterfaceSystem;
        // Symbol: drake::systems::lcm::LcmLogPlaybackSystem
        struct /* LcmLogPlaybackSystem */ {
          // Source: drake/systems/lcm/lcm_log_playback_system.h:19
          const char* doc =
R"""(Advances the cursor of a drake::lcm::DrakeLcmLog based on the
timestamps seen the Context that is used to simulate this System.

This is useful when a simulated Diagram contains
LcmSubscriberSystem(s) whose outputs should be determined by logged
data and when the log's cursor should advance automatically during
simulation.)""";
          // Symbol: drake::systems::lcm::LcmLogPlaybackSystem::DoCalcNextUpdateTime
          struct /* DoCalcNextUpdateTime */ {
            // Source: drake/systems/lcm/lcm_log_playback_system.h:33
            const char* doc = R"""()""";
          } DoCalcNextUpdateTime;
          // Symbol: drake::systems::lcm::LcmLogPlaybackSystem::LcmLogPlaybackSystem
          struct /* ctor */ {
            // Source: drake/systems/lcm/lcm_log_playback_system.h:28
            const char* doc =
R"""(Constructs a playback system that advances the given ``log``.

Parameter ``log``:
    non-null pointer that is aliased and retained by this object.)""";
          } ctor;
        } LcmLogPlaybackSystem;
        // Symbol: drake::systems::lcm::LcmPublisherSystem
        struct /* LcmPublisherSystem */ {
          // Source: drake/systems/lcm/lcm_publisher_system.h:49
          const char* doc =
R"""(Publishes an LCM message containing information from its input port.
Optionally sends a one-time initialization message. Publishing can be
set up to happen on a per-step or periodic basis. Publishing "by
force", through ``LcmPublisherSystem::Publish(const Context&)``, is
also enabled.

Note:
    You should generally provide an LCM interface yourself, since
    there should normally be just one of these typically-heavyweight
    objects per program. However, if you're sure there isn't any other
    need for an LCM interface in your program, you can let
    LcmPublisherSystem allocate and maintain a drake::lcm::DrakeLcm
    object internally.

.. pydrake_system::

    name: LcmPublisherSystem
    input_ports:
    - lcm_message)""";
          // Symbol: drake::systems::lcm::LcmPublisherSystem::AddInitializationMessage
          struct /* AddInitializationMessage */ {
            // Source: drake/systems/lcm/lcm_publisher_system.h:203
            const char* doc =
R"""(Specifies a message-publishing function to be invoked once from an
initialization event. If this method is not called, no initialization
event will be created.

You can only call this method once.

Raises:
    RuntimeError if called a second time.

Precondition:
    The publisher function may not be null.)""";
          } AddInitializationMessage;
          // Symbol: drake::systems::lcm::LcmPublisherSystem::InitializationPublisher
          struct /* InitializationPublisher */ {
            // Source: drake/systems/lcm/lcm_publisher_system.h:190
            const char* doc =
R"""(This is the type of an initialization message publisher that can be
provided via AddInitializationMessage().)""";
          } InitializationPublisher;
          // Symbol: drake::systems::lcm::LcmPublisherSystem::LcmPublisherSystem
          struct /* ctor */ {
            // Source: drake/systems/lcm/lcm_publisher_system.h:146
            const char* doc_4args =
R"""(A constructor for an LcmPublisherSystem that takes LCM message objects
on its sole abstract-valued input port. The LCM message type is
determined by the provided ``serializer``. Will publish on forced
events and either periodic or per-step events, as determined by
publish_period.

Parameter ``channel``:
    The LCM channel on which to publish.

Parameter ``serializer``:
    The serializer that converts between byte vectors and LCM message
    objects.

Parameter ``lcm``:
    A pointer to the LCM subsystem to use, which must remain valid for
    the lifetime of this object. If null, a drake::lcm::DrakeLcm
    object is allocated and maintained internally, but see the note in
    the class comments.

Parameter ``publish_period``:
    Period that messages will be published (optional). If the publish
    period is zero, LcmPublisherSystem will use per-step publishing
    instead; see LeafSystem::DeclarePerStepPublishEvent().

Precondition:
    publish_period is non-negative.)""";
            // Source: drake/systems/lcm/lcm_publisher_system.h:178
            const char* doc_5args =
R"""(A constructor for an LcmPublisherSystem that takes LCM message objects
on its sole abstract-valued input port. The LCM message type is
determined by the provided ``serializer``.

Parameter ``channel``:
    The LCM channel on which to publish.

Parameter ``serializer``:
    The serializer that converts between byte vectors and LCM message
    objects.

Parameter ``lcm``:
    A pointer to the LCM subsystem to use, which must remain valid for
    the lifetime of this object. If null, a drake::lcm::DrakeLcm
    object is allocated and maintained internally, but see the note in
    the class comments.

Parameter ``publish_triggers``:
    Set of triggers that determine when messages will be published.
    Supported TriggerTypes are {kForced, kPeriodic, kPerStep}. Will
    throw an exception if empty or if unsupported types are provided.

Parameter ``publish_period``:
    Period that messages will be published (optional). publish_period
    should only be non-zero if one of the publish_triggers is
    kPerStep.

Precondition:
    publish_period is non-negative.

Precondition:
    publish_period > 0 iff publish_triggers contains kPeriodic.

Precondition:
    publish_triggers contains a subset of {kForced, kPeriodic,
    kPerStep}.)""";
          } ctor;
          // Symbol: drake::systems::lcm::LcmPublisherSystem::Make
          struct /* Make */ {
            // Source: drake/systems/lcm/lcm_publisher_system.h:77
            const char* doc_3args =
R"""(A factory method that returns an LcmPublisherSystem that takes
Value<LcmMessage> message objects on its sole abstract-valued input
port.

Sets the default set of publish triggers: if publish_period = 0,
publishes on forced events and per step, if publish_period > 0,
publishes on forced events and periodically.

Template parameter ``LcmMessage``:
    message type to serialize, e.g., lcmt_drake_signal.

Parameter ``channel``:
    The LCM channel on which to publish.

Parameter ``lcm``:
    A pointer to the LCM subsystem to use, which must remain valid for
    the lifetime of this object. If null, a drake::lcm::DrakeLcm
    object is allocated and maintained internally, but see the note in
    the class comments.

Parameter ``publish_period``:
    Period that messages will be published (optional). If the publish
    period is zero, LcmPublisherSystem will use per-step publishing
    instead; see LeafSystem::DeclarePerStepPublishEvent().

Precondition:
    publish_period is non-negative.)""";
            // Source: drake/systems/lcm/lcm_publisher_system.h:114
            const char* doc_4args =
R"""(A factory method for an LcmPublisherSystem that takes LCM message
objects on its sole abstract-valued input port. The LCM message type
is determined by the provided ``serializer``.

Parameter ``channel``:
    The LCM channel on which to publish.

Parameter ``serializer``:
    The serializer that converts between byte vectors and LCM message
    objects.

Parameter ``lcm``:
    A pointer to the LCM subsystem to use, which must remain valid for
    the lifetime of this object. If null, a drake::lcm::DrakeLcm
    object is allocated and maintained internally, but see the note in
    the class comments.

Parameter ``publish_triggers``:
    Set of triggers that determine when messages will be published.
    Supported TriggerTypes are {kForced, kPeriodic, kPerStep}. Will
    throw an error if empty or if unsupported types are provided.

Parameter ``publish_period``:
    Period that messages will be published (optional). publish_period
    should only be non-zero if one of the publish_triggers is
    kPeriodic.

Precondition:
    publish_period is non-negative.

Precondition:
    publish_triggers contains a subset of {kForced, kPeriodic,
    kPerStep}.

Precondition:
    publish_period > 0 if and only if publish_triggers contains
    kPeriodic.)""";
          } Make;
          // Symbol: drake::systems::lcm::LcmPublisherSystem::get_channel_name
          struct /* get_channel_name */ {
            // Source: drake/systems/lcm/lcm_publisher_system.h:209
            const char* doc =
R"""(Returns the channel name supplied during construction.)""";
          } get_channel_name;
          // Symbol: drake::systems::lcm::LcmPublisherSystem::get_publish_period
          struct /* get_publish_period */ {
            // Source: drake/systems/lcm/lcm_publisher_system.h:229
            const char* doc =
R"""(Returns the publish_period provided at construction time.)""";
          } get_publish_period;
          // Symbol: drake::systems::lcm::LcmPublisherSystem::lcm
          struct /* lcm */ {
            // Source: drake/systems/lcm/lcm_publisher_system.h:221
            const char* doc =
R"""(Returns a mutable reference to the LCM object in use by this
publisher. This may have been supplied in the constructor or may be an
internally-maintained object of type drake::lcm::DrakeLcm.)""";
          } lcm;
          // Symbol: drake::systems::lcm::LcmPublisherSystem::make_name
          struct /* make_name */ {
            // Source: drake/systems/lcm/lcm_publisher_system.h:214
            const char* doc =
R"""(Returns the default name for a system that publishes ``channel``.)""";
          } make_name;
        } LcmPublisherSystem;
        // Symbol: drake::systems::lcm::LcmScopeSystem
        struct /* LcmScopeSystem */ {
          // Source: drake/systems/lcm/lcm_scope_system.h:20
          const char* doc =
R"""(LcmScopeSystem provides the ability to convert any vector output port
to a simple LCM message and publish that message periodically. The
intention is to instrument complex diagrams using external tools like
``lcm-spy``.)""";
          // Symbol: drake::systems::lcm::LcmScopeSystem::AddToBuilder
          struct /* AddToBuilder */ {
            // Source: drake/systems/lcm/lcm_scope_system.h:44
            const char* doc =
R"""(Adds an LcmScopeSystem and LcmPublisherSystem to the given
``builder``.

Parameter ``lcm``:
    A pointer to the LCM subsystem to use, which must remain valid for
    the lifetime of ``builder``. This will typically be an instance of
    an LcmInterfaceSystem that's already been added to the
    ``builder``.

Parameter ``signal``:
    The output port to be scoped. Must be an OutputPort of a system
    that's already been added to the ``builder``.

Parameter ``channel``:
    The LCM channel on which to publish.

Parameter ``publish_period``:
    Specifies how often messages will be published. If the period is
    zero, the LcmPublisherSystem will publish every step.)""";
          } AddToBuilder;
          // Symbol: drake::systems::lcm::LcmScopeSystem::LcmScopeSystem
          struct /* ctor */ {
            // Source: drake/systems/lcm/lcm_scope_system.h:29
            const char* doc =
R"""((Advanced.) Most users will use AddToBuilder instead of this
constructor. On its own, this constructor does not publish anything.

Creates a system with one input port and one output port. The input
accepts a vector of the given ``size``. The output produces an
lcmt_scope message.)""";
          } ctor;
        } LcmScopeSystem;
        // Symbol: drake::systems::lcm::LcmSubscriberSystem
        struct /* LcmSubscriberSystem */ {
          // Source: drake/systems/lcm/lcm_subscriber_system.h:42
          const char* doc =
R"""(Receives LCM messages from a given channel and outputs them to a
System<double>'s port. This class stores the most recently processed
LCM message in the State. When a LCM message arrives asynchronously,
an update event is scheduled to process the message and store it in
the State at the earliest possible simulation time. The output is
always consistent with the State.

To process a LCM message, CalcNextUpdateTime() needs to be called
first to check for new messages and schedule a callback event if a new
LCM message has arrived. The message is then processed and stored in
the Context by CalcUnrestrictedUpdate(). When this system is evaluated
by the Simulator, all these operations are taken care of by the
Simulator. On the other hand, the user needs to manually replicate
this process without the Simulator.

If LCM service in use is a drake::lcm::DrakeLcmLog (not live
operation), then see drake::systems::lcm::LcmLogPlaybackSystem for a
helper to advance the log cursor in concert with the simulation.)""";
          // Symbol: drake::systems::lcm::LcmSubscriberSystem::GetInternalMessageCount
          struct /* GetInternalMessageCount */ {
            // Source: drake/systems/lcm/lcm_subscriber_system.h:108
            const char* doc =
R"""(Returns the internal message counter. Meant to be used with
``WaitForMessage``.)""";
          } GetInternalMessageCount;
          // Symbol: drake::systems::lcm::LcmSubscriberSystem::GetMessageCount
          struct /* GetMessageCount */ {
            // Source: drake/systems/lcm/lcm_subscriber_system.h:113
            const char* doc =
R"""(Returns the message counter stored in ``context``.)""";
          } GetMessageCount;
          // Symbol: drake::systems::lcm::LcmSubscriberSystem::LcmSubscriberSystem
          struct /* ctor */ {
            // Source: drake/systems/lcm/lcm_subscriber_system.h:75
            const char* doc =
R"""(Constructor that returns a subscriber System that provides message
objects on its sole abstract-valued output port. The type of the
message object is determined by the ``serializer``.

Parameter ``channel``:
    The LCM channel on which to subscribe.

Parameter ``serializer``:
    The serializer that converts between byte vectors and LCM message
    objects.

Parameter ``lcm``:
    A non-null pointer to the LCM subsystem to subscribe on.)""";
          } ctor;
          // Symbol: drake::systems::lcm::LcmSubscriberSystem::Make
          struct /* Make */ {
            // Source: drake/systems/lcm/lcm_subscriber_system.h:57
            const char* doc =
R"""(Factory method that returns a subscriber System that provides
Value<LcmMessage> message objects on its sole abstract-valued output
port.

Template parameter ``LcmMessage``:
    message type to deserialize, e.g., lcmt_drake_signal.

Parameter ``channel``:
    The LCM channel on which to subscribe.

Parameter ``lcm``:
    A non-null pointer to the LCM subsystem to subscribe on.)""";
          } Make;
          // Symbol: drake::systems::lcm::LcmSubscriberSystem::WaitForMessage
          struct /* WaitForMessage */ {
            // Source: drake/systems/lcm/lcm_subscriber_system.h:101
            const char* doc =
R"""(Blocks the caller until its internal message count exceeds
``old_message_count`` with an optional timeout.

Parameter ``old_message_count``:
    Internal message counter.

Parameter ``message``:
    If non-null, will return the received message.

Parameter ``timeout``:
    The duration (in seconds) to wait before returning; a non-positive
    duration will not time out.

Returns:
    Returns the new count of received messages. If a timeout occurred,
    this will be less than or equal to old_message_count.

Precondition:
    If ``message`` is specified, this system must be abstract-valued.)""";
          } WaitForMessage;
          // Symbol: drake::systems::lcm::LcmSubscriberSystem::get_channel_name
          struct /* get_channel_name */ {
            // Source: drake/systems/lcm/lcm_subscriber_system.h:84
            const char* doc = R"""()""";
          } get_channel_name;
          // Symbol: drake::systems::lcm::LcmSubscriberSystem::make_name
          struct /* make_name */ {
            // Source: drake/systems/lcm/lcm_subscriber_system.h:82
            const char* doc =
R"""(Returns the default name for a system that subscribes to ``channel``.)""";
          } make_name;
        } LcmSubscriberSystem;
        // Symbol: drake::systems::lcm::Serializer
        struct /* Serializer */ {
          // Source: drake/systems/lcm/serializer.h:58
          const char* doc =
R"""(Serializer is specific to a single LcmMessage type, and translates
between LCM message bytes and drake::Value<LcmMessage> objects.

Template parameter ``LcmMessage``:
    message type to serialize, e.g., lcmt_drake_signal.)""";
          // Symbol: drake::systems::lcm::Serializer::CreateDefaultValue
          struct /* CreateDefaultValue */ {
            // Source: drake/systems/lcm/serializer.h:65
            const char* doc = R"""()""";
          } CreateDefaultValue;
          // Symbol: drake::systems::lcm::Serializer::Deserialize
          struct /* Deserialize */ {
            // Source: drake/systems/lcm/serializer.h:72
            const char* doc = R"""()""";
          } Deserialize;
          // Symbol: drake::systems::lcm::Serializer::Serialize
          struct /* Serialize */ {
            // Source: drake/systems/lcm/serializer.h:81
            const char* doc = R"""()""";
          } Serialize;
          // Symbol: drake::systems::lcm::Serializer::Serializer<LcmMessage>
          struct /* ctor */ {
            // Source: drake/systems/lcm/serializer.h:60
            const char* doc = R"""()""";
          } ctor;
        } Serializer;
        // Symbol: drake::systems::lcm::SerializerInterface
        struct /* SerializerInterface */ {
          // Source: drake/systems/lcm/serializer.h:22
          const char* doc =
R"""(SerializerInterface translates between LCM message bytes and
drake::AbstractValue objects that contain LCM messages, e.g., a
Value<lcmt_drake_signal>. See Serializer for a message-specific
concrete subclass.)""";
          // Symbol: drake::systems::lcm::SerializerInterface::CreateDefaultValue
          struct /* CreateDefaultValue */ {
            // Source: drake/systems/lcm/serializer.h:32
            const char* doc =
R"""(Creates a value-initialized (zeroed) instance of the message object.
The result can be used as the output object filled in by Deserialize.)""";
          } CreateDefaultValue;
          // Symbol: drake::systems::lcm::SerializerInterface::Deserialize
          struct /* Deserialize */ {
            // Source: drake/systems/lcm/serializer.h:37
            const char* doc =
R"""(Translates LCM message bytes into a drake::AbstractValue object.)""";
          } Deserialize;
          // Symbol: drake::systems::lcm::SerializerInterface::Serialize
          struct /* Serialize */ {
            // Source: drake/systems/lcm/serializer.h:44
            const char* doc =
R"""(Translates a drake::AbstractValue object into LCM message bytes.)""";
          } Serialize;
          // Symbol: drake::systems::lcm::SerializerInterface::SerializerInterface
          struct /* ctor */ {
            // Source: drake/systems/lcm/serializer.h:24
            const char* doc = R"""()""";
          } ctor;
        } SerializerInterface;
        // Symbol: drake::systems::lcm::TriggerTypeSet
        struct /* TriggerTypeSet */ {
          // Source: drake/systems/lcm/lcm_publisher_system.h:27
          const char* doc = R"""()""";
        } TriggerTypeSet;
      } lcm;
      // Symbol: drake::systems::rendering
      struct /* rendering */ {
        // Symbol: drake::systems::rendering::FrameVelocity
        struct /* FrameVelocity */ {
          // Source: drake/systems/rendering/frame_velocity.h:21
          const char* doc =
R"""(A 6-vector representing the derivatives of the position transform of
frame A in the world frame, Xdot_WA, in the form ``{R_WA, p_WA}``,
where ``p`` is the derivatives of x-y-z translation, and ``R`` is the
derivatives of x-y-z rotation.

The exact order of elements is ``{ωx, ωy, ωz, vx, vy, vz}``.)""";
          // Symbol: drake::systems::rendering::FrameVelocity::DoClone
          struct /* DoClone */ {
            // Source: drake/systems/rendering/frame_velocity.h:45
            const char* doc = R"""()""";
          } DoClone;
          // Symbol: drake::systems::rendering::FrameVelocity::FrameVelocity<T>
          struct /* ctor */ {
            // Source: drake/systems/rendering/frame_velocity.h:24
            const char* doc_0args = R"""(Default constructor.)""";
            // Source: drake/systems/rendering/frame_velocity.h:29
            const char* doc_1args =
R"""(Fully-parameterized constructor.

Parameter ``velocity``:
    the entire spatial velocity V_WA.)""";
          } ctor;
          // Symbol: drake::systems::rendering::FrameVelocity::get_velocity
          struct /* get_velocity */ {
            // Source: drake/systems/rendering/frame_velocity.h:38
            const char* doc =
R"""(Returns the entire spatial velocity V_WA.)""";
          } get_velocity;
          // Symbol: drake::systems::rendering::FrameVelocity::set_velocity
          struct /* set_velocity */ {
            // Source: drake/systems/rendering/frame_velocity.h:40
            const char* doc =
R"""(Assigns the entire spatial velocity V_WA.)""";
          } set_velocity;
        } FrameVelocity;
        // Symbol: drake::systems::rendering::MultibodyPositionToGeometryPose
        struct /* MultibodyPositionToGeometryPose */ {
          // Source: drake/systems/rendering/multibody_position_to_geometry_pose.h:35
          const char* doc =
R"""(A direct-feedthrough system that converts a vector of joint positions
directly to a geometry::FramePoseVector<T> to behave like a
MultibodyPlant::get_geometry_pose_output_port().

.. pydrake_system::

    name: MultibodyPositionToGeometryPose
    input_ports:
    - position
    output_ports:
    - geometry_pose

The position input must be a vector whose length matches either the
number of positions in the MultibodyPlant or the number of states
(based on the optional argument in the constructor). This option to
pass the full state vector is provided only for convenience -- only
the position values will affect the outputs.)""";
          // Symbol: drake::systems::rendering::MultibodyPositionToGeometryPose::MultibodyPositionToGeometryPose<T>
          struct /* ctor */ {
            // Source: drake/systems/rendering/multibody_position_to_geometry_pose.h:51
            const char* doc_2args_plant_input_multibody_state =
R"""(The MultibodyPositionToGeometryPose holds an internal, non-owned
reference to the MultibodyPlant object so you must ensure that
``plant`` has a longer lifetime than ``this``
MultibodyPositionToGeometryPose system.

Parameter ``input_multibody_state``:
    If true, the vector input port will be the size of the ``plant``
    *state* vector. If false, it will be the size of the ``plant``
    *position* vector. In both cases, only the positions will affect
    the output. $*Default:* false.

Raises:
    if ``plant`` is not finalized and registered with a SceneGraph.)""";
            // Source: drake/systems/rendering/multibody_position_to_geometry_pose.h:65
            const char* doc_2args_owned_plant_input_multibody_state =
R"""(The MultibodyPositionToGeometryPose owns its internal plant.

Parameter ``input_multibody_state``:
    If true, the vector input port will be the size of the ``plant``
    *state* vector. If false, it will be the size of the ``plant``
    *position* vector. In both cases, only the positions will affect
    the output. @default: false.

Raises:
    if ``owned_plant`` is not finalized and registered with a
    SceneGraph.)""";
          } ctor;
          // Symbol: drake::systems::rendering::MultibodyPositionToGeometryPose::multibody_plant
          struct /* multibody_plant */ {
            // Source: drake/systems/rendering/multibody_position_to_geometry_pose.h:71
            const char* doc = R"""()""";
          } multibody_plant;
          // Symbol: drake::systems::rendering::MultibodyPositionToGeometryPose::owns_plant
          struct /* owns_plant */ {
            // Source: drake/systems/rendering/multibody_position_to_geometry_pose.h:74
            const char* doc =
R"""(Returns true if this system owns its MultibodyPlant.)""";
          } owns_plant;
        } MultibodyPositionToGeometryPose;
        // Symbol: drake::systems::rendering::PoseAggregator
        struct /* PoseAggregator */ {
          // Source: drake/systems/rendering/pose_aggregator.h:77
          const char* doc =
R"""(PoseAggregator is a multiplexer for heterogeneous sources of poses and
the velocities of those poses. Supported sources are:

- A PoseVector input, which is a single pose {R, p}, and is vector-valued.
- A FrameVelocity input, which corresponds to a PoseVector input, and
  contains a single velocity {ω, v}, and is vector-valued.
- A PoseBundle input, which is a collection of poses and velocities, and is
  abstract-valued.

PoseAggregator is stateless.

The output is a flat PoseBundle that contains all the poses and
velocities from all the inputs. Unspecified velocities are zero. By
convention, each aggregated pose or velocity is in the same world
frame of reference.

The output poses are named in the form ``<source>`` or
``<source>::<pose>``.

- For poses derived from a PoseVector input, <source> is the bundle name
  provided at construction time, and "::<pose>" is omitted.
- For poses derived from a PoseBundle input, <source> is the bundle name
  provided at construction time, and <pose> is the name found in the input
  PoseBundle at output evaluation time. In any sane use case, the input
  names will be stable during a simulation, but PoseAggregator is stateless
  and therefore can't check whether this is actually true.

The output poses are also each assigned a model instance ID, which
must be an integer that is greater than or equal to zero. All poses
with the same model instance ID must have unique names. This enables
PoseAggregator to aggregate multiple instances of the same model.

- For poses derived from a PoseVector input, the instance ID is specified
  when the input is declared.
- For poses derived from a PoseBundle input, the instance ID is obtained
  directly from the PoseBundle.

In typical usage, Diagrams should contain just one PoseAggregator, and
every pose in the Diagram should appear as an input to it. Then,
Systems that need to ingest every pose in the universe, such as
renderers or sensor models, can simply depend on the output.)""";
          // Symbol: drake::systems::rendering::PoseAggregator::AddBundleInput
          struct /* AddBundleInput */ {
            // Source: drake/systems/rendering/pose_aggregator.h:104
            const char* doc =
R"""(Adds an input for a PoseBundle containing ``num_poses`` poses.)""";
          } AddBundleInput;
          // Symbol: drake::systems::rendering::PoseAggregator::AddSingleInput
          struct /* AddSingleInput */ {
            // Source: drake/systems/rendering/pose_aggregator.h:92
            const char* doc =
R"""(Adds an input for a PoseVector. ``name`` must be unique for all inputs
with the same ``model_instance_id``.)""";
          } AddSingleInput;
          // Symbol: drake::systems::rendering::PoseAggregator::AddSinglePoseAndVelocityInput
          struct /* AddSinglePoseAndVelocityInput */ {
            // Source: drake/systems/rendering/pose_aggregator.h:101
            const char* doc =
R"""(Adds an input for a PoseVector, and a corresponding input for a
FrameVelocity. ``name`` must be unique for all inputs with the same
``model_instance_id``.

Returns:
    Input ports for pose and velocity.)""";
          } AddSinglePoseAndVelocityInput;
          // Symbol: drake::systems::rendering::PoseAggregator::PoseAggregator<T>
          struct /* ctor */ {
            // Source: drake/systems/rendering/pose_aggregator.h:82
            const char* doc =
R"""(Constructs a default aggregator (with no inputs).)""";
            // Source: drake/systems/rendering/pose_aggregator.h:86
            const char* doc_copyconvert =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";
          } ctor;
        } PoseAggregator;
        // Symbol: drake::systems::rendering::PoseBundle
        struct /* PoseBundle */ {
          // Source: drake/systems/rendering/pose_bundle.h:34
          const char* doc =
R"""(PoseBundle is a container for a set of poses, represented by an
Isometry3, and corresponding velocities, represented by a
FrameVelocity. The poses and velocities are expressed in the world
frame: X_WFi, V_WFi. Each pose has a name and a model instance ID. If
two poses in the bundle have the same model instance ID, they must not
have the same name.)""";
          // Symbol: drake::systems::rendering::PoseBundle::PoseBundle<T>
          struct /* ctor */ {
            // Source: drake/systems/rendering/pose_bundle.h:36
            const char* doc = R"""()""";
          } ctor;
          // Symbol: drake::systems::rendering::PoseBundle::get_model_instance_id
          struct /* get_model_instance_id */ {
            // Source: drake/systems/rendering/pose_bundle.h:51
            const char* doc = R"""()""";
          } get_model_instance_id;
          // Symbol: drake::systems::rendering::PoseBundle::get_name
          struct /* get_name */ {
            // Source: drake/systems/rendering/pose_bundle.h:48
            const char* doc = R"""()""";
          } get_name;
          // Symbol: drake::systems::rendering::PoseBundle::get_num_poses
          struct /* get_num_poses */ {
            // Source: drake/systems/rendering/pose_bundle.h:41
            const char* doc = R"""()""";
          } get_num_poses;
          // Symbol: drake::systems::rendering::PoseBundle::get_transform
          struct /* get_transform */ {
            // Source: drake/systems/rendering/pose_bundle.h:42
            const char* doc = R"""()""";
          } get_transform;
          // Symbol: drake::systems::rendering::PoseBundle::get_velocity
          struct /* get_velocity */ {
            // Source: drake/systems/rendering/pose_bundle.h:45
            const char* doc = R"""()""";
          } get_velocity;
          // Symbol: drake::systems::rendering::PoseBundle::set_model_instance_id
          struct /* set_model_instance_id */ {
            // Source: drake/systems/rendering/pose_bundle.h:52
            const char* doc = R"""()""";
          } set_model_instance_id;
          // Symbol: drake::systems::rendering::PoseBundle::set_name
          struct /* set_name */ {
            // Source: drake/systems/rendering/pose_bundle.h:49
            const char* doc = R"""()""";
          } set_name;
          // Symbol: drake::systems::rendering::PoseBundle::set_transform
          struct /* set_transform */ {
            // Source: drake/systems/rendering/pose_bundle.h:43
            const char* doc = R"""()""";
          } set_transform;
          // Symbol: drake::systems::rendering::PoseBundle::set_velocity
          struct /* set_velocity */ {
            // Source: drake/systems/rendering/pose_bundle.h:46
            const char* doc = R"""()""";
          } set_velocity;
        } PoseBundle;
        // Symbol: drake::systems::rendering::PoseBundleToDrawMessage
        struct /* PoseBundleToDrawMessage */ {
          // Source: drake/systems/rendering/pose_bundle_to_draw_message.h:22
          const char* doc =
R"""(PoseBundleToDrawMessage converts a PoseBundle on its single
abstract-valued input port to a Drake Visualizer Interface LCM draw
message, lcmt_viewer_draw, on its single abstract-valued output port.

The draw message will contain one link for each pose in the
PoseBundle. The name of the link will be the name of the corresponding
pose. The robot_num will be the corresponding model instance ID.)""";
          // Symbol: drake::systems::rendering::PoseBundleToDrawMessage::PoseBundleToDrawMessage
          struct /* ctor */ {
            // Source: drake/systems/rendering/pose_bundle_to_draw_message.h:24
            const char* doc = R"""()""";
          } ctor;
        } PoseBundleToDrawMessage;
        // Symbol: drake::systems::rendering::PoseVector
        struct /* PoseVector */ {
          // Source: drake/systems/rendering/pose_vector.h:20
          const char* doc =
R"""(A 7-vector representing the transform of frame A in the world frame,
X_WA, in the form ``{p_WA, R_WA}``, where ``p`` is represented as an
x-y-z translation, and ``R`` is represented as a quaternion. The exact
order of elements is ``{x, y, z, qw, qx, qy, qz}``.)""";
          // Symbol: drake::systems::rendering::PoseVector::DoClone
          struct /* DoClone */ {
            // Source: drake/systems/rendering/pose_vector.h:51
            const char* doc = R"""()""";
          } DoClone;
          // Symbol: drake::systems::rendering::PoseVector::PoseVector<T>
          struct /* ctor */ {
            // Source: drake/systems/rendering/pose_vector.h:23
            const char* doc_0args = R"""(Default constructor.)""";
            // Source: drake/systems/rendering/pose_vector.h:30
            const char* doc_2args =
R"""(Fully-parameterized constructor.

Parameter ``rotation``:
    the orientation R_WA of frame A in the world frame W.

Parameter ``translation``:
    the position vector p_WA giving A's origin measured from W's
    origin, expressed in W.)""";
          } ctor;
          // Symbol: drake::systems::rendering::PoseVector::get_rotation
          struct /* get_rotation */ {
            // Source: drake/systems/rendering/pose_vector.h:44
            const char* doc = R"""(Returns the rotation R_WA.)""";
          } get_rotation;
          // Symbol: drake::systems::rendering::PoseVector::get_transform
          struct /* get_transform */ {
            // Source: drake/systems/rendering/pose_vector.h:34
            const char* doc = R"""(Returns the transform X_WA.)""";
          } get_transform;
          // Symbol: drake::systems::rendering::PoseVector::get_translation
          struct /* get_translation */ {
            // Source: drake/systems/rendering/pose_vector.h:39
            const char* doc = R"""(Returns the translation p_WA.)""";
          } get_translation;
          // Symbol: drake::systems::rendering::PoseVector::set_rotation
          struct /* set_rotation */ {
            // Source: drake/systems/rendering/pose_vector.h:46
            const char* doc = R"""(Assigns the rotation R_WA.)""";
          } set_rotation;
          // Symbol: drake::systems::rendering::PoseVector::set_transform
          struct /* set_transform */ {
            // Source: drake/systems/rendering/pose_vector.h:36
            const char* doc = R"""(Assigns the transform X_WA.)""";
          } set_transform;
          // Symbol: drake::systems::rendering::PoseVector::set_translation
          struct /* set_translation */ {
            // Source: drake/systems/rendering/pose_vector.h:41
            const char* doc = R"""(Assigns the translation p_WA.)""";
          } set_translation;
        } PoseVector;
        // Symbol: drake::systems::rendering::PoseVelocityInputPorts
        struct /* PoseVelocityInputPorts */ {
          // Source: drake/systems/rendering/pose_aggregator.h:21
          const char* doc =
R"""(A container with references to the input port for the pose input, and
a reference to the input port for the velocity input.)""";
          // Symbol: drake::systems::rendering::PoseVelocityInputPorts::pose_input_port
          struct /* pose_input_port */ {
            // Source: drake/systems/rendering/pose_aggregator.h:22
            const char* doc = R"""()""";
          } pose_input_port;
          // Symbol: drake::systems::rendering::PoseVelocityInputPorts::velocity_input_port
          struct /* velocity_input_port */ {
            // Source: drake/systems/rendering/pose_aggregator.h:23
            const char* doc = R"""()""";
          } velocity_input_port;
        } PoseVelocityInputPorts;
        // Symbol: drake::systems::rendering::RenderPoseToGeometryPose
        struct /* RenderPoseToGeometryPose */ {
          // Source: drake/systems/rendering/render_pose_to_geometry_pose.h:15
          const char* doc =
R"""(A direct-feedthrough system that converts the C++ type of poses from
rendering::PoseVector<T> on the input to geometry::FramePoseVector<T>
on the output.)""";
          // Symbol: drake::systems::rendering::RenderPoseToGeometryPose::RenderPoseToGeometryPose<T>
          struct /* ctor */ {
            // Source: drake/systems/rendering/render_pose_to_geometry_pose.h:23
            const char* doc_copyconvert =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";
          } ctor;
        } RenderPoseToGeometryPose;
      } rendering;
      // Symbol: drake::systems::scalar_conversion
      struct /* scalar_conversion */ {
        // Symbol: drake::systems::scalar_conversion::FromDoubleTraits
        struct /* FromDoubleTraits */ {
          // Source: drake/systems/framework/scalar_conversion_traits.h:83
          const char* doc =
R"""(A concrete traits class providing sugar to support for converting only
from the ``double`` scalar type. For example, if a
MySystem<symbolic::Expression> cannot be converted into a
MySystem<double>, it could specialize Traits as follows:


::

    namespace drake {
    namespace systems {
    namespace scalar_conversion {
    template <> struct Traits<MySystem> : public FromDoubleTraits {};
    }  // namespace scalar_conversion
    }  // namespace systems
    }  // namespace drake)""";
        } FromDoubleTraits;
        // Symbol: drake::systems::scalar_conversion::NonSymbolicTraits
        struct /* NonSymbolicTraits */ {
          // Source: drake/systems/framework/scalar_conversion_traits.h:61
          const char* doc =
R"""(A concrete traits class providing sugar to disable support for
symbolic evaluation (i.e., the symbolic::Expression scalar type).

For example, if MySystem does not support the symbolic expression
scalar type, it could specialize Traits as follows:


::

    namespace drake {
    namespace systems {
    namespace scalar_conversion {
    template <> struct Traits<MySystem> : public NonSymbolicTraits {};
    }  // namespace scalar_conversion
    }  // namespace systems
    }  // namespace drake)""";
        } NonSymbolicTraits;
        // Symbol: drake::systems::scalar_conversion::Traits
        struct /* Traits */ {
          // Source: drake/systems/framework/scalar_conversion_traits.h:39
          const char* doc =
R"""(A templated traits class for whether an ``S<U>`` can be converted into
an ``S<T>``; the default value is true for all values of ``S``, `T`,
and ``U``. Particular scalar-dependent classes (``S``) may specialize
this template to indicate whether the framework should support
conversion for any given combination of ``T`` and ``U``.

When ``Traits<S>::supported<T, U>`` is ``std::true_type``, the
"scalar-converting copy constructor" that relates ``S``, `T`, and
``U`` will be used. That constructor takes the form of, e.g., when
``S`` is ``Foo``:


::

    template <typename T>
    class Foo {
      template <typename U>
      explicit Foo(const Foo<U>& other);
    };

See system_scalar_conversion for detailed background and examples
related to scalar-type conversion support.

When ``Traits<S>::supported<T, U>`` is ``std::false_type``, the
``S<T>::S(const S<U>&)`` scalar-conversion copy constructor will not
even be mentioned by the framework, so that ``S`` need not even
compile for certain values of ``T`` and ``U``.

Template parameter ``S``:
    is the scalar-templated type to copy)""";
        } Traits;
        // Symbol: drake::systems::scalar_conversion::ValueConverter
        struct /* ValueConverter */ {
          // Source: drake/systems/framework/scalar_conversion_traits.h:95
          const char* doc =
R"""(Converts a scalar ``U u`` to its corresponding scalar ``T t``. When U
== T, the scalar is unchanged. When demoting Expression to
non-Expression, throws when there are unbound variables. In all other
cases, information beyond the double value (e.g., possible
derivatives) might be discarded.)""";
          // Symbol: drake::systems::scalar_conversion::ValueConverter::operator()
          struct /* operator_call */ {
            // Source: drake/systems/framework/scalar_conversion_traits.h:96
            const char* doc = R"""()""";
          } operator_call;
        } ValueConverter;
      } scalar_conversion;
      // Symbol: drake::systems::sensors
      struct /* sensors */ {
        // Symbol: drake::systems::sensors::Accelerometer
        struct /* Accelerometer */ {
          // Source: drake/systems/sensors/accelerometer.h:52
          const char* doc =
R"""(Sensor to represent an ideal accelerometer sensor. Currently does not
represent noise or bias, but this could and should be added at a later
date. This sensor measures the proper acceleration of a point on a
given body B. Proper acceleration subtracts gravity from the
coordinate acceleration a_WS_S. That is, aproper_WS_S = a_WS_S - g_S
Note that measurement is taken with respect to the world frame, but
expressed in the coordinates of the local sensor frame S. Sensor frame
S is rigidly affixed to the given body B. Note, also, the sign of the
gravity component. For typical settings (e.g. on Earth assuming a
constant gravitational field), the direction of "-g_S" is "upwards."

There are three inputs to this sensor (nominally from a
MultibodyPlant): 1. A vector of body poses (e.g.
plant.get_body_poses_output_port()) 2. A vector of spatial velocities
(e.g. plant.get_body_spatial_velocities_output_port()) 3. A vector of
spatial accelerations (e.g.
plant.get_body_spatial_accelerations_output_port())

This class is therefore defined by: 1. The body to which this sensor
is rigidly affixed. 2. A rigid transform from the body frame to the
sensor frame.

.. pydrake_system::

    name: Accelerometer
    input_ports:
    - body_poses
    - body_spatial_velocities
    - body_spatial_accelerations
    output_ports:
    - measurement)""";
          // Symbol: drake::systems::sensors::Accelerometer::Accelerometer<T>
          struct /* ctor */ {
            // Source: drake/systems/sensors/accelerometer.h:60
            const char* doc =
R"""(Parameter ``body``:
    the body B to which the sensor is affixed

Parameter ``X_BS``:
    the pose of sensor frame S in body B

Parameter ``gravity_vector``:
    the constant acceleration due to gravity expressed in world
    coordinates)""";
            // Source: drake/systems/sensors/accelerometer.h:66
            const char* doc_copyconvert =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";
          } ctor;
          // Symbol: drake::systems::sensors::Accelerometer::AddToDiagram
          struct /* AddToDiagram */ {
            // Source: drake/systems/sensors/accelerometer.h:113
            const char* doc =
R"""(Static factory method that creates an Accelerometer object and
connects it to the given plant. Modifies a Diagram by connecting the
input ports of the new Accelerometer to the appropriate output ports
of a MultibodyPlant. Must be called during Diagram building and given
the appropriate builder. This is a convenience method to simplify some
common boilerplate of Diagram wiring. Specifically, this makes three
connections:

1. plant.get_body_poses_output_port() to this.get_body_poses_input_port()
2. plant.get_body_spatial_velocities_output_port() to
       this.get_body_velocities_input_port()
3. plant.get_body_spatial_accelerations_output_port() to
       this.get_body_spatial_accelerations_output_port()

Parameter ``body``:
    the body B to which the sensor is affixed

Parameter ``X_BS``:
    the pose of sensor frame S in body B

Parameter ``gravity_vector``:
    the constant acceleration due to gravity expressed in world
    coordinates

Parameter ``plant``:
    the plant to which the sensor will be connected

Parameter ``builder``:
    a pointer to the DiagramBuilder)""";
          } AddToDiagram;
          // Symbol: drake::systems::sensors::Accelerometer::body_index
          struct /* body_index */ {
            // Source: drake/systems/sensors/accelerometer.h:85
            const char* doc =
R"""(Returns the index of the Body that was supplied in the constructor.)""";
          } body_index;
          // Symbol: drake::systems::sensors::Accelerometer::get_body_accelerations_input_port
          struct /* get_body_accelerations_input_port */ {
            // Source: drake/systems/sensors/accelerometer.h:76
            const char* doc = R"""()""";
          } get_body_accelerations_input_port;
          // Symbol: drake::systems::sensors::Accelerometer::get_body_poses_input_port
          struct /* get_body_poses_input_port */ {
            // Source: drake/systems/sensors/accelerometer.h:68
            const char* doc = R"""()""";
          } get_body_poses_input_port;
          // Symbol: drake::systems::sensors::Accelerometer::get_body_velocities_input_port
          struct /* get_body_velocities_input_port */ {
            // Source: drake/systems/sensors/accelerometer.h:72
            const char* doc = R"""()""";
          } get_body_velocities_input_port;
          // Symbol: drake::systems::sensors::Accelerometer::get_measurement_output_port
          struct /* get_measurement_output_port */ {
            // Source: drake/systems/sensors/accelerometer.h:80
            const char* doc = R"""()""";
          } get_measurement_output_port;
          // Symbol: drake::systems::sensors::Accelerometer::gravity_vector
          struct /* gravity_vector */ {
            // Source: drake/systems/sensors/accelerometer.h:88
            const char* doc =
R"""(Returns the gravity vector supplied in the constructor, or zero if
none.)""";
          } gravity_vector;
          // Symbol: drake::systems::sensors::Accelerometer::pose
          struct /* pose */ {
            // Source: drake/systems/sensors/accelerometer.h:91
            const char* doc =
R"""(Gets X_BS, the pose of sensor frame S in body B)""";
          } pose;
        } Accelerometer;
        // Symbol: drake::systems::sensors::BeamModel
        struct /* BeamModel */ {
          // Source: drake/systems/sensors/beam_model.h:48
          const char* doc =
R"""(Implements the "Beam Models of Range Finders" from section 6.3 of
Probabilistic Robotics (2006), by Thrun, Burgard, and Fox

This system takes a depth measurement signal as input, and outputs a
noisy measurement version of that signal, with some probability of
returning the true measurement with Gaussian noise, but also with some
probability of occlusions (short returns), of missed detections
(returning the max depth), and of returning just a (uniform) random
measurement.

Four additional input ports (each of the same dimension as the depth
signal) are provided for the random inputs: One for determining which
of the events occurred (true + noise, short return, max return, or
uniform return), and one each for modeling the distribution of short
true but noisy returns, short returns, and uniform returns).

We deviate from the textbook model in one respect: both here and in
the textbook, the distribution over short returns and the distribution
over getting a noisy version of the true return (aka a "hit") are
truncated. The short returns are from an exponential distribution but
truncated to be less than the input depth, and "hits" are drawn from a
Gaussian centered at the input depth but truncated at the maximum
range of the sensor. In the book, these distributions are normalized
so that the total probability of getting a short return and/or hit
stays constant (independent of the input depth). Here we do not
normalize, so that the probability of getting a short return decreases
as the input depth is smaller (there is a modeled obstacle closer to
the robot), and the tails of the "hit" distribution simply cause more
max returns as the input depth gets closer to the max range. This was
done both because it is arguably a better model and because it keeps
the code much simpler (to allow AutoDiff and Symbolic) given the
modeling framework we have here that builds the output out of simple
(non-truncated) random variable inputs.)""";
          // Symbol: drake::systems::sensors::BeamModel::BeamModel<T>
          struct /* ctor */ {
            // Source: drake/systems/sensors/beam_model.h:56
            const char* doc_copyconvert =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";
          } ctor;
          // Symbol: drake::systems::sensors::BeamModel::get_depth_input_port
          struct /* get_depth_input_port */ {
            // Source: drake/systems/sensors/beam_model.h:58
            const char* doc = R"""()""";
          } get_depth_input_port;
          // Symbol: drake::systems::sensors::BeamModel::get_event_random_input_port
          struct /* get_event_random_input_port */ {
            // Source: drake/systems/sensors/beam_model.h:61
            const char* doc = R"""()""";
          } get_event_random_input_port;
          // Symbol: drake::systems::sensors::BeamModel::get_hit_random_input_port
          struct /* get_hit_random_input_port */ {
            // Source: drake/systems/sensors/beam_model.h:64
            const char* doc = R"""()""";
          } get_hit_random_input_port;
          // Symbol: drake::systems::sensors::BeamModel::get_mutable_parameters
          struct /* get_mutable_parameters */ {
            // Source: drake/systems/sensors/beam_model.h:74
            const char* doc = R"""()""";
          } get_mutable_parameters;
          // Symbol: drake::systems::sensors::BeamModel::get_short_random_input_port
          struct /* get_short_random_input_port */ {
            // Source: drake/systems/sensors/beam_model.h:67
            const char* doc = R"""()""";
          } get_short_random_input_port;
          // Symbol: drake::systems::sensors::BeamModel::get_uniform_random_input_port
          struct /* get_uniform_random_input_port */ {
            // Source: drake/systems/sensors/beam_model.h:70
            const char* doc = R"""()""";
          } get_uniform_random_input_port;
          // Symbol: drake::systems::sensors::BeamModel::max_range
          struct /* max_range */ {
            // Source: drake/systems/sensors/beam_model.h:76
            const char* doc = R"""()""";
          } max_range;
        } BeamModel;
        // Symbol: drake::systems::sensors::BeamModelParams
        struct /* BeamModelParams */ {
          // Source: drake/systems/sensors/gen/beam_model_params.h:47
          const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";
          // Symbol: drake::systems::sensors::BeamModelParams::BeamModelParams<T>
          struct /* ctor */ {
            // Source: drake/systems/sensors/gen/beam_model_params.h:58
            const char* doc =
R"""(Default constructor. Sets all rows to their default value:

* ``lambda_short`` defaults to 1.0 dimensionless.

* ``sigma_hit`` defaults to 0.0 m.

* ``probability_short`` defaults to 0.0 dimensionless.

* ``probability_miss`` defaults to 0.0 dimensionless.

* ``probability_uniform`` defaults to 0.0 dimensionless.)""";
          } ctor;
          // Symbol: drake::systems::sensors::BeamModelParams::DoClone
          struct /* DoClone */ {
            // Source: drake/systems/sensors/gen/beam_model_params.h:98
            const char* doc = R"""()""";
          } DoClone;
          // Symbol: drake::systems::sensors::BeamModelParams::GetCoordinateNames
          struct /* GetCoordinateNames */ {
            // Source: drake/systems/sensors/gen/beam_model_params.h:229
            const char* doc =
R"""(See BeamModelParamsIndices::GetCoordinateNames().)""";
          } GetCoordinateNames;
          // Symbol: drake::systems::sensors::BeamModelParams::GetElementBounds
          struct /* GetElementBounds */ {
            // Source: drake/systems/sensors/gen/beam_model_params.h:253
            const char* doc = R"""()""";
          } GetElementBounds;
          // Symbol: drake::systems::sensors::BeamModelParams::IsValid
          struct /* IsValid */ {
            // Source: drake/systems/sensors/gen/beam_model_params.h:234
            const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";
          } IsValid;
          // Symbol: drake::systems::sensors::BeamModelParams::K
          struct /* K */ {
            // Source: drake/systems/sensors/gen/beam_model_params.h:50
            const char* doc =
R"""(An abbreviation for our row index constants.)""";
          } K;
          // Symbol: drake::systems::sensors::BeamModelParams::Serialize
          struct /* Serialize */ {
            // Source: drake/systems/sensors/gen/beam_model_params.h:214
            const char* doc =
R"""(Visit each field of this named vector, passing them (in order) to the
given Archive. The archive can read and/or write to the vector values.
One common use of Serialize is the //common/yaml tools.)""";
          } Serialize;
          // Symbol: drake::systems::sensors::BeamModelParams::SetToNamedVariables
          struct /* SetToNamedVariables */ {
            // Source: drake/systems/sensors/gen/beam_model_params.h:90
            const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";
          } SetToNamedVariables;
          // Symbol: drake::systems::sensors::BeamModelParams::lambda_short
          struct /* lambda_short */ {
            // Source: drake/systems/sensors/gen/beam_model_params.h:108
            const char* doc =
R"""(The rate parameter of the (truncated) exponential distribution
governing short returns

Note:
    ``lambda_short`` is expressed in units of dimensionless.

Note:
    ``lambda_short`` has a limited domain of [0.0, +Inf].)""";
          } lambda_short;
          // Symbol: drake::systems::sensors::BeamModelParams::probability_miss
          struct /* probability_miss */ {
            // Source: drake/systems/sensors/gen/beam_model_params.h:170
            const char* doc =
R"""(The probability of ignoring the input depth and simply returning the
max range of the sensor

Note:
    ``probability_miss`` is expressed in units of dimensionless.

Note:
    ``probability_miss`` has a limited domain of [0.0, 1.0].)""";
          } probability_miss;
          // Symbol: drake::systems::sensors::BeamModelParams::probability_short
          struct /* probability_short */ {
            // Source: drake/systems/sensors/gen/beam_model_params.h:149
            const char* doc =
R"""(The total probability of getting a short return is probability_short *
p(lambda_short*w_short <= input_depth)

Note:
    ``probability_short`` is expressed in units of dimensionless.

Note:
    ``probability_short`` has a limited domain of [0.0, 1.0].)""";
          } probability_short;
          // Symbol: drake::systems::sensors::BeamModelParams::probability_uniform
          struct /* probability_uniform */ {
            // Source: drake/systems/sensors/gen/beam_model_params.h:191
            const char* doc =
R"""(The probability of ignoring the input depth and simple returning a
uniform random value between 0 and the max range of the sensor

Note:
    ``probability_uniform`` is expressed in units of dimensionless.

Note:
    ``probability_uniform`` has a limited domain of [0.0, 1.0].)""";
          } probability_uniform;
          // Symbol: drake::systems::sensors::BeamModelParams::set_lambda_short
          struct /* set_lambda_short */ {
            // Source: drake/systems/sensors/gen/beam_model_params.h:113
            const char* doc = R"""(Setter that matches lambda_short().)""";
          } set_lambda_short;
          // Symbol: drake::systems::sensors::BeamModelParams::set_probability_miss
          struct /* set_probability_miss */ {
            // Source: drake/systems/sensors/gen/beam_model_params.h:175
            const char* doc = R"""(Setter that matches probability_miss().)""";
          } set_probability_miss;
          // Symbol: drake::systems::sensors::BeamModelParams::set_probability_short
          struct /* set_probability_short */ {
            // Source: drake/systems/sensors/gen/beam_model_params.h:154
            const char* doc =
R"""(Setter that matches probability_short().)""";
          } set_probability_short;
          // Symbol: drake::systems::sensors::BeamModelParams::set_probability_uniform
          struct /* set_probability_uniform */ {
            // Source: drake/systems/sensors/gen/beam_model_params.h:196
            const char* doc =
R"""(Setter that matches probability_uniform().)""";
          } set_probability_uniform;
          // Symbol: drake::systems::sensors::BeamModelParams::set_sigma_hit
          struct /* set_sigma_hit */ {
            // Source: drake/systems/sensors/gen/beam_model_params.h:134
            const char* doc = R"""(Setter that matches sigma_hit().)""";
          } set_sigma_hit;
          // Symbol: drake::systems::sensors::BeamModelParams::sigma_hit
          struct /* sigma_hit */ {
            // Source: drake/systems/sensors/gen/beam_model_params.h:129
            const char* doc =
R"""(The standard deviation of the (truncated) Gaussian distribution
governing the noisy returns of the true depth (aka hit)

Note:
    ``sigma_hit`` is expressed in units of m.

Note:
    ``sigma_hit`` has a limited domain of [0.0, +Inf].)""";
          } sigma_hit;
          // Symbol: drake::systems::sensors::BeamModelParams::with_lambda_short
          struct /* with_lambda_short */ {
            // Source: drake/systems/sensors/gen/beam_model_params.h:119
            const char* doc =
R"""(Fluent setter that matches lambda_short(). Returns a copy of ``this``
with lambda_short set to a new value.)""";
          } with_lambda_short;
          // Symbol: drake::systems::sensors::BeamModelParams::with_probability_miss
          struct /* with_probability_miss */ {
            // Source: drake/systems/sensors/gen/beam_model_params.h:181
            const char* doc =
R"""(Fluent setter that matches probability_miss(). Returns a copy of
``this`` with probability_miss set to a new value.)""";
          } with_probability_miss;
          // Symbol: drake::systems::sensors::BeamModelParams::with_probability_short
          struct /* with_probability_short */ {
            // Source: drake/systems/sensors/gen/beam_model_params.h:160
            const char* doc =
R"""(Fluent setter that matches probability_short(). Returns a copy of
``this`` with probability_short set to a new value.)""";
          } with_probability_short;
          // Symbol: drake::systems::sensors::BeamModelParams::with_probability_uniform
          struct /* with_probability_uniform */ {
            // Source: drake/systems/sensors/gen/beam_model_params.h:202
            const char* doc =
R"""(Fluent setter that matches probability_uniform(). Returns a copy of
``this`` with probability_uniform set to a new value.)""";
          } with_probability_uniform;
          // Symbol: drake::systems::sensors::BeamModelParams::with_sigma_hit
          struct /* with_sigma_hit */ {
            // Source: drake/systems/sensors/gen/beam_model_params.h:140
            const char* doc =
R"""(Fluent setter that matches sigma_hit(). Returns a copy of ``this``
with sigma_hit set to a new value.)""";
          } with_sigma_hit;
        } BeamModelParams;
        // Symbol: drake::systems::sensors::BeamModelParamsIndices
        struct /* BeamModelParamsIndices */ {
          // Source: drake/systems/sensors/gen/beam_model_params.h:27
          const char* doc =
R"""(Describes the row indices of a BeamModelParams.)""";
          // Symbol: drake::systems::sensors::BeamModelParamsIndices::GetCoordinateNames
          struct /* GetCoordinateNames */ {
            // Source: drake/systems/sensors/gen/beam_model_params.h:42
            const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words,
``BeamModelParamsIndices::GetCoordinateNames()[i]`` is the name for
``BasicVector::GetAtIndex(i)``.)""";
          } GetCoordinateNames;
        } BeamModelParamsIndices;
        // Symbol: drake::systems::sensors::CameraInfo
        struct /* CameraInfo */ {
          // Source: drake/systems/sensors/camera_info.h:132
          const char* doc =
R"""(Simple class for characterizing the Drake camera model. The camera
model is based on the `pinhole *model_
<http://docs.opencv.org/2.4/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html>`_
, which is related to but distinct from an actual `pinhole _camera_
<https://en.wikipedia.org/wiki/Pinhole_camera>`_. The former is a
mathematical model for producing images, the latter is a physical
object.

The camera info members are directly tied to the underlying model's
mathematical parameters. In order to understand the model parameters,
we will provide a discussion of how cameras are treated in Drake with
some common terminology (liberally borrowed from computer vision).

**Pinhole camera model**

(To get an exact definition of the terms used here, please refer to
the glossary below.)

Intuitively, a camera produces images of an observed environment. The
pinhole model serves as a camera for a virtually modeled environment.
Its parameters are those required to determine where in the resultant
image a virtual object appears. In essence, the parameters of the
camera model define a mapping from points in 3D space to a point on
the image (2D space).

The full discussion of this mapping can be found in the `OpenCV
documentation
<https://docs.opencv.org/2.4/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html>`_.
Here, we'll highlight one or two points as it relates to this struct.

The mapping from 3D to 2D is decomposed into two sets of properties:
extrinsic and intrinsic. The extrinsic properties define the pose of
the camera in the environment -- specifically, given the camera frame
``C``, it defines ``X_WC``. Once a point ``Q`` is measured and
expressed in the camera's frame (i.e., ``p_CQ_C``), the intrinsic
matrix projects it into the 2D image. CameraInfo does _not* concern
itself with the extrinsic properties (other classes are responsible
for that -- see RgbdSensor).

CameraInfo defines the parameters of the intrinsic projection. The
projection can be captured by the camera or intrinsic matrix which
essentially maps points in the camera frame C to the image plane (the
matrix is called ``A`` in the OpenCV documentation, but typically
called ``K`` in computer vision literature):

│ f_x 0 c_x │ K = │ 0 f_y c_y │, i.e., │ 0 0 1 │

- This matrix maps a point in the camera frame C to the projective space of the
image (via homogeneous coordinates). The resulting image coordinate ``(u, v)``
is extracted by dividing out the homogeneous scale factor.
- (c_x, c_y) defines the principal point.
- (f_x, f_y) defines the model focal length.

In other words, for point Q in the world frame, its projected position
in the 2D image ``(u_Q, v_Q)`` is calculated as:

│ u_Q │ s│ v_Q │ = K ⋅ X_CW ⋅ p_WQ │ 1 │

Note: The expression on the right will generally produce a homogeneous
coordinate vector of the form ``(s * u_Q, s * v_Q, s)``. The texture
coordinate is defined as the first two measures when the *third*
measure is 1. The magic of homogeneous coordinates allows us to simply
factor out ``s``.

**Glossary**

These terms are important to the discussion. Some refer to real world
concepts and some to the model. The application domain of the term
will be indicated and, where necessary, ambiguities will be resolved.
The terms are ordered alphabetically for ease of reference.

- **aperture**: the opening in a camera through which light passes. The origin
of the camera frame ``Co`` is located at the aperture's center.
- in a physical camera it may contain a lens and the size of the camera
affects optical artifacts such as depth of field.
- in the pinhole model, there is no lens and the aperture is a single point.
- **focal length**: a camera property that determines the field of view angle
and the scale of objects in the image (large focal length --> small field of
view angle).
- In a physical camera, it is the distance (in meters) between the center of
the lens and the plane at which all incoming, parallel light rays converge
(assuming a radially symmetric lens).
- in the pinhole model, ``(f_x, f_y)`` is described as "focal length", but the
units are in pixels and the interpretation is different. The relationship
between ``(f_x, f_y)`` and the physical focal length ``F`` is ``f_i = F * s_i``,
where ``(s_x, s_y)`` are the number of pixels per meter in the x- and
y-directions (of the image). Both values described as "focal length" have
analogous effects on field of view and scale of objects in the image.
- **frame**: (Also "pose") an origin point and a space-spanning basis in 2D/3D,
as in multibody_frames_and_bodies.
- Incidentally, the word "frame" is also used in conjunction with a single
image in a video (such as a "video frame"). Drake doesn't use this sense in
discussing cameras (unless explicitly noted).
- **image**: an array of measurements such that the measured values have
spatial relationships based on where they are in the array.
- **image frame**: the 2D frame embedded in 3D space spanning the image plane.
The image frame's x- and y-axes are parallel with ``Cx`` and ``Cy``,
respectively. Coordinates are expressed as the pair ``(u, v)`` and the camera's
image lies on the plane spanned by the frame's basis. The *center* of the
pixel in the first row and first column is at ``(u=0, v=0)``.
- **image plane**: a plane in 3D which is perpendicular to the camera's viewing
direction. Conceptually, the image lies on this plane.
- In a physical pinhole camera, the aperture is between the image plane and
the environment being imaged.
- In the pinhole model, the image plane lies between the environment and
aperture (i.e., in the positive Cz direction from Co).
- **imager**: a sensor whose measurements are reported in images.
- **principal point**: The projection of the camera origin, ``Co``, on the image
plane. Its value is measured from the image's origin in pixels.
- **sensor**: a measurement device.
- **viewing direction**: the direction the camera is facing. Defined as being
parallel with Cz.

When looking at the resulting image and reasoning about the camera
that produced it, one can say that Cz points into the image, Cx is
parallel with the image rows, pointing to the right, and Cy is
parallel with the image columns, pointing down leading to language
such as: "X-right", "Y-down", and "Z-forward".)""";
          // Symbol: drake::systems::sensors::CameraInfo::CameraInfo
          struct /* ctor */ {
            // Source: drake/systems/sensors/camera_info.h:149
            const char* doc_6args_width_height_focal_x_focal_y_center_x_center_y =
R"""(Constructor that directly sets the image size, principal point, and
focal lengths.

Parameter ``width``:
    The image width in pixels, must be greater than zero.

Parameter ``height``:
    The image height in pixels, must be greater than zero.

Parameter ``focal_x``:
    The *model* "focal length" x in pixels (as documented above).

Parameter ``focal_y``:
    The *model* "focal length" y in pixels (as documented above).

Parameter ``center_x``:
    The x coordinate of the principal point in pixels (as documented
    above).

Parameter ``center_y``:
    The y coordinate of the principal point in pixels (as documented
    above).)""";
            // Source: drake/systems/sensors/camera_info.h:160
            const char* doc_3args_width_height_intrinsic_matrix =
R"""(Constructs this instance by extracting focal_x, focal_y, center_x, and
center_y from the provided intrinsic_matrix.

Raises:
    RuntimeError if intrinsic_matrix is not of the form indicated
    above for the pinhole camera model (representing an affine /
    homogeneous transform).)""";
            // Source: drake/systems/sensors/camera_info.h:176
            const char* doc_3args_width_height_fov_y =
R"""(Constructs this instance from image size and vertical field of view.
We assume the principal point is in the center of the image; ``(center
x, center_y)`` is equal to ``(width / 2.0 - 0.5, height / 2.0 -
0.5)``. We also assume the focal lengths ``focal_x`` and ``focal_y``
are identical (modeling a radially symmetric lens). The value is
derived from field of view and image size as:

focal_x = focal_y = height * 0.5 / tan(0.5 * fov_y)

Parameter ``width``:
    The image width in pixels, must be greater than zero.

Parameter ``height``:
    The image height in pixels, must be greater than zero.

Parameter ``fov_y``:
    The vertical field of view in radians.)""";
          } ctor;
          // Symbol: drake::systems::sensors::CameraInfo::center_x
          struct /* center_x */ {
            // Source: drake/systems/sensors/camera_info.h:200
            const char* doc =
R"""(Returns the principal point's x coordinate in pixels.)""";
          } center_x;
          // Symbol: drake::systems::sensors::CameraInfo::center_y
          struct /* center_y */ {
            // Source: drake/systems/sensors/camera_info.h:203
            const char* doc =
R"""(Returns the principal point's y coordinate in pixels.)""";
          } center_y;
          // Symbol: drake::systems::sensors::CameraInfo::focal_x
          struct /* focal_x */ {
            // Source: drake/systems/sensors/camera_info.h:185
            const char* doc = R"""(Returns the focal length x in pixels.)""";
          } focal_x;
          // Symbol: drake::systems::sensors::CameraInfo::focal_y
          struct /* focal_y */ {
            // Source: drake/systems/sensors/camera_info.h:188
            const char* doc = R"""(Returns the focal length y in pixels.)""";
          } focal_y;
          // Symbol: drake::systems::sensors::CameraInfo::fov_x
          struct /* fov_x */ {
            // Source: drake/systems/sensors/camera_info.h:191
            const char* doc =
R"""(Returns the field of view in the x-direction (in radians).)""";
          } fov_x;
          // Symbol: drake::systems::sensors::CameraInfo::fov_y
          struct /* fov_y */ {
            // Source: drake/systems/sensors/camera_info.h:194
            const char* doc =
R"""(Returns the field of view in the y-direction (in radians).)""";
          } fov_y;
          // Symbol: drake::systems::sensors::CameraInfo::height
          struct /* height */ {
            // Source: drake/systems/sensors/camera_info.h:182
            const char* doc =
R"""(Returns the height of the image in pixels.)""";
          } height;
          // Symbol: drake::systems::sensors::CameraInfo::intrinsic_matrix
          struct /* intrinsic_matrix */ {
            // Source: drake/systems/sensors/camera_info.h:206
            const char* doc = R"""(Returns the camera intrinsic matrix, K.)""";
          } intrinsic_matrix;
          // Symbol: drake::systems::sensors::CameraInfo::width
          struct /* width */ {
            // Source: drake/systems/sensors/camera_info.h:179
            const char* doc =
R"""(Returns the width of the image in pixels.)""";
          } width;
        } CameraInfo;
        // Symbol: drake::systems::sensors::Color
        struct /* Color */ {
          // Source: drake/systems/sensors/color_palette.h:20
          const char* doc =
R"""(Holds r, g, b values to represent a color pixel.

Template parameter ``T``:
    A type for each color channel.)""";
          // Symbol: drake::systems::sensors::Color::b
          struct /* b */ {
            // Source: drake/systems/sensors/color_palette.h:23
            const char* doc = R"""(Green.)""";
          } b;
          // Symbol: drake::systems::sensors::Color::g
          struct /* g */ {
            // Source: drake/systems/sensors/color_palette.h:22
            const char* doc = R"""(Red.)""";
          } g;
          // Symbol: drake::systems::sensors::Color::r
          struct /* r */ {
            // Source: drake/systems/sensors/color_palette.h:21
            const char* doc = R"""()""";
          } r;
        } Color;
        // Symbol: drake::systems::sensors::ColorD
        struct /* ColorD */ {
          // Source: drake/systems/sensors/color_palette.h:65
          const char* doc =
R"""(Defines a color based on its three primary additive colors: red,
green, and blue. Each of these primary additive colors are in the
range of [0, 1].)""";
        } ColorD;
        // Symbol: drake::systems::sensors::ColorI
        struct /* ColorI */ {
          // Source: drake/systems/sensors/color_palette.h:61
          const char* doc =
R"""(Defines a color based on its three primary additive colors: red,
green, and blue. Each of these primary additive colors are in the
range of [0, 255].)""";
        } ColorI;
        // Symbol: drake::systems::sensors::ColorPalette
        struct /* ColorPalette */ {
          // Source: drake/systems/sensors/color_palette.h:79
          const char* doc =
R"""(Creates and holds a palette of colors for visualizing different
objects in a scene (the intent is for a different color to be applied
to each identified object). The colors are chosen so as to be easily
distinguishable. In other words, the intensities are spaced as widely
as possible given the number of required colors. Black, white and
gray, which has the same value for all the three color channels, are
not part of this color palette. This color palette can hold up to 1535
colors.

Template parameter ``IdType``:
    The type of value used for label values.)""";
          // Symbol: drake::systems::sensors::ColorPalette::ColorPalette<IdType>
          struct /* ctor */ {
            // Source: drake/systems/sensors/color_palette.h:96
            const char* doc =
R"""(A constructor for ColorPalette.

Parameter ``num_colors``:
    The number of colors that you want ColorPalette to hold. We assume
    this will be the number of rigid bodies in rendering scene.

Parameter ``terrain_id``:
    The id to express pixels which correspond to flat terrain. This
    will be used in the label image.

Parameter ``no_body_id``:
    The id to express pixels that have no body. This will be used in
    the label image.

Raises:
    RuntimeError When ``num_colors`` exceeds the maximum limit, which
    is 1535.)""";
          } ctor;
          // Symbol: drake::systems::sensors::ColorPalette::LookUpId
          struct /* LookUpId */ {
            // Source: drake/systems/sensors/color_palette.h:179
            const char* doc =
R"""(Looks up the ID which corresponds to the given color.

Parameter ``color``:
    The color you want to know the corresponding ID.)""";
          } LookUpId;
          // Symbol: drake::systems::sensors::ColorPalette::Normalize
          struct /* Normalize */ {
            // Source: drake/systems/sensors/color_palette.h:132
            const char* doc =
R"""(Takes ColorI whose pixel range is [0, 255] and returns ColorD whose
pixel range is [0, 1].

Parameter ``color``:
    An input color to be normalized.)""";
          } Normalize;
          // Symbol: drake::systems::sensors::ColorPalette::get_color
          struct /* get_color */ {
            // Source: drake/systems/sensors/color_palette.h:144
            const char* doc =
R"""(Returns a color of type ColorI which corresponds to given index. The
pixel range of returned color is [0, 255].

Parameter ``index``:
    An index that corresponds to the color to be returned.)""";
          } get_color;
          // Symbol: drake::systems::sensors::ColorPalette::get_normalized_color
          struct /* get_normalized_color */ {
            // Source: drake/systems/sensors/color_palette.h:159
            const char* doc =
R"""(Returns a color of type ColorD which corresponds to given index. The
pixel range of returned color is [0, 1].

Parameter ``index``:
    An index that corresponds to the color to be returned.)""";
          } get_normalized_color;
          // Symbol: drake::systems::sensors::ColorPalette::get_sky_color
          struct /* get_sky_color */ {
            // Source: drake/systems/sensors/color_palette.h:166
            const char* doc =
R"""(Returns the color of type ColorI which corresponds to sky. The pixel
range of returned color is [0, 255].)""";
          } get_sky_color;
          // Symbol: drake::systems::sensors::ColorPalette::get_terrain_color
          struct /* get_terrain_color */ {
            // Source: drake/systems/sensors/color_palette.h:172
            const char* doc =
R"""(Returns the color of type ColorI which corresponds to flat terrain.
The pixel range of returned color is [0, 255].)""";
          } get_terrain_color;
        } ColorPalette;
        // Symbol: drake::systems::sensors::Gyroscope
        struct /* Gyroscope */ {
          // Source: drake/systems/sensors/gyroscope.h:50
          const char* doc =
R"""(Sensor to represent an ideal gyroscopic sensor. Currently does not
represent noise or bias, but this could and should be added at a later
date. This sensor measures the angular velocity of a given body B
relative to the world frame. The sensor frame S is rigidly affixed to
the given body B. The measurement, written w_WS_S, is expressed in the
coordinates of frame S. Note that, since S is fixed to B, the angular
velocity of the two frames is identical, w_WS_S = w_WB_S.

There are two inputs to this sensor (nominally from a MultibodyPlant):
1. A vector of body poses (e.g. plant.get_body_poses_output_port()),
2. A vector of spatial velocities, (e.g.
plant.get_body_spatial_velocities_output_port()).

This class is therefore defined by: 1. The Body to which this sensor
is rigidly affixed, 2. The pose of the sensor frame in the body frame.
Note that the translational component of the transformation is not
strictly needed by a gyroscope, as the position of the sensor does not
affect the measurement. However, as a sensor does have a physical
location, it is included here for completeness and in case it might be
useful for display or other purposes.

.. pydrake_system::

    name: Gyroscope
    input_ports:
    - body_poses
    - body_spatial_velocities
    output_ports:
    - measurement)""";
          // Symbol: drake::systems::sensors::Gyroscope::AddToDiagram
          struct /* AddToDiagram */ {
            // Source: drake/systems/sensors/gyroscope.h:98
            const char* doc =
R"""(Static factory method that creates a Gyroscope object and connects it
to the given plant. Modifies a Diagram by connecting the input ports
of the new Gyroscope to the appropriate output ports of a
MultibodyPlant. Must be called during Diagram building and given the
appropriate builder. This is a convenience method to simplify some
common boilerplate of Diagram wiring. Specifically, this makes three
connections:

1. plant.get_body_poses_output_port() to this.get_body_poses_input_port()
2. plant.get_body_spatial_velocities_output_port() to
       this.get_body_velocities_input_port()

Parameter ``body``:
    the body B to which the sensor is affixed

Parameter ``X_BS``:
    X_BS the pose of sensor frame S in body B

Parameter ``plant``:
    the plant to which the sensor will be connected

Parameter ``builder``:
    a pointer to the DiagramBuilder)""";
          } AddToDiagram;
          // Symbol: drake::systems::sensors::Gyroscope::Gyroscope<T>
          struct /* ctor */ {
            // Source: drake/systems/sensors/gyroscope.h:57
            const char* doc =
R"""(Constructor for Gyroscope using full transform.

Parameter ``body``:
    the body B to which the sensor is affixed

Parameter ``X_BS``:
    the pose of sensor frame S in body B)""";
            // Source: drake/systems/sensors/gyroscope.h:62
            const char* doc_copyconvert =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";
          } ctor;
          // Symbol: drake::systems::sensors::Gyroscope::body_index
          struct /* body_index */ {
            // Source: drake/systems/sensors/gyroscope.h:77
            const char* doc =
R"""(Returns the index of the Body that was supplied in the constructor.)""";
          } body_index;
          // Symbol: drake::systems::sensors::Gyroscope::get_body_poses_input_port
          struct /* get_body_poses_input_port */ {
            // Source: drake/systems/sensors/gyroscope.h:64
            const char* doc = R"""()""";
          } get_body_poses_input_port;
          // Symbol: drake::systems::sensors::Gyroscope::get_body_velocities_input_port
          struct /* get_body_velocities_input_port */ {
            // Source: drake/systems/sensors/gyroscope.h:68
            const char* doc = R"""()""";
          } get_body_velocities_input_port;
          // Symbol: drake::systems::sensors::Gyroscope::get_measurement_output_port
          struct /* get_measurement_output_port */ {
            // Source: drake/systems/sensors/gyroscope.h:72
            const char* doc = R"""()""";
          } get_measurement_output_port;
          // Symbol: drake::systems::sensors::Gyroscope::pose
          struct /* pose */ {
            // Source: drake/systems/sensors/gyroscope.h:80
            const char* doc =
R"""(Gets X_BS, the pose of sensor frame S in body B.)""";
          } pose;
        } Gyroscope;
        // Symbol: drake::systems::sensors::Image
        struct /* Image */ {
          // Source: drake/systems/sensors/image.h:57
          const char* doc =
R"""(Simple data format for Image. For the complex calculation with the
image, consider converting this to other libaries' Matrix data format,
i.e., MatrixX in Eigen, Mat in OpenCV, and so on.

The origin of image coordinate system is on the left-upper corner.

Template parameter ``kPixelType``:
    The pixel type enum that denotes the pixel format and the data
    type of a channel.)""";
          // Symbol: drake::systems::sensors::Image::Image<kPixelType>
          struct /* ctor */ {
            // Source: drake/systems/sensors/image.h:86
            const char* doc_2args =
R"""(Image size only constructor. Specifies a width and height for the
image. All the channel values in all the pixels are initialized with
zero.

Parameter ``width``:
    Size of width for image which should be greater than zero

Parameter ``height``:
    Size of height for image which should be greater than zero)""";
            // Source: drake/systems/sensors/image.h:94
            const char* doc_3args =
R"""(Image size and initial value constructor. Specifies a width, height
and an initial value for all the channels in all the pixels.

Parameter ``width``:
    Size of width for image which should be greater than zero.

Parameter ``height``:
    Size of height for image which should be greater than zero.

Parameter ``initial_value``:
    A value set to all the channels in all the pixels)""";
            // Source: drake/systems/sensors/image.h:102
            const char* doc_0args = R"""(Constructs a zero-sized image.)""";
          } ctor;
          // Symbol: drake::systems::sensors::Image::NonTypeTemplateParameter
          struct /* NonTypeTemplateParameter */ {
            // Source: drake/systems/sensors/image.h:63
            const char* doc =
R"""(This is used by generic helpers such as drake::Value to deduce a
non-type template argument.)""";
          } NonTypeTemplateParameter;
          // Symbol: drake::systems::sensors::Image::T
          struct /* T */ {
            // Source: drake/systems/sensors/image.h:71
            const char* doc = R"""(The data type for a channel.)""";
          } T;
          // Symbol: drake::systems::sensors::Image::Traits
          struct /* Traits */ {
            // Source: drake/systems/sensors/image.h:68
            const char* doc =
R"""(An alias for ImageTraits that contains the data type for a channel,
the number of channels and the pixel format in it.)""";
          } Traits;
          // Symbol: drake::systems::sensors::Image::at
          struct /* at */ {
            // Source: drake/systems/sensors/image.h:138
            const char* doc_2args_x_y_nonconst =
R"""(Access to the pixel located at (x, y) in image coordinate system where
x is the variable for horizontal direction and y is one for vertical
direction. To access to the each channel value in the pixel (x, y),
you can do:

ImageRgbaU8 image(640, 480, 255); uint8_t red = image.at(x, y)[0];
uint8_t green = image.at(x, y)[1]; uint8_t blue = image.at(x, y)[2];
uint8_t alpha = image.at(x, y)[3];)""";
            // Source: drake/systems/sensors/image.h:146
            const char* doc_2args_x_y_const =
R"""(Const version of at() method. See the document for the non-const
version for the detail.)""";
          } at;
          // Symbol: drake::systems::sensors::Image::height
          struct /* height */ {
            // Source: drake/systems/sensors/image.h:108
            const char* doc =
R"""(Returns the size of height for the image)""";
          } height;
          // Symbol: drake::systems::sensors::Image::resize
          struct /* resize */ {
            // Source: drake/systems/sensors/image.h:118
            const char* doc =
R"""(Changes the sizes of the width and height for the image. The values
for them should be greater than zero. (To resize to zero, assign a
default- constructed Image into this; do not use this method.) All the
values in the pixels become zero after resize.)""";
          } resize;
          // Symbol: drake::systems::sensors::Image::size
          struct /* size */ {
            // Source: drake/systems/sensors/image.h:112
            const char* doc =
R"""(Returns the result of the number of pixels in a image by the number of
channels in a pixel)""";
          } size;
          // Symbol: drake::systems::sensors::Image::width
          struct /* width */ {
            // Source: drake/systems/sensors/image.h:105
            const char* doc = R"""(Returns the size of width for the image)""";
          } width;
        } Image;
        // Symbol: drake::systems::sensors::ImageBgr8U
        struct /* ImageBgr8U */ {
          // Source: drake/systems/sensors/image.h:24
          const char* doc =
R"""(The type for BGR image where the each channel has the type of uint8_t.)""";
        } ImageBgr8U;
        // Symbol: drake::systems::sensors::ImageBgra8U
        struct /* ImageBgra8U */ {
          // Source: drake/systems/sensors/image.h:30
          const char* doc =
R"""(The type for BGRA image where the each channel has the type of
uint8_t.)""";
        } ImageBgra8U;
        // Symbol: drake::systems::sensors::ImageDepth16U
        struct /* ImageDepth16U */ {
          // Source: drake/systems/sensors/image.h:36
          const char* doc =
R"""(The type for depth image where the channel has the type of uint16_t.)""";
        } ImageDepth16U;
        // Symbol: drake::systems::sensors::ImageDepth32F
        struct /* ImageDepth32F */ {
          // Source: drake/systems/sensors/image.h:33
          const char* doc =
R"""(The type for depth image where the channel has the type of float.)""";
        } ImageDepth32F;
        // Symbol: drake::systems::sensors::ImageExpr
        struct /* ImageExpr */ {
          // Source: drake/systems/sensors/image.h:46
          const char* doc =
R"""(The type for symbolic image where the channel has the type of
symbolic::Expression.)""";
        } ImageExpr;
        // Symbol: drake::systems::sensors::ImageGrey8U
        struct /* ImageGrey8U */ {
          // Source: drake/systems/sensors/image.h:42
          const char* doc =
R"""(The type for greyscale image where the channel has the type of
uint8_t.)""";
        } ImageGrey8U;
        // Symbol: drake::systems::sensors::ImageLabel16I
        struct /* ImageLabel16I */ {
          // Source: drake/systems/sensors/image.h:39
          const char* doc =
R"""(The type for label image where the channel has the type of int16_t.)""";
        } ImageLabel16I;
        // Symbol: drake::systems::sensors::ImageRgb8U
        struct /* ImageRgb8U */ {
          // Source: drake/systems/sensors/image.h:21
          const char* doc =
R"""(The type for RGB image where the each channel has the type of uint8_t.)""";
        } ImageRgb8U;
        // Symbol: drake::systems::sensors::ImageRgba8U
        struct /* ImageRgba8U */ {
          // Source: drake/systems/sensors/image.h:27
          const char* doc =
R"""(The type for RGBA image where the each channel has the type of
uint8_t.)""";
        } ImageRgba8U;
        // Symbol: drake::systems::sensors::ImageToLcmImageArrayT
        struct /* ImageToLcmImageArrayT */ {
          // Source: drake/systems/sensors/image_to_lcm_image_array_t.h:25
          const char* doc =
R"""(An ImageToLcmImageArrayT takes as input an ImageRgba8U, ImageDepth32F
and ImageLabel16I. This system outputs an AbstractValue containing a
``Value<robotlocomotion::image_array_t>`` LCM message that defines an
array of images (image_t). This message can then be sent to other
processes that sbscribe it using LcmPublisherSystem. Note that you
should NOT assume any particular order of those images stored in
robotlocomotion::image_array_t, instead check the semantic of those
images with robotlocomotion::image_t::pixel_format before using them.)""";
          // Symbol: drake::systems::sensors::ImageToLcmImageArrayT::DeclareImageInputPort
          struct /* DeclareImageInputPort */ {
            // Source: drake/systems/sensors/image_to_lcm_image_array_t.h:63
            const char* doc = R"""()""";
          } DeclareImageInputPort;
          // Symbol: drake::systems::sensors::ImageToLcmImageArrayT::ImageToLcmImageArrayT
          struct /* ctor */ {
            // Source: drake/systems/sensors/image_to_lcm_image_array_t.h:37
            const char* doc_4args =
R"""(An ImageToLcmImageArrayT constructor. Declares three input ports --
one color image, one depth image, and one label image.

Parameter ``color_frame_name``:
    The frame name used for color image.

Parameter ``depth_frame_name``:
    The frame name used for depth image.

Parameter ``label_frame_name``:
    The frame name used for label image.

Parameter ``do_compress``:
    When true, zlib compression will be performed. The default is
    false.)""";
            // Source: drake/systems/sensors/image_to_lcm_image_array_t.h:60
            const char* doc_1args =
R"""(Default constructor doesn't declare any ports. Use the Add*Input()
methods to declare them.)""";
          } ctor;
          // Symbol: drake::systems::sensors::ImageToLcmImageArrayT::color_image_input_port
          struct /* color_image_input_port */ {
            // Source: drake/systems/sensors/image_to_lcm_image_array_t.h:44
            const char* doc =
R"""(Returns the input port containing a color image. Note: Only valid if
the color/depth/label constructor is used.)""";
          } color_image_input_port;
          // Symbol: drake::systems::sensors::ImageToLcmImageArrayT::depth_image_input_port
          struct /* depth_image_input_port */ {
            // Source: drake/systems/sensors/image_to_lcm_image_array_t.h:48
            const char* doc =
R"""(Returns the input port containing a depth image. Note: Only valid if
the color/depth/label constructor is used.)""";
          } depth_image_input_port;
          // Symbol: drake::systems::sensors::ImageToLcmImageArrayT::image_array_t_msg_output_port
          struct /* image_array_t_msg_output_port */ {
            // Source: drake/systems/sensors/image_to_lcm_image_array_t.h:56
            const char* doc =
R"""(Returns the abstract valued output port that contains a
``Value<robotlocomotion::image_array_t>``.)""";
          } image_array_t_msg_output_port;
          // Symbol: drake::systems::sensors::ImageToLcmImageArrayT::label_image_input_port
          struct /* label_image_input_port */ {
            // Source: drake/systems/sensors/image_to_lcm_image_array_t.h:52
            const char* doc =
R"""(Returns the input port containing a label image. Note: Only valid if
the color/depth/label constructor is used.)""";
          } label_image_input_port;
        } ImageToLcmImageArrayT;
        // Symbol: drake::systems::sensors::ImageTraits
        struct /* ImageTraits */ {
          // Source: drake/systems/sensors/pixel_types.h:85
          const char* doc = R"""()""";
          // Symbol: drake::systems::sensors::ImageTraits::ChannelType
          struct /* ChannelType */ {
            // Source: drake/systems/sensors/pixel_types.h:86
            const char* doc = R"""()""";
          } ChannelType;
        } ImageTraits;
        // Symbol: drake::systems::sensors::ImageWriter
        struct /* ImageWriter */ {
          // Source: drake/systems/sensors/image_writer.h:91
          const char* doc =
R"""(A system for periodically writing images to the file system. The
system does not have a fixed set of input ports; the system can have
an arbitrary number of image input ports. Each input port is
independently configured with respect to:

- publish frequency,
- write location (directory) and image name,
- input image format (which, in turn, implies a file-system format),
- port name (which needs to be unique across all input ports in this system),
and
- context time at which output starts.

By design, this system is intended to work with RgbdCamera, but can
connect to any output port that provides images.

.. pydrake_system::

    name: ImageWriter
    input_ports:
    - declared_image1
    - declared_image2
    - ...
    - declared_imageN

ImageWriter supports three specific types of images:

- ImageRgba8U - typically a color image written to disk as .png images.
- ImageDepth32F - typically a depth image, written to disk as .tiff images.
- ImageLabel16I - typically a label image, written to disk as .png images.
- ImageDepth16U - typically a depth image, written to disk as .png images.
- ImageGrey8U - typically a grey scale image, written to disk as .png images.

Input ports are added to an ImageWriter via DeclareImageInputPort().
See that function's documentation for elaboration on how to configure
image output. It is important to note, that every declared image input
port *must* be connected; otherwise, attempting to write an image from
that port, will cause an error in the system.)""";
          // Symbol: drake::systems::sensors::ImageWriter::DeclareImageInputPort
          struct /* DeclareImageInputPort */ {
            // Source: drake/systems/sensors/image_writer.h:199
            const char* doc =
R"""(Declares and configures a new image input port. A port is configured
by providing:

- a unique port name,
- an output file format string,
- a publish period,
- a start time, and
- an image type.

Each port is evaluated independently, so that two ports on the same
ImageWriter can write images to different locations at different
frequencies, etc. If images are to be kept in sync (e.g., registered
color and depth images), they should be given the same period and
start time.

**Specifying the times at which images are written**

Given a *positive* publish period ``p``, images will be written at
times contained in the list of times: ``t = [0, 1⋅p, 2⋅p, ...]``. The
start time parameter determines what the *first* output time will be.
Given a "start time" value ``tₛ``, the frames will be written at: ``t
= tₛ + [0, 1⋅p, 2⋅p, ...]``.

**Specifying write location and output file names**

When writing image data to disk, the location and name of the output
files are controlled by a user-defined format string. The format
string should be compatible with ``fmt::format()``. ImageWriter
provides several *named* format arguments that can be referenced in
the format string:

- ``port_name``   - The name of the port (see below).
- ``image_type``  - One of ``color``, `depth`, or ``label``, depending on the
image type requested.
- ``time_double`` - The time (in seconds) stored in the context at the
invocation of Publish(), represented as a double.
- ``time_usec``   - The time (in microseconds) stored in the context at the
invocation of Publish(), represented as a 64-bit integer.
- ``time_msec``   - The time (in milliseconds) stored in the context at the
invocation of Publish(), represented as an integer.
- ``count``       - The number of images that have been written from this
port (the first image would get zero, the Nᵗʰ would get
N - 1). This value increments *every* time an image gets
written.

File names can then be specified as shown in the following examples
(assuming the port was declared as a color image port, with a name of
"my_port", a period of 0.02 s (50 Hz), and a start time of 5 s.

- ``/home/user/images/{port_name}/{time_usec}`` creates a sequence like:
- ``/home/user/images/my_port/5000000.png``
- `/home/user/images/my_port/5020000.png`
- ``/home/user/images/my_port/5040000.png``
- ...
- `/home/user/images/{image_type}/{time_msec:05}` creates a sequence like:
- ``/home/user/images/color/05000.png``
- `/home/user/images/color/05020.png`
- ``/home/user/images/color/05040.png``
- ...
- `/home/user/{port_name}/my_image_{count:03}.txt` creates a sequence like:
- ``/home/user/my_port/my_image_000.txt.png``
- `/home/user/my_port/my_image_001.txt.png`
- ``/home/user/my_port/my_image_002.txt.png``
- ...

We call attention particularly to the following:

- Note the zero-padding arguments in the second and third examples. Making
use of zero-padding typically facilitates *other* processes.
- If the file name format does not end with an appropriate extension (e.g.,
``.png`` or ``.tiff``), the extension will be added.
- The directory specified in the format will be tested for validity
(does it exist, is it a directory, can the program write to it). The
full *file name* will *not* be validated. If it is invalid (e.g., too
long, invalid characters, bad format substitution), images will silently
not be created.
- The third example uses the count flag -- regardless of start time, the
first file written will always be zero, the second one, etc.
- The directory can *only* depend ``port_name`` and ``image_type``. It *cannot*
depend on values that change over time (e.g., ``time_double``, `count`,
etc.

Parameter ``port_name``:
    The name of the port (must be unique among all image ports). This
    string is available in the format string as ``port_name``.

Parameter ``file_name_format``:
    The ``fmt::format()``-compatible string which defines the
    context-dependent file name to write the image to.

Parameter ``publish_period``:
    The period at which images read from this input port are written
    in calls to Publish().

Parameter ``start_time``:
    The minimum value for the context's time at which images will be
    written in calls to Publish().

Template parameter ``kPixelType``:
    The representation of the per-pixel data (see PixelType). Must be
    one of {PixelType::kRgba8U, PixelType::kDepth32F,
    PixelType::kLabel16I, PixelType::kDepth16U, or
    PixelType::kGrey8U}.

Raises:
    RuntimeError if (1) the directory encoded in the
    ``file_name_format`` is not "valid" (see documentation above for
    definition), (2) ``publish_period`` is not positive, or (3)
    ``port_name`` is used by a previous input port.)""";
          } DeclareImageInputPort;
          // Symbol: drake::systems::sensors::ImageWriter::ImageWriter
          struct /* ctor */ {
            // Source: drake/systems/sensors/image_writer.h:96
            const char* doc =
R"""(Constructs default instance with no image ports.)""";
          } ctor;
        } ImageWriter;
        // Symbol: drake::systems::sensors::InvalidDepth
        struct /* InvalidDepth */ {
          // Source: drake/systems/sensors/image.h:163
          const char* doc =
R"""(Set of constants used to represent invalid depth values. Note that in
the case that a depth is not measurable, the constants defined here
are not used. Instead we set the depth to NaN.)""";
          // Symbol: drake::systems::sensors::InvalidDepth::InvalidDepth
          struct /* ctor */ {
            // Source: drake/systems/sensors/image.h:165
            const char* doc = R"""()""";
          } ctor;
        } InvalidDepth;
        // Symbol: drake::systems::sensors::Label
        struct /* Label */ {
          // Source: drake/systems/sensors/image.h:177
          const char* doc = R"""(Set of labels used for label image.)""";
          // Symbol: drake::systems::sensors::Label::Label
          struct /* ctor */ {
            // Source: drake/systems/sensors/image.h:179
            const char* doc = R"""()""";
          } ctor;
        } Label;
        // Symbol: drake::systems::sensors::LcmImageArrayToImages
        struct /* LcmImageArrayToImages */ {
          // Source: drake/systems/sensors/lcm_image_array_to_images.h:18
          const char* doc =
R"""(An LcmImageArrayToImages takes as input an AbstractValue containing a
``Value<robotlocomotion::image_array_t>`` LCM message that defines an
array of images (image_t). The system has output ports for one color
image as an ImageRgba8U and one depth image as ImageDepth32F (intended
to be similar to the API of RgbdCamera, though without the label image
port).)""";
          // Symbol: drake::systems::sensors::LcmImageArrayToImages::LcmImageArrayToImages
          struct /* ctor */ {
            // Source: drake/systems/sensors/lcm_image_array_to_images.h:20
            const char* doc = R"""()""";
          } ctor;
          // Symbol: drake::systems::sensors::LcmImageArrayToImages::color_image_output_port
          struct /* color_image_output_port */ {
            // Source: drake/systems/sensors/lcm_image_array_to_images.h:34
            const char* doc =
R"""(Returns the abstract valued output port that contains a RGBA image of
the type ImageRgba8U. The image will be empty if no color image was
received in the most recent message (so, for example, sending color
and depth in different messages will not produce useful results).)""";
          } color_image_output_port;
          // Symbol: drake::systems::sensors::LcmImageArrayToImages::depth_image_output_port
          struct /* depth_image_output_port */ {
            // Source: drake/systems/sensors/lcm_image_array_to_images.h:42
            const char* doc =
R"""(Returns the abstract valued output port that contains an
ImageDepth32F. The image will be empty if no color image was received
in the most recent message (so, for example, sending color and depth
in different messages will not produce useful results).)""";
          } depth_image_output_port;
          // Symbol: drake::systems::sensors::LcmImageArrayToImages::image_array_t_input_port
          struct /* image_array_t_input_port */ {
            // Source: drake/systems/sensors/lcm_image_array_to_images.h:26
            const char* doc =
R"""(Returns the abstract valued input port that expects a
``Value<robotlocomotion::image_array_t>``.)""";
          } image_array_t_input_port;
        } LcmImageArrayToImages;
        // Symbol: drake::systems::sensors::LcmImageTraits
        struct /* LcmImageTraits */ {
          // Source: drake/systems/sensors/lcm_image_traits.h:62
          const char* doc = R"""()""";
        } LcmImageTraits;
        // Symbol: drake::systems::sensors::LcmPixelTraits
        struct /* LcmPixelTraits */ {
          // Source: drake/systems/sensors/lcm_image_traits.h:17
          const char* doc = R"""()""";
        } LcmPixelTraits;
        // Symbol: drake::systems::sensors::OptitrackLcmFrameSender
        struct /* OptitrackLcmFrameSender */ {
          // Source: drake/systems/sensors/optitrack_sender.h:29
          const char* doc =
R"""(The system has one abstract-valued input port and one abstract-valued
output port. The one abstract input port accepts
geometry::FramePoseVector. The abstract output port produces
``optitrack_frame_t``.

Note that this system does not actually send this message on an LCM
channel. To send the message, the output of this system should be
connected to an input port of a Value object templated on type
``optitrack_frame_t``.)""";
          // Symbol: drake::systems::sensors::OptitrackLcmFrameSender::OptitrackLcmFrameSender
          struct /* ctor */ {
            // Source: drake/systems/sensors/optitrack_sender.h:40
            const char* doc =
R"""(Create an OptitrackLcmFrameSender.

Parameter ``frame_map``:
    contains a map of geometry::FrameId to the rigid body name and id
    to be published in the resulting ``optitrack_rigid_body_t`` and
    ``optitrack_rigid_body_description_t`` messages (descriptions not
    yet implemented).)""";
          } ctor;
          // Symbol: drake::systems::sensors::OptitrackLcmFrameSender::get_lcm_output_port
          struct /* get_lcm_output_port */ {
            // Source: drake/systems/sensors/optitrack_sender.h:49
            const char* doc = R"""()""";
          } get_lcm_output_port;
          // Symbol: drake::systems::sensors::OptitrackLcmFrameSender::get_optitrack_input_port
          struct /* get_optitrack_input_port */ {
            // Source: drake/systems/sensors/optitrack_sender.h:45
            const char* doc = R"""()""";
          } get_optitrack_input_port;
        } OptitrackLcmFrameSender;
        // Symbol: drake::systems::sensors::PixelFormat
        struct /* PixelFormat */ {
          // Source: drake/systems/sensors/pixel_types.h:45
          const char* doc =
R"""(The enum class to be used to express semantic meaning of pixels. This
also expresses the order of channels in a pixel if the pixel has
multiple channels.)""";
          // Symbol: drake::systems::sensors::PixelFormat::kBgr
          struct /* kBgr */ {
            // Source: drake/systems/sensors/pixel_types.h:49
            const char* doc =
R"""(The pixel format used for all the BGR images.)""";
          } kBgr;
          // Symbol: drake::systems::sensors::PixelFormat::kBgra
          struct /* kBgra */ {
            // Source: drake/systems/sensors/pixel_types.h:53
            const char* doc =
R"""(The pixel format used for all the BGRA images.)""";
          } kBgra;
          // Symbol: drake::systems::sensors::PixelFormat::kDepth
          struct /* kDepth */ {
            // Source: drake/systems/sensors/pixel_types.h:57
            const char* doc =
R"""(The pixel format used for all the depth images.)""";
          } kDepth;
          // Symbol: drake::systems::sensors::PixelFormat::kExpr
          struct /* kExpr */ {
            // Source: drake/systems/sensors/pixel_types.h:61
            const char* doc =
R"""(The pixel format used for all the symbolic images.)""";
          } kExpr;
          // Symbol: drake::systems::sensors::PixelFormat::kGrey
          struct /* kGrey */ {
            // Source: drake/systems/sensors/pixel_types.h:55
            const char* doc =
R"""(The pixel format used for all the greyscale images.)""";
          } kGrey;
          // Symbol: drake::systems::sensors::PixelFormat::kLabel
          struct /* kLabel */ {
            // Source: drake/systems/sensors/pixel_types.h:59
            const char* doc =
R"""(The pixel format used for all the labe images.)""";
          } kLabel;
          // Symbol: drake::systems::sensors::PixelFormat::kRgb
          struct /* kRgb */ {
            // Source: drake/systems/sensors/pixel_types.h:47
            const char* doc =
R"""(The pixel format used for all the RGB images.)""";
          } kRgb;
          // Symbol: drake::systems::sensors::PixelFormat::kRgba
          struct /* kRgba */ {
            // Source: drake/systems/sensors/pixel_types.h:51
            const char* doc =
R"""(The pixel format used for all the RGBA images.)""";
          } kRgba;
        } PixelFormat;
        // Symbol: drake::systems::sensors::PixelType
        struct /* PixelType */ {
          // Source: drake/systems/sensors/pixel_types.h:21
          const char* doc =
R"""(The enum class to be used for describing pixel type in Image class.
The naming rule for the enum members is: k + (pixel format) + (bit per
a channel) + (data type for channels). For the type for channels, one
of the following capital letters is used.

- I: int
- U: unsigned int
- F: float)""";
          // Symbol: drake::systems::sensors::PixelType::kBgr8U
          struct /* kBgr8U */ {
            // Source: drake/systems/sensors/pixel_types.h:25
            const char* doc = R"""(The pixel format used by ImageBgr8U.)""";
          } kBgr8U;
          // Symbol: drake::systems::sensors::PixelType::kBgra8U
          struct /* kBgra8U */ {
            // Source: drake/systems/sensors/pixel_types.h:29
            const char* doc = R"""(The pixel format used by ImageBgra8U.)""";
          } kBgra8U;
          // Symbol: drake::systems::sensors::PixelType::kDepth16U
          struct /* kDepth16U */ {
            // Source: drake/systems/sensors/pixel_types.h:33
            const char* doc = R"""(The pixel format used by ImageDepth16U.)""";
          } kDepth16U;
          // Symbol: drake::systems::sensors::PixelType::kDepth32F
          struct /* kDepth32F */ {
            // Source: drake/systems/sensors/pixel_types.h:35
            const char* doc = R"""(The pixel format used by ImageDepth32F.)""";
          } kDepth32F;
          // Symbol: drake::systems::sensors::PixelType::kExpr
          struct /* kExpr */ {
            // Source: drake/systems/sensors/pixel_types.h:39
            const char* doc =
R"""(The pixel format representing symbolic::Expression.)""";
          } kExpr;
          // Symbol: drake::systems::sensors::PixelType::kGrey8U
          struct /* kGrey8U */ {
            // Source: drake/systems/sensors/pixel_types.h:31
            const char* doc = R"""(The pixel format used by ImageGrey8U.)""";
          } kGrey8U;
          // Symbol: drake::systems::sensors::PixelType::kLabel16I
          struct /* kLabel16I */ {
            // Source: drake/systems/sensors/pixel_types.h:37
            const char* doc = R"""(The pixel format used by ImageLabel16I.)""";
          } kLabel16I;
          // Symbol: drake::systems::sensors::PixelType::kRgb8U
          struct /* kRgb8U */ {
            // Source: drake/systems/sensors/pixel_types.h:23
            const char* doc = R"""(The pixel format used by ImageRgb8U.)""";
          } kRgb8U;
          // Symbol: drake::systems::sensors::PixelType::kRgba8U
          struct /* kRgba8U */ {
            // Source: drake/systems/sensors/pixel_types.h:27
            const char* doc = R"""(The pixel format used by ImageRgba8U.)""";
          } kRgba8U;
        } PixelType;
        // Symbol: drake::systems::sensors::RgbdSensor
        struct /* RgbdSensor */ {
          // Source: drake/systems/sensors/rgbd_sensor.h:96
          const char* doc =
R"""(A meta-sensor that houses RGB, depth, and label cameras, producing
their corresponding images based on the contents of the
geometry::SceneGraph.

.. pydrake_system::

    name: RgbdSensor
    input_ports:
    - geometry_query
    output_ports:
    - color_image
    - depth_image_32f
    - depth_image_16u
    - label_image
    - X_WB

The following text uses terminology and conventions from CameraInfo.
Please review its documentation.

This class uses the following frames:

- W - world frame
- C - color camera frame, used for both color and label cameras to guarantee
perfect registration between color and label images.
- D - depth camera frame
- B - sensor body frame. Approximately, the frame of the "physical" sensor
that contains the color, depth, and label cameras. The contained cameras
are rigidly fixed to B and X_WB is what is used to pose the sensor in the
world (or, alternatively, X_PB where P is some parent frame for which X_WP
is known).

By default, frames B, C, and D are coincident and aligned. These can
be changed using the ``camera_poses`` constructor parameter. Frames C
and D are always rigidly affixed to the sensor body frame B.

In terms of the camera intrinsics outlined in CameraInfo, this sensor
assumes that each camera's principal point is in the center of the
image and that the focal lengths in both the x- and y-directions are
equal.

Output port image formats:

- color_image: Four channels, each channel uint8_t, in the following order:
red, green, blue, and alpha.

- depth_image_32f: One channel, float, representing the Z value in
``D`` in *meters*. The values 0 and infinity are reserved for out-of-range
depth returns (too close or too far, respectively, as defined by
geometry::render::DepthRenderCamera "DepthRenderCamera").

- depth_image_16u: One channel, uint16_t, representing the Z value in
``D`` in *millimeters*. The values 0 and 65535 are reserved for out-of-range
depth returns (too close or too far, respectively, as defined by
geometry::render::DepthRenderCamera "DepthRenderCamera").
Additionally, 65535 will also be returned if the
depth measurement exceeds the representation range of uint16_t. Thus, the
maximum valid depth return is 65534mm.

- label_image: One channel, int16_t, whose value is a unique
geometry::render::RenderLabel "RenderLabel" value aligned with the
color camera frame. See geometry::render::RenderLabel "RenderLabel"
for discussion of interpreting rendered labels.

Note:
    These depth sensor measurements differ from those of range data
    used by laser range finders (like DepthSensor), where the depth
    value represents the distance from the sensor origin to the
    object's surface.)""";
          // Symbol: drake::systems::sensors::RgbdSensor::CameraPoses
          struct /* CameraPoses */ {
            // Source: drake/systems/sensors/rgbd_sensor.h:107
            const char* doc_deprecated =
R"""(Specifies poses of cameras with respect ot the sensor base ``B``. /
(Deprecated.)

Deprecated:
    The constructors that take poses explicitly have been deprecated.
    Pose is now part of the RenderCamera interface. See the
    RenderCamera-based RgbdSensor constructors. This will be removed
    from Drake on or after 2021-04-01.)""";
            // Symbol: drake::systems::sensors::RgbdSensor::CameraPoses::X_BC
            struct /* X_BC */ {
              // Source: drake/systems/sensors/rgbd_sensor.h:110
              const char* doc =
R"""(Pose of color camera ``C`` with respect to sensor base ``B``. Defaults
to the identity matrix.)""";
            } X_BC;
            // Symbol: drake::systems::sensors::RgbdSensor::CameraPoses::X_BD
            struct /* X_BD */ {
              // Source: drake/systems/sensors/rgbd_sensor.h:114
              const char* doc =
R"""(Pose of depth camera ``D`` with respect to sensor base ``B``. Defaults
to the identity matrix.)""";
            } X_BD;
          } CameraPoses;
          // Symbol: drake::systems::sensors::RgbdSensor::RgbdSensor
          struct /* ctor */ {
            // Source: drake/systems/sensors/rgbd_sensor.h:147
            const char* doc_legacy_individual_intrinsics =
R"""(Constructs an RgbdSensor whose frame ``B`` is rigidly affixed to the
frame P, indicated by ``parent_id``, and with the given "simple"
camera properties. The camera is "simple" in the sense that it models
a camera with a radially symmetric lens and a principal point that
projects onto the center of the image. The camera will move as frame P
moves. For a stationary camera, use the frame id from
SceneGraph::world_frame_id().

Parameter ``parent_id``:
    The identifier of a parent frame ``P`` in geometry::SceneGraph to
    which this camera is rigidly affixed with pose ``X_PB``.

Parameter ``X_PB``:
    The pose of the camera ``B`` frame relative to the parent frame
    ``P``.

Parameter ``color_properties``:
    Defines camera's color (and label) intrinsics and renderer.

Parameter ``depth_properties``:
    Defines camera's depth intrinsics and renderer.

Parameter ``camera_poses``:
    The poses of the color (C) and depth camera (D) frames with
    respect to the sensor base (B). If omitted, all three frames will
    be aligned and coincident.

Parameter ``show_window``:
    A flag for showing a visible window. If this is false, off-screen
    rendering is executed. The default is false.
     /
    (Deprecated.)

Deprecated:
    CameraProperties are being deprecated. Please use the RenderCamera
    variant. This will be removed from Drake on or after 2021-04-01.)""";
            // Source: drake/systems/sensors/rgbd_sensor.h:162
            const char* doc_legacy_combined_intrinsics =
R"""(Constructs an RgbdSensor in the same way as the above overload, but
using the ``CameraProperties`` portion of ``properties`` for color
(and label) properties, and all of ``properties`` for depth
properties.  /
(Deprecated.)

Deprecated:
    CameraProperties are being deprecated. Please use the RenderCamera
    variant. This will be removed from Drake on or after 2021-04-01.)""";
            // Source: drake/systems/sensors/rgbd_sensor.h:170
            const char* doc_individual_intrinsics =
R"""(Constructs an RgbdSensor with fully specified render camera models for
both color/label and depth cameras.)""";
            // Source: drake/systems/sensors/rgbd_sensor.h:179
            const char* doc_combined_intrinsics =
R"""(Constructs an RgbdSensor with fully specified render camera models for
both the depth camera. The color camera in inferred from the
``depth_camera``; it shares the same
geometry::render::RenderCameraCore and is configured to show the
window based on the value of ``show_color_window``.)""";
          } ctor;
          // Symbol: drake::systems::sensors::RgbdSensor::X_BC
          struct /* X_BC */ {
            // Source: drake/systems/sensors/rgbd_sensor.h:210
            const char* doc = R"""(Returns ``X_BC``.)""";
          } X_BC;
          // Symbol: drake::systems::sensors::RgbdSensor::X_BD
          struct /* X_BD */ {
            // Source: drake/systems/sensors/rgbd_sensor.h:215
            const char* doc = R"""(Returns ``X_BD``.)""";
          } X_BD;
          // Symbol: drake::systems::sensors::RgbdSensor::X_WB_output_port
          struct /* X_WB_output_port */ {
            // Source: drake/systems/sensors/rgbd_sensor.h:243
            const char* doc =
R"""(Returns the abstract-valued output port that contains a RigidTransform
for ``X_WB``.)""";
          } X_WB_output_port;
          // Symbol: drake::systems::sensors::RgbdSensor::color_camera_info
          struct /* color_camera_info */ {
            // Source: drake/systems/sensors/rgbd_sensor.h:189
            const char* doc =
R"""(Returns the intrinsics properties of the color camera model.)""";
          } color_camera_info;
          // Symbol: drake::systems::sensors::RgbdSensor::color_image_output_port
          struct /* color_image_output_port */ {
            // Source: drake/systems/sensors/rgbd_sensor.h:226
            const char* doc =
R"""(Returns the abstract-valued output port that contains an ImageRgba8U.)""";
          } color_image_output_port;
          // Symbol: drake::systems::sensors::RgbdSensor::color_render_camera
          struct /* color_render_camera */ {
            // Source: drake/systems/sensors/rgbd_sensor.h:200
            const char* doc =
R"""(Returns the render camera for color/label renderings.)""";
          } color_render_camera;
          // Symbol: drake::systems::sensors::RgbdSensor::depth_camera_info
          struct /* depth_camera_info */ {
            // Source: drake/systems/sensors/rgbd_sensor.h:195
            const char* doc =
R"""(Returns the intrinsics properties of the depth camera model.)""";
          } depth_camera_info;
          // Symbol: drake::systems::sensors::RgbdSensor::depth_image_16U_output_port
          struct /* depth_image_16U_output_port */ {
            // Source: drake/systems/sensors/rgbd_sensor.h:234
            const char* doc =
R"""(Returns the abstract-valued output port that contains an
ImageDepth16U.)""";
          } depth_image_16U_output_port;
          // Symbol: drake::systems::sensors::RgbdSensor::depth_image_32F_output_port
          struct /* depth_image_32F_output_port */ {
            // Source: drake/systems/sensors/rgbd_sensor.h:230
            const char* doc =
R"""(Returns the abstract-valued output port that contains an
ImageDepth32F.)""";
          } depth_image_32F_output_port;
          // Symbol: drake::systems::sensors::RgbdSensor::depth_render_camera
          struct /* depth_render_camera */ {
            // Source: drake/systems/sensors/rgbd_sensor.h:205
            const char* doc =
R"""(Returns the render camera for depth renderings.)""";
          } depth_render_camera;
          // Symbol: drake::systems::sensors::RgbdSensor::label_image_output_port
          struct /* label_image_output_port */ {
            // Source: drake/systems/sensors/rgbd_sensor.h:238
            const char* doc =
R"""(Returns the abstract-valued output port that contains an
ImageLabel16I.)""";
          } label_image_output_port;
          // Symbol: drake::systems::sensors::RgbdSensor::parent_frame_id
          struct /* parent_frame_id */ {
            // Source: drake/systems/sensors/rgbd_sensor.h:220
            const char* doc =
R"""(Returns the id of the frame to which the base is affixed.)""";
          } parent_frame_id;
          // Symbol: drake::systems::sensors::RgbdSensor::query_object_input_port
          struct /* query_object_input_port */ {
            // Source: drake/systems/sensors/rgbd_sensor.h:223
            const char* doc =
R"""(Returns the geometry::QueryObject<double>-valued input port.)""";
          } query_object_input_port;
        } RgbdSensor;
        // Symbol: drake::systems::sensors::RgbdSensorDiscrete
        struct /* RgbdSensorDiscrete */ {
          // Source: drake/systems/sensors/rgbd_sensor.h:303
          const char* doc =
R"""(Wraps a continuous RgbdSensor with a zero-order hold to create a
discrete sensor.

.. pydrake_system::

    name: RgbdSensorDiscrete
    input_ports:
    - geometry_query
    output_ports:
    - color_image
    - depth_image_32f
    - depth_image_16u
    - label_image
    - X_WB)""";
          // Symbol: drake::systems::sensors::RgbdSensorDiscrete::RgbdSensorDiscrete
          struct /* ctor */ {
            // Source: drake/systems/sensors/rgbd_sensor.h:318
            const char* doc =
R"""(Constructs a diagram containing a (non-registered) RgbdSensor that
will update at a given rate.

Parameter ``sensor``:
    The continuous sensor used to generate periodic images.

Parameter ``period``:
    Update period (sec).

Parameter ``render_label_image``:
    If true, renders label image (which requires additional overhead).
    If false, ``label_image_output_port`` will raise an error if
    called.)""";
          } ctor;
          // Symbol: drake::systems::sensors::RgbdSensorDiscrete::X_WB_output_port
          struct /* X_WB_output_port */ {
            // Source: drake/systems/sensors/rgbd_sensor.h:354
            const char* doc =
R"""(See also:
    RgbdSensor::base_pose_output_port().)""";
          } X_WB_output_port;
          // Symbol: drake::systems::sensors::RgbdSensorDiscrete::color_image_output_port
          struct /* color_image_output_port */ {
            // Source: drake/systems/sensors/rgbd_sensor.h:334
            const char* doc =
R"""(See also:
    RgbdSensor::color_image_output_port().)""";
          } color_image_output_port;
          // Symbol: drake::systems::sensors::RgbdSensorDiscrete::depth_image_16U_output_port
          struct /* depth_image_16U_output_port */ {
            // Source: drake/systems/sensors/rgbd_sensor.h:344
            const char* doc =
R"""(See also:
    RgbdSensor::depth_image_16U_output_port().)""";
          } depth_image_16U_output_port;
          // Symbol: drake::systems::sensors::RgbdSensorDiscrete::depth_image_32F_output_port
          struct /* depth_image_32F_output_port */ {
            // Source: drake/systems/sensors/rgbd_sensor.h:339
            const char* doc =
R"""(See also:
    RgbdSensor::depth_image_32F_output_port().)""";
          } depth_image_32F_output_port;
          // Symbol: drake::systems::sensors::RgbdSensorDiscrete::label_image_output_port
          struct /* label_image_output_port */ {
            // Source: drake/systems/sensors/rgbd_sensor.h:349
            const char* doc =
R"""(See also:
    RgbdSensor::label_image_output_port().)""";
          } label_image_output_port;
          // Symbol: drake::systems::sensors::RgbdSensorDiscrete::period
          struct /* period */ {
            // Source: drake/systems/sensors/rgbd_sensor.h:326
            const char* doc =
R"""(Returns update period for discrete camera.)""";
          } period;
          // Symbol: drake::systems::sensors::RgbdSensorDiscrete::query_object_input_port
          struct /* query_object_input_port */ {
            // Source: drake/systems/sensors/rgbd_sensor.h:329
            const char* doc =
R"""(See also:
    RgbdSensor::query_object_input_port().)""";
          } query_object_input_port;
          // Symbol: drake::systems::sensors::RgbdSensorDiscrete::sensor
          struct /* sensor */ {
            // Source: drake/systems/sensors/rgbd_sensor.h:323
            const char* doc =
R"""(Returns reference to RgbdSensor instance.)""";
          } sensor;
        } RgbdSensorDiscrete;
        // Symbol: drake::systems::sensors::RotaryEncoders
        struct /* RotaryEncoders */ {
          // Source: drake/systems/sensors/rotary_encoders.h:23
          const char* doc =
R"""(Simple model to capture the quantization and calibration offset
effects of a rotary encoder. Consider combining this with a
ZeroOrderHold system to capture the sampled-data effects.

The inputs to this system are assumed to be in radians, and the
outputs of the system are also in radians.)""";
          // Symbol: drake::systems::sensors::RotaryEncoders::RotaryEncoders<T>
          struct /* ctor */ {
            // Source: drake/systems/sensors/rotary_encoders.h:29
            const char* doc_1args =
R"""(Quantization-only constructor. Specifies one ticks_per_revolution
count for every element of the input port.)""";
            // Source: drake/systems/sensors/rotary_encoders.h:36
            const char* doc_2args =
R"""(Selector-only constructor. Provides arguments to select particular
indices from the input signal to use in the output. Since
ticks_per_revolution is not being set, the outputs will NOT be
quantized.

Parameter ``input_port_size``:
    Dimension of the expected input signal

Parameter ``input_vector_indices``:
    List of indices)""";
            // Source: drake/systems/sensors/rotary_encoders.h:40
            const char* doc_3args = R"""(Quantization and Selector constructor.)""";
            // Source: drake/systems/sensors/rotary_encoders.h:46
            const char* doc_copyconvert =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";
          } ctor;
          // Symbol: drake::systems::sensors::RotaryEncoders::get_calibration_offsets
          struct /* get_calibration_offsets */ {
            // Source: drake/systems/sensors/rotary_encoders.h:54
            const char* doc =
R"""(Retrieve the calibration offset parameters.)""";
          } get_calibration_offsets;
          // Symbol: drake::systems::sensors::RotaryEncoders::set_calibration_offsets
          struct /* set_calibration_offsets */ {
            // Source: drake/systems/sensors/rotary_encoders.h:49
            const char* doc = R"""(Set the calibration offset parameters.)""";
          } set_calibration_offsets;
        } RotaryEncoders;
        // Symbol: drake::systems::sensors::SaveToPng
        struct /* SaveToPng */ {
          // Source: drake/systems/sensors/image_writer.h:37
          const char* doc_was_unable_to_choose_unambiguous_names =
R"""(Writes the color (8-bit, RGBA) image data to disk.)""";
        } SaveToPng;
        // Symbol: drake::systems::sensors::SaveToTiff
        struct /* SaveToTiff */ {
          // Source: drake/systems/sensors/image_writer.h:42
          const char* doc =
R"""(Writes the depth (32-bit) image data to disk. Png files do not support
channels larger than 16-bits and its support for floating point values
is also limited at best. So, depth images can only be written as
tiffs.)""";
        } SaveToTiff;
      } sensors;
      // Symbol: drake::systems::system_scalar_converter_internal
      struct /* system_scalar_converter_internal */ {
        // Symbol: drake::systems::system_scalar_converter_internal::Make
        struct /* Make */ {
          // Source: drake/systems/framework/system_scalar_converter.h:224
          const char* doc = R"""()""";
        } Make;
      } system_scalar_converter_internal;
      // Symbol: drake::systems::trajectory_optimization
      struct /* trajectory_optimization */ {
        // Symbol: drake::systems::trajectory_optimization::AddDirectCollocationConstraint
        struct /* AddDirectCollocationConstraint */ {
          // Source: drake/systems/trajectory_optimization/direct_collocation.h:149
          const char* doc =
R"""(Helper method to add a DirectCollocationConstraint to the ``prog``,
ensuring that the order of variables in the binding matches the order
expected by the constraint.)""";
        } AddDirectCollocationConstraint;
        // Symbol: drake::systems::trajectory_optimization::DirectCollocation
        struct /* DirectCollocation */ {
          // Source: drake/systems/trajectory_optimization/direct_collocation.h:27
          const char* doc =
R"""(DirectCollocation implements the approach to trajectory optimization
as described in C. R. Hargraves and S. W. Paris. Direct trajectory
optimization using nonlinear programming and collocation. J Guidance,
10(4):338-342, July-August 1987. It assumes a first-order hold on the
input trajectory and a cubic spline representation of the state
trajectory, and adds dynamic constraints (and running costs) to the
midpoints as well as the breakpoints in order to achieve a 3rd order
integration accuracy.

Note: This algorithm only works with the continuous states of a
system.)""";
          // Symbol: drake::systems::trajectory_optimization::DirectCollocation::DirectCollocation
          struct /* ctor */ {
            // Source: drake/systems/trajectory_optimization/direct_collocation.h:54
            const char* doc =
R"""(Constructs the MathematicalProgram% and adds the collocation
constraints.

Parameter ``system``:
    A dynamical system to be used in the dynamic constraints. This
    system must support System::ToAutoDiffXd. Note that this is
    aliased for the lifetime of this object.

Parameter ``context``:
    Required to describe any parameters of the system. The values of
    the state in this context do not have any effect. This context
    will also be "cloned" by the optimization; changes to the context
    after calling this method will NOT impact the trajectory
    optimization.

Parameter ``num_time_samples``:
    The number of breakpoints in the trajectory.

Parameter ``minimum_timestep``:
    Minimum spacing between sample times.

Parameter ``maximum_timestep``:
    Maximum spacing between sample times.

Parameter ``input_port_index``:
    A valid input port index for ``system`` or InputPortSelection. All
    other inputs on the system will be left disconnected (if they are
    disconnected in ``context)`` or will be fixed to their current
    values (if they are connected/fixed in ``context)``.

*Default:* kUseFirstInputIfItExists.
    $Parameter ``assume_non_continuous_states_are_fixed``:

Boolean which, if true, allows this algorithm to optimize without
considering the dynamics of any non-continuous states. This is helpful
for optimizing systems that might have some additional book-keeping
variables in their state. Only use this if you are sure that the
dynamics of the additional state variables cannot impact the dynamics
of the continuous states. $*Default:* false.)""";
          } ctor;
          // Symbol: drake::systems::trajectory_optimization::DirectCollocation::ReconstructInputTrajectory
          struct /* ReconstructInputTrajectory */ {
            // Source: drake/systems/trajectory_optimization/direct_collocation.h:71
            const char* doc = R"""()""";
          } ReconstructInputTrajectory;
          // Symbol: drake::systems::trajectory_optimization::DirectCollocation::ReconstructStateTrajectory
          struct /* ReconstructStateTrajectory */ {
            // Source: drake/systems/trajectory_optimization/direct_collocation.h:74
            const char* doc = R"""()""";
          } ReconstructStateTrajectory;
        } DirectCollocation;
        // Symbol: drake::systems::trajectory_optimization::DirectCollocationConstraint
        struct /* DirectCollocationConstraint */ {
          // Source: drake/systems/trajectory_optimization/direct_collocation.h:96
          const char* doc =
R"""(Implements the direct collocation constraints for a first-order hold
on the input and a cubic polynomial representation of the state
trajectories.

Note that the DirectCollocation implementation allocates only ONE of
these constraints, but binds that constraint multiple times (with
different decision variables, along the trajectory).)""";
          // Symbol: drake::systems::trajectory_optimization::DirectCollocationConstraint::DirectCollocationConstraint
          struct /* ctor */ {
            // Source: drake/systems/trajectory_optimization/direct_collocation.h:102
            const char* doc =
R"""(See also:
    DirectCollocation constructor for a description of the parameters.)""";
          } ctor;
          // Symbol: drake::systems::trajectory_optimization::DirectCollocationConstraint::DoEval
          struct /* DoEval */ {
            // Source: drake/systems/trajectory_optimization/direct_collocation.h:121
            const char* doc = R"""()""";
          } DoEval;
          // Symbol: drake::systems::trajectory_optimization::DirectCollocationConstraint::num_inputs
          struct /* num_inputs */ {
            // Source: drake/systems/trajectory_optimization/direct_collocation.h:111
            const char* doc = R"""()""";
          } num_inputs;
          // Symbol: drake::systems::trajectory_optimization::DirectCollocationConstraint::num_states
          struct /* num_states */ {
            // Source: drake/systems/trajectory_optimization/direct_collocation.h:110
            const char* doc = R"""()""";
          } num_states;
        } DirectCollocationConstraint;
        // Symbol: drake::systems::trajectory_optimization::DirectTranscription
        struct /* DirectTranscription */ {
          // Source: drake/systems/trajectory_optimization/direct_transcription.h:30
          const char* doc =
R"""(DirectTranscription is perhaps the simplest implementation of a
multiple shooting method, where we have decision variables
representing the control and input at every sample time in the
trajectory, and one-step of numerical integration provides the dynamic
constraints between those decision variables.)""";
          // Symbol: drake::systems::trajectory_optimization::DirectTranscription::DirectTranscription
          struct /* ctor */ {
            // Source: drake/systems/trajectory_optimization/direct_transcription.h:54
            const char* doc_4args =
R"""(Constructs the MathematicalProgram and adds the dynamic constraints.
This version of the constructor is only for simple discrete-time
systems (with a single periodic timestep update). Continuous-time
systems must call one of the constructors that takes bounds on the
timestep as an argument.

Parameter ``system``:
    A dynamical system to be used in the dynamic constraints. This
    system must support System::ToAutoDiffXd. Note that this is
    aliased for the lifetime of this object.

Parameter ``context``:
    Required to describe any parameters of the system. The values of
    the state in this context do not have any effect. This context
    will also be "cloned" by the optimization; changes to the context
    after calling this method will NOT impact the trajectory
    optimization.

Parameter ``num_time_samples``:
    The number of breakpoints in the trajectory.

Parameter ``input_port_index``:
    A valid input port index or valid InputPortSelection for
    ``system``. All other inputs on the system will be left
    disconnected (if they are disconnected in ``context)`` or will be
    set to their current values (if they are connected/fixed in
    ``context)``.

*Default:* kUseFirstInputIfItExists.)""";
            // Source: drake/systems/trajectory_optimization/direct_transcription.h:114
            const char* doc_5args =
R"""(Constructs the MathematicalProgram and adds the dynamic constraints.
This version of the constructor is only for continuous-time systems;
the dynamics constraints use explicit forward Euler integration.

Parameter ``system``:
    A dynamical system to be used in the dynamic constraints. This
    system must support System::ToAutoDiffXd. Note that this is
    aliased for the lifetime of this object.

Parameter ``context``:
    Required to describe any parameters of the system. The values of
    the state in this context do not have any effect. This context
    will also be "cloned" by the optimization; changes to the context
    after calling this method will NOT impact the trajectory
    optimization.

Parameter ``num_time_samples``:
    The number of breakpoints in the trajectory.

Parameter ``fixed_timestep``:
    The spacing between sample times.

Parameter ``input_port_index``:
    A valid input port index or valid InputPortSelection for
    ``system``. All other inputs on the system will be left
    disconnected (if they are disconnected in ``context)`` or will be
    set to their current values (if they are connected/fixed in
    ``context)``.

*Default:* kUseFirstInputIfItExists.)""";
          } ctor;
          // Symbol: drake::systems::trajectory_optimization::DirectTranscription::ReconstructInputTrajectory
          struct /* ReconstructInputTrajectory */ {
            // Source: drake/systems/trajectory_optimization/direct_transcription.h:129
            const char* doc =
R"""(Get the input trajectory at the solution as a PiecewisePolynomial. The
order of the trajectory will be determined by the integrator used in
the dynamic constraints.)""";
          } ReconstructInputTrajectory;
          // Symbol: drake::systems::trajectory_optimization::DirectTranscription::ReconstructStateTrajectory
          struct /* ReconstructStateTrajectory */ {
            // Source: drake/systems/trajectory_optimization/direct_transcription.h:135
            const char* doc =
R"""(Get the state trajectory at the solution as a PiecewisePolynomial. The
order of the trajectory will be determined by the integrator used in
the dynamic constraints.)""";
          } ReconstructStateTrajectory;
        } DirectTranscription;
        // Symbol: drake::systems::trajectory_optimization::MidPointIntegrationConstraint
        struct /* MidPointIntegrationConstraint */ {
          // Source: drake/systems/trajectory_optimization/integration_constraint.h:14
          const char* doc =
R"""(Implements the midpoint integration

(ẋₗ + ẋᵣ)/2 * dt = xᵣ - xₗ where the bounded variables are (xᵣ, xₗ,
ẋᵣ, ẋₗ, dt))""";
          // Symbol: drake::systems::trajectory_optimization::MidPointIntegrationConstraint::ComposeX
          struct /* ComposeX */ {
            // Source: drake/systems/trajectory_optimization/integration_constraint.h:24
            const char* doc =
R"""(Compose x for the Eval input from individual variables.)""";
          } ComposeX;
          // Symbol: drake::systems::trajectory_optimization::MidPointIntegrationConstraint::MidPointIntegrationConstraint
          struct /* ctor */ {
            // Source: drake/systems/trajectory_optimization/integration_constraint.h:16
            const char* doc = R"""()""";
          } ctor;
        } MidPointIntegrationConstraint;
        // Symbol: drake::systems::trajectory_optimization::MultipleShooting
        struct /* MultipleShooting */ {
          // Source: drake/systems/trajectory_optimization/multiple_shooting.h:39
          const char* doc =
R"""(MultipleShooting is an abstract class for trajectory optimization that
creates decision variables for inputs, states, and (optionally) sample
times along the trajectory, then provides a number of methods for
working with those decision variables.

Subclasses must implement the abstract methods: DoAddRunningCost()
ReconstructInputTrajectory() ReconstructStateTrajectory() using all of
the correct interpolation schemes for the specific transcription
method, and should add the constraints to impose the System% dynamics
in their constructor.

This class assumes that there are a fixed number (N) time
steps/samples, and that the trajectory is discretized into timesteps h
(N-1 of these), state x (N of these), and control input u (N of
these).)""";
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::AddCompleteTrajectoryCallback
          struct /* AddCompleteTrajectoryCallback */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:285
            const char* doc =
R"""(Adds a callback method to visualize intermediate results of all
variables used in the trajectory optimization. The callback should be
of the form MyVisualization(sample_times, states, inputs, values),
where sample_times is an N-by-1 VectorXd of sample times, states is a
num_states-by-N MatrixXd of the current (intermediate) state
trajectory at the break points, inputs is a num_inputs-by-N MatrixXd
of the current (intermediate) input trajectory at the break points and
values is a vector of num_rows-by-N MatrixXds of the current
(intermediate) extra sequential variables specified by ``names`` at
the break points.

Note:
    Just like other costs/constraints, not all solvers support
    callbacks. Adding a callback here will force
    MathematicalProgram::Solve to select a solver that support
    callbacks. For instance, adding a visualization callback to a
    quadratic programming problem may result in using a nonlinear
    programming solver as the default solver.)""";
          } AddCompleteTrajectoryCallback;
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::AddConstraintToAllKnotPoints
          struct /* AddConstraintToAllKnotPoints */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:155
            const char* doc =
R"""(Adds a constraint to all breakpoints, where any instances of time(),
state(), and/or input() placeholder variables, as well as placeholder
variables returned by calls to NewSequentialVariable(), are
substituted with the relevant variables for each time index.

Returns:
    A vector of the constraints added to each knot point.)""";
          } AddConstraintToAllKnotPoints;
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::AddDurationBounds
          struct /* AddDurationBounds */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:197
            const char* doc =
R"""(Adds a constraint on the total duration of the trajectory.

Parameter ``lower_bound``:
    A scalar double lower bound.

Parameter ``upper_bound``:
    A scalar double upper bound.

Returns:
    The constraint enforcing the duration bounds.

Raises:
    RuntimeError if timesteps are not declared as decision variables.)""";
          } AddDurationBounds;
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::AddEqualTimeIntervalsConstraints
          struct /* AddEqualTimeIntervalsConstraints */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:189
            const char* doc =
R"""(Adds constraints to enforce that all timesteps have equal duration.

Returns:
    A vector of constraints enforcing all time intervals are equal.

Raises:
    RuntimeError if timesteps are not declared as decision variables.)""";
          } AddEqualTimeIntervalsConstraints;
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::AddFinalCost
          struct /* AddFinalCost */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:207
            const char* doc_1args_e =
R"""(Adds a cost to the final time, of the form

.. math:: cost = e(t,x,u),

where any instances of time(), state(), and/or input() placeholder
variables, as well as placeholder variables returned by calls to
NewSequentialVariable(), are substituted with the relevant variables
for the final time index.

Returns:
    The final cost added to the problem.)""";
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:217
            const char* doc_1args_matrix =
R"""(Adds support for passing in a (scalar) matrix Expression, which is a
common output of most symbolic linear algebra operations.

Returns:
    The final cost added to the problem.

Note:
    Derived classes will need to type using
    MultipleShooting::AddFinalCost; to "unhide" this method.)""";
          } AddFinalCost;
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::AddInputTrajectoryCallback
          struct /* AddInputTrajectoryCallback */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:248
            const char* doc =
R"""(Adds a callback method to visualize intermediate results of input
variables used in the trajectory optimization. The callback should be
of the form MyVisualization(sample_times, values), where breaks is a
N-by-1 VectorXd of sample times, and values is a num_inputs-by-N
MatrixXd representing the current (intermediate) value of the input
trajectory at the break points in each column.

Note:
    Just like other costs/constraints, not all solvers support
    callbacks. Adding a callback here will force
    MathematicalProgram::Solve to select a solver that support
    callbacks. For instance, adding a visualization callback to a
    quadratic programming problem may result in using a nonlinear
    programming solver as the default solver.)""";
          } AddInputTrajectoryCallback;
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::AddRunningCost
          struct /* AddRunningCost */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:139
            const char* doc_1args_g =
R"""(Adds an integrated cost to all time steps, of the form

.. math:: cost = \int_0^T g(t,x,u) dt,

where any instances of time(), state(), and/or input() placeholder
variables, as well as placeholder variables returned by calls to
NewSequentialVariable(), are substituted with the relevant variables
for each time index. The particular integration scheme is determined
by the derived class implementation.)""";
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:144
            const char* doc_1args_constEigenMatrixBase =
R"""(Adds support for passing in a (scalar) matrix Expression, which is a
common output of most symbolic linear algebra operations.)""";
          } AddRunningCost;
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::AddStateTrajectoryCallback
          struct /* AddStateTrajectoryCallback */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:265
            const char* doc =
R"""(Adds a callback method to visualize intermediate results of state
variables used in the trajectory optimization. The callback should be
of the form MyVisualization(sample_times, values), where sample_times
is a N-by-1 VectorXd of sample times, and values is a num_states-by-N
MatrixXd representing the current (intermediate) value of the state
trajectory at the break points in each column.

Note:
    Just like other costs/constraints, not all solvers support
    callbacks. Adding a callback here will force
    MathematicalProgram::Solve to select a solver that support
    callbacks. For instance, adding a visualization callback to a
    quadratic programming problem may result in using a nonlinear
    programming solver as the default solver.)""";
          } AddStateTrajectoryCallback;
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::AddTimeIntervalBounds
          struct /* AddTimeIntervalBounds */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:181
            const char* doc =
R"""(Adds bounds on all time intervals.

Parameter ``lower_bound``:
    A scalar double lower bound.

Parameter ``upper_bound``:
    A scalar double upper bound.

Returns:
    The bounding box constraint enforcing time interval bounds.

Raises:
    RuntimeError if timesteps are not declared as decision variables.)""";
          } AddTimeIntervalBounds;
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::CompleteTrajectoryCallback
          struct /* CompleteTrajectoryCallback */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:231
            const char* doc = R"""()""";
          } CompleteTrajectoryCallback;
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::GetInputSamples
          struct /* GetInputSamples */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:325
            const char* doc =
R"""(Returns a matrix containing the input values (arranged in columns) at
each breakpoint at the solution.)""";
          } GetInputSamples;
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::GetSampleTimes
          struct /* GetSampleTimes */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:313
            const char* doc_1args_h_var_values =
R"""(Returns a vector containing the elapsed time at each breakpoint.)""";
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:318
            const char* doc_1args_result =
R"""(Returns a vector containing the elapsed time at each breakpoint at the
solution.)""";
          } GetSampleTimes;
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::GetSequentialVariable
          struct /* GetSequentialVariable */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:438
            const char* doc =
R"""(Returns the decision variables associated with the sequential variable
``name``.)""";
          } GetSequentialVariable;
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::GetSequentialVariableAtIndex
          struct /* GetSequentialVariableAtIndex */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:129
            const char* doc =
R"""(Returns the decision variables associated with the sequential variable
``name`` at time index ``index``.

See also:
    NewSequentialVariable().)""";
          } GetSequentialVariableAtIndex;
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::GetSequentialVariableSamples
          struct /* GetSequentialVariableSamples */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:338
            const char* doc =
R"""(Returns a matrix containing the sequential variable values (arranged
in columns) at each breakpoint at the solution.

Parameter ``name``:
    The name of sequential variable to get the results for. Must
    correspond to an already added sequential variable.)""";
          } GetSequentialVariableSamples;
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::GetStateSamples
          struct /* GetStateSamples */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:330
            const char* doc =
R"""(Returns a matrix containing the state values (arranged in columns) at
each breakpoint at the solution.)""";
          } GetStateSamples;
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::MultipleShooting
          struct /* ctor */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:368
            const char* doc_4args_num_inputs_num_states_num_time_samples_fixed_timestep =
R"""(Constructs a MultipleShooting instance with fixed sample times. It
creates new placeholder variables for input and state.

Parameter ``num_inputs``:
    Number of inputs at each sample point.

Parameter ``num_states``:
    Number of states at each sample point.

Parameter ``num_time_samples``:
    Number of time samples.

Parameter ``fixed_timestep``:
    The spacing between sample times.)""";
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:379
            const char* doc_4args_input_state_num_time_samples_fixed_timestep =
R"""(Constructs a MultipleShooting instance with fixed sample times. It
uses the provided ``input`` and ``state`` as placeholders instead of
creating new placeholder variables for them.

Parameter ``input``:
    Placeholder variables for input.

Parameter ``state``:
    Placeholder variables for state.

Parameter ``num_time_samples``:
    Number of time samples.

Parameter ``fixed_timestep``:
    The spacing between sample times.)""";
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:392
            const char* doc_5args_num_inputs_num_states_num_time_samples_minimum_timestep_maximum_timestep =
R"""(Constructs a MultipleShooting instance with sample times as decision
variables. It creates new placeholder variables for input, state, and
time.

Parameter ``num_inputs``:
    Number of inputs at each sample point.

Parameter ``num_states``:
    Number of states at each sample point.

Parameter ``num_time_samples``:
    Number of time samples.

Parameter ``minimum_timestep``:
    Minimum spacing between sample times.

Parameter ``maximum_timestep``:
    Maximum spacing between sample times.)""";
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:405
            const char* doc_6args_input_state_time_num_time_samples_minimum_timestep_maximum_timestep =
R"""(Constructs a MultipleShooting instance with sample times as decision
variables. It uses the provided ``input``, `state`, and ``time`` as
placeholders instead of creating new placeholder variables for them.

Parameter ``input``:
    Placeholder variables for input.

Parameter ``state``:
    Placeholder variables for state.

Parameter ``time``:
    Placeholder variable for time.

Parameter ``num_time_samples``:
    Number of time samples.

Parameter ``minimum_timestep``:
    Minimum spacing between sample times.

Parameter ``maximum_timestep``:
    Maximum spacing between sample times.)""";
          } ctor;
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::N
          struct /* N */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:424
            const char* doc = R"""()""";
          } N;
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::NewSequentialVariable
          struct /* NewSequentialVariable */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:123
            const char* doc =
R"""(Adds a sequential variable (a variable that has associated decision
variables for each time index) to the optimization problem and returns
a placeholder variable (not actually declared as a decision variable
in the MathematicalProgram). This variable will be substituted for
real decision variables at particular times in methods like
AddRunningCost(). Passing this variable directly into
objectives/constraints for the parent classes will result in an error.)""";
          } NewSequentialVariable;
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::ReconstructInputTrajectory
          struct /* ReconstructInputTrajectory */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:346
            const char* doc =
R"""(Get the input trajectory at the solution as a PiecewisePolynomial. The
order of the trajectory will be determined by the integrator used in
the dynamic constraints. Requires that the system has at least one
input port.)""";
          } ReconstructInputTrajectory;
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::ReconstructStateTrajectory
          struct /* ReconstructStateTrajectory */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:352
            const char* doc =
R"""(Get the state trajectory at the solution as a PiecewisePolynomial. The
order of the trajectory will be determined by the integrator used in
the dynamic constraints.)""";
          } ReconstructStateTrajectory;
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::SetInitialTrajectory
          struct /* SetInitialTrajectory */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:308
            const char* doc = R"""()""";
          } SetInitialTrajectory;
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::SubstitutePlaceholderVariables
          struct /* SubstitutePlaceholderVariables */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:412
            const char* doc =
R"""(Replaces e.g. placeholder_x_var_ with x_vars_ at time interval
``interval_index``, for all placeholder variables.)""";
          } SubstitutePlaceholderVariables;
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::TrajectoryCallback
          struct /* TrajectoryCallback */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:225
            const char* doc = R"""()""";
          } TrajectoryCallback;
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::final_state
          struct /* final_state */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:102
            const char* doc =
R"""(Returns the decision variables associated with the state, x, at the
final time index.)""";
          } final_state;
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::fixed_timestep
          struct /* fixed_timestep */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:355
            const char* doc = R"""()""";
          } fixed_timestep;
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::h_vars
          struct /* h_vars */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:430
            const char* doc = R"""()""";
          } h_vars;
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::initial_state
          struct /* initial_state */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:95
            const char* doc =
R"""(Returns the decision variables associated with the state, x, at the
initial time index.)""";
          } initial_state;
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::input
          struct /* input */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:81
            const char* doc_0args =
R"""(Returns placeholder decision variables (not actually declared as
decision variables in the MathematicalProgram) associated with the
input, u, but with the time-index undetermined. These variables will
be substituted for real decision variables at particular times in
methods like AddRunningCost. Passing these variables directly into
objectives/constraints for the parent classes will result in an error.)""";
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:109
            const char* doc_1args =
R"""(Returns the decision variables associated with the input, u, at time
index ``index``.)""";
          } input;
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::num_inputs
          struct /* num_inputs */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:420
            const char* doc = R"""()""";
          } num_inputs;
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::num_states
          struct /* num_states */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:422
            const char* doc = R"""()""";
          } num_states;
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::state
          struct /* state */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:71
            const char* doc_0args =
R"""(Returns placeholder decision variables (not actually declared as
decision variables in the MathematicalProgram) associated with the
state, x, but with the time-index undetermined. These variables will
be substituted for real decision variables at particular times in
methods like AddRunningCost. Passing these variables directly into
objectives/constraints for the parent classes will result in an error.)""";
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:87
            const char* doc_1args =
R"""(Returns the decision variables associated with the state, x, at time
index ``index``.)""";
          } state;
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::time
          struct /* time */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:61
            const char* doc =
R"""(Returns a placeholder decision variable (not actually declared as a
decision variable in the MathematicalProgram) associated with the
time, t. This variable will be substituted for real decision variables
at particular times in methods like AddRunningCost. Passing this
variable directly into objectives/constraints for the parent classes
will result in an error.)""";
          } time;
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::timestep
          struct /* timestep */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:49
            const char* doc =
R"""(Returns the decision variable associated with the timestep, h, at time
index ``index``.

Raises:
    RuntimeError if timesteps are not declared as decision variables.)""";
          } timestep;
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::timesteps_are_decision_variables
          struct /* timesteps_are_decision_variables */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:426
            const char* doc = R"""()""";
          } timesteps_are_decision_variables;
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::u_vars
          struct /* u_vars */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:432
            const char* doc = R"""()""";
          } u_vars;
          // Symbol: drake::systems::trajectory_optimization::MultipleShooting::x_vars
          struct /* x_vars */ {
            // Source: drake/systems/trajectory_optimization/multiple_shooting.h:434
            const char* doc = R"""()""";
          } x_vars;
        } MultipleShooting;
        // Symbol: drake::systems::trajectory_optimization::TimeStep
        struct /* TimeStep */ {
          // Source: drake/systems/trajectory_optimization/direct_transcription.h:20
          const char* doc = R"""()""";
          // Symbol: drake::systems::trajectory_optimization::TimeStep::TimeStep
          struct /* ctor */ {
            // Source: drake/systems/trajectory_optimization/direct_transcription.h:22
            const char* doc = R"""()""";
          } ctor;
          // Symbol: drake::systems::trajectory_optimization::TimeStep::value
          struct /* value */ {
            // Source: drake/systems/trajectory_optimization/direct_transcription.h:21
            const char* doc = R"""()""";
          } value;
        } TimeStep;
      } trajectory_optimization;
    } systems;
    // Symbol: drake::temp_directory
    struct /* temp_directory */ {
      // Source: drake/common/temp_directory.h:15
      const char* doc =
R"""(Returns a directory location suitable for temporary files.

Returns:
    The value of the environment variable TEST_TMPDIR if defined or
    otherwise ${TMPDIR:-/tmp}/robotlocomotion_drake_XXXXXX where each
    X is replaced by a character from the portable filename character
    set. Any trailing / will be stripped from the output.

Raises:
    RuntimeError If the path referred to by TEST_TMPDIR or
    ${TMPDIR:-/tmp}/robotlocomotion_drake_XXXXXX cannot be created,
    does not exist, or is not a directory.)""";
    } temp_directory;
    // Symbol: drake::to_string
    struct /* to_string */ {
      // Source: drake/common/identifier.h:226
      const char* doc =
R"""(Enables use of identifiers with to_string. It requires ADL to work.
So, it should be invoked as: ``to_string(id);`` and should be preceded
by ``using std::to_string``.)""";
    } to_string;
    // Symbol: drake::trajectories
    struct /* trajectories */ {
      // Symbol: drake::trajectories::BsplineTrajectory
      struct /* BsplineTrajectory */ {
        // Source: drake/common/trajectories/bspline_trajectory.h:20
        const char* doc =
R"""(Represents a B-spline curve using a given ``basis`` with ordered
``control_points`` such that each control point is a matrix in ℝʳᵒʷˢ ˣ
ᶜᵒˡˢ.

See also:
    math::BsplineBasis)""";
        // Symbol: drake::trajectories::BsplineTrajectory::BsplineTrajectory<T>
        struct /* ctor */ {
          // Source: drake/common/trajectories/bspline_trajectory.h:29
          const char* doc =
R"""(Constructs a B-spline trajectory with the given ``basis`` and
``control_points``.

Precondition:
    control_points.size() == basis.num_basis_functions())""";
        } ctor;
        // Symbol: drake::trajectories::BsplineTrajectory::Clone
        struct /* Clone */ {
          // Source: drake/common/trajectories/bspline_trajectory.h:49
          const char* doc = R"""()""";
        } Clone;
        // Symbol: drake::trajectories::BsplineTrajectory::CopyBlock
        struct /* CopyBlock */ {
          // Source: drake/common/trajectories/bspline_trajectory.h:106
          const char* doc =
R"""(Returns a new BsplineTrajectory that uses the same basis as ``this``,
and whose control points are the result of calling
``point.block(start_row, start_col, block_rows, block_cols)`` on each
``point`` in ``this->control_points()``.)""";
        } CopyBlock;
        // Symbol: drake::trajectories::BsplineTrajectory::CopyHead
        struct /* CopyHead */ {
          // Source: drake/common/trajectories/bspline_trajectory.h:114
          const char* doc =
R"""(Returns a new BsplineTrajectory that uses the same basis as ``this``,
and whose control points are the result of calling ``point.head(n)``
on each ``point`` in ``this->control_points()``.

Precondition:
    this->cols() == 1

Precondition:
    control_points()[0].head(n) must be a valid operation.)""";
        } CopyHead;
        // Symbol: drake::trajectories::BsplineTrajectory::CopyWithSelector
        struct /* CopyWithSelector */ {
          // Source: drake/common/trajectories/bspline_trajectory.h:99
          const char* doc =
R"""(Returns a new BsplineTrajectory that uses the same basis as ``this``,
and whose control points are the result of calling ``select(point)``
on each ``point`` in ``this->control_points()``.)""";
        } CopyWithSelector;
        // Symbol: drake::trajectories::BsplineTrajectory::FinalValue
        struct /* FinalValue */ {
          // Source: drake/common/trajectories/bspline_trajectory.h:82
          const char* doc = R"""(Returns this->value(this->end_time()))""";
        } FinalValue;
        // Symbol: drake::trajectories::BsplineTrajectory::InitialValue
        struct /* InitialValue */ {
          // Source: drake/common/trajectories/bspline_trajectory.h:79
          const char* doc = R"""(Returns this->value(this->start_time()))""";
        } InitialValue;
        // Symbol: drake::trajectories::BsplineTrajectory::InsertKnots
        struct /* InsertKnots */ {
          // Source: drake/common/trajectories/bspline_trajectory.h:94
          const char* doc =
R"""(Adds new knots at the specified ``additional_knots`` without changing
the behavior of the trajectory. The basis and control points of the
trajectory are adjusted such that it produces the same value for any
valid time before and after this method is called. The resulting
trajectory is guaranteed to have the same level of continuity as the
original, even if knot values are duplicated. Note that
``additional_knots`` need not be sorted.

Precondition:
    start_time() <= t <= end_time() for all t in ``additional_knots``)""";
        } InsertKnots;
        // Symbol: drake::trajectories::BsplineTrajectory::Serialize
        struct /* Serialize */ {
          // Source: drake/common/trajectories/bspline_trajectory.h:128
          const char* doc =
R"""(Passes this object to an Archive; see serialize_tips for background.
This method is only available when T = double.)""";
        } Serialize;
        // Symbol: drake::trajectories::BsplineTrajectory::basis
        struct /* basis */ {
          // Source: drake/common/trajectories/bspline_trajectory.h:85
          const char* doc = R"""(Returns the basis of this curve.)""";
        } basis;
        // Symbol: drake::trajectories::BsplineTrajectory::cols
        struct /* cols */ {
          // Source: drake/common/trajectories/bspline_trajectory.h:63
          const char* doc = R"""()""";
        } cols;
        // Symbol: drake::trajectories::BsplineTrajectory::control_points
        struct /* control_points */ {
          // Source: drake/common/trajectories/bspline_trajectory.h:74
          const char* doc =
R"""(Returns the control points of this curve.)""";
        } control_points;
        // Symbol: drake::trajectories::BsplineTrajectory::end_time
        struct /* end_time */ {
          // Source: drake/common/trajectories/bspline_trajectory.h:67
          const char* doc = R"""()""";
        } end_time;
        // Symbol: drake::trajectories::BsplineTrajectory::num_control_points
        struct /* num_control_points */ {
          // Source: drake/common/trajectories/bspline_trajectory.h:71
          const char* doc =
R"""(Returns the number of control points in this curve.)""";
        } num_control_points;
        // Symbol: drake::trajectories::BsplineTrajectory::rows
        struct /* rows */ {
          // Source: drake/common/trajectories/bspline_trajectory.h:61
          const char* doc = R"""()""";
        } rows;
        // Symbol: drake::trajectories::BsplineTrajectory::start_time
        struct /* start_time */ {
          // Source: drake/common/trajectories/bspline_trajectory.h:65
          const char* doc = R"""()""";
        } start_time;
        // Symbol: drake::trajectories::BsplineTrajectory::value
        struct /* value */ {
          // Source: drake/common/trajectories/bspline_trajectory.h:59
          const char* doc =
R"""(Evaluates the BsplineTrajectory at the given time t.

Parameter ``t``:
    The time at which to evaluate the BsplineTrajectory.

Returns:
    The matrix of evaluated values.

Precondition:
    If T == symbolic::Expression, ``t.is_constant()`` must be true.

Warning:
    If t does not lie in the range [start_time(), end_time()], the
    trajectory will silently be evaluated at the closest valid value
    of time to t. For example, ``value(-1)`` will return ``value(0)``
    for a trajectory defined over [0, 1].)""";
        } value;
      } BsplineTrajectory;
      // Symbol: drake::trajectories::DiscreteTimeTrajectory
      struct /* DiscreteTimeTrajectory */ {
        // Source: drake/common/trajectories/discrete_time_trajectory.h:58
        const char* doc =
R"""(A DiscreteTimeTrajectory is a Trajectory whose value is only defined
at discrete time points. Calling ``value()`` at a time that is not
equal to one of those times (up to a tolerance) will throw. This
trajectory does *not* have well-defined time-derivatives.

In some applications, it may be preferable to use
PiecewisePolynomial<T>::ZeroOrderHold instead of a
DiscreteTimeTrajectory (and we offer a method here to easily convert).
Note if the breaks are periodic, then one can also achieve a similar
result in a Diagram by using the DiscreteTimeTrajectory in a
TrajectorySource and connecting a ZeroOrderHold system to the output
port, but remember that this will add discrete state to your diagram.

So why not always use the zero-order hold (ZOH) trajectory? This class
forces us to be more precise in our implementations. For instance,
consider the case of a solution to a discrete-time finite-horizon
linear quadratic regulator (LQR) problem. In this case, the solution
to the Riccati equation is a DiscreteTimeTrajectory, K(t).
Implementing @verbatim x(t) -> MatrixGain(-K(t)) -> u(t) @verbatim in
a block diagram is perfectly correct, and if the u(t) is only
connected to the original system that it was designed for, then K(t)
will only get evaluated at the defined sample times, and all is well.
But if you wire it up to a continuous-time system, then K(t) may be
evaluated at arbitrary times, and may throw. If one wishes to use the
K(t) solution on a continuous-time system, then we can use @verbatim
x(t) -> MatrixGain(-K(t)) -> ZOH -> u(t). @verbatim This is different,
and *more correct* than implementing K(t) as a zero-order hold
trajectory, because in this version, both K(t) and the inputs x(t)
will only be evaluated at the discrete-time input. If ``t_s`` was the
most recent discrete sample time, then this means u(t) =
-K(t_s)*x(t_s) instead of u(t) = -K(t_s)*x(t). Using x(t_s) and having
a true zero-order hold on u(t) is the correct model for the
discrete-time LQR result.

@tparam_default_scalars)""";
        // Symbol: drake::trajectories::DiscreteTimeTrajectory::Clone
        struct /* Clone */ {
          // Source: drake/common/trajectories/discrete_time_trajectory.h:106
          const char* doc = R"""(Returns a deep copy of the trajectory.)""";
        } Clone;
        // Symbol: drake::trajectories::DiscreteTimeTrajectory::DiscreteTimeTrajectory<T>
        struct /* ctor */ {
          // Source: drake/common/trajectories/discrete_time_trajectory.h:61
          const char* doc_was_unable_to_choose_unambiguous_names = R"""()""";
        } ctor;
        // Symbol: drake::trajectories::DiscreteTimeTrajectory::ToZeroOrderHold
        struct /* ToZeroOrderHold */ {
          // Source: drake/common/trajectories/discrete_time_trajectory.h:91
          const char* doc =
R"""(Converts the discrete-time trajectory using
PiecewisePolynomial<T>::ZeroOrderHold().)""";
        } ToZeroOrderHold;
        // Symbol: drake::trajectories::DiscreteTimeTrajectory::cols
        struct /* cols */ {
          // Source: drake/common/trajectories/discrete_time_trajectory.h:119
          const char* doc =
R"""(Returns the number of cols in the MatrixX<T> returned by value().

Precondition:
    num_times() > 0.)""";
        } cols;
        // Symbol: drake::trajectories::DiscreteTimeTrajectory::end_time
        struct /* end_time */ {
          // Source: drake/common/trajectories/discrete_time_trajectory.h:127
          const char* doc =
R"""(Returns the maximum value of get_times().

Precondition:
    num_times() > 0.)""";
        } end_time;
        // Symbol: drake::trajectories::DiscreteTimeTrajectory::get_times
        struct /* get_times */ {
          // Source: drake/common/trajectories/discrete_time_trajectory.h:103
          const char* doc =
R"""(Returns the times where the trajectory value is defined.)""";
        } get_times;
        // Symbol: drake::trajectories::DiscreteTimeTrajectory::num_times
        struct /* num_times */ {
          // Source: drake/common/trajectories/discrete_time_trajectory.h:100
          const char* doc =
R"""(Returns the number of discrete times where the trajectory value is
defined.)""";
        } num_times;
        // Symbol: drake::trajectories::DiscreteTimeTrajectory::rows
        struct /* rows */ {
          // Source: drake/common/trajectories/discrete_time_trajectory.h:115
          const char* doc =
R"""(Returns the number of rows in the MatrixX<T> returned by value().

Precondition:
    num_times() > 0.)""";
        } rows;
        // Symbol: drake::trajectories::DiscreteTimeTrajectory::start_time
        struct /* start_time */ {
          // Source: drake/common/trajectories/discrete_time_trajectory.h:123
          const char* doc =
R"""(Returns the minimum value of get_times().

Precondition:
    num_times() > 0.)""";
        } start_time;
        // Symbol: drake::trajectories::DiscreteTimeTrajectory::time_comparison_tolerance
        struct /* time_comparison_tolerance */ {
          // Source: drake/common/trajectories/discrete_time_trajectory.h:96
          const char* doc =
R"""(The trajectory is only defined at finite sample times. This method
returns the tolerance used determine which time sample (if any)
matches a query time on calls to value(t).)""";
        } time_comparison_tolerance;
        // Symbol: drake::trajectories::DiscreteTimeTrajectory::value
        struct /* value */ {
          // Source: drake/common/trajectories/discrete_time_trajectory.h:111
          const char* doc =
R"""(Returns the value of the trajectory at ``t``.

Raises:
    runtime_error if t is not within tolerance of one of the sample
    times.)""";
        } value;
      } DiscreteTimeTrajectory;
      // Symbol: drake::trajectories::ExponentialPlusPiecewisePolynomial
      struct /* ExponentialPlusPiecewisePolynomial */ {
        // Source: drake/common/trajectories/exponential_plus_piecewise_polynomial.h:22
        const char* doc =
R"""(y(t) = K * exp(A * (t - t_j)) * alpha.col(j) +
piecewise_polynomial_part(t))""";
        // Symbol: drake::trajectories::ExponentialPlusPiecewisePolynomial::Clone
        struct /* Clone */ {
          // Source: drake/common/trajectories/exponential_plus_piecewise_polynomial.h:57
          const char* doc = R"""()""";
        } Clone;
        // Symbol: drake::trajectories::ExponentialPlusPiecewisePolynomial::ExponentialPlusPiecewisePolynomial<T>
        struct /* ctor */ {
          // Source: drake/common/trajectories/exponential_plus_piecewise_polynomial.h:26
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::trajectories::ExponentialPlusPiecewisePolynomial::cols
        struct /* cols */ {
          // Source: drake/common/trajectories/exponential_plus_piecewise_polynomial.h:65
          const char* doc = R"""()""";
        } cols;
        // Symbol: drake::trajectories::ExponentialPlusPiecewisePolynomial::derivative
        struct /* derivative */ {
          // Source: drake/common/trajectories/exponential_plus_piecewise_polynomial.h:61
          const char* doc = R"""()""";
        } derivative;
        // Symbol: drake::trajectories::ExponentialPlusPiecewisePolynomial::rows
        struct /* rows */ {
          // Source: drake/common/trajectories/exponential_plus_piecewise_polynomial.h:63
          const char* doc = R"""()""";
        } rows;
        // Symbol: drake::trajectories::ExponentialPlusPiecewisePolynomial::shiftRight
        struct /* shiftRight */ {
          // Source: drake/common/trajectories/exponential_plus_piecewise_polynomial.h:67
          const char* doc = R"""()""";
        } shiftRight;
        // Symbol: drake::trajectories::ExponentialPlusPiecewisePolynomial::value
        struct /* value */ {
          // Source: drake/common/trajectories/exponential_plus_piecewise_polynomial.h:59
          const char* doc = R"""()""";
        } value;
      } ExponentialPlusPiecewisePolynomial;
      // Symbol: drake::trajectories::PiecewisePolynomial
      struct /* PiecewisePolynomial */ {
        // Source: drake/common/trajectories/piecewise_polynomial.h:74
        const char* doc =
R"""(A scalar multi-variate piecewise polynomial.

PiecewisePolynomial represents a list of contiguous segments in a
scalar independent variable (typically corresponding to time) with
Polynomials defined at each segment. We call the output from
evaluating the PiecewisePolynomial at the scalar independent variable
"the output", and that output can be either a Eigen MatrixX<T> (if
evaluated using value()) or a scalar (if evaluated using
scalar_value()).

An example of a piecewise polynomial is a function of m segments in
time, where a different polynomial is defined for each segment. For a
specific example, consider the absolute value function over the
interval [-1, 1]. We can define a PiecewisePolynomial over this
interval using breaks at t = { -1.0, 0.0, 1.0 }, and "samples" of
abs(t).


::

    // Construct the PiecewisePolynomial.
    const std::vector<double> breaks = { -1.0, 0.0, 1.0 };
    std::vector<Eigen::MatrixXd> samples(3);
    for (int i = 0; i < static_cast<int>(breaks.size()); ++i) {
      samples[i].resize(1, 1);
      samples[i](0, 0) = std::abs(breaks[i]);
    }
    const auto pp =
         PiecewisePolynomial<double>::FirstOrderHold(breaks, samples);
    const int row = 0, col = 0;
    
    // Evaluate the PiecewisePolynomial at some values.
    std::cout << pp.value(-.5)(row, col) << std::endl;    // Outputs 0.5.
    std::cout << pp.value(0.0)(row, col) << std::endl;    // Outputs 0.0;
    
    // Show how we can evaluate the first derivative (outputs -1.0).
    std::cout << pp.derivative(1).value(-.5)(row, col) << std::endl;

A note on terminology. For piecewise-polynomial interpolation, we use
``breaks`` to indicate the scalar (e.g. times) which form the boundary
of each segment. We use ``samples`` to indicate the function value at
the ``breaks``, e.g. ``p(breaks[i]) = samples[i]``. The term ``knot``
should be reserved for the "(x,y)" coordinate, here ``knot[i] =
(breaks[i], samples[i])``, though it is used inconsistently in the
interpolation literature (sometimes for ``breaks``, sometimes for
``samples``), so we try to mostly avoid it here.

PiecewisePolynomial objects can be added, subtracted, and multiplied.
They cannot be divided because Polynomials are not closed under
division.

Warning:
    PiecewisePolynomial silently clips input evaluations outside of
    the range defined by the breaks. So ``pp.value(-2.0, row, col)``
    in the example above would evaluate to -1.0. See value().

@tparam_default_scalars)""";
        // Symbol: drake::trajectories::PiecewisePolynomial::AppendCubicHermiteSegment
        struct /* AppendCubicHermiteSegment */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:701
          const char* doc =
R"""(The CubicHermite spline construction has a nice property of being
incremental (each segment can be solved independently). Given a new
sample and it's derivative, this method adds one segment to the end of
``this`` where the start sample and derivative are taken as the value
and derivative at the final break of ``this``.

Precondition:
    ``this`` is not empty()

Precondition:
    ``time`` > end_time()

Precondition:
    ``sample`` and ``sample_dot`` must have size rows() x cols().)""";
        } AppendCubicHermiteSegment;
        // Symbol: drake::trajectories::PiecewisePolynomial::AppendFirstOrderSegment
        struct /* AppendFirstOrderSegment */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:709
          const char* doc =
R"""(Given a new sample, this method adds one segment to the end of
``this`` using a first-order hold, where the start sample is taken as
the value at the final break of ``this``.)""";
        } AppendFirstOrderSegment;
        // Symbol: drake::trajectories::PiecewisePolynomial::Block
        struct /* Block */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:575
          const char* doc =
R"""(Extracts a trajectory representing a block of size (block_rows,
block_cols) starting at (start_row, start_col) from the
PiecewisePolynomial.

Returns:
    a PiecewisePolynomial such that ret.value(t) =
    this.value(t).block(i,j,p,q);)""";
        } Block;
        // Symbol: drake::trajectories::PiecewisePolynomial::Clone
        struct /* Clone */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:184
          const char* doc = R"""()""";
        } Clone;
        // Symbol: drake::trajectories::PiecewisePolynomial::ConcatenateInTime
        struct /* ConcatenateInTime */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:688
          const char* doc =
R"""(Concatenates ``other`` to the end of ``this``.

Warning:
    The resulting PiecewisePolynomial will only be continuous to the
    degree that the first Polynomial of ``other`` is continuous with
    the last Polynomial of ``this``. See warning about evaluating
    discontinuous derivatives at breaks in derivative().

Parameter ``other``:
    PiecewisePolynomial instance to concatenate.

Raises:
    RuntimeError if trajectories' dimensions do not match each other
    (either rows() or cols() does not match between this and
    ``other``).

Raises:
    RuntimeError if ``this->end_time()`` and ``other->start_time()``
    are not within PiecewiseTrajectory<T>::kEpsilonTime from each
    other.)""";
        } ConcatenateInTime;
        // Symbol: drake::trajectories::PiecewisePolynomial::Cubic
        struct /* Cubic */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:422
          const char* doc = R"""()""";
        } Cubic;
        // Symbol: drake::trajectories::PiecewisePolynomial::CubicHermite
        struct /* CubicHermite */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:375
          const char* doc =
R"""(Version of CubicHermite(breaks, samples, samples_dot) that uses vector
samples and Eigen VectorXd / MatrixX<T> arguments. Corresponding
columns of ``samples`` and ``samples_dot`` are used as the sample
point and independent variable derivative, respectively.

Precondition:
    ``samples.cols() == samples_dot.cols() == breaks.size()``.)""";
        } CubicHermite;
        // Symbol: drake::trajectories::PiecewisePolynomial::CubicShapePreserving
        struct /* CubicShapePreserving */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:313
          const char* doc =
R"""(Version of CubicShapePreserving(breaks, samples,
zero_end_point_derivatives) that uses vector samples and Eigen
VectorXd and MatrixX<T> arguments. Each column of ``samples``
represents a sample point.

Precondition:
    ``samples.cols() == breaks.size()``.

Raises:
    RuntimeError under the conditions specified under
    coefficient_construction_methods.)""";
        } CubicShapePreserving;
        // Symbol: drake::trajectories::PiecewisePolynomial::CubicWithContinuousSecondDerivatives
        struct /* CubicWithContinuousSecondDerivatives */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:346
          const char* doc_4args =
R"""(Version of CubicWithContinuousSecondDerivatives() that uses vector
samples and Eigen VectorXd / MatrixX<T> arguments. Each column of
``samples`` represents a sample point.

Precondition:
    ``samples.cols() == breaks.size()``.

Raises:
    RuntimeError under the conditions specified under
    coefficient_construction_methods.)""";
          // Source: drake/common/trajectories/piecewise_polynomial.h:417
          const char* doc_3args =
R"""(Version of CubicWithContinuousSecondDerivatives(breaks, samples) that
uses vector samples and Eigen VectorXd / MatrixX<T> arguments. Each
column of ``samples`` represents a sample point.

Precondition:
    ``samples.cols() == breaks.size()``.)""";
        } CubicWithContinuousSecondDerivatives;
        // Symbol: drake::trajectories::PiecewisePolynomial::FirstOrderHold
        struct /* FirstOrderHold */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:253
          const char* doc =
R"""(Version of FirstOrderHold(breaks, samples) that uses vector samples
and Eigen VectorXd / MatrixX<T> arguments. Each column of ``samples``
represents a sample point.

Precondition:
    ``samples.cols() == breaks.size()``

Raises:
    RuntimeError under the conditions specified under
    coefficient_construction_methods.)""";
        } FirstOrderHold;
        // Symbol: drake::trajectories::PiecewisePolynomial::LagrangeInterpolatingPolynomial
        struct /* LagrangeInterpolatingPolynomial */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:449
          const char* doc =
R"""(Version of LagrangeInterpolatingPolynomial(times, samples) that uses
vector samples and Eigen VectorXd / MatrixX<T> arguments. Each column
of ``samples`` represents a sample point.

Precondition:
    ``samples.cols() == times.size()``.)""";
        } LagrangeInterpolatingPolynomial;
        // Symbol: drake::trajectories::PiecewisePolynomial::PiecewisePolynomial<T>
        struct /* ctor */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:79
          const char* doc_0args =
R"""(Constructs an empty piecewise polynomial.)""";
          // Source: drake/common/trajectories/piecewise_polynomial.h:92
          const char* doc_1args_constEigenMatrixBase =
R"""(Single segment, constant value constructor over the interval [-∞, ∞].
The constructed PiecewisePolynomial will return ``constant_value`` at
every evaluated point (i.e., ``value(t) = constant_value`` ∀t ∈ [-∞,
∞]).)""";
          // Source: drake/common/trajectories/piecewise_polynomial.h:169
          const char* doc_2args_polynomials_matrix_breaks =
R"""(Constructs a PiecewisePolynomial using matrix-output Polynomials
defined over each segment.

Precondition:
    ``polynomials.size() == breaks.size() - 1``)""";
          // Source: drake/common/trajectories/piecewise_polynomial.h:178
          const char* doc_2args_polynomials_breaks =
R"""(Constructs a PiecewisePolynomial using scalar-output Polynomials
defined over each segment.

Precondition:
    ``polynomials.size() == breaks.size() - 1``)""";
        } ctor;
        // Symbol: drake::trajectories::PiecewisePolynomial::PolynomialMatrix
        struct /* PolynomialMatrix */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:84
          const char* doc = R"""()""";
        } PolynomialMatrix;
        // Symbol: drake::trajectories::PiecewisePolynomial::RemoveFinalSegment
        struct /* RemoveFinalSegment */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:716
          const char* doc =
R"""(Removes the final segment from the trajectory, reducing the number of
segments by 1.

Precondition:
    ``this`` is not empty())""";
        } RemoveFinalSegment;
        // Symbol: drake::trajectories::PiecewisePolynomial::Reshape
        struct /* Reshape */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:567
          const char* doc =
R"""(Reshapes the dimensions of the Eigen::MatrixX<T> returned by value(),
EvalDerivative(), etc.

Precondition:
    ``rows`` x ``cols`` must equal this.rows() * this.cols().

See also:
    Eigen::PlainObjectBase::resize().)""";
        } Reshape;
        // Symbol: drake::trajectories::PiecewisePolynomial::ReverseTime
        struct /* ReverseTime */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:726
          const char* doc =
R"""(Modifies the trajectory so that pp_after(t) = pp_before(-t).

Note:
    The new trajectory will evaluate differently at precisely the
    break points if the original trajectory was discontinuous at the
    break points. This is because the segments are defined on the
    half-open intervals [breaks(i), breaks(i+1)), and the order of the
    breaks have been reversed.)""";
        } ReverseTime;
        // Symbol: drake::trajectories::PiecewisePolynomial::ScaleTime
        struct /* ScaleTime */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:736
          const char* doc =
R"""(Scales the time of the trajectory by non-negative ``scale`` (use
ReverseTime() if you want to also negate time). The resulting
polynomial evaluates to pp_after(t) = pp_before(t/scale).

As an example, `scale`=2 will result in a trajectory that is twice as
long (start_time() and end_time() have both doubled).)""";
        } ScaleTime;
        // Symbol: drake::trajectories::PiecewisePolynomial::ZeroOrderHold
        struct /* ZeroOrderHold */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:229
          const char* doc =
R"""(Version of ZeroOrderHold(breaks, samples) that uses vector samples and
Eigen VectorXd/MatrixX<T> arguments. Each column of ``samples``
represents a sample point.

Precondition:
    ``samples.cols() == breaks.size()``

Raises:
    RuntimeError under the conditions specified under
    coefficient_construction_methods.)""";
        } ZeroOrderHold;
        // Symbol: drake::trajectories::PiecewisePolynomial::cols
        struct /* cols */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:558
          const char* doc =
R"""(Returns the column count of the output matrices.

Raises:
    RuntimeError if empty().)""";
        } cols;
        // Symbol: drake::trajectories::PiecewisePolynomial::derivative
        struct /* derivative */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:469
          const char* doc =
R"""(Returns a PiecewisePolynomial where each segment is the specified
derivative of the corresponding segment in ``this``. Any rules or
limitations of Polynomial::derivative() also apply to this function.

Derivatives evaluated at non-differentiable points return the value at
the left hand side of the interval.

Parameter ``derivative_order``:
    The order of the derivative, namely, if ``derivative_order`` = n,
    the n'th derivative of the polynomial will be returned.

Warning:
    In the event of discontinuous derivatives evaluated at breaks, it
    is not defined which polynomial (i.e., to the left or right of the
    break) will be the one that is evaluated at the break.)""";
        } derivative;
        // Symbol: drake::trajectories::PiecewisePolynomial::empty
        struct /* empty */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:497
          const char* doc =
R"""(Returns ``True`` if this trajectory has no breaks/samples/polynomials.)""";
        } empty;
        // Symbol: drake::trajectories::PiecewisePolynomial::getPolynomial
        struct /* getPolynomial */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:537
          const char* doc =
R"""(Gets the Polynomial with the given matrix row and column index that
corresponds to the given segment index. Equivalent to
``getPolynomialMatrix(segment_index)(row, col)``.

Note:
    Calls PiecewiseTrajectory<T>::segment_number_range_check() to
    validate ``segment_index``.)""";
        } getPolynomial;
        // Symbol: drake::trajectories::PiecewisePolynomial::getPolynomialMatrix
        struct /* getPolynomialMatrix */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:528
          const char* doc =
R"""(Gets the matrix of Polynomials corresponding to the given segment
index.

Warning:
    ``segment_index`` is not checked for validity.)""";
        } getPolynomialMatrix;
        // Symbol: drake::trajectories::PiecewisePolynomial::getSegmentPolynomialDegree
        struct /* getSegmentPolynomialDegree */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:545
          const char* doc =
R"""(Gets the degree of the Polynomial with the given matrix row and column
index that corresponds to the given segment index. Equivalent to
``getPolynomial(segment_index, row, col).GetDegree()``.)""";
        } getSegmentPolynomialDegree;
        // Symbol: drake::trajectories::PiecewisePolynomial::integral
        struct /* integral */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:480
          const char* doc_was_unable_to_choose_unambiguous_names =
R"""(Returns a PiecewisePolynomial that is the indefinite integral of this
one. Any rules or limitations of Polynomial::integral() also apply to
this function.

If ``value_at_start_time`` is given, it does the following only for
the first segment: adds that constant as the constant term
(zeroth-order coefficient) of the resulting Polynomial.)""";
        } integral;
        // Symbol: drake::trajectories::PiecewisePolynomial::isApprox
        struct /* isApprox */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:669
          const char* doc =
R"""(Checks whether a PiecewisePolynomial is approximately equal to this
one by calling Polynomial<T>::CoefficientsAlmostEqual() on every
element of every segment.

See also:
    Polynomial<T>::CoefficientsAlmostEqual().)""";
        } isApprox;
        // Symbol: drake::trajectories::PiecewisePolynomial::operator*
        struct /* operator_mul */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:653
          const char* doc =
R"""(Multiplies each Polynomial in the PolynomialMatrix of ``other`` by the
corresponding Polynomial in the PolynomialMatrix of ``this`` (i.e., a
coefficient-wise multiplication). If ``this`` corresponds to t² and
``other`` corresponds to t³, ``this *= other`` will correspond to t⁵.

Raises:
    RuntimeError if every element of ``other.get_segment_times()`` is
    not within PiecewiseTrajectory::kEpsilonTime from
    `this->get_segment_times()1.)""";
        } operator_mul;
        // Symbol: drake::trajectories::PiecewisePolynomial::operator*=
        struct /* operator_imul */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:610
          const char* doc =
R"""(Multiplies each Polynomial in the PolynomialMatrix of ``other`` by the
corresponding Polynomial in the PolynomialMatrix of ``this`` (i.e., a
coefficient-wise multiplication), storing the result in ``this``. If
``this`` corresponds to t² and ``other`` corresponds to t³, ``this *=
other`` will correspond to t⁵.

Raises:
    RuntimeError if every element of ``other.get_segment_times()`` is
    not within PiecewiseTrajectory::kEpsilonTime from
    `this->get_segment_times().)""";
        } operator_imul;
        // Symbol: drake::trajectories::PiecewisePolynomial::operator+
        struct /* operator_add */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:625
          const char* doc =
R"""(Adds each Polynomial in the PolynomialMatrix of ``other`` to the
corresponding Polynomial in the PolynomialMatrix of ``this``. If
``this`` corresponds to t² and ``other`` corresponds to t³, ``this +
other`` will correspond to t³ + t².

Raises:
    RuntimeError if every element of ``other.get_segment_times()`` is
    not within PiecewiseTrajectory::kEpsilonTime from
    `this->get_segment_times().)""";
        } operator_add;
        // Symbol: drake::trajectories::PiecewisePolynomial::operator+=
        struct /* operator_iadd */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:587
          const char* doc =
R"""(Adds each Polynomial in the PolynomialMatrix of ``other`` to the
corresponding Polynomial in the PolynomialMatrix of ``this``, storing
the result in ``this``. If ``this`` corresponds to t² and ``other``
corresponds to t³, ``this += other`` will correspond to t³ + t².

Raises:
    RuntimeError if every element of ``other.get_segment_times()`` is
    not within PiecewiseTrajectory::kEpsilonTime from
    `this->get_segment_times().)""";
        } operator_iadd;
        // Symbol: drake::trajectories::PiecewisePolynomial::operator-
        struct /* operator_sub */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:636
          const char* doc_1args =
R"""(Subtracts each Polynomial in the PolynomialMatrix of ``other`` from
the corresponding Polynomial in the PolynomialMatrix of ``this``. If
``this`` corresponds to t² and ``other`` corresponds to t³, ``this -
other`` will correspond to t² - t³.

Raises:
    RuntimeError if every element of ``other.get_segment_times()`` is
    not within PiecewiseTrajectory::kEpsilonTime from
    `this->get_segment_times().)""";
          // Source: drake/common/trajectories/piecewise_polynomial.h:642
          const char* doc_0args =
R"""(Implements unary minus operator. Multiplies each Polynomial in
``this`` by -1.)""";
        } operator_sub;
        // Symbol: drake::trajectories::PiecewisePolynomial::operator-=
        struct /* operator_isub */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:598
          const char* doc =
R"""(Subtracts each Polynomial in the PolynomialMatrix of ``other`` from
the corresponding Polynomial in the PolynomialMatrix of ``this``,
storing the result in ``this``. If ``this`` corresponds to t² and
``other`` corresponds to t³, ``this -= other`` will correspond to t² -
t³.

Raises:
    RuntimeError if every element of ``other.get_segment_times()`` is
    not within PiecewiseTrajectory::kEpsilonTime from
    `this->get_segment_times().)""";
        } operator_isub;
        // Symbol: drake::trajectories::PiecewisePolynomial::rows
        struct /* rows */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:552
          const char* doc =
R"""(Returns the row count of the output matrices.

Raises:
    RuntimeError if empty().)""";
        } rows;
        // Symbol: drake::trajectories::PiecewisePolynomial::scalarValue
        struct /* scalarValue */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:504
          const char* doc =
R"""(Evaluates the trajectory at the given time without returning the
entire matrix. Equivalent to value(t)(row, col).

Warning:
    See warnings in value().)""";
        } scalarValue;
        // Symbol: drake::trajectories::PiecewisePolynomial::setPolynomialMatrixBlock
        struct /* setPolynomialMatrixBlock */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:756
          const char* doc =
R"""(Replaces the specified block of the PolynomialMatrix at the given
segment index.

Note:
    Calls PiecewiseTrajectory<T>::segment_number_range_check() to
    validate ``segment_index``.

Warning:
    This code relies upon Eigen to verify that the replacement block
    is not too large.)""";
        } setPolynomialMatrixBlock;
        // Symbol: drake::trajectories::PiecewisePolynomial::shiftRight
        struct /* shiftRight */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:746
          const char* doc =
R"""(Adds ``offset`` to all of the breaks. ``offset`` need not be a
non-negative number. The resulting polynomial will evaluate to
pp_after(t) = pp_before(t-offset).

As an example, `offset`=2 will result in the start_time() and
end_time() being 2 seconds later.)""";
        } shiftRight;
        // Symbol: drake::trajectories::PiecewisePolynomial::slice
        struct /* slice */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:766
          const char* doc =
R"""(Returns the PiecewisePolynomial comprising the ``num_segments``
segments starting at the specified ``start_segment_index``.

Note:
    Calls PiecewiseTrajectory<T>::segment_number_range_check() to
    validate ``segment_index``.)""";
        } slice;
        // Symbol: drake::trajectories::PiecewisePolynomial::value
        struct /* value */ {
          // Source: drake/common/trajectories/piecewise_polynomial.h:519
          const char* doc =
R"""(Evaluates the PiecewisePolynomial at the given time t.

Parameter ``t``:
    The time at which to evaluate the PiecewisePolynomial.

Returns:
    The matrix of evaluated values.

Precondition:
    If T == symbolic::Expression, ``t.is_constant()`` must be true.

Warning:
    If t does not lie in the range that the polynomial is defined
    over, the polynomial will silently be evaluated at the closest
    point to t. For example, ``value(-1)`` will return ``value(0)``
    for a polynomial defined over [0, 1].

Warning:
    See warning in polynomial_construction_warning.)""";
        } value;
      } PiecewisePolynomial;
      // Symbol: drake::trajectories::PiecewisePose
      struct /* PiecewisePose */ {
        // Source: drake/common/trajectories/piecewise_pose.h:23
        const char* doc =
R"""(A wrapper class that represents a pose trajectory, whose rotation part
is a PiecewiseQuaternionSlerp and the translation part is a
PiecewisePolynomial.

@tparam_default_scalars)""";
        // Symbol: drake::trajectories::PiecewisePose::Clone
        struct /* Clone */ {
          // Source: drake/common/trajectories/piecewise_pose.h:56
          const char* doc = R"""()""";
        } Clone;
        // Symbol: drake::trajectories::PiecewisePose::MakeCubicLinearWithEndLinearVelocity
        struct /* MakeCubicLinearWithEndLinearVelocity */ {
          // Source: drake/common/trajectories/piecewise_pose.h:50
          const char* doc =
R"""(Constructs a PiecewisePose from given ``time`` and ``poses``. A cubic
polynomial with given end velocities is used to construct the position
part. The rotational part is represented by a piecewise quaterion
trajectory. There must be at least two elements in ``times`` and
``poses``.

Parameter ``times``:
    Breaks used to build the splines.

Parameter ``poses``:
    Knots used to build the splines.

Parameter ``start_vel``:
    Start linear velocity.

Parameter ``end_vel``:
    End linear velocity.)""";
        } MakeCubicLinearWithEndLinearVelocity;
        // Symbol: drake::trajectories::PiecewisePose::PiecewisePose<T>
        struct /* ctor */ {
          // Source: drake/common/trajectories/piecewise_pose.h:30
          const char* doc_0args =
R"""(Constructs an empty piecewise pose trajectory.)""";
          // Source: drake/common/trajectories/piecewise_pose.h:37
          const char* doc_2args =
R"""(Constructor.

Parameter ``pos_traj``:
    Position trajectory.

Parameter ``rot_traj``:
    Orientation trajectory.)""";
        } ctor;
        // Symbol: drake::trajectories::PiecewisePose::cols
        struct /* cols */ {
          // Source: drake/common/trajectories/piecewise_pose.h:60
          const char* doc = R"""()""";
        } cols;
        // Symbol: drake::trajectories::PiecewisePose::get_acceleration
        struct /* get_acceleration */ {
          // Source: drake/common/trajectories/piecewise_pose.h:81
          const char* doc =
R"""(Returns the interpolated acceleration at ``time`` or zero if ``time``
is before this trajectory's start time or after its end time.)""";
        } get_acceleration;
        // Symbol: drake::trajectories::PiecewisePose::get_orientation_trajectory
        struct /* get_orientation_trajectory */ {
          // Source: drake/common/trajectories/piecewise_pose.h:99
          const char* doc = R"""(Returns the orientation trajectory.)""";
        } get_orientation_trajectory;
        // Symbol: drake::trajectories::PiecewisePose::get_pose
        struct /* get_pose */ {
          // Source: drake/common/trajectories/piecewise_pose.h:65
          const char* doc =
R"""(Returns the interpolated pose at ``time``.)""";
        } get_pose;
        // Symbol: drake::trajectories::PiecewisePose::get_position_trajectory
        struct /* get_position_trajectory */ {
          // Source: drake/common/trajectories/piecewise_pose.h:92
          const char* doc = R"""(Returns the position trajectory.)""";
        } get_position_trajectory;
        // Symbol: drake::trajectories::PiecewisePose::get_velocity
        struct /* get_velocity */ {
          // Source: drake/common/trajectories/piecewise_pose.h:75
          const char* doc =
R"""(Returns the interpolated velocity at ``time`` or zero if ``time`` is
before this trajectory's start time or after its end time.)""";
        } get_velocity;
        // Symbol: drake::trajectories::PiecewisePose::is_approx
        struct /* is_approx */ {
          // Source: drake/common/trajectories/piecewise_pose.h:87
          const char* doc =
R"""(Returns true if the position and orientation trajectories are both
within ``tol`` from the other's.)""";
        } is_approx;
        // Symbol: drake::trajectories::PiecewisePose::rows
        struct /* rows */ {
          // Source: drake/common/trajectories/piecewise_pose.h:58
          const char* doc = R"""()""";
        } rows;
        // Symbol: drake::trajectories::PiecewisePose::value
        struct /* value */ {
          // Source: drake/common/trajectories/piecewise_pose.h:67
          const char* doc = R"""()""";
        } value;
      } PiecewisePose;
      // Symbol: drake::trajectories::PiecewiseQuaternionSlerp
      struct /* PiecewiseQuaternionSlerp */ {
        // Source: drake/common/trajectories/piecewise_quaternion.h:33
        const char* doc =
R"""(A class representing a trajectory for quaternions that are
interpolated using piecewise slerp (spherical linear interpolation).
All the orientation samples are expected to be with respect to the
same parent reference frame, i.e. q_i represents the rotation R_PBi
for the orientation of frame B at the ith sample in a fixed parent
frame P. The world frame is a common choice for the parent frame. The
angular velocity and acceleration are also relative to the parent
frame and expressed in the parent frame. Since there is a sign
ambiguity when using quaternions to represent orientation, namely q
and -q represent the same orientation, the internal quaternion
representations ensure that q_n.dot(q_{n+1}) >= 0. Another intuitive
way to think about this is that consecutive quaternions have the
shortest geodesic distance on the unit sphere.

@tparam_default_scalars)""";
        // Symbol: drake::trajectories::PiecewiseQuaternionSlerp::Append
        struct /* Append */ {
          // Source: drake/common/trajectories/piecewise_quaternion.h:137
          const char* doc_2args_time_quaternion =
R"""(Given a new Quaternion, this method adds one segment to the end of
``this``.)""";
          // Source: drake/common/trajectories/piecewise_quaternion.h:143
          const char* doc_2args_time_rotation_matrix =
R"""(Given a new RotationMatrix, this method adds one segment to the end of
``this``.)""";
          // Source: drake/common/trajectories/piecewise_quaternion.h:148
          const char* doc_2args_time_angle_axis =
R"""(Given a new AngleAxis, this method adds one segment to the end of
``this``.)""";
        } Append;
        // Symbol: drake::trajectories::PiecewiseQuaternionSlerp::Clone
        struct /* Clone */ {
          // Source: drake/common/trajectories/piecewise_quaternion.h:80
          const char* doc = R"""()""";
        } Clone;
        // Symbol: drake::trajectories::PiecewiseQuaternionSlerp::PiecewiseQuaternionSlerp<T>
        struct /* ctor */ {
          // Source: drake/common/trajectories/piecewise_quaternion.h:40
          const char* doc_0args =
R"""(Builds an empty PiecewiseQuaternionSlerp.)""";
          // Source: drake/common/trajectories/piecewise_quaternion.h:47
          const char* doc_2args_breaks_quaternions =
R"""(Builds a PiecewiseQuaternionSlerp.

Raises:
    RuntimeError if breaks and quaternions have different length, or
    breaks have length < 2.)""";
          // Source: drake/common/trajectories/piecewise_quaternion.h:56
          const char* doc_2args_breaks_rotation_matrices =
R"""(Builds a PiecewiseQuaternionSlerp.

Raises:
    RuntimeError if breaks and rot_matrices have different length, or
    breaks have length < 2.)""";
          // Source: drake/common/trajectories/piecewise_quaternion.h:74
          const char* doc_2args_breaks_angle_axes =
R"""(Builds a PiecewiseQuaternionSlerp.

Raises:
    RuntimeError if breaks and ang_axes have different length, or
    breaks have length < 2.)""";
        } ctor;
        // Symbol: drake::trajectories::PiecewiseQuaternionSlerp::angular_acceleration
        struct /* angular_acceleration */ {
          // Source: drake/common/trajectories/piecewise_quaternion.h:111
          const char* doc =
R"""(Interpolates angular acceleration.

Parameter ``time``:
    Time for interpolation.

Returns:
    The interpolated angular acceleration at ``time``, which is always
    zero for slerp.)""";
        } angular_acceleration;
        // Symbol: drake::trajectories::PiecewiseQuaternionSlerp::angular_velocity
        struct /* angular_velocity */ {
          // Source: drake/common/trajectories/piecewise_quaternion.h:103
          const char* doc =
R"""(Interpolates angular velocity.

Parameter ``time``:
    Time for interpolation.

Returns:
    The interpolated angular velocity at ``time``, which is constant
    per segment.)""";
        } angular_velocity;
        // Symbol: drake::trajectories::PiecewiseQuaternionSlerp::cols
        struct /* cols */ {
          // Source: drake/common/trajectories/piecewise_quaternion.h:84
          const char* doc = R"""()""";
        } cols;
        // Symbol: drake::trajectories::PiecewiseQuaternionSlerp::get_quaternion_samples
        struct /* get_quaternion_samples */ {
          // Source: drake/common/trajectories/piecewise_quaternion.h:122
          const char* doc =
R"""(Getter for the internal quaternion samples.

Note:
    The returned quaternions might be different from the ones used for
    construction because the internal representations are set to
    always be the "closest" w.r.t to the previous one.

Returns:
    the internal sample points.)""";
        } get_quaternion_samples;
        // Symbol: drake::trajectories::PiecewiseQuaternionSlerp::is_approx
        struct /* is_approx */ {
          // Source: drake/common/trajectories/piecewise_quaternion.h:131
          const char* doc =
R"""(Returns true if all the corresponding segment times are within ``tol``
seconds, and the angle difference between the corresponding quaternion
sample points are within ``tol`` (using ``ExtractDoubleOrThrow``).)""";
        } is_approx;
        // Symbol: drake::trajectories::PiecewiseQuaternionSlerp::orientation
        struct /* orientation */ {
          // Source: drake/common/trajectories/piecewise_quaternion.h:91
          const char* doc =
R"""(Interpolates orientation.

Parameter ``time``:
    Time for interpolation.

Returns:
    The interpolated quaternion at ``time``.)""";
        } orientation;
        // Symbol: drake::trajectories::PiecewiseQuaternionSlerp::rows
        struct /* rows */ {
          // Source: drake/common/trajectories/piecewise_quaternion.h:82
          const char* doc = R"""()""";
        } rows;
        // Symbol: drake::trajectories::PiecewiseQuaternionSlerp::value
        struct /* value */ {
          // Source: drake/common/trajectories/piecewise_quaternion.h:93
          const char* doc = R"""()""";
        } value;
      } PiecewiseQuaternionSlerp;
      // Symbol: drake::trajectories::PiecewiseTrajectory
      struct /* PiecewiseTrajectory */ {
        // Source: drake/common/trajectories/piecewise_trajectory.h:22
        const char* doc =
R"""(Abstract class that implements the basic logic of maintaining
consequent segments of time (delimited by ``breaks``) to implement a
trajectory that is represented by simpler logic in each segment or
"piece".

@tparam_default_scalars)""";
        // Symbol: drake::trajectories::PiecewiseTrajectory::PiecewiseTrajectory<T>
        struct /* ctor */ {
          // Source: drake/common/trajectories/piecewise_trajectory.h:62
          const char* doc =
R"""(``breaks`` increments must be greater or equal to kEpsilonTime.)""";
        } ctor;
        // Symbol: drake::trajectories::PiecewiseTrajectory::RandomSegmentTimes
        struct /* RandomSegmentTimes */ {
          // Source: drake/common/trajectories/piecewise_trajectory.h:52
          const char* doc = R"""()""";
        } RandomSegmentTimes;
        // Symbol: drake::trajectories::PiecewiseTrajectory::SegmentTimesEqual
        struct /* SegmentTimesEqual */ {
          // Source: drake/common/trajectories/piecewise_trajectory.h:64
          const char* doc = R"""()""";
        } SegmentTimesEqual;
        // Symbol: drake::trajectories::PiecewiseTrajectory::breaks
        struct /* breaks */ {
          // Source: drake/common/trajectories/piecewise_trajectory.h:67
          const char* doc = R"""()""";
        } breaks;
        // Symbol: drake::trajectories::PiecewiseTrajectory::duration
        struct /* duration */ {
          // Source: drake/common/trajectories/piecewise_trajectory.h:35
          const char* doc = R"""()""";
        } duration;
        // Symbol: drake::trajectories::PiecewiseTrajectory::end_time
        struct /* end_time */ {
          // Source: drake/common/trajectories/piecewise_trajectory.h:33
          const char* doc = R"""()""";
        } end_time;
        // Symbol: drake::trajectories::PiecewiseTrajectory::get_mutable_breaks
        struct /* get_mutable_breaks */ {
          // Source: drake/common/trajectories/piecewise_trajectory.h:68
          const char* doc = R"""()""";
        } get_mutable_breaks;
        // Symbol: drake::trajectories::PiecewiseTrajectory::get_number_of_segments
        struct /* get_number_of_segments */ {
          // Source: drake/common/trajectories/piecewise_trajectory.h:29
          const char* doc = R"""()""";
        } get_number_of_segments;
        // Symbol: drake::trajectories::PiecewiseTrajectory::get_segment_index
        struct /* get_segment_index */ {
          // Source: drake/common/trajectories/piecewise_trajectory.h:46
          const char* doc = R"""()""";
        } get_segment_index;
        // Symbol: drake::trajectories::PiecewiseTrajectory::get_segment_times
        struct /* get_segment_times */ {
          // Source: drake/common/trajectories/piecewise_trajectory.h:48
          const char* doc = R"""()""";
        } get_segment_times;
        // Symbol: drake::trajectories::PiecewiseTrajectory::is_time_in_range
        struct /* is_time_in_range */ {
          // Source: drake/common/trajectories/piecewise_trajectory.h:44
          const char* doc =
R"""(Returns true iff ``t >= getStartTime() && t <= getEndTime()``.)""";
        } is_time_in_range;
        // Symbol: drake::trajectories::PiecewiseTrajectory::segment_number_range_check
        struct /* segment_number_range_check */ {
          // Source: drake/common/trajectories/piecewise_trajectory.h:50
          const char* doc = R"""()""";
        } segment_number_range_check;
        // Symbol: drake::trajectories::PiecewiseTrajectory::start_time
        struct /* start_time */ {
          // Source: drake/common/trajectories/piecewise_trajectory.h:31
          const char* doc = R"""()""";
        } start_time;
      } PiecewiseTrajectory;
      // Symbol: drake::trajectories::Trajectory
      struct /* Trajectory */ {
        // Source: drake/common/trajectories/trajectory.h:22
        const char* doc =
R"""(A Trajectory represents a time-varying matrix, indexed by a single
scalar time.

@tparam_default_scalars)""";
        // Symbol: drake::trajectories::Trajectory::Clone
        struct /* Clone */ {
          // Source: drake/common/trajectories/trajectory.h:29
          const char* doc =
R"""(Returns:
    A deep copy of this Trajectory.)""";
        } Clone;
        // Symbol: drake::trajectories::Trajectory::DoEvalDerivative
        struct /* DoEvalDerivative */ {
          // Source: drake/common/trajectories/trajectory.h:94
          const char* doc = R"""()""";
        } DoEvalDerivative;
        // Symbol: drake::trajectories::Trajectory::DoMakeDerivative
        struct /* DoMakeDerivative */ {
          // Source: drake/common/trajectories/trajectory.h:96
          const char* doc = R"""()""";
        } DoMakeDerivative;
        // Symbol: drake::trajectories::Trajectory::EvalDerivative
        struct /* EvalDerivative */ {
          // Source: drake/common/trajectories/trajectory.h:62
          const char* doc =
R"""(Evaluates the derivative of ``this`` at the given time ``t``. Returns
the nth derivative, where ``n`` is the value of ``derivative_order``.

Precondition:
    derivative_order must be non-negative.)""";
        } EvalDerivative;
        // Symbol: drake::trajectories::Trajectory::MakeDerivative
        struct /* MakeDerivative */ {
          // Source: drake/common/trajectories/trajectory.h:70
          const char* doc =
R"""(Takes the derivative of this Trajectory.

Parameter ``derivative_order``:
    The number of times to take the derivative before returning.

Returns:
    The nth derivative of this object.)""";
        } MakeDerivative;
        // Symbol: drake::trajectories::Trajectory::Trajectory<T>
        struct /* ctor */ {
          // Source: drake/common/trajectories/trajectory.h:89
          const char* doc = R"""()""";
        } ctor;
        // Symbol: drake::trajectories::Trajectory::cols
        struct /* cols */ {
          // Source: drake/common/trajectories/trajectory.h:81
          const char* doc =
R"""(Returns:
    The number of columns in the matrix returned by value().)""";
        } cols;
        // Symbol: drake::trajectories::Trajectory::do_has_derivative
        struct /* do_has_derivative */ {
          // Source: drake/common/trajectories/trajectory.h:92
          const char* doc = R"""()""";
        } do_has_derivative;
        // Symbol: drake::trajectories::Trajectory::end_time
        struct /* end_time */ {
          // Source: drake/common/trajectories/trajectory.h:85
          const char* doc = R"""()""";
        } end_time;
        // Symbol: drake::trajectories::Trajectory::has_derivative
        struct /* has_derivative */ {
          // Source: drake/common/trajectories/trajectory.h:54
          const char* doc =
R"""(Returns true iff the Trajectory provides and implementation for
EvalDerivative() and MakeDerivative(). The derivative need not be
continuous, but should return a result for all t for which value(t)
returns a result.)""";
        } has_derivative;
        // Symbol: drake::trajectories::Trajectory::rows
        struct /* rows */ {
          // Source: drake/common/trajectories/trajectory.h:76
          const char* doc =
R"""(Returns:
    The number of rows in the matrix returned by value().)""";
        } rows;
        // Symbol: drake::trajectories::Trajectory::start_time
        struct /* start_time */ {
          // Source: drake/common/trajectories/trajectory.h:83
          const char* doc = R"""()""";
        } start_time;
        // Symbol: drake::trajectories::Trajectory::value
        struct /* value */ {
          // Source: drake/common/trajectories/trajectory.h:36
          const char* doc =
R"""(Evaluates the trajectory at the given time ``t``.

Parameter ``t``:
    The time at which to evaluate the trajectory.

Returns:
    The matrix of evaluated values.)""";
        } value;
        // Symbol: drake::trajectories::Trajectory::vector_values
        struct /* vector_values */ {
          // Source: drake/common/trajectories/trajectory.h:46
          const char* doc =
R"""(If cols()==1, then evaluates the trajectory at each time ``t``, and
returns the results as a Matrix with the ith column corresponding to
the ith time. Otherwise, if rows()==1, then evaluates the trajectory
at each time ``t``, and returns the results as a Matrix with the ith
row corresponding to the ith time.

Raises:
    RuntimeError if both cols and rows are not equal to 1.)""";
        } vector_values;
      } Trajectory;
    } trajectories;
    // Symbol: drake::uhash
    struct /* uhash */ {
      // Source: drake/common/hash.h:195
      const char* doc =
R"""(A hashing functor, somewhat like ``std::hash``. Given an item of type
``T``, applies hash_append to it, directing the bytes to append into
the given ``HashAlgorithm``, and then finally returning the
algorithm's result.)""";
      // Symbol: drake::uhash::operator()
      struct /* operator_call */ {
        // Source: drake/common/hash.h:199
        const char* doc = R"""()""";
      } operator_call;
      // Symbol: drake::uhash::result_type
      struct /* result_type */ {
        // Source: drake/common/hash.h:196
        const char* doc = R"""()""";
      } result_type;
    } uhash;
    // Symbol: drake::unused
    struct /* unused */ {
      // Source: drake/common/unused.h:51
      const char* doc =
R"""(Documents the argument(s) as unused, placating GCC's
-Wunused-parameter warning. This can be called within function bodies
to mark that certain parameters are unused.

When possible, removing the unused parameter is better than placating
the warning. However, in some cases the parameter is part of a virtual
API or template concept that is used elsewhere, so we can't remove it.
In those cases, this function might be an appropriate work-around.

Here's rough advice on how to fix Wunused-parameter warnings:

(1) If the parameter can be removed entirely, prefer that as the first
choice. (This may not be possible if, e.g., a method must match some
virtual API or template concept.)

(2) Unless the parameter name has acute value, prefer to omit the name
of the parameter, leaving only the type, e.g.


::

    void Print(const State& state) override { /* No state to print. */ }

changes to


::

    void Print(const State&) override { /* No state to print. */}

This no longer triggers the warning and further makes it clear that a
parameter required by the API is definitively unused in the function.

This is an especially good solution in the context of method
definitions (vs declarations); the parameter name used in a definition
is entirely irrelevant to Doxygen and most readers.

(3) When leaving the parameter name intact has acute value, it is
acceptable to keep the name and mark it ``unused``. For example, when
the name appears as part of a virtual method's base class declaration,
the name is used by Doxygen to document the method, e.g.,


::

    /** Sets the default State of a System.  This default implementation is to
        set all zeros.  Subclasses may override to use non-zero defaults.  The
        custom defaults may be based on the given ``context``, when relevant.  
    virtual void SetDefault(const Context<T>& context, State<T>* state) const {
      unused(context);
      state->SetZero();
    })""";
    } unused;
    // Symbol: drake::yaml
    struct /* yaml */ {
      // Symbol: drake::yaml::YamlReadArchive
      struct /* YamlReadArchive */ {
        // Source: drake/common/yaml/yaml_read_archive.h:67
        const char* doc =
R"""(Loads data from a YAML file into a C++ structure, using the Serialize
/ Archive pattern.

Sample data:


::

    {yaml}
    doc:
      foo: 1.0
      bar: [2.0, 3.0]

Sample code:


::

    {cpp}
    struct MyData {
      double foo{NAN};
      std::vector<double> bar;
    
      template <typename Archive>
      void Serialize(Archive* a) {
        a->Visit(DRAKE_NVP(foo));
        a->Visit(DRAKE_NVP(bar));
      }
    };
    
    MyData LoadData(const std::string& filename) {
      MyData result;
      const YAML::Node& root = YAML::LoadFile(filename);
      common::YamlReadArchive(root).Accept(&result);
      return result;
    }

Structures can be arbitrarily nested, as long as each ``struct`` has a
``Serialize`` method. Many common built-in types (int, double,
std::string, std::vector, std::array, std::optional, std::variant,
Eigen::Matrix) may also be used.

YAML's "merge keys" (https://yaml.org/type/merge.html) are supported.

For inspiration and background, see:
https://www.boost.org/doc/libs/release/libs/serialization/doc/tutorial.html)""";
        // Symbol: drake::yaml::YamlReadArchive::Accept
        struct /* Accept */ {
          // Source: drake/common/yaml/yaml_read_archive.h:107
          const char* doc =
R"""(Sets the contents ``serializable`` based on the YAML file associated
with this archive. See the YamlReadArchive class overview for details.)""";
        } Accept;
        // Symbol: drake::yaml::YamlReadArchive::Options
        struct /* Options */ {
          // Source: drake/common/yaml/yaml_read_archive.h:73
          const char* doc =
R"""(Configuration for YamlReadArchive to govern when certain conditions
are errors or not. Refer to the member fields for details.)""";
          // Symbol: drake::yaml::YamlReadArchive::Options::allow_cpp_with_no_yaml
          struct /* allow_cpp_with_no_yaml */ {
            // Source: drake/common/yaml/yaml_read_archive.h:85
            const char* doc =
R"""(Allows Serializables to provide more key-value pairs than are present
in the YAML data. In other words, the structs have default values that
are left intact unless the YAML data provides a value.)""";
          } allow_cpp_with_no_yaml;
          // Symbol: drake::yaml::YamlReadArchive::Options::allow_yaml_with_no_cpp
          struct /* allow_yaml_with_no_cpp */ {
            // Source: drake/common/yaml/yaml_read_archive.h:80
            const char* doc =
R"""(Allows yaml Maps to have extra key-value pairs that are not Visited by
the Serializable being parsed into. In other words, the Serializable
types provide an incomplete schema for the YAML data. This allows for
parsing only a subset of the YAML data.)""";
          } allow_yaml_with_no_cpp;
          // Symbol: drake::yaml::YamlReadArchive::Options::retain_map_defaults
          struct /* retain_map_defaults */ {
            // Source: drake/common/yaml/yaml_read_archive.h:92
            const char* doc =
R"""(If set to true, when parsing a std::map the Archive will merge the
YAML data into the destination, instead of replacing the std::map
contents entirely. In other words, a visited std::map can have default
values that are left intact unless the YAML data provides a value *for
that specific key*.)""";
          } retain_map_defaults;
        } Options;
        // Symbol: drake::yaml::YamlReadArchive::Visit
        struct /* Visit */ {
          // Source: drake/common/yaml/yaml_read_archive.h:120
          const char* doc =
R"""((Advanced.) Sets the value pointed to by ``nvp.value()`` based on the
YAML file associated with this archive. Most users should should call
Accept, not Visit.)""";
        } Visit;
        // Symbol: drake::yaml::YamlReadArchive::YamlReadArchive
        struct /* ctor */ {
          // Source: drake/common/yaml/yaml_read_archive.h:97
          const char* doc_1args =
R"""(Creates an archive that reads from ``root``. See the YamlReadArchive
class overview for details.)""";
          // Source: drake/common/yaml/yaml_read_archive.h:102
          const char* doc_2args =
R"""(Creates an archive that reads from ``root``, with ``options`` that
allow for less restrictive parsing. See the YamlReadArchive class
overview for details.)""";
        } ctor;
      } YamlReadArchive;
      // Symbol: drake::yaml::YamlWriteArchive
      struct /* YamlWriteArchive */ {
        // Source: drake/common/yaml/yaml_write_archive.h:71
        const char* doc =
R"""(Saves data from a C++ structure into a YAML file, using the Serialize
/ Archive pattern.

Sample code:


::

    {cpp}
    struct MyData {
      double foo{NAN};
      std::vector<double> bar;
    
      template <typename Archive>
      void Serialize(Archive* a) {
        a->Visit(DRAKE_NVP(foo));
        a->Visit(DRAKE_NVP(bar));
      }
    };
    
    std::string SaveData(const MyData& data) {
      common::YamlWriteArchive archive;
      archive.Accept(data);
      return archive.EmitString();
    }
    
    int main() {
      MyData data{1.0, {2.0, 3.0}};
      std::cout << SaveData(data);
      return 0;
    }

Output:


::

    {yaml}
    root:
      foo: 1.0
      bar: [2.0, 3.0]

Structures can be arbitrarily nested, as long as each ``struct`` has a
``Serialize`` method. Many common built-in types (int, double,
std::string, std::vector, std::array, std::map, std::unordered_map,
std::optional, std::variant, Eigen::Matrix) may also be used.

The EmitString output is always deterministic, even for unordered
datatypes like std::unordered_map.

For inspiration and background, see:
https://www.boost.org/doc/libs/release/libs/serialization/doc/tutorial.html)""";
        // Symbol: drake::yaml::YamlWriteArchive::Accept
        struct /* Accept */ {
          // Source: drake/common/yaml/yaml_write_archive.h:82
          const char* doc =
R"""(Copies the contents of ``serializable`` into the YAML object
associated with this archive. See the YamlWriteArchive class overview
for details.)""";
        } Accept;
        // Symbol: drake::yaml::YamlWriteArchive::EmitString
        struct /* EmitString */ {
          // Source: drake/common/yaml/yaml_write_archive.h:109
          const char* doc =
R"""(Returns the YAML string for whatever Serializable was most recently
passed into Accept.

If the ``root_name`` is empty, the returned document will be the
Serializable's visited content (which itself is already a Map node)
directly. If the visited serializable content is null (in cases
``Accpet()`` has not been called or the entries are erased after
calling ``EraseMatchingMaps()``), then an empty map ``{}`` will be
emitted.

If the ``root_name`` is not empty, the returned document will be a
single Map node named using ``root_name`` with the Serializable's
visited content as key-value entries within it. The visited content
could be null and the nullness is defined as above.)""";
        } EmitString;
        // Symbol: drake::yaml::YamlWriteArchive::EraseMatchingMaps
        struct /* EraseMatchingMaps */ {
          // Source: drake/common/yaml/yaml_write_archive.h:118
          const char* doc =
R"""((Advanced.) Remove from this archive any map entries that are
identical to an entry in ``other``, iff they reside at the same
location within the node tree hierarchy, and iff their parent nodes
(and grandparent, etc., all the way up to the root) are also all maps.
This enables emitting a minimal YAML representation when the output
will be later loaded using YamlReadArchive's option to
retain_map_defaults; the "all parents are maps" condition is the
complement to what retain_map_defaults admits.)""";
        } EraseMatchingMaps;
        // Symbol: drake::yaml::YamlWriteArchive::Visit
        struct /* Visit */ {
          // Source: drake/common/yaml/yaml_write_archive.h:123
          const char* doc =
R"""((Advanced.) Copies the value pointed to by ``nvp.value()`` into the
YAML object. Most users should should call Accept, not Visit.)""";
        } Visit;
        // Symbol: drake::yaml::YamlWriteArchive::YamlWriteArchive
        struct /* ctor */ {
          // Source: drake/common/yaml/yaml_write_archive.h:77
          const char* doc =
R"""(Creates an archive. See the YamlWriteArchive class overview for
details.)""";
        } ctor;
      } YamlWriteArchive;
    } yaml;
  } drake;
} pydrake_doc;

#if defined(__GNUG__)
#pragma GCC diagnostic pop
#endif
